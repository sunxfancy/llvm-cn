# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2003-2016, LLVM Project
# This file is distributed under the same license as the LLVM package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2016.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: LLVM 3.8\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2016-04-17 11:36+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.3.3\n"

#: ../../SourceLevelDebugging.rst:3
msgid "Source Level Debugging with LLVM"
msgstr ""

#: ../../SourceLevelDebugging.rst:9 ../../SourceLevelDebugging.rst:481
#: ../../SourceLevelDebugging.rst:688
msgid "Introduction"
msgstr ""

#: ../../SourceLevelDebugging.rst:11
msgid ""
"This document is the central repository for all information pertaining to"
" debug information in LLVM.  It describes the :ref:`actual format that "
"the LLVM debug information takes <format>`, which is useful for those "
"interested in creating front-ends or dealing directly with the "
"information.  Further, this document provides specific examples of what "
"debug information for C/C++ looks like."
msgstr ""

#: ../../SourceLevelDebugging.rst:18
msgid "Philosophy behind LLVM debugging information"
msgstr ""

#: ../../SourceLevelDebugging.rst:20
msgid ""
"The idea of the LLVM debugging information is to capture how the "
"important pieces of the source-language's Abstract Syntax Tree map onto "
"LLVM code. Several design aspects have shaped the solution that appears "
"here.  The important ones are:"
msgstr ""

#: ../../SourceLevelDebugging.rst:25
msgid ""
"Debugging information should have very little impact on the rest of the "
"compiler.  No transformations, analyses, or code generators should need "
"to be modified because of debugging information."
msgstr ""

#: ../../SourceLevelDebugging.rst:29
msgid ""
"LLVM optimizations should interact in :ref:`well-defined and easily "
"described ways <intro_debugopt>` with the debugging information."
msgstr ""

#: ../../SourceLevelDebugging.rst:32
msgid ""
"Because LLVM is designed to support arbitrary programming languages, "
"LLVM-to-LLVM tools should not need to know anything about the semantics "
"of the source-level-language."
msgstr ""

#: ../../SourceLevelDebugging.rst:36
msgid ""
"Source-level languages are often **widely** different from one another. "
"LLVM should not put any restrictions of the flavor of the source-"
"language, and the debugging information should work with any language."
msgstr ""

#: ../../SourceLevelDebugging.rst:40
msgid ""
"With code generator support, it should be possible to use an LLVM "
"compiler to compile a program to native machine code and standard "
"debugging formats.  This allows compatibility with traditional machine-"
"code level debuggers, like GDB or DBX."
msgstr ""

#: ../../SourceLevelDebugging.rst:45
msgid ""
"The approach used by the LLVM implementation is to use a small set of "
":ref:`intrinsic functions <format_common_intrinsics>` to define a mapping"
" between LLVM program objects and the source-level objects.  The "
"description of the source-level program is maintained in LLVM metadata in"
" an :ref:`implementation-defined format <ccxx_frontend>` (the C/C++ "
"front-end currently uses working draft 7 of the `DWARF 3 standard "
"<http://www.eagercon.com/dwarf/dwarf3std.htm>`_)."
msgstr ""

#: ../../SourceLevelDebugging.rst:53
msgid ""
"When a program is being debugged, a debugger interacts with the user and "
"turns the stored debug information into source-language specific "
"information.  As such, a debugger must be aware of the source-language, "
"and is thus tied to a specific language or family of languages."
msgstr ""

#: ../../SourceLevelDebugging.rst:59
msgid "Debug information consumers"
msgstr ""

#: ../../SourceLevelDebugging.rst:61
msgid ""
"The role of debug information is to provide meta information normally "
"stripped away during the compilation process.  This meta information "
"provides an LLVM user a relationship between generated code and the "
"original program source code."
msgstr ""

#: ../../SourceLevelDebugging.rst:66
msgid ""
"Currently, debug information is consumed by DwarfDebug to produce dwarf "
"information used by the gdb debugger.  Other targets could use the same "
"information to produce stabs or other debug forms."
msgstr ""

#: ../../SourceLevelDebugging.rst:70
msgid ""
"It would also be reasonable to use debug information to feed profiling "
"tools for analysis of generated code, or, tools for reconstructing the "
"original source from generated code."
msgstr ""

#: ../../SourceLevelDebugging.rst:74
msgid "TODO - expound a bit more."
msgstr ""

#: ../../SourceLevelDebugging.rst:79
msgid "Debugging optimized code"
msgstr ""

#: ../../SourceLevelDebugging.rst:81
msgid ""
"An extremely high priority of LLVM debugging information is to make it "
"interact well with optimizations and analysis.  In particular, the LLVM "
"debug information provides the following guarantees:"
msgstr ""

#: ../../SourceLevelDebugging.rst:85
msgid ""
"LLVM debug information **always provides information to accurately read "
"the source-level state of the program**, regardless of which LLVM "
"optimizations have been run, and without any modification to the "
"optimizations themselves.  However, some optimizations may impact the "
"ability to modify the current state of the program with a debugger, such "
"as setting program variables, or calling functions that have been "
"deleted."
msgstr ""

#: ../../SourceLevelDebugging.rst:93
msgid ""
"As desired, LLVM optimizations can be upgraded to be aware of the LLVM "
"debugging information, allowing them to update the debugging information "
"as they perform aggressive optimizations.  This means that, with effort, "
"the LLVM optimizers could optimize debug code just as well as non-debug "
"code."
msgstr ""

#: ../../SourceLevelDebugging.rst:99
msgid ""
"LLVM debug information does not prevent optimizations from happening (for"
" example inlining, basic block reordering/merging/cleanup, tail "
"duplication, etc)."
msgstr ""

#: ../../SourceLevelDebugging.rst:103
msgid ""
"LLVM debug information is automatically optimized along with the rest of "
"the program, using existing facilities.  For example, duplicate "
"information is automatically merged by the linker, and unused information"
" is automatically removed."
msgstr ""

#: ../../SourceLevelDebugging.rst:108
msgid ""
"Basically, the debug information allows you to compile a program with "
"\"``-O0 -g``\" and get full debug information, allowing you to "
"arbitrarily modify the program as it executes from a debugger.  Compiling"
" a program with \"``-O3 -g``\" gives you full debug information that is "
"always available and accurate for reading (e.g., you get accurate stack "
"traces despite tail call elimination and inlining), but you might lose "
"the ability to modify the program and call functions where were optimized"
" out of the program, or inlined away completely."
msgstr ""

#: ../../SourceLevelDebugging.rst:117
msgid ""
":ref:`LLVM test suite <test-suite-quickstart>` provides a framework to "
"test optimizer's handling of debugging information.  It can be run like "
"this:"
msgstr ""

#: ../../SourceLevelDebugging.rst:125
msgid ""
"This will test impact of debugging information on optimization passes.  "
"If debugging information influences optimization passes then it will be "
"reported as a failure.  See :doc:`TestingGuide` for more information on "
"LLVM test infrastructure and how to run various tests."
msgstr ""

#: ../../SourceLevelDebugging.rst:133 ../../SourceLevelDebugging.rst:475
msgid "Debugging information format"
msgstr ""

#: ../../SourceLevelDebugging.rst:135
msgid ""
"LLVM debugging information has been carefully designed to make it "
"possible for the optimizer to optimize the program and debugging "
"information without necessarily having to know anything about debugging "
"information.  In particular, the use of metadata avoids duplicated "
"debugging information from the beginning, and the global dead code "
"elimination pass automatically deletes debugging information for a "
"function if it decides to delete the function."
msgstr ""

#: ../../SourceLevelDebugging.rst:142
msgid ""
"To do this, most of the debugging information (descriptors for types, "
"variables, functions, source files, etc) is inserted by the language "
"front-end in the form of LLVM metadata."
msgstr ""

#: ../../SourceLevelDebugging.rst:146
msgid ""
"Debug information is designed to be agnostic about the target debugger "
"and debugging information representation (e.g. DWARF/Stabs/etc).  It uses"
" a generic pass to decode the information that represents variables, "
"types, functions, namespaces, etc: this allows for arbitrary source-"
"language semantics and type-systems to be used, as long as there is a "
"module written for the target debugger to interpret the information."
msgstr ""

#: ../../SourceLevelDebugging.rst:153
msgid ""
"To provide basic functionality, the LLVM debugger does have to make some "
"assumptions about the source-level language being debugged, though it "
"keeps these to a minimum.  The only common features that the LLVM "
"debugger assumes exist are `source files <LangRef.html#difile>`_, and "
"`program objects <LangRef.html#diglobalvariable>`_.  These abstract "
"objects are used by a debugger to form stack traces, show information "
"about local variables, etc."
msgstr ""

#: ../../SourceLevelDebugging.rst:160
msgid ""
"This section of the documentation first describes the representation "
"aspects common to any source-language.  :ref:`ccxx_frontend` describes "
"the data layout conventions used by the C and C++ front-ends."
msgstr ""

#: ../../SourceLevelDebugging.rst:164
msgid ""
"Debug information descriptors are `specialized metadata nodes "
"<LangRef.html#specialized-metadata>`_, first-class subclasses of "
"``Metadata``."
msgstr ""

#: ../../SourceLevelDebugging.rst:170
msgid "Debugger intrinsic functions"
msgstr ""

#: ../../SourceLevelDebugging.rst:172
msgid ""
"LLVM uses several intrinsic functions (name prefixed with "
"\"``llvm.dbg``\") to provide debug information at various points in "
"generated code."
msgstr ""

#: ../../SourceLevelDebugging.rst:176
msgid "``llvm.dbg.declare``"
msgstr ""

#: ../../SourceLevelDebugging.rst:182
msgid ""
"This intrinsic provides information about a local element (e.g., "
"variable). The first argument is metadata holding the alloca for the "
"variable.  The second argument is a `local variable "
"<LangRef.html#dilocalvariable>`_ containing a description of the "
"variable.  The third argument is a `complex expression "
"<LangRef.html#diexpression>`_."
msgstr ""

#: ../../SourceLevelDebugging.rst:189
msgid "``llvm.dbg.value``"
msgstr ""

#: ../../SourceLevelDebugging.rst:195
msgid ""
"This intrinsic provides information when a user source variable is set to"
" a new value.  The first argument is the new value (wrapped as metadata)."
"  The second argument is the offset in the user source variable where the"
" new value is written.  The third argument is a `local variable "
"<LangRef.html#dilocalvariable>`_ containing a description of the "
"variable.  The third argument is a `complex expression "
"<LangRef.html#diexpression>`_."
msgstr ""

#: ../../SourceLevelDebugging.rst:203
msgid "Object lifetimes and scoping"
msgstr ""

#: ../../SourceLevelDebugging.rst:205
msgid ""
"In many languages, the local variables in functions can have their "
"lifetimes or scopes limited to a subset of a function.  In the C family "
"of languages, for example, variables are only live (readable and "
"writable) within the source block that they are defined in.  In "
"functional languages, values are only readable after they have been "
"defined.  Though this is a very obvious concept, it is non-trivial to "
"model in LLVM, because it has no notion of scoping in this sense, and "
"does not want to be tied to a language's scoping rules."
msgstr ""

#: ../../SourceLevelDebugging.rst:213
msgid ""
"In order to handle this, the LLVM debug format uses the metadata attached"
" to llvm instructions to encode line number and scoping information.  "
"Consider the following C fragment, for example:"
msgstr ""

#: ../../SourceLevelDebugging.rst:229
msgid "Compiled to LLVM, this function would be represented like this:"
msgstr ""

#: ../../SourceLevelDebugging.rst:289
msgid ""
"This example illustrates a few important details about LLVM debugging "
"information.  In particular, it shows how the ``llvm.dbg.declare`` "
"intrinsic and location information, which are attached to an instruction,"
" are applied together to allow a debugger to analyze the relationship "
"between statements, variable definitions, and the code used to implement "
"the function."
msgstr ""

#: ../../SourceLevelDebugging.rst:300
msgid ""
"The first intrinsic ``%llvm.dbg.declare`` encodes debugging information "
"for the variable ``X``.  The metadata ``!dbg !14`` attached to the "
"intrinsic provides scope information for the variable ``X``."
msgstr ""

#: ../../SourceLevelDebugging.rst:311
msgid ""
"Here ``!14`` is metadata providing `location information "
"<LangRef.html#dilocation>`_.  In this example, scope is encoded by "
"``!4``, a `subprogram descriptor <LangRef.html#disubprogram>`_.  This way"
" the location information attached to the intrinsics indicates that the "
"variable ``X`` is declared at line number 2 at a function level scope in "
"function ``foo``."
msgstr ""

#: ../../SourceLevelDebugging.rst:317
msgid "Now lets take another example."
msgstr ""

#: ../../SourceLevelDebugging.rst:324
msgid ""
"The third intrinsic ``%llvm.dbg.declare`` encodes debugging information "
"for variable ``Z``.  The metadata ``!dbg !19`` attached to the intrinsic "
"provides scope information for the variable ``Z``."
msgstr ""

#: ../../SourceLevelDebugging.rst:333
msgid ""
"Here ``!19`` indicates that ``Z`` is declared at line number 5 and column"
" number 0 inside of lexical scope ``!18``.  The lexical scope itself "
"resides inside of subprogram ``!4`` described above."
msgstr ""

#: ../../SourceLevelDebugging.rst:337
msgid ""
"The scope information attached with each instruction provides a "
"straightforward way to find instructions covered by a scope."
msgstr ""

#: ../../SourceLevelDebugging.rst:343
msgid "C/C++ front-end specific debug information"
msgstr ""

#: ../../SourceLevelDebugging.rst:345
msgid ""
"The C and C++ front-ends represent information about the program in a "
"format that is effectively identical to `DWARF 3.0 "
"<http://www.eagercon.com/dwarf/dwarf3std.htm>`_ in terms of information "
"content.  This allows code generators to trivially support native "
"debuggers by generating standard dwarf information, and contains enough "
"information for non-dwarf targets to translate it as needed."
msgstr ""

#: ../../SourceLevelDebugging.rst:352
msgid ""
"This section describes the forms used to represent C and C++ programs.  "
"Other languages could pattern themselves after this (which itself is "
"tuned to representing programs in the same way that DWARF 3 does), or "
"they could choose to provide completely different forms if they don't fit"
" into the DWARF model. As support for debugging information gets added to"
" the various LLVM source-language front-ends, the information used should"
" be documented here."
msgstr ""

#: ../../SourceLevelDebugging.rst:359
msgid ""
"The following sections provide examples of a few C/C++ constructs and the"
" debug information that would best describe those constructs.  The "
"canonical references are the ``DIDescriptor`` classes defined in "
"``include/llvm/IR/DebugInfo.h`` and the implementations of the helper "
"functions in ``lib/IR/DIBuilder.cpp``."
msgstr ""

#: ../../SourceLevelDebugging.rst:366
msgid "C/C++ source file information"
msgstr ""

#: ../../SourceLevelDebugging.rst:368
msgid ""
"``llvm::Instruction`` provides easy access to metadata attached with an "
"instruction.  One can extract line number information encoded in LLVM IR "
"using ``Instruction::getDebugLoc()`` and ``DILocation::getLine()``."
msgstr ""

#: ../../SourceLevelDebugging.rst:381
msgid "C/C++ global variable information"
msgstr ""

#: ../../SourceLevelDebugging.rst:383
msgid "Given an integer global variable declared as follows:"
msgstr ""

#: ../../SourceLevelDebugging.rst:389 ../../SourceLevelDebugging.rst:455
msgid "a C/C++ front-end would generate the following descriptors:"
msgstr ""

#: ../../SourceLevelDebugging.rst:445
msgid "C/C++ function information"
msgstr ""

#: ../../SourceLevelDebugging.rst:447
msgid "Given a function declared as follows:"
msgstr ""

#: ../../SourceLevelDebugging.rst:478
msgid "Debugging Information Extension for Objective C Properties"
msgstr ""

#: ../../SourceLevelDebugging.rst:483
msgid ""
"Objective C provides a simpler way to declare and define accessor methods"
" using declared properties.  The language provides features to declare a "
"property and to let compiler synthesize accessor methods."
msgstr ""

#: ../../SourceLevelDebugging.rst:487
msgid ""
"The debugger lets developer inspect Objective C interfaces and their "
"instance variables and class variables.  However, the debugger does not "
"know anything about the properties defined in Objective C interfaces.  "
"The debugger consumes information generated by compiler in DWARF format."
"  The format does not support encoding of Objective C properties.  This "
"proposal describes DWARF extensions to encode Objective C properties, "
"which the debugger can use to let developers inspect Objective C "
"properties."
msgstr ""

#: ../../SourceLevelDebugging.rst:496
msgid "Proposal"
msgstr ""

#: ../../SourceLevelDebugging.rst:498
msgid ""
"Objective C properties exist separately from class members.  A property "
"can be defined only by \"setter\" and \"getter\" selectors, and be "
"calculated anew on each access.  Or a property can just be a direct "
"access to some declared ivar. Finally it can have an ivar \"automatically"
" synthesized\" for it by the compiler, in which case the property can be "
"referred to in user code directly using the standard C dereference syntax"
" as well as through the property \"dot\" syntax, but there is no entry in"
" the ``@interface`` declaration corresponding to this ivar."
msgstr ""

#: ../../SourceLevelDebugging.rst:506
msgid ""
"To facilitate debugging, these properties we will add a new DWARF TAG "
"into the ``DW_TAG_structure_type`` definition for the class to hold the "
"description of a given property, and a set of DWARF attributes that "
"provide said description. The property tag will also contain the name and"
" declared type of the property."
msgstr ""

#: ../../SourceLevelDebugging.rst:511
msgid ""
"If there is a related ivar, there will also be a DWARF property attribute"
" placed in the ``DW_TAG_member`` DIE for that ivar referring back to the "
"property TAG for that property.  And in the case where the compiler "
"synthesizes the ivar directly, the compiler is expected to generate a "
"``DW_TAG_member`` for that ivar (with the ``DW_AT_artificial`` set to 1),"
" whose name will be the name used to access this ivar directly in code, "
"and with the property attribute pointing back to the property it is "
"backing."
msgstr ""

#: ../../SourceLevelDebugging.rst:519
msgid "The following examples will serve as illustration for our discussion:"
msgstr ""

#: ../../SourceLevelDebugging.rst:536
msgid "This produces the following DWARF (this is a \"pseudo dwarfdump\" output):"
msgstr ""

#: ../../SourceLevelDebugging.rst:567
msgid ""
"Note, the current convention is that the name of the ivar for an auto-"
"synthesized property is the name of the property from which it derives "
"with an underscore prepended, as is shown in the example.  But we "
"actually don't need to know this convention, since we are given the name "
"of the ivar directly."
msgstr ""

#: ../../SourceLevelDebugging.rst:573
msgid ""
"Also, it is common practice in ObjC to have different property "
"declarations in the @interface and @implementation - e.g. to provide a "
"read-only property in the interface,and a read-write interface in the "
"implementation.  In that case, the compiler should emit whichever "
"property declaration will be in force in the current translation unit."
msgstr ""

#: ../../SourceLevelDebugging.rst:579
msgid ""
"Developers can decorate a property with attributes which are encoded "
"using ``DW_AT_APPLE_property_attribute``."
msgstr ""

#: ../../SourceLevelDebugging.rst:593
msgid ""
"The setter and getter method names are attached to the property using "
"``DW_AT_APPLE_property_setter`` and ``DW_AT_APPLE_property_getter`` "
"attributes."
msgstr ""

#: ../../SourceLevelDebugging.rst:608
msgid "The DWARF for this would be:"
msgstr ""

#: ../../SourceLevelDebugging.rst:630
msgid "New DWARF Tags"
msgstr ""

#: ../../SourceLevelDebugging.rst:633
msgid "TAG"
msgstr ""

#: ../../SourceLevelDebugging.rst:633 ../../SourceLevelDebugging.rst:642
#: ../../SourceLevelDebugging.rst:657
msgid "Value"
msgstr ""

#: ../../SourceLevelDebugging.rst:635
msgid "DW_TAG_APPLE_property"
msgstr ""

#: ../../SourceLevelDebugging.rst:635
msgid "0x4200"
msgstr ""

#: ../../SourceLevelDebugging.rst:639
msgid "New DWARF Attributes"
msgstr ""

#: ../../SourceLevelDebugging.rst:642
msgid "Attribute"
msgstr ""

#: ../../SourceLevelDebugging.rst:642
msgid "Classes"
msgstr ""

#: ../../SourceLevelDebugging.rst:644
msgid "DW_AT_APPLE_property"
msgstr ""

#: ../../SourceLevelDebugging.rst:644
msgid "0x3fed"
msgstr ""

#: ../../SourceLevelDebugging.rst:644
msgid "Reference"
msgstr ""

#: ../../SourceLevelDebugging.rst:646
msgid "DW_AT_APPLE_property_getter"
msgstr ""

#: ../../SourceLevelDebugging.rst:646
msgid "0x3fe9"
msgstr ""

#: ../../SourceLevelDebugging.rst:646 ../../SourceLevelDebugging.rst:648
msgid "String"
msgstr ""

#: ../../SourceLevelDebugging.rst:648
msgid "DW_AT_APPLE_property_setter"
msgstr ""

#: ../../SourceLevelDebugging.rst:648
msgid "0x3fea"
msgstr ""

#: ../../SourceLevelDebugging.rst:650
msgid "DW_AT_APPLE_property_attribute"
msgstr ""

#: ../../SourceLevelDebugging.rst:650
msgid "0x3feb"
msgstr ""

#: ../../SourceLevelDebugging.rst:650
msgid "Constant"
msgstr ""

#: ../../SourceLevelDebugging.rst:654
msgid "New DWARF Constants"
msgstr ""

#: ../../SourceLevelDebugging.rst:657
msgid "Name"
msgstr ""

#: ../../SourceLevelDebugging.rst:659
msgid "DW_APPLE_PROPERTY_readonly"
msgstr ""

#: ../../SourceLevelDebugging.rst:659
msgid "0x01"
msgstr ""

#: ../../SourceLevelDebugging.rst:661
msgid "DW_APPLE_PROPERTY_getter"
msgstr ""

#: ../../SourceLevelDebugging.rst:661
msgid "0x02"
msgstr ""

#: ../../SourceLevelDebugging.rst:663
msgid "DW_APPLE_PROPERTY_assign"
msgstr ""

#: ../../SourceLevelDebugging.rst:663
msgid "0x04"
msgstr ""

#: ../../SourceLevelDebugging.rst:665
msgid "DW_APPLE_PROPERTY_readwrite"
msgstr ""

#: ../../SourceLevelDebugging.rst:665
msgid "0x08"
msgstr ""

#: ../../SourceLevelDebugging.rst:667
msgid "DW_APPLE_PROPERTY_retain"
msgstr ""

#: ../../SourceLevelDebugging.rst:667
msgid "0x10"
msgstr ""

#: ../../SourceLevelDebugging.rst:669
msgid "DW_APPLE_PROPERTY_copy"
msgstr ""

#: ../../SourceLevelDebugging.rst:669
msgid "0x20"
msgstr ""

#: ../../SourceLevelDebugging.rst:671
msgid "DW_APPLE_PROPERTY_nonatomic"
msgstr ""

#: ../../SourceLevelDebugging.rst:671
msgid "0x40"
msgstr ""

#: ../../SourceLevelDebugging.rst:673
msgid "DW_APPLE_PROPERTY_setter"
msgstr ""

#: ../../SourceLevelDebugging.rst:673
msgid "0x80"
msgstr ""

#: ../../SourceLevelDebugging.rst:675
msgid "DW_APPLE_PROPERTY_atomic"
msgstr ""

#: ../../SourceLevelDebugging.rst:675
msgid "0x100"
msgstr ""

#: ../../SourceLevelDebugging.rst:677
msgid "DW_APPLE_PROPERTY_weak"
msgstr ""

#: ../../SourceLevelDebugging.rst:677
msgid "0x200"
msgstr ""

#: ../../SourceLevelDebugging.rst:679
msgid "DW_APPLE_PROPERTY_strong"
msgstr ""

#: ../../SourceLevelDebugging.rst:679
msgid "0x400"
msgstr ""

#: ../../SourceLevelDebugging.rst:681
msgid "DW_APPLE_PROPERTY_unsafe_unretained"
msgstr ""

#: ../../SourceLevelDebugging.rst:681
msgid "0x800"
msgstr ""

#: ../../SourceLevelDebugging.rst:685
msgid "Name Accelerator Tables"
msgstr ""

#: ../../SourceLevelDebugging.rst:690
msgid ""
"The \"``.debug_pubnames``\" and \"``.debug_pubtypes``\" formats are not "
"what a debugger needs.  The \"``pub``\" in the section name indicates "
"that the entries in the table are publicly visible names only.  This "
"means no static or hidden functions show up in the "
"\"``.debug_pubnames``\".  No static variables or private class variables "
"are in the \"``.debug_pubtypes``\".  Many compilers add different things "
"to these tables, so we can't rely upon the contents between gcc, icc, or "
"clang."
msgstr ""

#: ../../SourceLevelDebugging.rst:698
msgid ""
"The typical query given by users tends not to match up with the contents "
"of these tables.  For example, the DWARF spec states that \"In the case "
"of the name of a function member or static data member of a C++ "
"structure, class or union, the name presented in the "
"\"``.debug_pubnames``\" section is not the simple name given by the "
"``DW_AT_name attribute`` of the referenced debugging information entry, "
"but rather the fully qualified name of the data or function member.\" So "
"the only names in these tables for complex C++ entries is a fully "
"qualified name.  Debugger users tend not to enter their search strings as"
" \"``a::b::c(int,const Foo&) const``\", but rather as \"``c``\", "
"\"``b::c``\" , or \"``a::b::c``\".  So the name entered in the name table"
" must be demangled in order to chop it up appropriately and additional "
"names must be manually entered into the table to make it effective as a "
"name lookup table for debuggers to use."
msgstr ""

#: ../../SourceLevelDebugging.rst:712
msgid ""
"All debuggers currently ignore the \"``.debug_pubnames``\" table as a "
"result of its inconsistent and useless public-only name content making it"
" a waste of space in the object file.  These tables, when they are "
"written to disk, are not sorted in any way, leaving every debugger to do "
"its own parsing and sorting. These tables also include an inlined copy of"
" the string values in the table itself making the tables much larger than"
" they need to be on disk, especially for large C++ programs."
msgstr ""

#: ../../SourceLevelDebugging.rst:720
msgid ""
"Can't we just fix the sections by adding all of the names we need to this"
" table? No, because that is not what the tables are defined to contain "
"and we won't know the difference between the old bad tables and the new "
"good tables. At best we could make our own renamed sections that contain "
"all of the data we need."
msgstr ""

#: ../../SourceLevelDebugging.rst:726
msgid ""
"These tables are also insufficient for what a debugger like LLDB needs.  "
"LLDB uses clang for its expression parsing where LLDB acts as a PCH.  "
"LLDB is then often asked to look for type \"``foo``\" or namespace "
"\"``bar``\", or list items in namespace \"``baz``\".  Namespaces are not "
"included in the pubnames or pubtypes tables.  Since clang asks a lot of "
"questions when it is parsing an expression, we need to be very fast when "
"looking up names, as it happens a lot.  Having new accelerator tables "
"that are optimized for very quick lookups will benefit this type of "
"debugging experience greatly."
msgstr ""

#: ../../SourceLevelDebugging.rst:735
msgid ""
"We would like to generate name lookup tables that can be mapped into "
"memory from disk, and used as is, with little or no up-front parsing.  We"
" would also be able to control the exact content of these different "
"tables so they contain exactly what we need.  The Name Accelerator Tables"
" were designed to fix these issues.  In order to solve these issues we "
"need to:"
msgstr ""

#: ../../SourceLevelDebugging.rst:741
msgid "Have a format that can be mapped into memory from disk and used as is"
msgstr ""

#: ../../SourceLevelDebugging.rst:742
msgid "Lookups should be very fast"
msgstr ""

#: ../../SourceLevelDebugging.rst:743
msgid "Extensible table format so these tables can be made by many producers"
msgstr ""

#: ../../SourceLevelDebugging.rst:744
msgid "Contain all of the names needed for typical lookups out of the box"
msgstr ""

#: ../../SourceLevelDebugging.rst:745
msgid "Strict rules for the contents of tables"
msgstr ""

#: ../../SourceLevelDebugging.rst:747
msgid ""
"Table size is important and the accelerator table format should allow the"
" reuse of strings from common string tables so the strings for the names "
"are not duplicated.  We also want to make sure the table is ready to be "
"used as-is by simply mapping the table into memory with minimal header "
"parsing."
msgstr ""

#: ../../SourceLevelDebugging.rst:752
msgid ""
"The name lookups need to be fast and optimized for the kinds of lookups "
"that debuggers tend to do.  Optimally we would like to touch as few parts"
" of the mapped table as possible when doing a name lookup and be able to "
"quickly find the name entry we are looking for, or discover there are no "
"matches.  In the case of debuggers we optimized for lookups that fail "
"most of the time."
msgstr ""

#: ../../SourceLevelDebugging.rst:758
msgid ""
"Each table that is defined should have strict rules on exactly what is in"
" the accelerator tables and documented so clients can rely on the "
"content."
msgstr ""

#: ../../SourceLevelDebugging.rst:762
msgid "Hash Tables"
msgstr ""

#: ../../SourceLevelDebugging.rst:765
msgid "Standard Hash Tables"
msgstr ""

#: ../../SourceLevelDebugging.rst:767
msgid ""
"Typical hash tables have a header, buckets, and each bucket points to the"
" bucket contents:"
msgstr ""

#: ../../SourceLevelDebugging.rst:780
msgid "The BUCKETS are an array of offsets to DATA for each hash:"
msgstr ""

#: ../../SourceLevelDebugging.rst:793
msgid ""
"So for ``bucket[3]`` in the example above, we have an offset into the "
"table 0x000034f0 which points to a chain of entries for the bucket.  Each"
" bucket must contain a next pointer, full 32 bit hash value, the string "
"itself, and the data for the current string value."
msgstr ""

#: ../../SourceLevelDebugging.rst:817
msgid ""
"The problem with this layout for debuggers is that we need to optimize "
"for the negative lookup case where the symbol we're searching for is not "
"present.  So if we were to lookup \"``printf``\" in the table above, we "
"would make a 32 hash for \"``printf``\", it might match ``bucket[3]``.  "
"We would need to go to the offset 0x000034f0 and start looking to see if "
"our 32 bit hash matches.  To do so, we need to read the next pointer, "
"then read the hash, compare it, and skip to the next bucket.  Each time "
"we are skipping many bytes in memory and touching new cache pages just to"
" do the compare on the full 32 bit hash.  All of these accesses then tell"
" us that we didn't have a match."
msgstr ""

#: ../../SourceLevelDebugging.rst:828
msgid "Name Hash Tables"
msgstr ""

#: ../../SourceLevelDebugging.rst:830
msgid ""
"To solve the issues mentioned above we have structured the hash tables a "
"bit differently: a header, buckets, an array of all unique 32 bit hash "
"values, followed by an array of hash value data offsets, one for each "
"hash value, then the data for all hash values:"
msgstr ""

#: ../../SourceLevelDebugging.rst:849
msgid ""
"The ``BUCKETS`` in the name tables are an index into the ``HASHES`` "
"array.  By making all of the full 32 bit hash values contiguous in "
"memory, we allow ourselves to efficiently check for a match while "
"touching as little memory as possible.  Most often checking the 32 bit "
"hash values is as far as the lookup goes.  If it does match, it usually "
"is a match with no collisions.  So for a table with \"``n_buckets``\" "
"buckets, and \"``n_hashes``\" unique 32 bit hash values, we can clarify "
"the contents of the ``BUCKETS``, ``HASHES`` and ``OFFSETS`` as:"
msgstr ""

#: ../../SourceLevelDebugging.rst:878
msgid ""
"So taking the exact same data from the standard hash example above we end"
" up with:"
msgstr ""

#: ../../SourceLevelDebugging.rst:964
msgid ""
"So we still have all of the same data, we just organize it more "
"efficiently for debugger lookup.  If we repeat the same \"``printf``\" "
"lookup from above, we would hash \"``printf``\" and find it matches "
"``BUCKETS[3]`` by taking the 32 bit hash value and modulo it by "
"``n_buckets``.  ``BUCKETS[3]`` contains \"6\" which is the index into the"
" ``HASHES`` table.  We would then compare any consecutive 32 bit hashes "
"values in the ``HASHES`` array as long as the hashes would be in "
"``BUCKETS[3]``.  We do this by verifying that each subsequent hash value "
"modulo ``n_buckets`` is still 3.  In the case of a failed lookup we would"
" access the memory for ``BUCKETS[3]``, and then compare a few consecutive"
" 32 bit hashes before we know that we have no match.  We don't end up "
"marching through multiple words of memory and we really keep the number "
"of processor data cache lines being accessed as small as possible."
msgstr ""

#: ../../SourceLevelDebugging.rst:977
msgid ""
"The string hash that is used for these lookup tables is the Daniel J. "
"Bernstein hash which is also used in the ELF ``GNU_HASH`` sections.  It "
"is a very good hash for all kinds of names in programs with very few hash"
" collisions."
msgstr ""

#: ../../SourceLevelDebugging.rst:982
msgid ""
"Empty buckets are designated by using an invalid hash index of "
"``UINT32_MAX``."
msgstr ""

#: ../../SourceLevelDebugging.rst:985
msgid "Details"
msgstr ""

#: ../../SourceLevelDebugging.rst:987
msgid ""
"These name hash tables are designed to be generic where specializations "
"of the table get to define additional data that goes into the header "
"(\"``HeaderData``\"), how the string value is stored (\"``KeyType``\") "
"and the content of the data for each hash value."
msgstr ""

#: ../../SourceLevelDebugging.rst:993
msgid "Header Layout"
msgstr ""

#: ../../SourceLevelDebugging.rst:995
msgid ""
"The header has a fixed part, and the specialized part.  The exact format "
"of the header is:"
msgstr ""

#: ../../SourceLevelDebugging.rst:1013
msgid ""
"The header starts with a 32 bit \"``magic``\" value which must be "
"``'HASH'`` encoded as an ASCII integer.  This allows the detection of the"
" start of the hash table and also allows the table's byte order to be "
"determined so the table can be correctly extracted.  The \"``magic``\" "
"value is followed by a 16 bit ``version`` number which allows the table "
"to be revised and modified in the future.  The current version number is "
"1. ``hash_function`` is a ``uint16_t`` enumeration that specifies which "
"hash function was used to produce this table. The current values for the "
"hash function enumerations include:"
msgstr ""

#: ../../SourceLevelDebugging.rst:1029
msgid ""
"``bucket_count`` is a 32 bit unsigned integer that represents how many "
"buckets are in the ``BUCKETS`` array.  ``hashes_count`` is the number of "
"unique 32 bit hash values that are in the ``HASHES`` array, and is the "
"same number of offsets are contained in the ``OFFSETS`` array.  "
"``header_data_len`` specifies the size in bytes of the ``HeaderData`` "
"that is filled in by specialized versions of this table."
msgstr ""

#: ../../SourceLevelDebugging.rst:1037
msgid "Fixed Lookup"
msgstr ""

#: ../../SourceLevelDebugging.rst:1039
msgid ""
"The header is followed by the buckets, hashes, offsets, and hash value "
"data."
msgstr ""

#: ../../SourceLevelDebugging.rst:1050
msgid ""
"``buckets`` is an array of 32 bit indexes into the ``hashes`` array.  The"
" ``hashes`` array contains all of the 32 bit hash values for all names in"
" the hash table.  Each hash in the ``hashes`` table has an offset in the "
"``offsets`` array that points to the data for the hash value."
msgstr ""

#: ../../SourceLevelDebugging.rst:1055
msgid ""
"This table setup makes it very easy to repurpose these tables to contain "
"different data, while keeping the lookup mechanism the same for all "
"tables. This layout also makes it possible to save the table to disk and "
"map it in later and do very efficient name lookups with little or no "
"parsing."
msgstr ""

#: ../../SourceLevelDebugging.rst:1060
msgid ""
"DWARF lookup tables can be implemented in a variety of ways and can store"
" a lot of information for each name.  We want to make the DWARF tables "
"extensible and able to store the data efficiently so we have used some of"
" the DWARF features that enable efficient data storage to define exactly "
"what kind of data we store for each name."
msgstr ""

#: ../../SourceLevelDebugging.rst:1066
msgid ""
"The ``HeaderData`` contains a definition of the contents of each HashData"
" chunk. We might want to store an offset to all of the debug information "
"entries (DIEs) for each name.  To keep things extensible, we create a "
"list of items, or Atoms, that are contained in the data for each name.  "
"First comes the type of the data in each atom:"
msgstr ""

#: ../../SourceLevelDebugging.rst:1084
msgid "The enumeration values and their meanings are:"
msgstr ""

#: ../../SourceLevelDebugging.rst:1095
msgid ""
"Then we allow each atom type to define the atom type and how the data for"
" each atom type data is encoded:"
msgstr ""

#: ../../SourceLevelDebugging.rst:1106
msgid ""
"The ``form`` type above is from the DWARF specification and defines the "
"exact encoding of the data for the Atom type.  See the DWARF "
"specification for the ``DW_FORM_`` definitions."
msgstr ""

#: ../../SourceLevelDebugging.rst:1119
msgid ""
"``HeaderData`` defines the base DIE offset that should be added to any "
"atoms that are encoded using the ``DW_FORM_ref1``, ``DW_FORM_ref2``, "
"``DW_FORM_ref4``, ``DW_FORM_ref8`` or ``DW_FORM_ref_udata``.  It also "
"defines what is contained in each ``HashData`` object -- ``Atom.form`` "
"tells us how large each field will be in the ``HashData`` and the "
"``Atom.type`` tells us how this data should be interpreted."
msgstr ""

#: ../../SourceLevelDebugging.rst:1126
msgid ""
"For the current implementations of the \"``.apple_names``\" (all "
"functions + globals), the \"``.apple_types``\" (names of all types that "
"are defined), and the \"``.apple_namespaces``\" (all namespaces), we "
"currently set the ``Atom`` array to be:"
msgstr ""

#: ../../SourceLevelDebugging.rst:1137
msgid ""
"This defines the contents to be the DIE offset (eAtomTypeDIEOffset) that "
"is encoded as a 32 bit value (DW_FORM_data4).  This allows a single name "
"to have multiple matching DIEs in a single file, which could come up with"
" an inlined function for instance.  Future tables could include more "
"information about the DIE such as flags indicating if the DIE is a "
"function, method, block, or inlined."
msgstr ""

#: ../../SourceLevelDebugging.rst:1144
msgid ""
"The KeyType for the DWARF table is a 32 bit string table offset into the "
"\".debug_str\" table.  The \".debug_str\" is the string table for the "
"DWARF which may already contain copies of all of the strings.  This helps"
" make sure, with help from the compiler, that we reuse the strings "
"between all of the DWARF sections and keeps the hash table size down.  "
"Another benefit to having the compiler generate all strings as "
"DW_FORM_strp in the debug info, is that DWARF parsing can be made much "
"faster."
msgstr ""

#: ../../SourceLevelDebugging.rst:1152
msgid ""
"After a lookup is made, we get an offset into the hash data.  The hash "
"data needs to be able to deal with 32 bit hash collisions, so the chunk "
"of data at the offset in the hash data consists of a triple:"
msgstr ""

#: ../../SourceLevelDebugging.rst:1162
#, python-format
msgid ""
"If \"str_offset\" is zero, then the bucket contents are done. 99.9% of "
"the hash data chunks contain a single item (no 32 bit hash collision):"
msgstr ""

#: ../../SourceLevelDebugging.rst:1177
msgid "If there are collisions, you will have multiple valid string offsets:"
msgstr ""

#: ../../SourceLevelDebugging.rst:1195
msgid ""
"Current testing with real world C++ binaries has shown that there is "
"around 1 32 bit hash collision per 100,000 name entries."
msgstr ""

#: ../../SourceLevelDebugging.rst:1199
msgid "Contents"
msgstr ""

#: ../../SourceLevelDebugging.rst:1201
msgid ""
"As we said, we want to strictly define exactly what is included in the "
"different tables.  For DWARF, we have 3 tables: \"``.apple_names``\", "
"\"``.apple_types``\", and \"``.apple_namespaces``\"."
msgstr ""

#: ../../SourceLevelDebugging.rst:1205
msgid ""
"\"``.apple_names``\" sections should contain an entry for each DWARF DIE "
"whose ``DW_TAG`` is a ``DW_TAG_label``, ``DW_TAG_inlined_subroutine``, or"
" ``DW_TAG_subprogram`` that has address attributes: ``DW_AT_low_pc``, "
"``DW_AT_high_pc``, ``DW_AT_ranges`` or ``DW_AT_entry_pc``.  It also "
"contains ``DW_TAG_variable`` DIEs that have a ``DW_OP_addr`` in the "
"location (global and static variables).  All global and static variables "
"should be included, including those scoped within functions and classes."
"  For example using the following code:"
msgstr ""

#: ../../SourceLevelDebugging.rst:1223
msgid ""
"Both of the static ``var`` variables would be included in the table.  All"
" functions should emit both their full names and their basenames.  For C "
"or C++, the full name is the mangled name (if available) which is usually"
" in the ``DW_AT_MIPS_linkage_name`` attribute, and the ``DW_AT_name`` "
"contains the function basename.  If global or static variables have a "
"mangled name in a ``DW_AT_MIPS_linkage_name`` attribute, this should be "
"emitted along with the simple name found in the ``DW_AT_name`` attribute."
msgstr ""

#: ../../SourceLevelDebugging.rst:1231
msgid ""
"\"``.apple_types``\" sections should contain an entry for each DWARF DIE "
"whose tag is one of:"
msgstr ""

#: ../../SourceLevelDebugging.rst:1234
msgid "DW_TAG_array_type"
msgstr ""

#: ../../SourceLevelDebugging.rst:1235
msgid "DW_TAG_class_type"
msgstr ""

#: ../../SourceLevelDebugging.rst:1236
msgid "DW_TAG_enumeration_type"
msgstr ""

#: ../../SourceLevelDebugging.rst:1237
msgid "DW_TAG_pointer_type"
msgstr ""

#: ../../SourceLevelDebugging.rst:1238
msgid "DW_TAG_reference_type"
msgstr ""

#: ../../SourceLevelDebugging.rst:1239
msgid "DW_TAG_string_type"
msgstr ""

#: ../../SourceLevelDebugging.rst:1240
msgid "DW_TAG_structure_type"
msgstr ""

#: ../../SourceLevelDebugging.rst:1241
msgid "DW_TAG_subroutine_type"
msgstr ""

#: ../../SourceLevelDebugging.rst:1242
msgid "DW_TAG_typedef"
msgstr ""

#: ../../SourceLevelDebugging.rst:1243
msgid "DW_TAG_union_type"
msgstr ""

#: ../../SourceLevelDebugging.rst:1244
msgid "DW_TAG_ptr_to_member_type"
msgstr ""

#: ../../SourceLevelDebugging.rst:1245
msgid "DW_TAG_set_type"
msgstr ""

#: ../../SourceLevelDebugging.rst:1246
msgid "DW_TAG_subrange_type"
msgstr ""

#: ../../SourceLevelDebugging.rst:1247
msgid "DW_TAG_base_type"
msgstr ""

#: ../../SourceLevelDebugging.rst:1248
msgid "DW_TAG_const_type"
msgstr ""

#: ../../SourceLevelDebugging.rst:1249
msgid "DW_TAG_file_type"
msgstr ""

#: ../../SourceLevelDebugging.rst:1250
msgid "DW_TAG_namelist"
msgstr ""

#: ../../SourceLevelDebugging.rst:1251
msgid "DW_TAG_packed_type"
msgstr ""

#: ../../SourceLevelDebugging.rst:1252
msgid "DW_TAG_volatile_type"
msgstr ""

#: ../../SourceLevelDebugging.rst:1253
msgid "DW_TAG_restrict_type"
msgstr ""

#: ../../SourceLevelDebugging.rst:1254
msgid "DW_TAG_interface_type"
msgstr ""

#: ../../SourceLevelDebugging.rst:1255
msgid "DW_TAG_unspecified_type"
msgstr ""

#: ../../SourceLevelDebugging.rst:1256
msgid "DW_TAG_shared_type"
msgstr ""

#: ../../SourceLevelDebugging.rst:1258
msgid ""
"Only entries with a ``DW_AT_name`` attribute are included, and the entry "
"must not be a forward declaration (``DW_AT_declaration`` attribute with a"
" non-zero value).  For example, using the following code:"
msgstr ""

#: ../../SourceLevelDebugging.rst:1270
msgid "We get a few type DIEs:"
msgstr ""

#: ../../SourceLevelDebugging.rst:1283
msgid ""
"The DW_TAG_pointer_type is not included because it does not have a "
"``DW_AT_name``."
msgstr ""

#: ../../SourceLevelDebugging.rst:1285
msgid ""
"\"``.apple_namespaces``\" section should contain all ``DW_TAG_namespace``"
" DIEs. If we run into a namespace that has no name this is an anonymous "
"namespace, and the name should be output as \"``(anonymous namespace)``\""
" (without the quotes). Why?  This matches the output of the "
"``abi::cxa_demangle()`` that is in the standard C++ library that "
"demangles mangled names."
msgstr ""

#: ../../SourceLevelDebugging.rst:1293
msgid "Language Extensions and File Format Changes"
msgstr ""

#: ../../SourceLevelDebugging.rst:1296
msgid "Objective-C Extensions"
msgstr ""

#: ../../SourceLevelDebugging.rst:1298
msgid ""
"\"``.apple_objc``\" section should contain all ``DW_TAG_subprogram`` DIEs"
" for an Objective-C class.  The name used in the hash table is the name "
"of the Objective-C class itself.  If the Objective-C class has a "
"category, then an entry is made for both the class name without the "
"category, and for the class name with the category.  So if we have a DIE "
"at offset 0x1234 with a name of method \"``-[NSString(my_additions) "
"stringWithSpecialString:]``\", we would add an entry for \"``NSString``\""
" that points to DIE 0x1234, and an entry for "
"\"``NSString(my_additions)``\" that points to 0x1234.  This allows us to "
"quickly track down all Objective-C methods for an Objective-C class when "
"doing expressions.  It is needed because of the dynamic nature of "
"Objective-C where anyone can add methods to a class.  The DWARF for "
"Objective-C methods is also emitted differently from C++ classes where "
"the methods are not usually contained in the class definition, they are "
"scattered about across one or more compile units.  Categories can also be"
" defined in different shared libraries. So we need to be able to quickly "
"find all of the methods and class functions given the Objective-C class "
"name, or quickly find all methods and class functions for a class + "
"category name.  This table does not contain any selector names, it just "
"maps Objective-C class names (or class names + category) to all of the "
"methods and class functions.  The selectors are added as function "
"basenames in the \"``.debug_names``\" section."
msgstr ""

#: ../../SourceLevelDebugging.rst:1319
msgid ""
"In the \"``.apple_names``\" section for Objective-C functions, the full "
"name is the entire function name with the brackets (\"``-[NSString "
"stringWithCString:]``\") and the basename is the selector only "
"(\"``stringWithCString:``\")."
msgstr ""

#: ../../SourceLevelDebugging.rst:1325
msgid "Mach-O Changes"
msgstr ""

#: ../../SourceLevelDebugging.rst:1327
msgid ""
"The sections names for the apple hash tables are for non-mach-o files.  "
"For mach-o files, the sections should be contained in the ``__DWARF`` "
"segment with names as follows:"
msgstr ""

#: ../../SourceLevelDebugging.rst:1331
msgid "\"``.apple_names``\" -> \"``__apple_names``\""
msgstr ""

#: ../../SourceLevelDebugging.rst:1332
msgid "\"``.apple_types``\" -> \"``__apple_types``\""
msgstr ""

#: ../../SourceLevelDebugging.rst:1333
msgid "\"``.apple_namespaces``\" -> \"``__apple_namespac``\" (16 character limit)"
msgstr ""

#: ../../SourceLevelDebugging.rst:1334
msgid "\"``.apple_objc``\" -> \"``__apple_objc``\""
msgstr ""

