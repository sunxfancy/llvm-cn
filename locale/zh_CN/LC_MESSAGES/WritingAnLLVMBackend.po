# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2003-2016, LLVM Project
# This file is distributed under the same license as the LLVM package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2016.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: LLVM 3.8\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2016-04-17 11:36+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.3.3\n"

#: ../../WritingAnLLVMBackend.rst:3
msgid "Writing an LLVM Backend"
msgstr ""

#: ../../WritingAnLLVMBackend.rst:14
msgid "Introduction"
msgstr ""

#: ../../WritingAnLLVMBackend.rst:16
msgid ""
"This document describes techniques for writing compiler backends that "
"convert the LLVM Intermediate Representation (IR) to code for a specified"
" machine or other languages.  Code intended for a specific machine can "
"take the form of either assembly code or binary code (usable for a JIT "
"compiler)."
msgstr ""

#: ../../WritingAnLLVMBackend.rst:21
msgid ""
"The backend of LLVM features a target-independent code generator that may"
" create output for several types of target CPUs --- including X86, "
"PowerPC, ARM, and SPARC.  The backend may also be used to generate code "
"targeted at SPUs of the Cell processor or GPUs to support the execution "
"of compute kernels."
msgstr ""

#: ../../WritingAnLLVMBackend.rst:26
msgid ""
"The document focuses on existing examples found in subdirectories of "
"``llvm/lib/Target`` in a downloaded LLVM release.  In particular, this "
"document focuses on the example of creating a static compiler (one that "
"emits text assembly) for a SPARC target, because SPARC has fairly "
"standard characteristics, such as a RISC instruction set and "
"straightforward calling conventions."
msgstr ""

#: ../../WritingAnLLVMBackend.rst:34
msgid "Audience"
msgstr ""

#: ../../WritingAnLLVMBackend.rst:36
msgid ""
"The audience for this document is anyone who needs to write an LLVM "
"backend to generate code for a specific hardware or software target."
msgstr ""

#: ../../WritingAnLLVMBackend.rst:40
msgid "Prerequisite Reading"
msgstr ""

#: ../../WritingAnLLVMBackend.rst:42
msgid "These essential documents must be read before reading this document:"
msgstr ""

#: ../../WritingAnLLVMBackend.rst:44
msgid ""
"`LLVM Language Reference Manual <LangRef.html>`_ --- a reference manual "
"for the LLVM assembly language."
msgstr ""

#: ../../WritingAnLLVMBackend.rst:47
msgid ""
":doc:`CodeGenerator` --- a guide to the components (classes and code "
"generation algorithms) for translating the LLVM internal representation "
"into machine code for a specified target.  Pay particular attention to "
"the descriptions of code generation stages: Instruction Selection, "
"Scheduling and Formation, SSA-based Optimization, Register Allocation, "
"Prolog/Epilog Code Insertion, Late Machine Code Optimizations, and Code "
"Emission."
msgstr ""

#: ../../WritingAnLLVMBackend.rst:54
msgid ""
":doc:`TableGen/index` --- a document that describes the TableGen "
"(``tblgen``) application that manages domain-specific information to "
"support LLVM code generation.  TableGen processes input from a target "
"description file (``.td`` suffix) and generates C++ code that can be used"
" for code generation."
msgstr ""

#: ../../WritingAnLLVMBackend.rst:60
msgid ""
":doc:`WritingAnLLVMPass` --- The assembly printer is a ``FunctionPass``, "
"as are several ``SelectionDAG`` processing steps."
msgstr ""

#: ../../WritingAnLLVMBackend.rst:63
msgid ""
"To follow the SPARC examples in this document, have a copy of `The SPARC "
"Architecture Manual, Version 8 <http://www.sparc.org/standards/V8.pdf>`_ "
"for reference.  For details about the ARM instruction set, refer to the "
"`ARM Architecture Reference Manual <http://infocenter.arm.com/>`_.  For "
"more about the GNU Assembler format (``GAS``), see `Using As "
"<http://sourceware.org/binutils/docs/as/index.html>`_, especially for the"
" assembly printer.  \"Using As\" contains a list of target machine "
"dependent features."
msgstr ""

#: ../../WritingAnLLVMBackend.rst:73
msgid "Basic Steps"
msgstr ""

#: ../../WritingAnLLVMBackend.rst:75
msgid ""
"To write a compiler backend for LLVM that converts the LLVM IR to code "
"for a specified target (machine or other language), follow these steps:"
msgstr ""

#: ../../WritingAnLLVMBackend.rst:78
msgid ""
"Create a subclass of the ``TargetMachine`` class that describes "
"characteristics of your target machine.  Copy existing examples of "
"specific ``TargetMachine`` class and header files; for example, start "
"with ``SparcTargetMachine.cpp`` and ``SparcTargetMachine.h``, but change "
"the file names for your target.  Similarly, change code that references "
"\"``Sparc``\" to reference your target."
msgstr ""

#: ../../WritingAnLLVMBackend.rst:85
msgid ""
"Describe the register set of the target.  Use TableGen to generate code "
"for register definition, register aliases, and register classes from a "
"target-specific ``RegisterInfo.td`` input file.  You should also write "
"additional code for a subclass of the ``TargetRegisterInfo`` class that "
"represents the class register file data used for register allocation and "
"also describes the interactions between registers."
msgstr ""

#: ../../WritingAnLLVMBackend.rst:92
msgid ""
"Describe the instruction set of the target.  Use TableGen to generate "
"code for target-specific instructions from target-specific versions of "
"``TargetInstrFormats.td`` and ``TargetInstrInfo.td``.  You should write "
"additional code for a subclass of the ``TargetInstrInfo`` class to "
"represent machine instructions supported by the target machine."
msgstr ""

#: ../../WritingAnLLVMBackend.rst:98
msgid ""
"Describe the selection and conversion of the LLVM IR from a Directed "
"Acyclic Graph (DAG) representation of instructions to native target-"
"specific instructions.  Use TableGen to generate code that matches "
"patterns and selects instructions based on additional information in a "
"target-specific version of ``TargetInstrInfo.td``.  Write code for "
"``XXXISelDAGToDAG.cpp``, where ``XXX`` identifies the specific target, to"
" perform pattern matching and DAG-to-DAG instruction selection.  Also "
"write code in ``XXXISelLowering.cpp`` to replace or remove operations and"
" data types that are not supported natively in a SelectionDAG."
msgstr ""

#: ../../WritingAnLLVMBackend.rst:108
msgid ""
"Write code for an assembly printer that converts LLVM IR to a GAS format "
"for your target machine.  You should add assembly strings to the "
"instructions defined in your target-specific version of "
"``TargetInstrInfo.td``.  You should also write code for a subclass of "
"``AsmPrinter`` that performs the LLVM-to-assembly conversion and a "
"trivial subclass of ``TargetAsmInfo``."
msgstr ""

#: ../../WritingAnLLVMBackend.rst:114
msgid ""
"Optionally, add support for subtargets (i.e., variants with different "
"capabilities).  You should also write code for a subclass of the "
"``TargetSubtarget`` class, which allows you to use the ``-mcpu=`` and "
"``-mattr=`` command-line options."
msgstr ""

#: ../../WritingAnLLVMBackend.rst:119
msgid ""
"Optionally, add JIT support and create a machine code emitter (subclass "
"of ``TargetJITInfo``) that is used to emit binary code directly into "
"memory."
msgstr ""

#: ../../WritingAnLLVMBackend.rst:122
msgid ""
"In the ``.cpp`` and ``.h``. files, initially stub up these methods and "
"then implement them later.  Initially, you may not know which private "
"members that the class will need and which components will need to be "
"subclassed."
msgstr ""

#: ../../WritingAnLLVMBackend.rst:127
msgid "Preliminaries"
msgstr ""

#: ../../WritingAnLLVMBackend.rst:129
msgid ""
"To actually create your compiler backend, you need to create and modify a"
" few files.  The absolute minimum is discussed here.  But to actually use"
" the LLVM target-independent code generator, you must perform the steps "
"described in the :doc:`LLVM Target-Independent Code Generator "
"<CodeGenerator>` document."
msgstr ""

#: ../../WritingAnLLVMBackend.rst:134
msgid ""
"First, you should create a subdirectory under ``lib/Target`` to hold all "
"the files related to your target.  If your target is called \"Dummy\", "
"create the directory ``lib/Target/Dummy``."
msgstr ""

#: ../../WritingAnLLVMBackend.rst:138
msgid ""
"In this new directory, create a ``Makefile``.  It is easiest to copy a "
"``Makefile`` of another target and modify it.  It should at least contain"
" the ``LEVEL``, ``LIBRARYNAME`` and ``TARGET`` variables, and then "
"include ``$(LEVEL)/Makefile.common``.  The library can be named "
"``LLVMDummy`` (for example, see the MIPS target).  Alternatively, you can"
" split the library into ``LLVMDummyCodeGen`` and ``LLVMDummyAsmPrinter``,"
" the latter of which should be implemented in a subdirectory below "
"``lib/Target/Dummy`` (for example, see the PowerPC target)."
msgstr ""

#: ../../WritingAnLLVMBackend.rst:147
msgid ""
"Note that these two naming schemes are hardcoded into ``llvm-config``.  "
"Using any other naming scheme will confuse ``llvm-config`` and produce a "
"lot of (seemingly unrelated) linker errors when linking ``llc``."
msgstr ""

#: ../../WritingAnLLVMBackend.rst:151
msgid ""
"To make your target actually do something, you need to implement a "
"subclass of ``TargetMachine``.  This implementation should typically be "
"in the file ``lib/Target/DummyTargetMachine.cpp``, but any file in the "
"``lib/Target`` directory will be built and should work.  To use LLVM's "
"target independent code generator, you should do what all current machine"
" backends do: create a subclass of ``LLVMTargetMachine``.  (To create a "
"target from scratch, create a subclass of ``TargetMachine``.)"
msgstr ""

#: ../../WritingAnLLVMBackend.rst:159
msgid ""
"To get LLVM to actually build and link your target, you need to add it to"
" the ``TARGETS_TO_BUILD`` variable.  To do this, you modify the configure"
" script to know about your target when parsing the ``--enable-targets`` "
"option.  Search the configure script for ``TARGETS_TO_BUILD``, add your "
"target to the lists there (some creativity required), and then "
"reconfigure.  Alternatively, you can change ``autoconf/configure.ac`` and"
" regenerate configure by running ``./autoconf/AutoRegen.sh``."
msgstr ""

#: ../../WritingAnLLVMBackend.rst:168
msgid "Target Machine"
msgstr ""

#: ../../WritingAnLLVMBackend.rst:170
msgid ""
"``LLVMTargetMachine`` is designed as a base class for targets implemented"
" with the LLVM target-independent code generator.  The "
"``LLVMTargetMachine`` class should be specialized by a concrete target "
"class that implements the various virtual methods.  ``LLVMTargetMachine``"
" is defined as a subclass of ``TargetMachine`` in "
"``include/llvm/Target/TargetMachine.h``.  The ``TargetMachine`` class "
"implementation (``TargetMachine.cpp``) also processes numerous command-"
"line options."
msgstr ""

#: ../../WritingAnLLVMBackend.rst:178
msgid ""
"To create a concrete target-specific subclass of ``LLVMTargetMachine``, "
"start by copying an existing ``TargetMachine`` class and header.  You "
"should name the files that you create to reflect your specific target.  "
"For instance, for the SPARC target, name the files "
"``SparcTargetMachine.h`` and ``SparcTargetMachine.cpp``."
msgstr ""

#: ../../WritingAnLLVMBackend.rst:184
msgid ""
"For a target machine ``XXX``, the implementation of ``XXXTargetMachine`` "
"must have access methods to obtain objects that represent target "
"components.  These methods are named ``get*Info``, and are intended to "
"obtain the instruction set (``getInstrInfo``), register set "
"(``getRegisterInfo``), stack frame layout (``getFrameInfo``), and similar"
" information.  ``XXXTargetMachine`` must also implement the "
"``getDataLayout`` method to access an object with target-specific data "
"characteristics, such as data type size and alignment requirements."
msgstr ""

#: ../../WritingAnLLVMBackend.rst:192
msgid ""
"For instance, for the SPARC target, the header file "
"``SparcTargetMachine.h`` declares prototypes for several ``get*Info`` and"
" ``getDataLayout`` methods that simply return a class member."
msgstr ""

#: ../../WritingAnLLVMBackend.rst:230
msgid "``getInstrInfo()``"
msgstr ""

#: ../../WritingAnLLVMBackend.rst:231
msgid "``getRegisterInfo()``"
msgstr ""

#: ../../WritingAnLLVMBackend.rst:232
msgid "``getFrameInfo()``"
msgstr ""

#: ../../WritingAnLLVMBackend.rst:233
msgid "``getDataLayout()``"
msgstr ""

#: ../../WritingAnLLVMBackend.rst:234
msgid "``getSubtargetImpl()``"
msgstr ""

#: ../../WritingAnLLVMBackend.rst:236
msgid "For some targets, you also need to support the following methods:"
msgstr ""

#: ../../WritingAnLLVMBackend.rst:238
msgid "``getTargetLowering()``"
msgstr ""

#: ../../WritingAnLLVMBackend.rst:239
msgid "``getJITInfo()``"
msgstr ""

#: ../../WritingAnLLVMBackend.rst:241
msgid ""
"Some architectures, such as GPUs, do not support jumping to an arbitrary "
"program location and implement branching using masked execution and loop "
"using special instructions around the loop body. In order to avoid CFG "
"modifications that introduce irreducible control flow not handled by such"
" hardware, a target must call `setRequiresStructuredCFG(true)` when being"
" initialized."
msgstr ""

#: ../../WritingAnLLVMBackend.rst:247
msgid ""
"In addition, the ``XXXTargetMachine`` constructor should specify a "
"``TargetDescription`` string that determines the data layout for the "
"target machine, including characteristics such as pointer size, "
"alignment, and endianness.  For example, the constructor for "
"``SparcTargetMachine`` contains the following:"
msgstr ""

#: ../../WritingAnLLVMBackend.rst:261
msgid "Hyphens separate portions of the ``TargetDescription`` string."
msgstr ""

#: ../../WritingAnLLVMBackend.rst:263
msgid ""
"An upper-case \"``E``\" in the string indicates a big-endian target data "
"model. A lower-case \"``e``\" indicates little-endian."
msgstr ""

#: ../../WritingAnLLVMBackend.rst:266
msgid ""
"\"``p:``\" is followed by pointer information: size, ABI alignment, and "
"preferred alignment.  If only two figures follow \"``p:``\", then the "
"first value is pointer size, and the second value is both ABI and "
"preferred alignment."
msgstr ""

#: ../../WritingAnLLVMBackend.rst:271
msgid ""
"Then a letter for numeric type alignment: \"``i``\", \"``f``\", "
"\"``v``\", or \"``a``\" (corresponding to integer, floating point, "
"vector, or aggregate). \"``i``\", \"``v``\", or \"``a``\" are followed by"
" ABI alignment and preferred alignment. \"``f``\" is followed by three "
"values: the first indicates the size of a long double, then ABI "
"alignment, and then ABI preferred alignment."
msgstr ""

#: ../../WritingAnLLVMBackend.rst:278
msgid "Target Registration"
msgstr ""

#: ../../WritingAnLLVMBackend.rst:280
msgid ""
"You must also register your target with the ``TargetRegistry``, which is "
"what other LLVM tools use to be able to lookup and use your target at "
"runtime.  The ``TargetRegistry`` can be used directly, but for most "
"targets there are helper templates which should take care of the work for"
" you."
msgstr ""

#: ../../WritingAnLLVMBackend.rst:285
msgid ""
"All targets should declare a global ``Target`` object which is used to "
"represent the target during registration.  Then, in the target's "
"``TargetInfo`` library, the target should define that object and use the "
"``RegisterTarget`` template to register the target.  For example, the "
"Sparc registration code looks like this:"
msgstr ""

#: ../../WritingAnLLVMBackend.rst:300
msgid ""
"This allows the ``TargetRegistry`` to look up the target by name or by "
"target triple.  In addition, most targets will also register additional "
"features which are available in separate libraries.  These registration "
"steps are separate, because some clients may wish to only link in some "
"parts of the target --- the JIT code generator does not require the use "
"of the assembler printer, for example.  Here is an example of registering"
" the Sparc assembly printer:"
msgstr ""

#: ../../WritingAnLLVMBackend.rst:313
msgid ""
"For more information, see \"`llvm/Target/TargetRegistry.h </doxygen"
"/TargetRegistry_8h-source.html>`_\"."
msgstr ""

#: ../../WritingAnLLVMBackend.rst:317
msgid "Register Set and Register Classes"
msgstr ""

#: ../../WritingAnLLVMBackend.rst:319
msgid ""
"You should describe a concrete target-specific class that represents the "
"register file of a target machine.  This class is called "
"``XXXRegisterInfo`` (where ``XXX`` identifies the target) and represents "
"the class register file data that is used for register allocation.  It "
"also describes the interactions between registers."
msgstr ""

#: ../../WritingAnLLVMBackend.rst:325
msgid ""
"You also need to define register classes to categorize related registers."
"  A register class should be added for groups of registers that are all "
"treated the same way for some instruction.  Typical examples are register"
" classes for integer, floating-point, or vector registers.  A register "
"allocator allows an instruction to use any register in a specified "
"register class to perform the instruction in a similar manner.  Register "
"classes allocate virtual registers to instructions from these sets, and "
"register classes let the target-independent register allocator "
"automatically choose the actual registers."
msgstr ""

#: ../../WritingAnLLVMBackend.rst:335
msgid ""
"Much of the code for registers, including register definition, register "
"aliases, and register classes, is generated by TableGen from "
"``XXXRegisterInfo.td`` input files and placed in "
"``XXXGenRegisterInfo.h.inc`` and ``XXXGenRegisterInfo.inc`` output files."
"  Some of the code in the implementation of ``XXXRegisterInfo`` requires "
"hand-coding."
msgstr ""

#: ../../WritingAnLLVMBackend.rst:342
msgid "Defining a Register"
msgstr ""

#: ../../WritingAnLLVMBackend.rst:344
msgid ""
"The ``XXXRegisterInfo.td`` file typically starts with register "
"definitions for a target machine.  The ``Register`` class (specified in "
"``Target.td``) is used to define an object for each register.  The "
"specified string ``n`` becomes the ``Name`` of the register.  The basic "
"``Register`` object does not have any subregisters and does not specify "
"any aliases."
msgstr ""

#: ../../WritingAnLLVMBackend.rst:363
msgid ""
"For example, in the ``X86RegisterInfo.td`` file, there are register "
"definitions that utilize the ``Register`` class, such as:"
msgstr ""

#: ../../WritingAnLLVMBackend.rst:370
msgid ""
"This defines the register ``AL`` and assigns it values (with "
"``DwarfRegNum``) that are used by ``gcc``, ``gdb``, or a debug "
"information writer to identify a register.  For register ``AL``, "
"``DwarfRegNum`` takes an array of 3 values representing 3 different "
"modes: the first element is for X86-64, the second for exception handling"
" (EH) on X86-32, and the third is generic. -1 is a special Dwarf number "
"that indicates the gcc number is undefined, and -2 indicates the register"
" number is invalid for this mode."
msgstr ""

#: ../../WritingAnLLVMBackend.rst:378
msgid ""
"From the previously described line in the ``X86RegisterInfo.td`` file, "
"TableGen generates this code in the ``X86GenRegisterInfo.inc`` file:"
msgstr ""

#: ../../WritingAnLLVMBackend.rst:391
msgid ""
"From the register info file, TableGen generates a ``TargetRegisterDesc`` "
"object for each register.  ``TargetRegisterDesc`` is defined in "
"``include/llvm/Target/TargetRegisterInfo.h`` with the following fields:"
msgstr ""

#: ../../WritingAnLLVMBackend.rst:406
msgid ""
"TableGen uses the entire target description file (``.td``) to determine "
"text names for the register (in the ``AsmName`` and ``Name`` fields of "
"``TargetRegisterDesc``) and the relationships of other registers to the "
"defined register (in the other ``TargetRegisterDesc`` fields).  In this "
"example, other definitions establish the registers \"``AX``\", "
"\"``EAX``\", and \"``RAX``\" as aliases for one another, so TableGen "
"generates a null-terminated array (``AL_AliasSet``) for this register "
"alias set."
msgstr ""

#: ../../WritingAnLLVMBackend.rst:414
msgid ""
"The ``Register`` class is commonly used as a base class for more complex "
"classes.  In ``Target.td``, the ``Register`` class is the base for the "
"``RegisterWithSubRegs`` class that is used to define registers that need "
"to specify subregisters in the ``SubRegs`` list, as shown here:"
msgstr ""

#: ../../WritingAnLLVMBackend.rst:425
msgid ""
"In ``SparcRegisterInfo.td``, additional register classes are defined for "
"SPARC: a ``Register`` subclass, ``SparcReg``, and further subclasses: "
"``Ri``, ``Rf``, and ``Rd``.  SPARC registers are identified by 5-bit ID "
"numbers, which is a feature common to these subclasses.  Note the use of "
"\"``let``\" expressions to override values that are initially defined in "
"a superclass (such as ``SubRegs`` field in the ``Rd`` class)."
msgstr ""

#: ../../WritingAnLLVMBackend.rst:454
msgid ""
"In the ``SparcRegisterInfo.td`` file, there are register definitions that"
" utilize these subclasses of ``Register``, such as:"
msgstr ""

#: ../../WritingAnLLVMBackend.rst:468
msgid ""
"The last two registers shown above (``D0`` and ``D1``) are double-"
"precision floating-point registers that are aliases for pairs of single-"
"precision floating-point sub-registers.  In addition to aliases, the sub-"
"register and super-register relationships of the defined register are in "
"fields of a register's ``TargetRegisterDesc``."
msgstr ""

#: ../../WritingAnLLVMBackend.rst:475
msgid "Defining a Register Class"
msgstr ""

#: ../../WritingAnLLVMBackend.rst:477
msgid ""
"The ``RegisterClass`` class (specified in ``Target.td``) is used to "
"define an object that represents a group of related registers and also "
"defines the default allocation order of the registers.  A target "
"description file ``XXXRegisterInfo.td`` that uses ``Target.td`` can "
"construct register classes using the following class:"
msgstr ""

#: ../../WritingAnLLVMBackend.rst:505
msgid "To define a ``RegisterClass``, use the following 4 arguments:"
msgstr ""

#: ../../WritingAnLLVMBackend.rst:507
msgid "The first argument of the definition is the name of the namespace."
msgstr ""

#: ../../WritingAnLLVMBackend.rst:509
msgid ""
"The second argument is a list of ``ValueType`` register type values that "
"are defined in ``include/llvm/CodeGen/ValueTypes.td``.  Defined values "
"include integer types (such as ``i16``, ``i32``, and ``i1`` for Boolean),"
" floating-point types (``f32``, ``f64``), and vector types (for example, "
"``v8i16`` for an ``8 x i16`` vector).  All registers in a "
"``RegisterClass`` must have the same ``ValueType``, but some registers "
"may store vector data in different configurations.  For example a "
"register that can process a 128-bit vector may be able to handle 16 8-bit"
" integer elements, 8 16-bit integers, 4 32-bit integers, and so on."
msgstr ""

#: ../../WritingAnLLVMBackend.rst:519
msgid ""
"The third argument of the ``RegisterClass`` definition specifies the "
"alignment required of the registers when they are stored or loaded to "
"memory."
msgstr ""

#: ../../WritingAnLLVMBackend.rst:523
msgid ""
"The final argument, ``regList``, specifies which registers are in this "
"class. If an alternative allocation order method is not specified, then "
"``regList`` also defines the order of allocation used by the register "
"allocator.  Besides simply listing registers with ``(add R0, R1, ...)``, "
"more advanced set operators are available.  See "
"``include/llvm/Target/Target.td`` for more information."
msgstr ""

#: ../../WritingAnLLVMBackend.rst:530
msgid ""
"In ``SparcRegisterInfo.td``, three ``RegisterClass`` objects are defined:"
" ``FPRegs``, ``DFPRegs``, and ``IntRegs``.  For all three register "
"classes, the first argument defines the namespace with the string "
"\"``SP``\".  ``FPRegs`` defines a group of 32 single-precision floating-"
"point registers (``F0`` to ``F31``); ``DFPRegs`` defines a group of 16 "
"double-precision registers (``D0-D15``)."
msgstr ""

#: ../../WritingAnLLVMBackend.rst:560
msgid ""
"Using ``SparcRegisterInfo.td`` with TableGen generates several output "
"files that are intended for inclusion in other source code that you "
"write. ``SparcRegisterInfo.td`` generates ``SparcGenRegisterInfo.h.inc``,"
" which should be included in the header file for the implementation of "
"the SPARC register implementation that you write "
"(``SparcRegisterInfo.h``).  In ``SparcGenRegisterInfo.h.inc`` a new "
"structure is defined called ``SparcGenRegisterInfo`` that uses "
"``TargetRegisterInfo`` as its base.  It also specifies types, based upon "
"the defined register classes: ``DFPRegsClass``, ``FPRegsClass``, and "
"``IntRegsClass``."
msgstr ""

#: ../../WritingAnLLVMBackend.rst:570
msgid ""
"``SparcRegisterInfo.td`` also generates ``SparcGenRegisterInfo.inc``, "
"which is included at the bottom of ``SparcRegisterInfo.cpp``, the SPARC "
"register implementation.  The code below shows only the generated integer"
" registers and associated register classes.  The order of registers in "
"``IntRegs`` reflects the order in the definition of ``IntRegs`` in the "
"target description file."
msgstr ""

#: ../../WritingAnLLVMBackend.rst:623
msgid ""
"The register allocators will avoid using reserved registers, and callee "
"saved registers are not used until all the volatile registers have been "
"used.  That is usually good enough, but in some cases it may be necessary"
" to provide custom allocation orders."
msgstr ""

#: ../../WritingAnLLVMBackend.rst:629
msgid "Implement a subclass of ``TargetRegisterInfo``"
msgstr ""

#: ../../WritingAnLLVMBackend.rst:631
msgid ""
"The final step is to hand code portions of ``XXXRegisterInfo``, which "
"implements the interface described in ``TargetRegisterInfo.h`` (see "
":ref:`TargetRegisterInfo`).  These functions return ``0``, ``NULL``, or "
"``false``, unless overridden.  Here is a list of functions that are "
"overridden for the SPARC implementation in ``SparcRegisterInfo.cpp``:"
msgstr ""

#: ../../WritingAnLLVMBackend.rst:637
msgid ""
"``getCalleeSavedRegs`` --- Returns a list of callee-saved registers in "
"the order of the desired callee-save stack frame offset."
msgstr ""

#: ../../WritingAnLLVMBackend.rst:640
msgid ""
"``getReservedRegs`` --- Returns a bitset indexed by physical register "
"numbers, indicating if a particular register is unavailable."
msgstr ""

#: ../../WritingAnLLVMBackend.rst:643
msgid ""
"``hasFP`` --- Return a Boolean indicating if a function should have a "
"dedicated frame pointer register."
msgstr ""

#: ../../WritingAnLLVMBackend.rst:646
msgid ""
"``eliminateCallFramePseudoInstr`` --- If call frame setup or destroy "
"pseudo instructions are used, this can be called to eliminate them."
msgstr ""

#: ../../WritingAnLLVMBackend.rst:649
msgid ""
"``eliminateFrameIndex`` --- Eliminate abstract frame indices from "
"instructions that may use them."
msgstr ""

#: ../../WritingAnLLVMBackend.rst:652
msgid "``emitPrologue`` --- Insert prologue code into the function."
msgstr ""

#: ../../WritingAnLLVMBackend.rst:654
msgid "``emitEpilogue`` --- Insert epilogue code into the function."
msgstr ""

#: ../../WritingAnLLVMBackend.rst:659
msgid "Instruction Set"
msgstr ""

#: ../../WritingAnLLVMBackend.rst:661
msgid ""
"During the early stages of code generation, the LLVM IR code is converted"
" to a ``SelectionDAG`` with nodes that are instances of the ``SDNode`` "
"class containing target instructions.  An ``SDNode`` has an opcode, "
"operands, type requirements, and operation properties.  For example, is "
"an operation commutative, does an operation load from memory.  The "
"various operation node types are described in the "
"``include/llvm/CodeGen/SelectionDAGNodes.h`` file (values of the "
"``NodeType`` enum in the ``ISD`` namespace)."
msgstr ""

#: ../../WritingAnLLVMBackend.rst:669
msgid ""
"TableGen uses the following target description (``.td``) input files to "
"generate much of the code for instruction definition:"
msgstr ""

#: ../../WritingAnLLVMBackend.rst:672
msgid ""
"``Target.td`` --- Where the ``Instruction``, ``Operand``, ``InstrInfo``, "
"and other fundamental classes are defined."
msgstr ""

#: ../../WritingAnLLVMBackend.rst:675
msgid ""
"``TargetSelectionDAG.td`` --- Used by ``SelectionDAG`` instruction "
"selection generators, contains ``SDTC*`` classes (selection DAG type "
"constraint), definitions of ``SelectionDAG`` nodes (such as ``imm``, "
"``cond``, ``bb``, ``add``, ``fadd``, ``sub``), and pattern support "
"(``Pattern``, ``Pat``, ``PatFrag``, ``PatLeaf``, ``ComplexPattern``."
msgstr ""

#: ../../WritingAnLLVMBackend.rst:681
msgid ""
"``XXXInstrFormats.td`` --- Patterns for definitions of target-specific "
"instructions."
msgstr ""

#: ../../WritingAnLLVMBackend.rst:684
msgid ""
"``XXXInstrInfo.td`` --- Target-specific definitions of instruction "
"templates, condition codes, and instructions of an instruction set.  For "
"architecture modifications, a different file name may be used.  For "
"example, for Pentium with SSE instruction, this file is "
"``X86InstrSSE.td``, and for Pentium with MMX, this file is "
"``X86InstrMMX.td``."
msgstr ""

#: ../../WritingAnLLVMBackend.rst:690
msgid ""
"There is also a target-specific ``XXX.td`` file, where ``XXX`` is the "
"name of the target.  The ``XXX.td`` file includes the other ``.td`` input"
" files, but its contents are only directly important for subtargets."
msgstr ""

#: ../../WritingAnLLVMBackend.rst:694
msgid ""
"You should describe a concrete target-specific class ``XXXInstrInfo`` "
"that represents machine instructions supported by a target machine. "
"``XXXInstrInfo`` contains an array of ``XXXInstrDescriptor`` objects, "
"each of which describes one instruction.  An instruction descriptor "
"defines:"
msgstr ""

#: ../../WritingAnLLVMBackend.rst:699
msgid "Opcode mnemonic"
msgstr ""

#: ../../WritingAnLLVMBackend.rst:700
msgid "Number of operands"
msgstr ""

#: ../../WritingAnLLVMBackend.rst:701
msgid "List of implicit register definitions and uses"
msgstr ""

#: ../../WritingAnLLVMBackend.rst:702
msgid "Target-independent properties (such as memory access, is commutable)"
msgstr ""

#: ../../WritingAnLLVMBackend.rst:703
msgid "Target-specific flags"
msgstr ""

#: ../../WritingAnLLVMBackend.rst:705
msgid ""
"The Instruction class (defined in ``Target.td``) is mostly used as a base"
" for more complex instruction classes."
msgstr ""

#: ../../WritingAnLLVMBackend.rst:722
msgid ""
"A ``SelectionDAG`` node (``SDNode``) should contain an object "
"representing a target-specific instruction that is defined in "
"``XXXInstrInfo.td``.  The instruction objects should represent "
"instructions from the architecture manual of the target machine (such as "
"the SPARC Architecture Manual for the SPARC target)."
msgstr ""

#: ../../WritingAnLLVMBackend.rst:728
msgid ""
"A single instruction from the architecture manual is often modeled as "
"multiple target instructions, depending upon its operands.  For example, "
"a manual might describe an add instruction that takes a register or an "
"immediate operand.  An LLVM target could model this with two instructions"
" named ``ADDri`` and ``ADDrr``."
msgstr ""

#: ../../WritingAnLLVMBackend.rst:734
msgid ""
"You should define a class for each instruction category and define each "
"opcode as a subclass of the category with appropriate parameters such as "
"the fixed binary encoding of opcodes and extended opcodes.  You should "
"map the register bits to the bits of the instruction in which they are "
"encoded (for the JIT). Also you should specify how the instruction should"
" be printed when the automatic assembly printer is used."
msgstr ""

#: ../../WritingAnLLVMBackend.rst:741
msgid ""
"As is described in the SPARC Architecture Manual, Version 8, there are "
"three major 32-bit formats for instructions.  Format 1 is only for the "
"``CALL`` instruction.  Format 2 is for branch on condition codes and "
"``SETHI`` (set high bits of a register) instructions.  Format 3 is for "
"other instructions."
msgstr ""

#: ../../WritingAnLLVMBackend.rst:746
msgid ""
"Each of these formats has corresponding classes in "
"``SparcInstrFormat.td``. ``InstSP`` is a base class for other instruction"
" classes.  Additional base classes are specified for more precise "
"formats: for example in ``SparcInstrFormat.td``, ``F2_1`` is for "
"``SETHI``, and ``F2_2`` is for branches.  There are three other base "
"classes: ``F3_1`` for register/register operations, ``F3_2`` for "
"register/immediate operations, and ``F3_3`` for floating-point "
"operations.  ``SparcInstrInfo.td`` also adds the base class ``Pseudo`` "
"for synthetic SPARC instructions."
msgstr ""

#: ../../WritingAnLLVMBackend.rst:755
msgid ""
"``SparcInstrInfo.td`` largely consists of operand and instruction "
"definitions for the SPARC target.  In ``SparcInstrInfo.td``, the "
"following target description file entry, ``LDrr``, defines the Load "
"Integer instruction for a Word (the ``LD`` SPARC opcode) from a memory "
"address to a register.  The first parameter, the value 3 (``11``\\ "
":sub:`2`), is the operation value for this category of operation.  The "
"second parameter (``000000``\\ :sub:`2`) is the specific operation value "
"for ``LD``/Load Word.  The third parameter is the output destination, "
"which is a register operand and defined in the ``Register`` target "
"description file (``IntRegs``)."
msgstr ""

#: ../../WritingAnLLVMBackend.rst:771
msgid ""
"The fourth parameter is the input source, which uses the address operand "
"``MEMrr`` that is defined earlier in ``SparcInstrInfo.td``:"
msgstr ""

#: ../../WritingAnLLVMBackend.rst:781
msgid ""
"The fifth parameter is a string that is used by the assembly printer and "
"can be left as an empty string until the assembly printer interface is "
"implemented. The sixth and final parameter is the pattern used to match "
"the instruction during the SelectionDAG Select Phase described in "
":doc:`CodeGenerator`. This parameter is detailed in the next section, "
":ref:`instruction-selector`."
msgstr ""

#: ../../WritingAnLLVMBackend.rst:787
msgid ""
"Instruction class definitions are not overloaded for different operand "
"types, so separate versions of instructions are needed for register, "
"memory, or immediate value operands.  For example, to perform a Load "
"Integer instruction for a Word from an immediate operand to a register, "
"the following instruction class is defined:"
msgstr ""

#: ../../WritingAnLLVMBackend.rst:799
msgid ""
"Writing these definitions for so many similar instructions can involve a "
"lot of cut and paste.  In ``.td`` files, the ``multiclass`` directive "
"enables the creation of templates to define several instruction classes "
"at once (using the ``defm`` directive).  For example in "
"``SparcInstrInfo.td``, the ``multiclass`` pattern ``F3_12`` is defined to"
" create 2 instruction classes each time ``F3_12`` is invoked:"
msgstr ""

#: ../../WritingAnLLVMBackend.rst:819
msgid ""
"So when the ``defm`` directive is used for the ``XOR`` and ``ADD`` "
"instructions, as seen below, it creates four instruction objects: "
"``XORrr``, ``XORri``, ``ADDrr``, and ``ADDri``."
msgstr ""

#: ../../WritingAnLLVMBackend.rst:828
msgid ""
"``SparcInstrInfo.td`` also includes definitions for condition codes that "
"are referenced by branch instructions.  The following definitions in "
"``SparcInstrInfo.td`` indicate the bit location of the SPARC condition "
"code. For example, the 10\\ :sup:`th` bit represents the \"greater than\""
" condition for integers, and the 22\\ :sup:`nd` bit represents the "
"\"greater than\" condition for floats."
msgstr ""

#: ../../WritingAnLLVMBackend.rst:846
msgid ""
"(Note that ``Sparc.h`` also defines enums that correspond to the same "
"SPARC condition codes.  Care must be taken to ensure the values in "
"``Sparc.h`` correspond to the values in ``SparcInstrInfo.td``.  I.e., "
"``SPCC::ICC_NE = 9``, ``SPCC::FCC_U = 23`` and so on.)"
msgstr ""

#: ../../WritingAnLLVMBackend.rst:852
msgid "Instruction Operand Mapping"
msgstr ""

#: ../../WritingAnLLVMBackend.rst:854
msgid ""
"The code generator backend maps instruction operands to fields in the "
"instruction.  Operands are assigned to unbound fields in the instruction "
"in the order they are defined.  Fields are bound when they are assigned a"
" value.  For example, the Sparc target defines the ``XNORrr`` instruction"
" as a ``F3_1`` format instruction having three operands."
msgstr ""

#: ../../WritingAnLLVMBackend.rst:867
msgid ""
"The instruction templates in ``SparcInstrFormats.td`` show the base class"
" for ``F3_1`` is ``InstSP``."
msgstr ""

#: ../../WritingAnLLVMBackend.rst:883
msgid "``InstSP`` leaves the ``op`` field unbound."
msgstr ""

#: ../../WritingAnLLVMBackend.rst:898
msgid ""
"``F3`` binds the ``op`` field and defines the ``rd``, ``op3``, and "
"``rs1`` fields.  ``F3`` format instructions will bind the operands "
"``rd``, ``op3``, and ``rs1`` fields."
msgstr ""

#: ../../WritingAnLLVMBackend.rst:915
msgid ""
"``F3_1`` binds the ``op3`` field and defines the ``rs2`` fields.  "
"``F3_1`` format instructions will bind the operands to the ``rd``, "
"``rs1``, and ``rs2`` fields.  This results in the ``XNORrr`` instruction "
"binding ``$dst``, ``$b``, and ``$c`` operands to the ``rd``, ``rs1``, and"
" ``rs2`` fields respectively."
msgstr ""

#: ../../WritingAnLLVMBackend.rst:921
msgid "Instruction Operand Name Mapping"
msgstr ""

#: ../../WritingAnLLVMBackend.rst:923
msgid ""
"TableGen will also generate a function called getNamedOperandIdx() which "
"can be used to look up an operand's index in a MachineInstr based on its "
"TableGen name.  Setting the UseNamedOperandTable bit in an instruction's "
"TableGen definition will add all of its operands to an enumeration in the"
" llvm::XXX:OpName namespace and also add an entry for it into the "
"OperandMap table, which can be queried using getNamedOperandIdx()"
msgstr ""

#: ../../WritingAnLLVMBackend.rst:939
msgid ""
"The entries in the OpName enum are taken verbatim from the TableGen "
"definitions, so operands with lowercase names will have lower case "
"entries in the enum."
msgstr ""

#: ../../WritingAnLLVMBackend.rst:942
msgid ""
"To include the getNamedOperandIdx() function in your backend, you will "
"need to define a few preprocessor macros in XXXInstrInfo.cpp and "
"XXXInstrInfo.h. For example:"
msgstr ""

#: ../../WritingAnLLVMBackend.rst:946
msgid "XXXInstrInfo.cpp:"
msgstr ""

#: ../../WritingAnLLVMBackend.rst:953
msgid "XXXInstrInfo.h:"
msgstr ""

#: ../../WritingAnLLVMBackend.rst:965
msgid "Instruction Operand Types"
msgstr ""

#: ../../WritingAnLLVMBackend.rst:967
msgid ""
"TableGen will also generate an enumeration consisting of all named "
"Operand types defined in the backend, in the llvm::XXX::OpTypes "
"namespace. Some common immediate Operand types (for instance i8, i32, "
"i64, f32, f64) are defined for all targets in "
"``include/llvm/Target/Target.td``, and are available in each Target's "
"OpTypes enum.  Also, only named Operand types appear in the enumeration: "
"anonymous types are ignored. For example, the X86 backend defines "
"``brtarget`` and ``brtarget8``, both instances of the TableGen "
"``Operand`` class, which represent branch target operands:"
msgstr ""

#: ../../WritingAnLLVMBackend.rst:982
msgid "This results in:"
msgstr ""

#: ../../WritingAnLLVMBackend.rst:1000
msgid ""
"In typical TableGen fashion, to use the enum, you will need to define a "
"preprocessor macro:"
msgstr ""

#: ../../WritingAnLLVMBackend.rst:1010
msgid "Instruction Scheduling"
msgstr ""

#: ../../WritingAnLLVMBackend.rst:1012
msgid ""
"Instruction itineraries can be queried using MCDesc::getSchedClass(). The"
" value can be named by an enumemation in llvm::XXX::Sched namespace "
"generated by TableGen in XXXGenInstrInfo.inc. The name of the schedule "
"classes are the same as provided in XXXSchedule.td plus a default "
"NoItinerary class."
msgstr ""

#: ../../WritingAnLLVMBackend.rst:1018
msgid "Instruction Relation Mapping"
msgstr ""

#: ../../WritingAnLLVMBackend.rst:1020
msgid ""
"This TableGen feature is used to relate instructions with each other.  It"
" is particularly useful when you have multiple instruction formats and "
"need to switch between them after instruction selection.  This entire "
"feature is driven by relation models which can be defined in "
"``XXXInstrInfo.td`` files according to the target-specific instruction "
"set.  Relation models are defined using ``InstrMapping`` class as a base."
"  TableGen parses all the models and generates instruction relation maps "
"using the specified information. Relation maps are emitted as tables in "
"the ``XXXGenInstrInfo.inc`` file along with the functions to query them."
"  For the detailed information on how to use this feature, please refer "
"to :doc:`HowToUseInstrMappings`."
msgstr ""

#: ../../WritingAnLLVMBackend.rst:1032
msgid "Implement a subclass of ``TargetInstrInfo``"
msgstr ""

#: ../../WritingAnLLVMBackend.rst:1034
msgid ""
"The final step is to hand code portions of ``XXXInstrInfo``, which "
"implements the interface described in ``TargetInstrInfo.h`` (see "
":ref:`TargetInstrInfo`). These functions return ``0`` or a Boolean or "
"they assert, unless overridden. Here's a list of functions that are "
"overridden for the SPARC implementation in ``SparcInstrInfo.cpp``:"
msgstr ""

#: ../../WritingAnLLVMBackend.rst:1040
msgid ""
"``isLoadFromStackSlot`` --- If the specified machine instruction is a "
"direct load from a stack slot, return the register number of the "
"destination and the ``FrameIndex`` of the stack slot."
msgstr ""

#: ../../WritingAnLLVMBackend.rst:1044
msgid ""
"``isStoreToStackSlot`` --- If the specified machine instruction is a "
"direct store to a stack slot, return the register number of the "
"destination and the ``FrameIndex`` of the stack slot."
msgstr ""

#: ../../WritingAnLLVMBackend.rst:1048
msgid "``copyPhysReg`` --- Copy values between a pair of physical registers."
msgstr ""

#: ../../WritingAnLLVMBackend.rst:1050
msgid "``storeRegToStackSlot`` --- Store a register value to a stack slot."
msgstr ""

#: ../../WritingAnLLVMBackend.rst:1052
msgid "``loadRegFromStackSlot`` --- Load a register value from a stack slot."
msgstr ""

#: ../../WritingAnLLVMBackend.rst:1054
msgid "``storeRegToAddr`` --- Store a register value to memory."
msgstr ""

#: ../../WritingAnLLVMBackend.rst:1056
msgid "``loadRegFromAddr`` --- Load a register value from memory."
msgstr ""

#: ../../WritingAnLLVMBackend.rst:1058
msgid ""
"``foldMemoryOperand`` --- Attempt to combine instructions of any load or "
"store instruction for the specified operand(s)."
msgstr ""

#: ../../WritingAnLLVMBackend.rst:1062
msgid "Branch Folding and If Conversion"
msgstr ""

#: ../../WritingAnLLVMBackend.rst:1064
msgid ""
"Performance can be improved by combining instructions or by eliminating "
"instructions that are never reached.  The ``AnalyzeBranch`` method in "
"``XXXInstrInfo`` may be implemented to examine conditional instructions "
"and remove unnecessary instructions.  ``AnalyzeBranch`` looks at the end "
"of a machine basic block (MBB) for opportunities for improvement, such as"
" branch folding and if conversion.  The ``BranchFolder`` and "
"``IfConverter`` machine function passes (see the source files "
"``BranchFolding.cpp`` and ``IfConversion.cpp`` in the ``lib/CodeGen`` "
"directory) call ``AnalyzeBranch`` to improve the control flow graph that "
"represents the instructions."
msgstr ""

#: ../../WritingAnLLVMBackend.rst:1074
msgid ""
"Several implementations of ``AnalyzeBranch`` (for ARM, Alpha, and X86) "
"can be examined as models for your own ``AnalyzeBranch`` implementation."
"  Since SPARC does not implement a useful ``AnalyzeBranch``, the ARM "
"target implementation is shown below."
msgstr ""

#: ../../WritingAnLLVMBackend.rst:1079
msgid "``AnalyzeBranch`` returns a Boolean value and takes four parameters:"
msgstr ""

#: ../../WritingAnLLVMBackend.rst:1081
msgid "``MachineBasicBlock &MBB`` --- The incoming block to be examined."
msgstr ""

#: ../../WritingAnLLVMBackend.rst:1083
msgid ""
"``MachineBasicBlock *&TBB`` --- A destination block that is returned.  "
"For a conditional branch that evaluates to true, ``TBB`` is the "
"destination."
msgstr ""

#: ../../WritingAnLLVMBackend.rst:1086
msgid ""
"``MachineBasicBlock *&FBB`` --- For a conditional branch that evaluates "
"to false, ``FBB`` is returned as the destination."
msgstr ""

#: ../../WritingAnLLVMBackend.rst:1089
msgid ""
"``std::vector<MachineOperand> &Cond`` --- List of operands to evaluate a "
"condition for a conditional branch."
msgstr ""

#: ../../WritingAnLLVMBackend.rst:1092
msgid ""
"In the simplest case, if a block ends without a branch, then it falls "
"through to the successor block.  No destination blocks are specified for "
"either ``TBB`` or ``FBB``, so both parameters return ``NULL``.  The start"
" of the ``AnalyzeBranch`` (see code below for the ARM target) shows the "
"function parameters and the code for the simplest case."
msgstr ""

#: ../../WritingAnLLVMBackend.rst:1109
msgid ""
"If a block ends with a single unconditional branch instruction, then "
"``AnalyzeBranch`` (shown below) should return the destination of that "
"branch in the ``TBB`` parameter."
msgstr ""

#: ../../WritingAnLLVMBackend.rst:1120
msgid ""
"If a block ends with two unconditional branches, then the second branch "
"is never reached.  In that situation, as shown below, remove the last "
"branch instruction and return the penultimate branch in the ``TBB`` "
"parameter."
msgstr ""

#: ../../WritingAnLLVMBackend.rst:1134
msgid ""
"A block may end with a single conditional branch instruction that falls "
"through to successor block if the condition evaluates to false.  In that "
"case, ``AnalyzeBranch`` (shown below) should return the destination of "
"that conditional branch in the ``TBB`` parameter and a list of operands "
"in the ``Cond`` parameter to evaluate the condition."
msgstr ""

#: ../../WritingAnLLVMBackend.rst:1150
msgid ""
"If a block ends with both a conditional branch and an ensuing "
"unconditional branch, then ``AnalyzeBranch`` (shown below) should return "
"the conditional branch destination (assuming it corresponds to a "
"conditional evaluation of \"``true``\") in the ``TBB`` parameter and the "
"unconditional branch destination in the ``FBB`` (corresponding to a "
"conditional evaluation of \"``false``\").  A list of operands to evaluate"
" the condition should be returned in the ``Cond`` parameter."
msgstr ""

#: ../../WritingAnLLVMBackend.rst:1171
msgid ""
"For the last two cases (ending with a single conditional branch or ending"
" with one conditional and one unconditional branch), the operands "
"returned in the ``Cond`` parameter can be passed to methods of other "
"instructions to create new branches or perform other operations.  An "
"implementation of ``AnalyzeBranch`` requires the helper methods "
"``RemoveBranch`` and ``InsertBranch`` to manage subsequent operations."
msgstr ""

#: ../../WritingAnLLVMBackend.rst:1178
msgid ""
"``AnalyzeBranch`` should return false indicating success in most "
"circumstances. ``AnalyzeBranch`` should only return true when the method "
"is stumped about what to do, for example, if a block has three "
"terminating branches. ``AnalyzeBranch`` may return true if it encounters "
"a terminator it cannot handle, such as an indirect branch."
msgstr ""

#: ../../WritingAnLLVMBackend.rst:1187
msgid "Instruction Selector"
msgstr ""

#: ../../WritingAnLLVMBackend.rst:1189
msgid ""
"LLVM uses a ``SelectionDAG`` to represent LLVM IR instructions, and nodes"
" of the ``SelectionDAG`` ideally represent native target instructions.  "
"During code generation, instruction selection passes are performed to "
"convert non-native DAG instructions into native target-specific "
"instructions.  The pass described in ``XXXISelDAGToDAG.cpp`` is used to "
"match patterns and perform DAG-to-DAG instruction selection.  Optionally,"
" a pass may be defined (in ``XXXBranchSelector.cpp``) to perform similar "
"DAG-to-DAG operations for branch instructions.  Later, the code in "
"``XXXISelLowering.cpp`` replaces or removes operations and data types not"
" supported natively (legalizes) in a ``SelectionDAG``."
msgstr ""

#: ../../WritingAnLLVMBackend.rst:1200
msgid ""
"TableGen generates code for instruction selection using the following "
"target description input files:"
msgstr ""

#: ../../WritingAnLLVMBackend.rst:1203
msgid ""
"``XXXInstrInfo.td`` --- Contains definitions of instructions in a target-"
"specific instruction set, generates ``XXXGenDAGISel.inc``, which is "
"included in ``XXXISelDAGToDAG.cpp``."
msgstr ""

#: ../../WritingAnLLVMBackend.rst:1207
msgid ""
"``XXXCallingConv.td`` --- Contains the calling and return value "
"conventions for the target architecture, and it generates "
"``XXXGenCallingConv.inc``, which is included in ``XXXISelLowering.cpp``."
msgstr ""

#: ../../WritingAnLLVMBackend.rst:1211
msgid ""
"The implementation of an instruction selection pass must include a header"
" that declares the ``FunctionPass`` class or a subclass of "
"``FunctionPass``.  In ``XXXTargetMachine.cpp``, a Pass Manager (PM) "
"should add each instruction selection pass into the queue of passes to "
"run."
msgstr ""

#: ../../WritingAnLLVMBackend.rst:1216
msgid ""
"The LLVM static compiler (``llc``) is an excellent tool for visualizing "
"the contents of DAGs.  To display the ``SelectionDAG`` before or after "
"specific processing phases, use the command line options for ``llc``, "
"described at :ref:`SelectionDAG-Process`."
msgstr ""

#: ../../WritingAnLLVMBackend.rst:1221
msgid ""
"To describe instruction selector behavior, you should add patterns for "
"lowering LLVM code into a ``SelectionDAG`` as the last parameter of the "
"instruction definitions in ``XXXInstrInfo.td``.  For example, in "
"``SparcInstrInfo.td``, this entry defines a register store operation, and"
" the last parameter describes a pattern with the store DAG operator."
msgstr ""

#: ../../WritingAnLLVMBackend.rst:1232
msgid "``ADDRrr`` is a memory mode that is also defined in ``SparcInstrInfo.td``:"
msgstr ""

#: ../../WritingAnLLVMBackend.rst:1238
msgid ""
"The definition of ``ADDRrr`` refers to ``SelectADDRrr``, which is a "
"function defined in an implementation of the Instructor Selector (such as"
" ``SparcISelDAGToDAG.cpp``)."
msgstr ""

#: ../../WritingAnLLVMBackend.rst:1242
msgid ""
"In ``lib/Target/TargetSelectionDAG.td``, the DAG operator for store is "
"defined below:"
msgstr ""

#: ../../WritingAnLLVMBackend.rst:1255
msgid ""
"``XXXInstrInfo.td`` also generates (in ``XXXGenDAGISel.inc``) the "
"``SelectCode`` method that is used to call the appropriate processing "
"method for an instruction.  In this example, ``SelectCode`` calls "
"``Select_ISD_STORE`` for the ``ISD::STORE`` opcode."
msgstr ""

#: ../../WritingAnLLVMBackend.rst:1276
msgid ""
"The pattern for ``STrr`` is matched, so elsewhere in "
"``XXXGenDAGISel.inc``, code for ``STrr`` is created for "
"``Select_ISD_STORE``.  The ``Emit_22`` method is also generated in "
"``XXXGenDAGISel.inc`` to complete the processing of this instruction."
msgstr ""

#: ../../WritingAnLLVMBackend.rst:1303
msgid "The SelectionDAG Legalize Phase"
msgstr ""

#: ../../WritingAnLLVMBackend.rst:1305
msgid ""
"The Legalize phase converts a DAG to use types and operations that are "
"natively supported by the target.  For natively unsupported types and "
"operations, you need to add code to the target-specific "
"``XXXTargetLowering`` implementation to convert unsupported types and "
"operations to supported ones."
msgstr ""

#: ../../WritingAnLLVMBackend.rst:1310
msgid ""
"In the constructor for the ``XXXTargetLowering`` class, first use the "
"``addRegisterClass`` method to specify which types are supported and "
"which register classes are associated with them.  The code for the "
"register classes are generated by TableGen from ``XXXRegisterInfo.td`` "
"and placed in ``XXXGenRegisterInfo.h.inc``.  For example, the "
"implementation of the constructor for the SparcTargetLowering class (in "
"``SparcISelLowering.cpp``) starts with the following code:"
msgstr ""

#: ../../WritingAnLLVMBackend.rst:1324
msgid ""
"You should examine the node types in the ``ISD`` namespace "
"(``include/llvm/CodeGen/SelectionDAGNodes.h``) and determine which "
"operations the target natively supports.  For operations that do **not** "
"have native support, add a callback to the constructor for the "
"``XXXTargetLowering`` class, so the instruction selection process knows "
"what to do.  The ``TargetLowering`` class callback methods (declared in "
"``llvm/Target/TargetLowering.h``) are:"
msgstr ""

#: ../../WritingAnLLVMBackend.rst:1331
msgid "``setOperationAction`` --- General operation."
msgstr ""

#: ../../WritingAnLLVMBackend.rst:1332
msgid "``setLoadExtAction`` --- Load with extension."
msgstr ""

#: ../../WritingAnLLVMBackend.rst:1333
msgid "``setTruncStoreAction`` --- Truncating store."
msgstr ""

#: ../../WritingAnLLVMBackend.rst:1334
msgid "``setIndexedLoadAction`` --- Indexed load."
msgstr ""

#: ../../WritingAnLLVMBackend.rst:1335
msgid "``setIndexedStoreAction`` --- Indexed store."
msgstr ""

#: ../../WritingAnLLVMBackend.rst:1336
msgid "``setConvertAction`` --- Type conversion."
msgstr ""

#: ../../WritingAnLLVMBackend.rst:1337
msgid "``setCondCodeAction`` --- Support for a given condition code."
msgstr ""

#: ../../WritingAnLLVMBackend.rst:1339
msgid ""
"Note: on older releases, ``setLoadXAction`` is used instead of "
"``setLoadExtAction``.  Also, on older releases, ``setCondCodeAction`` may"
" not be supported.  Examine your release to see what methods are "
"specifically supported."
msgstr ""

#: ../../WritingAnLLVMBackend.rst:1344
msgid ""
"These callbacks are used to determine that an operation does or does not "
"work with a specified type (or types).  And in all cases, the third "
"parameter is a ``LegalAction`` type enum value: ``Promote``, ``Expand``, "
"``Custom``, or ``Legal``.  ``SparcISelLowering.cpp`` contains examples of"
" all four ``LegalAction`` values."
msgstr ""

#: ../../WritingAnLLVMBackend.rst:1351
msgid "Promote"
msgstr ""

#: ../../WritingAnLLVMBackend.rst:1353
msgid ""
"For an operation without native support for a given type, the specified "
"type may be promoted to a larger type that is supported.  For example, "
"SPARC does not support a sign-extending load for Boolean values (``i1`` "
"type), so in ``SparcISelLowering.cpp`` the third parameter below, "
"``Promote``, changes ``i1`` type values to a large type before loading."
msgstr ""

#: ../../WritingAnLLVMBackend.rst:1364
msgid "Expand"
msgstr ""

#: ../../WritingAnLLVMBackend.rst:1366
msgid ""
"For a type without native support, a value may need to be broken down "
"further, rather than promoted.  For an operation without native support, "
"a combination of other operations may be used to similar effect.  In "
"SPARC, the floating-point sine and cosine trig operations are supported "
"by expansion to other operations, as indicated by the third parameter, "
"``Expand``, to ``setOperationAction``:"
msgstr ""

#: ../../WritingAnLLVMBackend.rst:1379
msgid "Custom"
msgstr ""

#: ../../WritingAnLLVMBackend.rst:1381
msgid ""
"For some operations, simple type promotion or operation expansion may be "
"insufficient.  In some cases, a special intrinsic function must be "
"implemented."
msgstr ""

#: ../../WritingAnLLVMBackend.rst:1384
msgid ""
"For example, a constant value may require special treatment, or an "
"operation may require spilling and restoring registers in the stack and "
"working with register allocators."
msgstr ""

#: ../../WritingAnLLVMBackend.rst:1388
msgid ""
"As seen in ``SparcISelLowering.cpp`` code below, to perform a type "
"conversion from a floating point value to a signed integer, first the "
"``setOperationAction`` should be called with ``Custom`` as the third "
"parameter:"
msgstr ""

#: ../../WritingAnLLVMBackend.rst:1396
msgid ""
"In the ``LowerOperation`` method, for each ``Custom`` operation, a case "
"statement should be added to indicate what function to call.  In the "
"following code, an ``FP_TO_SINT`` opcode will call the "
"``LowerFP_TO_SINT`` method:"
msgstr ""

#: ../../WritingAnLLVMBackend.rst:1409
msgid ""
"Finally, the ``LowerFP_TO_SINT`` method is implemented, using an FP "
"register to convert the floating-point value to an integer."
msgstr ""

#: ../../WritingAnLLVMBackend.rst:1421
msgid "Legal"
msgstr ""

#: ../../WritingAnLLVMBackend.rst:1423
msgid ""
"The ``Legal`` ``LegalizeAction`` enum value simply indicates that an "
"operation **is** natively supported.  ``Legal`` represents the default "
"condition, so it is rarely used.  In ``SparcISelLowering.cpp``, the "
"action for ``CTPOP`` (an operation to count the bits set in an integer) "
"is natively supported only for SPARC v9.  The following code enables the "
"``Expand`` conversion technique for non-v9 SPARC implementations."
msgstr ""

#: ../../WritingAnLLVMBackend.rst:1438
msgid "Calling Conventions"
msgstr ""

#: ../../WritingAnLLVMBackend.rst:1440
msgid ""
"To support target-specific calling conventions, ``XXXGenCallingConv.td`` "
"uses interfaces (such as ``CCIfType`` and ``CCAssignToReg``) that are "
"defined in ``lib/Target/TargetCallingConv.td``.  TableGen can take the "
"target descriptor file ``XXXGenCallingConv.td`` and generate the header "
"file ``XXXGenCallingConv.inc``, which is typically included in "
"``XXXISelLowering.cpp``.  You can use the interfaces in "
"``TargetCallingConv.td`` to specify:"
msgstr ""

#: ../../WritingAnLLVMBackend.rst:1448
msgid "The order of parameter allocation."
msgstr ""

#: ../../WritingAnLLVMBackend.rst:1450
msgid ""
"Where parameters and return values are placed (that is, on the stack or "
"in registers)."
msgstr ""

#: ../../WritingAnLLVMBackend.rst:1453
msgid "Which registers may be used."
msgstr ""

#: ../../WritingAnLLVMBackend.rst:1455
msgid "Whether the caller or callee unwinds the stack."
msgstr ""

#: ../../WritingAnLLVMBackend.rst:1457
msgid ""
"The following example demonstrates the use of the ``CCIfType`` and "
"``CCAssignToReg`` interfaces.  If the ``CCIfType`` predicate is true "
"(that is, if the current argument is of type ``f32`` or ``f64``), then "
"the action is performed.  In this case, the ``CCAssignToReg`` action "
"assigns the argument value to the first available register: either ``R0``"
" or ``R1``."
msgstr ""

#: ../../WritingAnLLVMBackend.rst:1467
msgid ""
"``SparcCallingConv.td`` contains definitions for a target-specific "
"return-value calling convention (``RetCC_Sparc32``) and a basic 32-bit C "
"calling convention (``CC_Sparc32``).  The definition of ``RetCC_Sparc32``"
" (shown below) indicates which registers are used for specified scalar "
"return types.  A single-precision float is returned to register ``F0``, "
"and a double-precision float goes to register ``D0``.  A 32-bit integer "
"is returned in register ``I0`` or ``I1``."
msgstr ""

#: ../../WritingAnLLVMBackend.rst:1482
msgid ""
"The definition of ``CC_Sparc32`` in ``SparcCallingConv.td`` introduces "
"``CCAssignToStack``, which assigns the value to a stack slot with the "
"specified size and alignment.  In the example below, the first parameter,"
" 4, indicates the size of the slot, and the second parameter, also 4, "
"indicates the stack alignment along 4-byte units.  (Special cases: if "
"size is zero, then the ABI size is used; if alignment is zero, then the "
"ABI alignment is used.)"
msgstr ""

#: ../../WritingAnLLVMBackend.rst:1497
msgid ""
"``CCDelegateTo`` is another commonly used interface, which tries to find "
"a specified sub-calling convention, and, if a match is found, it is "
"invoked.  In the following example (in ``X86CallingConv.td``), the "
"definition of ``RetCC_X86_32_C`` ends with ``CCDelegateTo``.  After the "
"current value is assigned to the register ``ST0`` or ``ST1``, the "
"``RetCC_X86Common`` is invoked."
msgstr ""

#: ../../WritingAnLLVMBackend.rst:1512
msgid ""
"``CCIfCC`` is an interface that attempts to match the given name to the "
"current calling convention.  If the name identifies the current calling "
"convention, then a specified action is invoked.  In the following example"
" (in ``X86CallingConv.td``), if the ``Fast`` calling convention is in "
"use, then ``RetCC_X86_32_Fast`` is invoked.  If the ``SSECall`` calling "
"convention is in use, then ``RetCC_X86_32_SSE`` is invoked."
msgstr ""

#: ../../WritingAnLLVMBackend.rst:1527
msgid "Other calling convention interfaces include:"
msgstr ""

#: ../../WritingAnLLVMBackend.rst:1529
msgid ""
"``CCIf <predicate, action>`` --- If the predicate matches, apply the "
"action."
msgstr ""

#: ../../WritingAnLLVMBackend.rst:1531
msgid ""
"``CCIfInReg <action>`` --- If the argument is marked with the "
"\"``inreg``\" attribute, then apply the action."
msgstr ""

#: ../../WritingAnLLVMBackend.rst:1534
msgid ""
"``CCIfNest <action>`` --- If the argument is marked with the \"``nest``\""
" attribute, then apply the action."
msgstr ""

#: ../../WritingAnLLVMBackend.rst:1537
msgid ""
"``CCIfNotVarArg <action>`` --- If the current function does not take a "
"variable number of arguments, apply the action."
msgstr ""

#: ../../WritingAnLLVMBackend.rst:1540
msgid ""
"``CCAssignToRegWithShadow <registerList, shadowList>`` --- similar to "
"``CCAssignToReg``, but with a shadow list of registers."
msgstr ""

#: ../../WritingAnLLVMBackend.rst:1543
msgid ""
"``CCPassByVal <size, align>`` --- Assign value to a stack slot with the "
"minimum specified size and alignment."
msgstr ""

#: ../../WritingAnLLVMBackend.rst:1546
msgid ""
"``CCPromoteToType <type>`` --- Promote the current value to the specified"
" type."
msgstr ""

#: ../../WritingAnLLVMBackend.rst:1549
msgid ""
"``CallingConv <[actions]>`` --- Define each calling convention that is "
"supported."
msgstr ""

#: ../../WritingAnLLVMBackend.rst:1553
msgid "Assembly Printer"
msgstr ""

#: ../../WritingAnLLVMBackend.rst:1555
msgid ""
"During the code emission stage, the code generator may utilize an LLVM "
"pass to produce assembly output.  To do this, you want to implement the "
"code for a printer that converts LLVM IR to a GAS-format assembly "
"language for your target machine, using the following steps:"
msgstr ""

#: ../../WritingAnLLVMBackend.rst:1560
msgid ""
"Define all the assembly strings for your target, adding them to the "
"instructions defined in the ``XXXInstrInfo.td`` file.  (See :ref"
":`instruction-set`.)  TableGen will produce an output file "
"(``XXXGenAsmWriter.inc``) with an implementation of the "
"``printInstruction`` method for the ``XXXAsmPrinter`` class."
msgstr ""

#: ../../WritingAnLLVMBackend.rst:1566
msgid ""
"Write ``XXXTargetAsmInfo.h``, which contains the bare-bones declaration "
"of the ``XXXTargetAsmInfo`` class (a subclass of ``TargetAsmInfo``)."
msgstr ""

#: ../../WritingAnLLVMBackend.rst:1569
msgid ""
"Write ``XXXTargetAsmInfo.cpp``, which contains target-specific values for"
" ``TargetAsmInfo`` properties and sometimes new implementations for "
"methods."
msgstr ""

#: ../../WritingAnLLVMBackend.rst:1572
msgid ""
"Write ``XXXAsmPrinter.cpp``, which implements the ``AsmPrinter`` class "
"that performs the LLVM-to-assembly conversion."
msgstr ""

#: ../../WritingAnLLVMBackend.rst:1575
msgid ""
"The code in ``XXXTargetAsmInfo.h`` is usually a trivial declaration of "
"the ``XXXTargetAsmInfo`` class for use in ``XXXTargetAsmInfo.cpp``.  "
"Similarly, ``XXXTargetAsmInfo.cpp`` usually has a few declarations of "
"``XXXTargetAsmInfo`` replacement values that override the default values "
"in ``TargetAsmInfo.cpp``. For example in ``SparcTargetAsmInfo.cpp``:"
msgstr ""

#: ../../WritingAnLLVMBackend.rst:1592
msgid ""
"The X86 assembly printer implementation (``X86TargetAsmInfo``) is an "
"example where the target specific ``TargetAsmInfo`` class uses an "
"overridden methods: ``ExpandInlineAsm``."
msgstr ""

#: ../../WritingAnLLVMBackend.rst:1596
msgid ""
"A target-specific implementation of ``AsmPrinter`` is written in "
"``XXXAsmPrinter.cpp``, which implements the ``AsmPrinter`` class that "
"converts the LLVM to printable assembly.  The implementation must include"
" the following headers that have declarations for the ``AsmPrinter`` and "
"``MachineFunctionPass`` classes.  The ``MachineFunctionPass`` is a "
"subclass of ``FunctionPass``."
msgstr ""

#: ../../WritingAnLLVMBackend.rst:1608
msgid ""
"As a ``FunctionPass``, ``AsmPrinter`` first calls ``doInitialization`` to"
" set up the ``AsmPrinter``.  In ``SparcAsmPrinter``, a ``Mangler`` object"
" is instantiated to process variable names."
msgstr ""

#: ../../WritingAnLLVMBackend.rst:1612
msgid ""
"In ``XXXAsmPrinter.cpp``, the ``runOnMachineFunction`` method (declared "
"in ``MachineFunctionPass``) must be implemented for ``XXXAsmPrinter``.  "
"In ``MachineFunctionPass``, the ``runOnFunction`` method invokes "
"``runOnMachineFunction``.  Target-specific implementations of "
"``runOnMachineFunction`` differ, but generally do the following to "
"process each machine function:"
msgstr ""

#: ../../WritingAnLLVMBackend.rst:1619
msgid "Call ``SetupMachineFunction`` to perform initialization."
msgstr ""

#: ../../WritingAnLLVMBackend.rst:1621
msgid ""
"Call ``EmitConstantPool`` to print out (to the output stream) constants "
"which have been spilled to memory."
msgstr ""

#: ../../WritingAnLLVMBackend.rst:1624
msgid ""
"Call ``EmitJumpTableInfo`` to print out jump tables used by the current "
"function."
msgstr ""

#: ../../WritingAnLLVMBackend.rst:1627
msgid "Print out the label for the current function."
msgstr ""

#: ../../WritingAnLLVMBackend.rst:1629
msgid ""
"Print out the code for the function, including basic block labels and the"
" assembly for the instruction (using ``printInstruction``)"
msgstr ""

#: ../../WritingAnLLVMBackend.rst:1632
msgid ""
"The ``XXXAsmPrinter`` implementation must also include the code generated"
" by TableGen that is output in the ``XXXGenAsmWriter.inc`` file.  The "
"code in ``XXXGenAsmWriter.inc`` contains an implementation of the "
"``printInstruction`` method that may call these methods:"
msgstr ""

#: ../../WritingAnLLVMBackend.rst:1637
msgid "``printOperand``"
msgstr ""

#: ../../WritingAnLLVMBackend.rst:1638
msgid "``printMemOperand``"
msgstr ""

#: ../../WritingAnLLVMBackend.rst:1639
msgid "``printCCOperand`` (for conditional statements)"
msgstr ""

#: ../../WritingAnLLVMBackend.rst:1640
msgid "``printDataDirective``"
msgstr ""

#: ../../WritingAnLLVMBackend.rst:1641
msgid "``printDeclare``"
msgstr ""

#: ../../WritingAnLLVMBackend.rst:1642
msgid "``printImplicitDef``"
msgstr ""

#: ../../WritingAnLLVMBackend.rst:1643
msgid "``printInlineAsm``"
msgstr ""

#: ../../WritingAnLLVMBackend.rst:1645
msgid ""
"The implementations of ``printDeclare``, ``printImplicitDef``, "
"``printInlineAsm``, and ``printLabel`` in ``AsmPrinter.cpp`` are "
"generally adequate for printing assembly and do not need to be "
"overridden."
msgstr ""

#: ../../WritingAnLLVMBackend.rst:1649
msgid ""
"The ``printOperand`` method is implemented with a long "
"``switch``/``case`` statement for the type of operand: register, "
"immediate, basic block, external symbol, global address, constant pool "
"index, or jump table index.  For an instruction with a memory address "
"operand, the ``printMemOperand`` method should be implemented to generate"
" the proper output.  Similarly, ``printCCOperand`` should be used to "
"print a conditional operand."
msgstr ""

#: ../../WritingAnLLVMBackend.rst:1656
msgid ""
"``doFinalization`` should be overridden in ``XXXAsmPrinter``, and it "
"should be called to shut down the assembly printer.  During "
"``doFinalization``, global variables and constants are printed to output."
msgstr ""

#: ../../WritingAnLLVMBackend.rst:1661
msgid "Subtarget Support"
msgstr ""

#: ../../WritingAnLLVMBackend.rst:1663
msgid ""
"Subtarget support is used to inform the code generation process of "
"instruction set variations for a given chip set.  For example, the LLVM "
"SPARC implementation provided covers three major versions of the SPARC "
"microprocessor architecture: Version 8 (V8, which is a 32-bit "
"architecture), Version 9 (V9, a 64-bit architecture), and the UltraSPARC "
"architecture.  V8 has 16 double-precision floating-point registers that "
"are also usable as either 32 single-precision or 8 quad-precision "
"registers.  V8 is also purely big-endian. V9 has 32 double-precision "
"floating-point registers that are also usable as 16 quad-precision "
"registers, but cannot be used as single-precision registers. The "
"UltraSPARC architecture combines V9 with UltraSPARC Visual Instruction "
"Set extensions."
msgstr ""

#: ../../WritingAnLLVMBackend.rst:1675
msgid ""
"If subtarget support is needed, you should implement a target-specific "
"``XXXSubtarget`` class for your architecture.  This class should process "
"the command-line options ``-mcpu=`` and ``-mattr=``."
msgstr ""

#: ../../WritingAnLLVMBackend.rst:1679
msgid ""
"TableGen uses definitions in the ``Target.td`` and ``Sparc.td`` files to "
"generate code in ``SparcGenSubtarget.inc``.  In ``Target.td``, shown "
"below, the ``SubtargetFeature`` interface is defined.  The first 4 string"
" parameters of the ``SubtargetFeature`` interface are a feature name, an "
"attribute set by the feature, the value of the attribute, and a "
"description of the feature.  (The fifth parameter is a list of features "
"whose presence is implied, and its default value is an empty array.)"
msgstr ""

#: ../../WritingAnLLVMBackend.rst:1698
msgid ""
"In the ``Sparc.td`` file, the ``SubtargetFeature`` is used to define the "
"following features."
msgstr ""

#: ../../WritingAnLLVMBackend.rst:1711
msgid ""
"Elsewhere in ``Sparc.td``, the ``Proc`` class is defined and then is used"
" to define particular SPARC processor subtypes that may have the "
"previously described features."
msgstr ""

#: ../../WritingAnLLVMBackend.rst:1734
msgid ""
"From ``Target.td`` and ``Sparc.td`` files, the resulting "
"``SparcGenSubtarget.inc`` specifies enum values to identify the features,"
" arrays of constants to represent the CPU features and CPU subtypes, and "
"the ``ParseSubtargetFeatures`` method that parses the features string "
"that sets specified subtarget options.  The generated "
"``SparcGenSubtarget.inc`` file should be included in the "
"``SparcSubtarget.cpp``.  The target-specific implementation of the "
"``XXXSubtarget`` method should follow this pseudocode:"
msgstr ""

#: ../../WritingAnLLVMBackend.rst:1752
msgid "JIT Support"
msgstr ""

#: ../../WritingAnLLVMBackend.rst:1754
msgid ""
"The implementation of a target machine optionally includes a Just-In-Time"
" (JIT) code generator that emits machine code and auxiliary structures as"
" binary output that can be written directly to memory.  To do this, "
"implement JIT code generation by performing the following steps:"
msgstr ""

#: ../../WritingAnLLVMBackend.rst:1759
msgid ""
"Write an ``XXXCodeEmitter.cpp`` file that contains a machine function "
"pass that transforms target-machine instructions into relocatable machine"
" code."
msgstr ""

#: ../../WritingAnLLVMBackend.rst:1763
msgid ""
"Write an ``XXXJITInfo.cpp`` file that implements the JIT interfaces for "
"target-specific code-generation activities, such as emitting machine code"
" and stubs."
msgstr ""

#: ../../WritingAnLLVMBackend.rst:1767
msgid ""
"Modify ``XXXTargetMachine`` so that it provides a ``TargetJITInfo`` "
"object through its ``getJITInfo`` method."
msgstr ""

#: ../../WritingAnLLVMBackend.rst:1770
msgid ""
"There are several different approaches to writing the JIT support code.  "
"For instance, TableGen and target descriptor files may be used for "
"creating a JIT code generator, but are not mandatory.  For the Alpha and "
"PowerPC target machines, TableGen is used to generate "
"``XXXGenCodeEmitter.inc``, which contains the binary coding of machine "
"instructions and the ``getBinaryCodeForInstr`` method to access those "
"codes.  Other JIT implementations do not."
msgstr ""

#: ../../WritingAnLLVMBackend.rst:1778
msgid ""
"Both ``XXXJITInfo.cpp`` and ``XXXCodeEmitter.cpp`` must include the "
"``llvm/CodeGen/MachineCodeEmitter.h`` header file that defines the "
"``MachineCodeEmitter`` class containing code for several callback "
"functions that write data (in bytes, words, strings, etc.) to the output "
"stream."
msgstr ""

#: ../../WritingAnLLVMBackend.rst:1784
msgid "Machine Code Emitter"
msgstr ""

#: ../../WritingAnLLVMBackend.rst:1786
msgid ""
"In ``XXXCodeEmitter.cpp``, a target-specific of the ``Emitter`` class is "
"implemented as a function pass (subclass of ``MachineFunctionPass``).  "
"The target-specific implementation of ``runOnMachineFunction`` (invoked "
"by ``runOnFunction`` in ``MachineFunctionPass``) iterates through the "
"``MachineBasicBlock`` calls ``emitInstruction`` to process each "
"instruction and emit binary code.  ``emitInstruction`` is largely "
"implemented with case statements on the instruction types defined in "
"``XXXInstrInfo.h``.  For example, in ``X86CodeEmitter.cpp``, the "
"``emitInstruction`` method is built around the following "
"``switch``/``case`` statements:"
msgstr ""

#: ../../WritingAnLLVMBackend.rst:1837
msgid ""
"The implementations of these case statements often first emit the opcode "
"and then get the operand(s).  Then depending upon the operand, helper "
"methods may be called to process the operand(s).  For example, in "
"``X86CodeEmitter.cpp``, for the ``X86II::AddRegFrm`` case, the first data"
" emitted (by ``emitByte``) is the opcode added to the register operand.  "
"Then an object representing the machine operand, ``MO1``, is extracted.  "
"The helper methods such as ``isImmediate``, ``isGlobalAddress``, "
"``isExternalSymbol``, ``isConstantPoolIndex``, and ``isJumpTableIndex`` "
"determine the operand type. (``X86CodeEmitter.cpp`` also has private "
"methods such as ``emitConstant``, ``emitGlobalAddress``, "
"``emitExternalSymbolAddress``, ``emitConstPoolAddress``, and "
"``emitJumpTableAddress`` that emit the data into the output stream.)"
msgstr ""

#: ../../WritingAnLLVMBackend.rst:1879
msgid ""
"In the previous example, ``XXXCodeEmitter.cpp`` uses the variable ``rt``,"
" which is a ``RelocationType`` enum that may be used to relocate "
"addresses (for example, a global address with a PIC base offset).  The "
"``RelocationType`` enum for that target is defined in the short target-"
"specific ``XXXRelocations.h`` file.  The ``RelocationType`` is used by "
"the ``relocate`` method defined in ``XXXJITInfo.cpp`` to rewrite "
"addresses for referenced global symbols."
msgstr ""

#: ../../WritingAnLLVMBackend.rst:1886
msgid ""
"For example, ``X86Relocations.h`` specifies the following relocation "
"types for the X86 addresses.  In all four cases, the relocated value is "
"added to the value already in memory.  For ``reloc_pcrel_word`` and "
"``reloc_picrel_word``, there is an additional initial adjustment."
msgstr ""

#: ../../WritingAnLLVMBackend.rst:1901
msgid "Target JIT Info"
msgstr ""

#: ../../WritingAnLLVMBackend.rst:1903
msgid ""
"``XXXJITInfo.cpp`` implements the JIT interfaces for target-specific "
"code-generation activities, such as emitting machine code and stubs.  At "
"minimum, a target-specific version of ``XXXJITInfo`` implements the "
"following:"
msgstr ""

#: ../../WritingAnLLVMBackend.rst:1907
msgid ""
"``getLazyResolverFunction`` --- Initializes the JIT, gives the target a "
"function that is used for compilation."
msgstr ""

#: ../../WritingAnLLVMBackend.rst:1910
msgid ""
"``emitFunctionStub`` --- Returns a native function with a specified "
"address for a callback function."
msgstr ""

#: ../../WritingAnLLVMBackend.rst:1913
msgid ""
"``relocate`` --- Changes the addresses of referenced globals, based on "
"relocation types."
msgstr ""

#: ../../WritingAnLLVMBackend.rst:1916
msgid ""
"Callback function that are wrappers to a function stub that is used when "
"the real target is not initially known."
msgstr ""

#: ../../WritingAnLLVMBackend.rst:1919
msgid ""
"``getLazyResolverFunction`` is generally trivial to implement.  It makes "
"the incoming parameter as the global ``JITCompilerFunction`` and returns "
"the callback function that will be used a function wrapper.  For the "
"Alpha target (in ``AlphaJITInfo.cpp``), the ``getLazyResolverFunction`` "
"implementation is simply:"
msgstr ""

#: ../../WritingAnLLVMBackend.rst:1933
msgid ""
"For the X86 target, the ``getLazyResolverFunction`` implementation is a "
"little more complicated, because it returns a different callback function"
" for processors with SSE instructions and XMM registers."
msgstr ""

#: ../../WritingAnLLVMBackend.rst:1937
msgid ""
"The callback function initially saves and later restores the callee "
"register values, incoming arguments, and frame and return address.  The "
"callback function needs low-level access to the registers or stack, so it"
" is typically implemented with assembler."
msgstr ""

