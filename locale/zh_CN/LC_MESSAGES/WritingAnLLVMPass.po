# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2003-2016, LLVM Project
# This file is distributed under the same license as the LLVM package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2016.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: LLVM 3.8\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2016-04-17 11:36+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.3.3\n"

#: ../../WritingAnLLVMPass.rst:3
msgid "Writing an LLVM Pass"
msgstr ""

#: ../../WritingAnLLVMPass.rst:9
msgid "Introduction --- What is a pass?"
msgstr ""

#: ../../WritingAnLLVMPass.rst:11
msgid ""
"The LLVM Pass Framework is an important part of the LLVM system, because "
"LLVM passes are where most of the interesting parts of the compiler "
"exist.  Passes perform the transformations and optimizations that make up"
" the compiler, they build the analysis results that are used by these "
"transformations, and they are, above all, a structuring technique for "
"compiler code."
msgstr ""

#: ../../WritingAnLLVMPass.rst:17
msgid ""
"All LLVM passes are subclasses of the `Pass "
"<http://llvm.org/doxygen/classllvm_1_1Pass.html>`_ class, which implement"
" functionality by overriding virtual methods inherited from ``Pass``.  "
"Depending on how your pass works, you should inherit from the "
":ref:`ModulePass <writing-an-llvm-pass-ModulePass>` , "
":ref:`CallGraphSCCPass <writing-an-llvm-pass-CallGraphSCCPass>`, "
":ref:`FunctionPass <writing-an-llvm-pass-FunctionPass>` , or "
":ref:`LoopPass <writing-an-llvm-pass-LoopPass>`, or :ref:`RegionPass "
"<writing-an-llvm-pass-RegionPass>`, or :ref:`BasicBlockPass <writing-an-"
"llvm-pass-BasicBlockPass>` classes, which gives the system more "
"information about what your pass does, and how it can be combined with "
"other passes.  One of the main features of the LLVM Pass Framework is "
"that it schedules passes to run in an efficient way based on the "
"constraints that your pass meets (which are indicated by which class they"
" derive from)."
msgstr ""

#: ../../WritingAnLLVMPass.rst:32
msgid ""
"We start by showing you how to construct a pass, everything from setting "
"up the code, to compiling, loading, and executing it.  After the basics "
"are down, more advanced features are discussed."
msgstr ""

#: ../../WritingAnLLVMPass.rst:37
msgid "Quick Start --- Writing hello world"
msgstr ""

#: ../../WritingAnLLVMPass.rst:39
msgid ""
"Here we describe how to write the \"hello world\" of passes.  The "
"\"Hello\" pass is designed to simply print out the name of non-external "
"functions that exist in the program being compiled.  It does not modify "
"the program at all, it just inspects it.  The source code and files for "
"this pass are available in the LLVM source tree in the "
"``lib/Transforms/Hello`` directory."
msgstr ""

#: ../../WritingAnLLVMPass.rst:48
msgid "Setting up the build environment"
msgstr ""

#: ../../WritingAnLLVMPass.rst:50
msgid ""
"First, configure and build LLVM.  Next, you need to create a new "
"directory somewhere in the LLVM source base.  For this example, we'll "
"assume that you made ``lib/Transforms/Hello``.  Finally, you must set up "
"a build script (``Makefile``) that will compile the source code for the "
"new pass.  To do this, copy the following into ``Makefile``:"
msgstr ""

#: ../../WritingAnLLVMPass.rst:73
msgid ""
"This makefile specifies that all of the ``.cpp`` files in the current "
"directory are to be compiled and linked together into a shared object "
"``$(LEVEL)/Debug+Asserts/lib/Hello.so`` that can be dynamically loaded by"
" the :program:`opt` or :program:`bugpoint` tools via their "
":option:`-load` options. If your operating system uses a suffix other "
"than ``.so`` (such as Windows or Mac OS X), the appropriate extension "
"will be used."
msgstr ""

#: ../../WritingAnLLVMPass.rst:80
msgid "If you are used CMake to build LLVM, see :ref:`cmake-out-of-source-pass`."
msgstr ""

#: ../../WritingAnLLVMPass.rst:82
msgid ""
"Now that we have the build scripts set up, we just need to write the code"
" for the pass itself."
msgstr ""

#: ../../WritingAnLLVMPass.rst:88
msgid "Basic code required"
msgstr ""

#: ../../WritingAnLLVMPass.rst:90
msgid ""
"Now that we have a way to compile our new pass, we just have to write it."
" Start out with:"
msgstr ""

#: ../../WritingAnLLVMPass.rst:99
msgid ""
"Which are needed because we are writing a `Pass "
"<http://llvm.org/doxygen/classllvm_1_1Pass.html>`_, we are operating on "
"`Function <http://llvm.org/doxygen/classllvm_1_1Function.html>`_\\ s, and"
" we will be doing some printing."
msgstr ""

#: ../../WritingAnLLVMPass.rst:104 ../../WritingAnLLVMPass.rst:113
msgid "Next we have:"
msgstr ""

#: ../../WritingAnLLVMPass.rst:110
msgid ""
"... which is required because the functions from the include files live "
"in the llvm namespace."
msgstr ""

#: ../../WritingAnLLVMPass.rst:119
msgid ""
"... which starts out an anonymous namespace.  Anonymous namespaces are to"
" C++ what the \"``static``\" keyword is to C (at global scope).  It makes"
" the things declared inside of the anonymous namespace visible only to "
"the current file. If you're not familiar with them, consult a decent C++ "
"book for more information."
msgstr ""

#: ../../WritingAnLLVMPass.rst:125
msgid "Next, we declare our pass itself:"
msgstr ""

#: ../../WritingAnLLVMPass.rst:131
msgid ""
"This declares a \"``Hello``\" class that is a subclass of "
":ref:`FunctionPass <writing-an-llvm-pass-FunctionPass>`.  The different "
"builtin pass subclasses are described in detail :ref:`later <writing-an-"
"llvm-pass-pass-classes>`, but for now, know that ``FunctionPass`` "
"operates on a function at a time."
msgstr ""

#: ../../WritingAnLLVMPass.rst:141
msgid ""
"This declares pass identifier used by LLVM to identify pass.  This allows"
" LLVM to avoid using expensive C++ runtime information."
msgstr ""

#: ../../WritingAnLLVMPass.rst:154
msgid ""
"We declare a :ref:`runOnFunction <writing-an-llvm-pass-runOnFunction>` "
"method, which overrides an abstract virtual method inherited from "
":ref:`FunctionPass <writing-an-llvm-pass-FunctionPass>`.  This is where "
"we are supposed to do our thing, so we just print out our message with "
"the name of each function."
msgstr ""

#: ../../WritingAnLLVMPass.rst:163
msgid ""
"We initialize pass ID here.  LLVM uses ID's address to identify a pass, "
"so initialization value is not important."
msgstr ""

#: ../../WritingAnLLVMPass.rst:172
msgid ""
"Lastly, we :ref:`register our class <writing-an-llvm-pass-registration>` "
"``Hello``, giving it a command line argument \"``hello``\", and a name "
"\"Hello World Pass\".  The last two arguments describe its behavior: if a"
" pass walks CFG without modifying it then the third argument is set to "
"``true``; if a pass is an analysis pass, for example dominator tree pass,"
" then ``true`` is supplied as the fourth argument."
msgstr ""

#: ../../WritingAnLLVMPass.rst:179
msgid "As a whole, the ``.cpp`` file looks like:"
msgstr ""

#: ../../WritingAnLLVMPass.rst:205
msgid ""
"Now that it's all together, compile the file with a simple \"``gmake``\" "
"command from the top level of your build directory and you should get a "
"new file \"``Debug+Asserts/lib/Hello.so``\".  Note that everything in "
"this file is contained in an anonymous namespace --- this reflects the "
"fact that passes are self contained units that do not need external "
"interfaces (although they can have them) to be useful."
msgstr ""

#: ../../WritingAnLLVMPass.rst:213
msgid "Running a pass with ``opt``"
msgstr ""

#: ../../WritingAnLLVMPass.rst:215
msgid ""
"Now that you have a brand new shiny shared object file, we can use the "
":program:`opt` command to run an LLVM program through your pass.  Because"
" you registered your pass with ``RegisterPass``, you will be able to use "
"the :program:`opt` tool to access it, once loaded."
msgstr ""

#: ../../WritingAnLLVMPass.rst:220
msgid ""
"To test it, follow the example at the end of the :doc:`GettingStarted` to"
" compile \"Hello World\" to LLVM.  We can now run the bitcode file "
"(hello.bc) for the program through our transformation like this (or "
"course, any bitcode file will work):"
msgstr ""

#: ../../WritingAnLLVMPass.rst:232
msgid ""
"The :option:`-load` option specifies that :program:`opt` should load your"
" pass as a shared object, which makes \"``-hello``\" a valid command line"
" argument (which is one reason you need to :ref:`register your pass "
"<writing-an-llvm-pass-registration>`).  Because the Hello pass does not "
"modify the program in any interesting way, we just throw away the result "
"of :program:`opt` (sending it to ``/dev/null``)."
msgstr ""

#: ../../WritingAnLLVMPass.rst:239
msgid ""
"To see what happened to the other string you registered, try running "
":program:`opt` with the :option:`-help` option:"
msgstr ""

#: ../../WritingAnLLVMPass.rst:260
msgid ""
"The pass name gets added as the information string for your pass, giving "
"some documentation to users of :program:`opt`.  Now that you have a "
"working pass, you would go ahead and make it do the cool transformations "
"you want.  Once you get it all working and tested, it may become useful "
"to find out how fast your pass is.  The :ref:`PassManager <writing-an-"
"llvm-pass-passmanager>` provides a nice command line option (:option"
":`--time-passes`) that allows you to get information about the execution "
"time of your pass along with the other passes you queue up.  For example:"
msgstr ""

#: ../../WritingAnLLVMPass.rst:287
msgid ""
"As you can see, our implementation above is pretty fast.  The additional "
"passes listed are automatically inserted by the :program:`opt` tool to "
"verify that the LLVM emitted by your pass is still valid and well formed "
"LLVM, which hasn't been broken somehow."
msgstr ""

#: ../../WritingAnLLVMPass.rst:292
msgid ""
"Now that you have seen the basics of the mechanics behind passes, we can "
"talk about some more details of how they work and how to use them."
msgstr ""

#: ../../WritingAnLLVMPass.rst:298
msgid "Pass classes and requirements"
msgstr ""

#: ../../WritingAnLLVMPass.rst:300
msgid ""
"One of the first things that you should do when designing a new pass is "
"to decide what class you should subclass for your pass.  The :ref:`Hello "
"World <writing-an-llvm-pass-basiccode>` example uses the "
":ref:`FunctionPass <writing-an-llvm-pass-FunctionPass>` class for its "
"implementation, but we did not discuss why or when this should occur.  "
"Here we talk about the classes available, from the most general to the "
"most specific."
msgstr ""

#: ../../WritingAnLLVMPass.rst:307
msgid ""
"When choosing a superclass for your ``Pass``, you should choose the "
"**most specific** class possible, while still being able to meet the "
"requirements listed.  This gives the LLVM Pass Infrastructure information"
" necessary to optimize how passes are run, so that the resultant compiler"
" isn't unnecessarily slow."
msgstr ""

#: ../../WritingAnLLVMPass.rst:314
msgid "The ``ImmutablePass`` class"
msgstr ""

#: ../../WritingAnLLVMPass.rst:316
msgid ""
"The most plain and boring type of pass is the \"`ImmutablePass "
"<http://llvm.org/doxygen/classllvm_1_1ImmutablePass.html>`_\" class.  "
"This pass type is used for passes that do not have to be run, do not "
"change state, and never need to be updated.  This is not a normal type of"
" transformation or analysis, but can provide information about the "
"current compiler configuration."
msgstr ""

#: ../../WritingAnLLVMPass.rst:322
msgid ""
"Although this pass class is very infrequently used, it is important for "
"providing information about the current target machine being compiled "
"for, and other static information that can affect the various "
"transformations."
msgstr ""

#: ../../WritingAnLLVMPass.rst:326
msgid ""
"``ImmutablePass``\\ es never invalidate other transformations, are never "
"invalidated, and are never \"run\"."
msgstr ""

#: ../../WritingAnLLVMPass.rst:332
msgid "The ``ModulePass`` class"
msgstr ""

#: ../../WritingAnLLVMPass.rst:334
msgid ""
"The `ModulePass <http://llvm.org/doxygen/classllvm_1_1ModulePass.html>`_ "
"class is the most general of all superclasses that you can use.  Deriving"
" from ``ModulePass`` indicates that your pass uses the entire program as "
"a unit, referring to function bodies in no predictable order, or adding "
"and removing functions.  Because nothing is known about the behavior of "
"``ModulePass`` subclasses, no optimization can be done for their "
"execution."
msgstr ""

#: ../../WritingAnLLVMPass.rst:341
msgid ""
"A module pass can use function level passes (e.g. dominators) using the "
"``getAnalysis`` interface ``getAnalysis<DominatorTree>(llvm::Function "
"*)`` to provide the function to retrieve analysis result for, if the "
"function pass does not require any module or immutable passes.  Note that"
" this can only be done for functions for which the analysis ran, e.g. in "
"the case of dominators you should only ask for the ``DominatorTree`` for "
"function definitions, not declarations."
msgstr ""

#: ../../WritingAnLLVMPass.rst:349
msgid ""
"To write a correct ``ModulePass`` subclass, derive from ``ModulePass`` "
"and overload the ``runOnModule`` method with the following signature:"
msgstr ""

#: ../../WritingAnLLVMPass.rst:353
msgid "The ``runOnModule`` method"
msgstr ""

#: ../../WritingAnLLVMPass.rst:359
msgid ""
"The ``runOnModule`` method performs the interesting work of the pass.  It"
" should return ``true`` if the module was modified by the transformation "
"and ``false`` otherwise."
msgstr ""

#: ../../WritingAnLLVMPass.rst:366
msgid "The ``CallGraphSCCPass`` class"
msgstr ""

#: ../../WritingAnLLVMPass.rst:368
msgid ""
"The `CallGraphSCCPass "
"<http://llvm.org/doxygen/classllvm_1_1CallGraphSCCPass.html>`_ is used by"
" passes that need to traverse the program bottom-up on the call graph "
"(callees before callers).  Deriving from ``CallGraphSCCPass`` provides "
"some mechanics for building and traversing the ``CallGraph``, but also "
"allows the system to optimize execution of ``CallGraphSCCPass``\\ es.  If"
" your pass meets the requirements outlined below, and doesn't meet the "
"requirements of a :ref:`FunctionPass <writing-an-llvm-pass-FunctionPass>`"
" or :ref:`BasicBlockPass <writing-an-llvm-pass-BasicBlockPass>`, you "
"should derive from ``CallGraphSCCPass``."
msgstr ""

#: ../../WritingAnLLVMPass.rst:379
msgid "``TODO``: explain briefly what SCC, Tarjan's algo, and B-U mean."
msgstr ""

#: ../../WritingAnLLVMPass.rst:381
msgid "To be explicit, CallGraphSCCPass subclasses are:"
msgstr ""

#: ../../WritingAnLLVMPass.rst:383
msgid ""
"... *not allowed* to inspect or modify any ``Function``\\ s other than "
"those in the current SCC and the direct callers and direct callees of the"
" SCC."
msgstr ""

#: ../../WritingAnLLVMPass.rst:385
msgid ""
"... *required* to preserve the current ``CallGraph`` object, updating it "
"to reflect any changes made to the program."
msgstr ""

#: ../../WritingAnLLVMPass.rst:387
msgid ""
"... *not allowed* to add or remove SCC's from the current Module, though "
"they may change the contents of an SCC."
msgstr ""

#: ../../WritingAnLLVMPass.rst:389
msgid "... *allowed* to add or remove global variables from the current Module."
msgstr ""

#: ../../WritingAnLLVMPass.rst:390
msgid ""
"... *allowed* to maintain state across invocations of :ref:`runOnSCC "
"<writing-an-llvm-pass-runOnSCC>` (including global data)."
msgstr ""

#: ../../WritingAnLLVMPass.rst:393
msgid ""
"Implementing a ``CallGraphSCCPass`` is slightly tricky in some cases "
"because it has to handle SCCs with more than one node in it.  All of the "
"virtual methods described below should return ``true`` if they modified "
"the program, or ``false`` if they didn't."
msgstr ""

#: ../../WritingAnLLVMPass.rst:399
msgid "The ``doInitialization(CallGraph &)`` method"
msgstr ""

#: ../../WritingAnLLVMPass.rst:405
msgid ""
"The ``doInitialization`` method is allowed to do most of the things that "
"``CallGraphSCCPass``\\ es are not allowed to do.  They can add and remove"
" functions, get pointers to functions, etc.  The ``doInitialization`` "
"method is designed to do simple initialization type of stuff that does "
"not depend on the SCCs being processed.  The ``doInitialization`` method "
"call is not scheduled to overlap with any other pass executions (thus it "
"should be very fast)."
msgstr ""

#: ../../WritingAnLLVMPass.rst:415
msgid "The ``runOnSCC`` method"
msgstr ""

#: ../../WritingAnLLVMPass.rst:421
msgid ""
"The ``runOnSCC`` method performs the interesting work of the pass, and "
"should return ``true`` if the module was modified by the transformation, "
"``false`` otherwise."
msgstr ""

#: ../../WritingAnLLVMPass.rst:426
msgid "The ``doFinalization(CallGraph &)`` method"
msgstr ""

#: ../../WritingAnLLVMPass.rst:432
msgid ""
"The ``doFinalization`` method is an infrequently used method that is "
"called when the pass framework has finished calling :ref:`runOnSCC "
"<writing-an-llvm-pass-runOnSCC>` for every SCC in the program being "
"compiled."
msgstr ""

#: ../../WritingAnLLVMPass.rst:439
msgid "The ``FunctionPass`` class"
msgstr ""

#: ../../WritingAnLLVMPass.rst:441
msgid ""
"In contrast to ``ModulePass`` subclasses, `FunctionPass "
"<http://llvm.org/doxygen/classllvm_1_1Pass.html>`_ subclasses do have a "
"predictable, local behavior that can be expected by the system.  All "
"``FunctionPass`` execute on each function in the program independent of "
"all of the other functions in the program.  ``FunctionPass``\\ es do not "
"require that they are executed in a particular order, and "
"``FunctionPass``\\ es do not modify external functions."
msgstr ""

#: ../../WritingAnLLVMPass.rst:449
msgid "To be explicit, ``FunctionPass`` subclasses are not allowed to:"
msgstr ""

#: ../../WritingAnLLVMPass.rst:451
msgid ""
"Inspect or modify a ``Function`` other than the one currently being "
"processed."
msgstr ""

#: ../../WritingAnLLVMPass.rst:452
msgid "Add or remove ``Function``\\ s from the current ``Module``."
msgstr ""

#: ../../WritingAnLLVMPass.rst:453
msgid "Add or remove global variables from the current ``Module``."
msgstr ""

#: ../../WritingAnLLVMPass.rst:454
msgid ""
"Maintain state across invocations of :ref:`runOnFunction <writing-an-"
"llvm-pass-runOnFunction>` (including global data)."
msgstr ""

#: ../../WritingAnLLVMPass.rst:457
msgid ""
"Implementing a ``FunctionPass`` is usually straightforward (See the "
":ref:`Hello World <writing-an-llvm-pass-basiccode>` pass for example). "
"``FunctionPass``\\ es may overload three virtual methods to do their "
"work.  All of these methods should return ``true`` if they modified the "
"program, or ``false`` if they didn't."
msgstr ""

#: ../../WritingAnLLVMPass.rst:466
msgid "The ``doInitialization(Module &)`` method"
msgstr ""

#: ../../WritingAnLLVMPass.rst:472
msgid ""
"The ``doInitialization`` method is allowed to do most of the things that "
"``FunctionPass``\\ es are not allowed to do.  They can add and remove "
"functions, get pointers to functions, etc.  The ``doInitialization`` "
"method is designed to do simple initialization type of stuff that does "
"not depend on the functions being processed.  The ``doInitialization`` "
"method call is not scheduled to overlap with any other pass executions "
"(thus it should be very fast)."
msgstr ""

#: ../../WritingAnLLVMPass.rst:479
msgid ""
"A good example of how this method should be used is the `LowerAllocations"
" <http://llvm.org/doxygen/LowerAllocations_8cpp-source.html>`_ pass.  "
"This pass converts ``malloc`` and ``free`` instructions into platform "
"dependent ``malloc()`` and ``free()`` function calls.  It uses the "
"``doInitialization`` method to get a reference to the ``malloc`` and "
"``free`` functions that it needs, adding prototypes to the module if "
"necessary."
msgstr ""

#: ../../WritingAnLLVMPass.rst:489
msgid "The ``runOnFunction`` method"
msgstr ""

#: ../../WritingAnLLVMPass.rst:495
msgid ""
"The ``runOnFunction`` method must be implemented by your subclass to do "
"the transformation or analysis work of your pass.  As usual, a ``true`` "
"value should be returned if the function is modified."
msgstr ""

#: ../../WritingAnLLVMPass.rst:502
msgid "The ``doFinalization(Module &)`` method"
msgstr ""

#: ../../WritingAnLLVMPass.rst:508
msgid ""
"The ``doFinalization`` method is an infrequently used method that is "
"called when the pass framework has finished calling :ref:`runOnFunction "
"<writing-an-llvm-pass-runOnFunction>` for every function in the program "
"being compiled."
msgstr ""

#: ../../WritingAnLLVMPass.rst:516
msgid "The ``LoopPass`` class"
msgstr ""

#: ../../WritingAnLLVMPass.rst:518
msgid ""
"All ``LoopPass`` execute on each loop in the function independent of all "
"of the other loops in the function.  ``LoopPass`` processes loops in loop"
" nest order such that outer most loop is processed last."
msgstr ""

#: ../../WritingAnLLVMPass.rst:522
msgid ""
"``LoopPass`` subclasses are allowed to update loop nest using "
"``LPPassManager`` interface.  Implementing a loop pass is usually "
"straightforward. ``LoopPass``\\ es may overload three virtual methods to "
"do their work.  All these methods should return ``true`` if they modified"
" the program, or ``false`` if they didn't."
msgstr ""

#: ../../WritingAnLLVMPass.rst:529
msgid "The ``doInitialization(Loop *, LPPassManager &)`` method"
msgstr ""

#: ../../WritingAnLLVMPass.rst:535
msgid ""
"The ``doInitialization`` method is designed to do simple initialization "
"type of stuff that does not depend on the functions being processed.  The"
" ``doInitialization`` method call is not scheduled to overlap with any "
"other pass executions (thus it should be very fast).  ``LPPassManager`` "
"interface should be used to access ``Function`` or ``Module`` level "
"analysis information."
msgstr ""

#: ../../WritingAnLLVMPass.rst:544
msgid "The ``runOnLoop`` method"
msgstr ""

#: ../../WritingAnLLVMPass.rst:550
msgid ""
"The ``runOnLoop`` method must be implemented by your subclass to do the "
"transformation or analysis work of your pass.  As usual, a ``true`` value"
" should be returned if the function is modified.  ``LPPassManager`` "
"interface should be used to update loop nest."
msgstr ""

#: ../../WritingAnLLVMPass.rst:556 ../../WritingAnLLVMPass.rst:609
msgid "The ``doFinalization()`` method"
msgstr ""

#: ../../WritingAnLLVMPass.rst:562
msgid ""
"The ``doFinalization`` method is an infrequently used method that is "
"called when the pass framework has finished calling :ref:`runOnLoop "
"<writing-an-llvm-pass-runOnLoop>` for every loop in the program being "
"compiled."
msgstr ""

#: ../../WritingAnLLVMPass.rst:569
msgid "The ``RegionPass`` class"
msgstr ""

#: ../../WritingAnLLVMPass.rst:571
msgid ""
"``RegionPass`` is similar to :ref:`LoopPass <writing-an-llvm-pass-"
"LoopPass>`, but executes on each single entry single exit region in the "
"function. ``RegionPass`` processes regions in nested order such that the "
"outer most region is processed last."
msgstr ""

#: ../../WritingAnLLVMPass.rst:576
msgid ""
"``RegionPass`` subclasses are allowed to update the region tree by using "
"the ``RGPassManager`` interface.  You may overload three virtual methods "
"of ``RegionPass`` to implement your own region pass.  All these methods "
"should return ``true`` if they modified the program, or ``false`` if they"
" did not."
msgstr ""

#: ../../WritingAnLLVMPass.rst:582
msgid "The ``doInitialization(Region *, RGPassManager &)`` method"
msgstr ""

#: ../../WritingAnLLVMPass.rst:588
msgid ""
"The ``doInitialization`` method is designed to do simple initialization "
"type of stuff that does not depend on the functions being processed.  The"
" ``doInitialization`` method call is not scheduled to overlap with any "
"other pass executions (thus it should be very fast).  ``RPPassManager`` "
"interface should be used to access ``Function`` or ``Module`` level "
"analysis information."
msgstr ""

#: ../../WritingAnLLVMPass.rst:597
msgid "The ``runOnRegion`` method"
msgstr ""

#: ../../WritingAnLLVMPass.rst:603
msgid ""
"The ``runOnRegion`` method must be implemented by your subclass to do the"
" transformation or analysis work of your pass.  As usual, a true value "
"should be returned if the region is modified.  ``RGPassManager`` "
"interface should be used to update region tree."
msgstr ""

#: ../../WritingAnLLVMPass.rst:615
msgid ""
"The ``doFinalization`` method is an infrequently used method that is "
"called when the pass framework has finished calling :ref:`runOnRegion "
"<writing-an-llvm-pass-runOnRegion>` for every region in the program being"
" compiled."
msgstr ""

#: ../../WritingAnLLVMPass.rst:623
msgid "The ``BasicBlockPass`` class"
msgstr ""

#: ../../WritingAnLLVMPass.rst:625
msgid ""
"``BasicBlockPass``\\ es are just like :ref:`FunctionPass's <writing-an-"
"llvm-pass-FunctionPass>` , except that they must limit their scope of "
"inspection and modification to a single basic block at a time.  As such, "
"they are **not** allowed to do any of the following:"
msgstr ""

#: ../../WritingAnLLVMPass.rst:630
msgid "Modify or inspect any basic blocks outside of the current one."
msgstr ""

#: ../../WritingAnLLVMPass.rst:631
msgid ""
"Maintain state across invocations of :ref:`runOnBasicBlock <writing-an-"
"llvm-pass-runOnBasicBlock>`."
msgstr ""

#: ../../WritingAnLLVMPass.rst:633
msgid "Modify the control flow graph (by altering terminator instructions)"
msgstr ""

#: ../../WritingAnLLVMPass.rst:634
msgid ""
"Any of the things forbidden for :ref:`FunctionPasses <writing-an-llvm-"
"pass-FunctionPass>`."
msgstr ""

#: ../../WritingAnLLVMPass.rst:637
msgid ""
"``BasicBlockPass``\\ es are useful for traditional local and \"peephole\""
" optimizations.  They may override the same :ref:`doInitialization(Module"
" &) <writing-an-llvm-pass-doInitialization-mod>` and "
":ref:`doFinalization(Module &) <writing-an-llvm-pass-doFinalization-mod>`"
" methods that :ref:`FunctionPass's <writing-an-llvm-pass-FunctionPass>` "
"have, but also have the following virtual methods that may also be "
"implemented:"
msgstr ""

#: ../../WritingAnLLVMPass.rst:645
msgid "The ``doInitialization(Function &)`` method"
msgstr ""

#: ../../WritingAnLLVMPass.rst:651
msgid ""
"The ``doInitialization`` method is allowed to do most of the things that "
"``BasicBlockPass``\\ es are not allowed to do, but that "
"``FunctionPass``\\ es can.  The ``doInitialization`` method is designed "
"to do simple initialization that does not depend on the ``BasicBlock``\\ "
"s being processed.  The ``doInitialization`` method call is not scheduled"
" to overlap with any other pass executions (thus it should be very fast)."
msgstr ""

#: ../../WritingAnLLVMPass.rst:661
msgid "The ``runOnBasicBlock`` method"
msgstr ""

#: ../../WritingAnLLVMPass.rst:667
msgid ""
"Override this function to do the work of the ``BasicBlockPass``.  This "
"function is not allowed to inspect or modify basic blocks other than the "
"parameter, and are not allowed to modify the CFG.  A ``true`` value must "
"be returned if the basic block is modified."
msgstr ""

#: ../../WritingAnLLVMPass.rst:673
msgid "The ``doFinalization(Function &)`` method"
msgstr ""

#: ../../WritingAnLLVMPass.rst:679
msgid ""
"The ``doFinalization`` method is an infrequently used method that is "
"called when the pass framework has finished calling :ref:`runOnBasicBlock"
" <writing-an-llvm-pass-runOnBasicBlock>` for every ``BasicBlock`` in the "
"program being compiled.  This can be used to perform per-function "
"finalization."
msgstr ""

#: ../../WritingAnLLVMPass.rst:685
msgid "The ``MachineFunctionPass`` class"
msgstr ""

#: ../../WritingAnLLVMPass.rst:687
msgid ""
"A ``MachineFunctionPass`` is a part of the LLVM code generator that "
"executes on the machine-dependent representation of each LLVM function in"
" the program."
msgstr ""

#: ../../WritingAnLLVMPass.rst:690
msgid ""
"Code generator passes are registered and initialized specially by "
"``TargetMachine::addPassesToEmitFile`` and similar routines, so they "
"cannot generally be run from the :program:`opt` or :program:`bugpoint` "
"commands."
msgstr ""

#: ../../WritingAnLLVMPass.rst:694
msgid ""
"A ``MachineFunctionPass`` is also a ``FunctionPass``, so all the "
"restrictions that apply to a ``FunctionPass`` also apply to it.  "
"``MachineFunctionPass``\\ es also have additional restrictions.  In "
"particular, ``MachineFunctionPass``\\ es are not allowed to do any of the"
" following:"
msgstr ""

#: ../../WritingAnLLVMPass.rst:699
msgid ""
"Modify or create any LLVM IR ``Instruction``\\ s, ``BasicBlock``\\ s, "
"``Argument``\\ s, ``Function``\\ s, ``GlobalVariable``\\ s, "
"``GlobalAlias``\\ es, or ``Module``\\ s."
msgstr ""

#: ../../WritingAnLLVMPass.rst:702
msgid "Modify a ``MachineFunction`` other than the one currently being processed."
msgstr ""

#: ../../WritingAnLLVMPass.rst:703
msgid ""
"Maintain state across invocations of :ref:`runOnMachineFunction <writing-"
"an-llvm-pass-runOnMachineFunction>` (including global data)."
msgstr ""

#: ../../WritingAnLLVMPass.rst:709
msgid "The ``runOnMachineFunction(MachineFunction &MF)`` method"
msgstr ""

#: ../../WritingAnLLVMPass.rst:715
msgid ""
"``runOnMachineFunction`` can be considered the main entry point of a "
"``MachineFunctionPass``; that is, you should override this method to do "
"the work of your ``MachineFunctionPass``."
msgstr ""

#: ../../WritingAnLLVMPass.rst:719
msgid ""
"The ``runOnMachineFunction`` method is called on every "
"``MachineFunction`` in a ``Module``, so that the ``MachineFunctionPass`` "
"may perform optimizations on the machine-dependent representation of the "
"function.  If you want to get at the LLVM ``Function`` for the "
"``MachineFunction`` you're working on, use ``MachineFunction``'s "
"``getFunction()`` accessor method --- but remember, you may not modify "
"the LLVM ``Function`` or its contents from a ``MachineFunctionPass``."
msgstr ""

#: ../../WritingAnLLVMPass.rst:730
msgid "Pass registration"
msgstr ""

#: ../../WritingAnLLVMPass.rst:732
msgid ""
"In the :ref:`Hello World <writing-an-llvm-pass-basiccode>` example pass "
"we illustrated how pass registration works, and discussed some of the "
"reasons that it is used and what it does.  Here we discuss how and why "
"passes are registered."
msgstr ""

#: ../../WritingAnLLVMPass.rst:737
msgid ""
"As we saw above, passes are registered with the ``RegisterPass`` "
"template.  The template parameter is the name of the pass that is to be "
"used on the command line to specify that the pass should be added to a "
"program (for example, with :program:`opt` or :program:`bugpoint`).  The "
"first argument is the name of the pass, which is to be used for the "
":option:`-help` output of programs, as well as for debug output generated"
" by the :option:`--debug-pass` option."
msgstr ""

#: ../../WritingAnLLVMPass.rst:744
msgid ""
"If you want your pass to be easily dumpable, you should implement the "
"virtual print method:"
msgstr ""

#: ../../WritingAnLLVMPass.rst:748
msgid "The ``print`` method"
msgstr ""

#: ../../WritingAnLLVMPass.rst:754
msgid ""
"The ``print`` method must be implemented by \"analyses\" in order to "
"print a human readable version of the analysis results.  This is useful "
"for debugging an analysis itself, as well as for other people to figure "
"out how an analysis works.  Use the opt ``-analyze`` argument to invoke "
"this method."
msgstr ""

#: ../../WritingAnLLVMPass.rst:759
msgid ""
"The ``llvm::raw_ostream`` parameter specifies the stream to write the "
"results on, and the ``Module`` parameter gives a pointer to the top level"
" module of the program that has been analyzed.  Note however that this "
"pointer may be ``NULL`` in certain circumstances (such as calling the "
"``Pass::dump()`` from a debugger), so it should only be used to enhance "
"debug output, it should not be depended on."
msgstr ""

#: ../../WritingAnLLVMPass.rst:769
msgid "Specifying interactions between passes"
msgstr ""

#: ../../WritingAnLLVMPass.rst:771
msgid ""
"One of the main responsibilities of the ``PassManager`` is to make sure "
"that passes interact with each other correctly.  Because ``PassManager`` "
"tries to :ref:`optimize the execution of passes <writing-an-llvm-pass-"
"passmanager>` it must know how the passes interact with each other and "
"what dependencies exist between the various passes.  To track this, each "
"pass can declare the set of passes that are required to be executed "
"before the current pass, and the passes which are invalidated by the "
"current pass."
msgstr ""

#: ../../WritingAnLLVMPass.rst:779
msgid ""
"Typically this functionality is used to require that analysis results are"
" computed before your pass is run.  Running arbitrary transformation "
"passes can invalidate the computed analysis results, which is what the "
"invalidation set specifies.  If a pass does not implement the "
":ref:`getAnalysisUsage <writing-an-llvm-pass-getAnalysisUsage>` method, "
"it defaults to not having any prerequisite passes, and invalidating "
"**all** other passes."
msgstr ""

#: ../../WritingAnLLVMPass.rst:789
msgid "The ``getAnalysisUsage`` method"
msgstr ""

#: ../../WritingAnLLVMPass.rst:795
msgid ""
"By implementing the ``getAnalysisUsage`` method, the required and "
"invalidated sets may be specified for your transformation.  The "
"implementation should fill in the `AnalysisUsage "
"<http://llvm.org/doxygen/classllvm_1_1AnalysisUsage.html>`_ object with "
"information about which passes are required and not invalidated.  To do "
"this, a pass may call any of the following methods on the "
"``AnalysisUsage`` object:"
msgstr ""

#: ../../WritingAnLLVMPass.rst:803
msgid ""
"The ``AnalysisUsage::addRequired<>`` and "
"``AnalysisUsage::addRequiredTransitive<>`` methods"
msgstr ""

#: ../../WritingAnLLVMPass.rst:805
msgid ""
"If your pass requires a previous pass to be executed (an analysis for "
"example), it can use one of these methods to arrange for it to be run "
"before your pass. LLVM has many different types of analyses and passes "
"that can be required, spanning the range from ``DominatorSet`` to "
"``BreakCriticalEdges``.  Requiring ``BreakCriticalEdges``, for example, "
"guarantees that there will be no critical edges in the CFG when your pass"
" has been run."
msgstr ""

#: ../../WritingAnLLVMPass.rst:812
msgid ""
"Some analyses chain to other analyses to do their job.  For example, an "
"`AliasAnalysis <AliasAnalysis>` implementation is required to :ref:`chain"
" <aliasanalysis-chaining>` to other alias analysis passes.  In cases "
"where analyses chain, the ``addRequiredTransitive`` method should be used"
" instead of the ``addRequired`` method.  This informs the ``PassManager``"
" that the transitively required pass should be alive as long as the "
"requiring pass is."
msgstr ""

#: ../../WritingAnLLVMPass.rst:820
msgid "The ``AnalysisUsage::addPreserved<>`` method"
msgstr ""

#: ../../WritingAnLLVMPass.rst:822
msgid ""
"One of the jobs of the ``PassManager`` is to optimize how and when "
"analyses are run.  In particular, it attempts to avoid recomputing data "
"unless it needs to. For this reason, passes are allowed to declare that "
"they preserve (i.e., they don't invalidate) an existing analysis if it's "
"available.  For example, a simple constant folding pass would not modify "
"the CFG, so it can't possibly affect the results of dominator analysis.  "
"By default, all passes are assumed to invalidate all others."
msgstr ""

#: ../../WritingAnLLVMPass.rst:830
msgid ""
"The ``AnalysisUsage`` class provides several methods which are useful in "
"certain circumstances that are related to ``addPreserved``.  In "
"particular, the ``setPreservesAll`` method can be called to indicate that"
" the pass does not modify the LLVM program at all (which is true for "
"analyses), and the ``setPreservesCFG`` method can be used by "
"transformations that change instructions in the program but do not modify"
" the CFG or terminator instructions (note that this property is "
"implicitly set for :ref:`BasicBlockPass <writing-an-llvm-pass-"
"BasicBlockPass>`\\ es)."
msgstr ""

#: ../../WritingAnLLVMPass.rst:839
msgid ""
"``addPreserved`` is particularly useful for transformations like "
"``BreakCriticalEdges``.  This pass knows how to update a small set of "
"loop and dominator related analyses if they exist, so it can preserve "
"them, despite the fact that it hacks on the CFG."
msgstr ""

#: ../../WritingAnLLVMPass.rst:845
msgid "Example implementations of ``getAnalysisUsage``"
msgstr ""

#: ../../WritingAnLLVMPass.rst:858
msgid "The ``getAnalysis<>`` and ``getAnalysisIfAvailable<>`` methods"
msgstr ""

#: ../../WritingAnLLVMPass.rst:860
msgid ""
"The ``Pass::getAnalysis<>`` method is automatically inherited by your "
"class, providing you with access to the passes that you declared that you"
" required with the :ref:`getAnalysisUsage <writing-an-llvm-pass-"
"getAnalysisUsage>` method.  It takes a single template argument that "
"specifies which pass class you want, and returns a reference to that "
"pass.  For example:"
msgstr ""

#: ../../WritingAnLLVMPass.rst:873
msgid ""
"This method call returns a reference to the pass desired.  You may get a "
"runtime assertion failure if you attempt to get an analysis that you did "
"not declare as required in your :ref:`getAnalysisUsage <writing-an-llvm-"
"pass-getAnalysisUsage>` implementation.  This method can be called by "
"your ``run*`` method implementation, or by any other local method invoked"
" by your ``run*`` method."
msgstr ""

#: ../../WritingAnLLVMPass.rst:880
msgid ""
"A module level pass can use function level analysis info using this "
"interface. For example:"
msgstr ""

#: ../../WritingAnLLVMPass.rst:891
msgid ""
"In above example, ``runOnFunction`` for ``DominatorTree`` is called by "
"pass manager before returning a reference to the desired pass."
msgstr ""

#: ../../WritingAnLLVMPass.rst:894
msgid ""
"If your pass is capable of updating analyses if they exist (e.g., "
"``BreakCriticalEdges``, as described above), you can use the "
"``getAnalysisIfAvailable`` method, which returns a pointer to the "
"analysis if it is active.  For example:"
msgstr ""

#: ../../WritingAnLLVMPass.rst:906
msgid "Implementing Analysis Groups"
msgstr ""

#: ../../WritingAnLLVMPass.rst:908
msgid ""
"Now that we understand the basics of how passes are defined, how they are"
" used, and how they are required from other passes, it's time to get a "
"little bit fancier.  All of the pass relationships that we have seen so "
"far are very simple: one pass depends on one other specific pass to be "
"run before it can run.  For many applications, this is great, for others,"
" more flexibility is required."
msgstr ""

#: ../../WritingAnLLVMPass.rst:915
msgid ""
"In particular, some analyses are defined such that there is a single "
"simple interface to the analysis results, but multiple ways of "
"calculating them. Consider alias analysis for example.  The most trivial "
"alias analysis returns \"may alias\" for any alias query.  The most "
"sophisticated analysis a flow-sensitive, context-sensitive "
"interprocedural analysis that can take a significant amount of time to "
"execute (and obviously, there is a lot of room between these two extremes"
" for other implementations).  To cleanly support situations like this, "
"the LLVM Pass Infrastructure supports the notion of Analysis Groups."
msgstr ""

#: ../../WritingAnLLVMPass.rst:926
msgid "Analysis Group Concepts"
msgstr ""

#: ../../WritingAnLLVMPass.rst:928
msgid ""
"An Analysis Group is a single simple interface that may be implemented by"
" multiple different passes.  Analysis Groups can be given human readable "
"names just like passes, but unlike passes, they need not derive from the "
"``Pass`` class.  An analysis group may have one or more implementations, "
"one of which is the \"default\" implementation."
msgstr ""

#: ../../WritingAnLLVMPass.rst:934
msgid ""
"Analysis groups are used by client passes just like other passes are: the"
" ``AnalysisUsage::addRequired()`` and ``Pass::getAnalysis()`` methods.  "
"In order to resolve this requirement, the :ref:`PassManager <writing-an-"
"llvm-pass-passmanager>` scans the available passes to see if any "
"implementations of the analysis group are available.  If none is "
"available, the default implementation is created for the pass to use.  "
"All standard rules for :ref:`interaction between passes <writing-an-llvm-"
"pass-interaction>` still apply."
msgstr ""

#: ../../WritingAnLLVMPass.rst:943
msgid ""
"Although :ref:`Pass Registration <writing-an-llvm-pass-registration>` is "
"optional for normal passes, all analysis group implementations must be "
"registered, and must use the :ref:`INITIALIZE_AG_PASS <writing-an-llvm-"
"pass-RegisterAnalysisGroup>` template to join the implementation pool.  "
"Also, a default implementation of the interface **must** be registered "
"with :ref:`RegisterAnalysisGroup <writing-an-llvm-pass-"
"RegisterAnalysisGroup>`."
msgstr ""

#: ../../WritingAnLLVMPass.rst:951
msgid ""
"As a concrete example of an Analysis Group in action, consider the "
"`AliasAnalysis "
"<http://llvm.org/doxygen/classllvm_1_1AliasAnalysis.html>`_ analysis "
"group.  The default implementation of the alias analysis interface (the "
"`basicaa <http://llvm.org/doxygen/structBasicAliasAnalysis.html>`_ pass) "
"just does a few simple checks that don't require significant analysis to "
"compute (such as: two different globals can never alias each other, etc)."
" Passes that use the `AliasAnalysis "
"<http://llvm.org/doxygen/classllvm_1_1AliasAnalysis.html>`_ interface "
"(for example the `gcse <http://llvm.org/doxygen/structGCSE.html>`_ pass),"
" do not care which implementation of alias analysis is actually provided,"
" they just use the designated interface."
msgstr ""

#: ../../WritingAnLLVMPass.rst:963
msgid ""
"From the user's perspective, commands work just like normal.  Issuing the"
" command ``opt -gcse ...`` will cause the ``basicaa`` class to be "
"instantiated and added to the pass sequence.  Issuing the command ``opt "
"-somefancyaa -gcse ...`` will cause the ``gcse`` pass to use the "
"``somefancyaa`` alias analysis (which doesn't actually exist, it's just a"
" hypothetical example) instead."
msgstr ""

#: ../../WritingAnLLVMPass.rst:972
msgid "Using ``RegisterAnalysisGroup``"
msgstr ""

#: ../../WritingAnLLVMPass.rst:974
msgid ""
"The ``RegisterAnalysisGroup`` template is used to register the analysis "
"group itself, while the ``INITIALIZE_AG_PASS`` is used to add pass "
"implementations to the analysis group.  First, an analysis group should "
"be registered, with a human readable name provided for it.  Unlike "
"registration of passes, there is no command line argument to be specified"
" for the Analysis Group Interface itself, because it is \"abstract\":"
msgstr ""

#: ../../WritingAnLLVMPass.rst:985
msgid ""
"Once the analysis is registered, passes can declare that they are valid "
"implementations of the interface by using the following code:"
msgstr ""

#: ../../WritingAnLLVMPass.rst:999
msgid ""
"This just shows a class ``FancyAA`` that uses the ``INITIALIZE_AG_PASS`` "
"macro both to register and to \"join\" the `AliasAnalysis "
"<http://llvm.org/doxygen/classllvm_1_1AliasAnalysis.html>`_ analysis "
"group. Every implementation of an analysis group should join using this "
"macro."
msgstr ""

#: ../../WritingAnLLVMPass.rst:1015
msgid ""
"Here we show how the default implementation is specified (using the final"
" argument to the ``INITIALIZE_AG_PASS`` template).  There must be exactly"
" one default implementation available at all times for an Analysis Group "
"to be used. Only default implementation can derive from "
"``ImmutablePass``.  Here we declare that the `BasicAliasAnalysis "
"<http://llvm.org/doxygen/structBasicAliasAnalysis.html>`_ pass is the "
"default implementation for the interface."
msgstr ""

#: ../../WritingAnLLVMPass.rst:1024
msgid "Pass Statistics"
msgstr ""

#: ../../WritingAnLLVMPass.rst:1026
msgid ""
"The `Statistic <http://llvm.org/doxygen/Statistic_8h-source.html>`_ class"
" is designed to be an easy way to expose various success metrics from "
"passes. These statistics are printed at the end of a run, when the "
":option:`-stats` command line option is enabled on the command line.  See"
" the :ref:`Statistics section <Statistic>` in the Programmer's Manual for"
" details."
msgstr ""

#: ../../WritingAnLLVMPass.rst:1035
msgid "What PassManager does"
msgstr ""

#: ../../WritingAnLLVMPass.rst:1037
msgid ""
"The `PassManager <http://llvm.org/doxygen/PassManager_8h-source.html>`_ "
"`class <http://llvm.org/doxygen/classllvm_1_1PassManager.html>`_ takes a "
"list of passes, ensures their :ref:`prerequisites <writing-an-llvm-pass-"
"interaction>` are set up correctly, and then schedules passes to run "
"efficiently.  All of the LLVM tools that run passes use the PassManager "
"for execution of these passes."
msgstr ""

#: ../../WritingAnLLVMPass.rst:1043
msgid ""
"The PassManager does two main things to try to reduce the execution time "
"of a series of passes:"
msgstr ""

#: ../../WritingAnLLVMPass.rst:1046
msgid ""
"**Share analysis results.**  The ``PassManager`` attempts to avoid "
"recomputing analysis results as much as possible.  This means keeping "
"track of which analyses are available already, which analyses get "
"invalidated, and which analyses are needed to be run for a pass.  An "
"important part of work is that the ``PassManager`` tracks the exact "
"lifetime of all analysis results, allowing it to :ref:`free memory "
"<writing-an-llvm-pass-releaseMemory>` allocated to holding analysis "
"results as soon as they are no longer needed."
msgstr ""

#: ../../WritingAnLLVMPass.rst:1055
msgid ""
"**Pipeline the execution of passes on the program.**  The ``PassManager``"
" attempts to get better cache and memory usage behavior out of a series "
"of passes by pipelining the passes together.  This means that, given a "
"series of consecutive :ref:`FunctionPass <writing-an-llvm-pass-"
"FunctionPass>`, it will execute all of the :ref:`FunctionPass <writing-"
"an-llvm-pass-FunctionPass>` on the first function, then all of the "
":ref:`FunctionPasses <writing-an-llvm-pass-FunctionPass>` on the second "
"function, etc... until the entire program has been run through the "
"passes."
msgstr ""

#: ../../WritingAnLLVMPass.rst:1064
msgid ""
"This improves the cache behavior of the compiler, because it is only "
"touching the LLVM program representation for a single function at a time,"
" instead of traversing the entire program.  It reduces the memory "
"consumption of compiler, because, for example, only one `DominatorSet "
"<http://llvm.org/doxygen/classllvm_1_1DominatorSet.html>`_ needs to be "
"calculated at a time.  This also makes it possible to implement some "
":ref:`interesting enhancements <writing-an-llvm-pass-SMP>` in the future."
msgstr ""

#: ../../WritingAnLLVMPass.rst:1072
msgid ""
"The effectiveness of the ``PassManager`` is influenced directly by how "
"much information it has about the behaviors of the passes it is "
"scheduling.  For example, the \"preserved\" set is intentionally "
"conservative in the face of an unimplemented :ref:`getAnalysisUsage "
"<writing-an-llvm-pass-getAnalysisUsage>` method.  Not implementing when "
"it should be implemented will have the effect of not allowing any "
"analysis results to live across the execution of your pass."
msgstr ""

#: ../../WritingAnLLVMPass.rst:1079
msgid ""
"The ``PassManager`` class exposes a ``--debug-pass`` command line options"
" that is useful for debugging pass execution, seeing how things work, and"
" diagnosing when you should be preserving more analyses than you "
"currently are.  (To get information about all of the variants of the "
"``--debug-pass`` option, just type \"``opt -help-hidden``\")."
msgstr ""

#: ../../WritingAnLLVMPass.rst:1085
msgid ""
"By using the --debug-pass=Structure option, for example, we can see how "
"our :ref:`Hello World <writing-an-llvm-pass-basiccode>` pass interacts "
"with other passes.  Lets try it out with the gcse and licm passes:"
msgstr ""

#: ../../WritingAnLLVMPass.rst:1109
msgid ""
"This output shows us when passes are constructed and when the analysis "
"results are known to be dead (prefixed with \"``--``\").  Here we see "
"that GCSE uses dominator and immediate dominator information to do its "
"job.  The LICM pass uses natural loop information, which uses dominator "
"sets, but not immediate dominators.  Because immediate dominators are no "
"longer useful after the GCSE pass, it is immediately destroyed.  The "
"dominator sets are then reused to compute natural loop information, which"
" is then used by the LICM pass."
msgstr ""

#: ../../WritingAnLLVMPass.rst:1117
msgid ""
"After the LICM pass, the module verifier runs (which is automatically "
"added by the :program:`opt` tool), which uses the dominator set to check "
"that the resultant LLVM code is well formed.  After it finishes, the "
"dominator set information is destroyed, after being computed once, and "
"shared by three passes."
msgstr ""

#: ../../WritingAnLLVMPass.rst:1123
msgid ""
"Lets see how this changes when we run the :ref:`Hello World <writing-an-"
"llvm-pass-basiccode>` pass in between the two passes:"
msgstr ""

#: ../../WritingAnLLVMPass.rst:1153
msgid ""
"Here we see that the :ref:`Hello World <writing-an-llvm-pass-basiccode>` "
"pass has killed the Dominator Set pass, even though it doesn't modify the"
" code at all!  To fix this, we need to add the following "
":ref:`getAnalysisUsage <writing-an-llvm-pass-getAnalysisUsage>` method to"
" our pass:"
msgstr ""

#: ../../WritingAnLLVMPass.rst:1165
msgid "Now when we run our pass, we get this output:"
msgstr ""

#: ../../WritingAnLLVMPass.rst:1193
msgid ""
"Which shows that we don't accidentally invalidate dominator information "
"anymore, and therefore do not have to compute it twice."
msgstr ""

#: ../../WritingAnLLVMPass.rst:1199
msgid "The ``releaseMemory`` method"
msgstr ""

#: ../../WritingAnLLVMPass.rst:1205
msgid ""
"The ``PassManager`` automatically determines when to compute analysis "
"results, and how long to keep them around for.  Because the lifetime of "
"the pass object itself is effectively the entire duration of the "
"compilation process, we need some way to free analysis results when they "
"are no longer useful.  The ``releaseMemory`` virtual method is the way to"
" do this."
msgstr ""

#: ../../WritingAnLLVMPass.rst:1211
msgid ""
"If you are writing an analysis or any other pass that retains a "
"significant amount of state (for use by another pass which \"requires\" "
"your pass and uses the :ref:`getAnalysis <writing-an-llvm-pass-"
"getAnalysis>` method) you should implement ``releaseMemory`` to, well, "
"release the memory allocated to maintain this internal state.  This "
"method is called after the ``run*`` method for the class, before the next"
" call of ``run*`` in your pass."
msgstr ""

#: ../../WritingAnLLVMPass.rst:1219
msgid "Registering dynamically loaded passes"
msgstr ""

#: ../../WritingAnLLVMPass.rst:1221
msgid ""
"*Size matters* when constructing production quality tools using LLVM, "
"both for the purposes of distribution, and for regulating the resident "
"code size when running on the target system.  Therefore, it becomes "
"desirable to selectively use some passes, while omitting others and "
"maintain the flexibility to change configurations later on.  You want to "
"be able to do all this, and, provide feedback to the user.  This is where"
" pass registration comes into play."
msgstr ""

#: ../../WritingAnLLVMPass.rst:1228
msgid ""
"The fundamental mechanisms for pass registration are the "
"``MachinePassRegistry`` class and subclasses of "
"``MachinePassRegistryNode``."
msgstr ""

#: ../../WritingAnLLVMPass.rst:1231
msgid ""
"An instance of ``MachinePassRegistry`` is used to maintain a list of "
"``MachinePassRegistryNode`` objects.  This instance maintains the list "
"and communicates additions and deletions to the command line interface."
msgstr ""

#: ../../WritingAnLLVMPass.rst:1235
msgid ""
"An instance of ``MachinePassRegistryNode`` subclass is used to maintain "
"information provided about a particular pass.  This information includes "
"the command line name, the command help string and the address of the "
"function used to create an instance of the pass.  A global static "
"constructor of one of these instances *registers* with a corresponding "
"``MachinePassRegistry``, the static destructor *unregisters*.  Thus a "
"pass that is statically linked in the tool will be registered at start "
"up.  A dynamically loaded pass will register on load and unregister at "
"unload."
msgstr ""

#: ../../WritingAnLLVMPass.rst:1245
msgid "Using existing registries"
msgstr ""

#: ../../WritingAnLLVMPass.rst:1247
msgid ""
"There are predefined registries to track instruction scheduling "
"(``RegisterScheduler``) and register allocation (``RegisterRegAlloc``) "
"machine passes.  Here we will describe how to *register* a register "
"allocator machine pass."
msgstr ""

#: ../../WritingAnLLVMPass.rst:1252
msgid ""
"Implement your register allocator machine pass.  In your register "
"allocator ``.cpp`` file add the following include:"
msgstr ""

#: ../../WritingAnLLVMPass.rst:1259
msgid ""
"Also in your register allocator ``.cpp`` file, define a creator function "
"in the form:"
msgstr ""

#: ../../WritingAnLLVMPass.rst:1268
msgid ""
"Note that the signature of this function should match the type of "
"``RegisterRegAlloc::FunctionPassCtor``.  In the same file add the "
"\"installing\" declaration, in the form:"
msgstr ""

#: ../../WritingAnLLVMPass.rst:1278
msgid ""
"Note the two spaces prior to the help string produces a tidy result on "
"the :option:`-help` query."
msgstr ""

#: ../../WritingAnLLVMPass.rst:1292
msgid ""
"And that's it.  The user is now free to use ``-regalloc=myregalloc`` as "
"an option.  Registering instruction schedulers is similar except use the "
"``RegisterScheduler`` class.  Note that the "
"``RegisterScheduler::FunctionPassCtor`` is significantly different from "
"``RegisterRegAlloc::FunctionPassCtor``."
msgstr ""

#: ../../WritingAnLLVMPass.rst:1298
msgid ""
"To force the load/linking of your register allocator into the "
":program:`llc`/:program:`lli` tools, add your creator function's global "
"declaration to ``Passes.h`` and add a \"pseudo\" call line to "
"``llvm/Codegen/LinkAllCodegenComponents.h``."
msgstr ""

#: ../../WritingAnLLVMPass.rst:1304
msgid "Creating new registries"
msgstr ""

#: ../../WritingAnLLVMPass.rst:1306
msgid ""
"The easiest way to get started is to clone one of the existing "
"registries; we recommend ``llvm/CodeGen/RegAllocRegistry.h``.  The key "
"things to modify are the class name and the ``FunctionPassCtor`` type."
msgstr ""

#: ../../WritingAnLLVMPass.rst:1310
msgid ""
"Then you need to declare the registry.  Example: if your pass registry is"
" ``RegisterMyPasses`` then define:"
msgstr ""

#: ../../WritingAnLLVMPass.rst:1317
msgid "And finally, declare the command line option for your passes.  Example:"
msgstr ""

#: ../../WritingAnLLVMPass.rst:1327
msgid ""
"Here the command option is \"``mypass``\", with ``createDefaultMyPass`` "
"as the default creator."
msgstr ""

#: ../../WritingAnLLVMPass.rst:1331
msgid "Using GDB with dynamically loaded passes"
msgstr ""

#: ../../WritingAnLLVMPass.rst:1333
msgid ""
"Unfortunately, using GDB with dynamically loaded passes is not as easy as"
" it should be.  First of all, you can't set a breakpoint in a shared "
"object that has not been loaded yet, and second of all there are problems"
" with inlined functions in shared objects.  Here are some suggestions to "
"debugging your pass with GDB."
msgstr ""

#: ../../WritingAnLLVMPass.rst:1339
msgid ""
"For sake of discussion, I'm going to assume that you are debugging a "
"transformation invoked by :program:`opt`, although nothing described here"
" depends on that."
msgstr ""

#: ../../WritingAnLLVMPass.rst:1344
msgid "Setting a breakpoint in your pass"
msgstr ""

#: ../../WritingAnLLVMPass.rst:1346
msgid "First thing you do is start gdb on the opt process:"
msgstr ""

#: ../../WritingAnLLVMPass.rst:1360
msgid ""
"Note that :program:`opt` has a lot of debugging information in it, so it "
"takes time to load.  Be patient.  Since we cannot set a breakpoint in our"
" pass yet (the shared object isn't loaded until runtime), we must execute"
" the process, and have it stop before it invokes our pass, but after it "
"has loaded the shared object.  The most foolproof way of doing this is to"
" set a breakpoint in ``PassManager::run`` and then run the process with "
"the arguments you want:"
msgstr ""

#: ../../WritingAnLLVMPass.rst:1377
msgid ""
"Once the :program:`opt` stops in the ``PassManager::run`` method you are "
"now free to set breakpoints in your pass so that you can trace through "
"execution or do other standard debugging stuff."
msgstr ""

#: ../../WritingAnLLVMPass.rst:1382
msgid "Miscellaneous Problems"
msgstr ""

#: ../../WritingAnLLVMPass.rst:1384
msgid ""
"Once you have the basics down, there are a couple of problems that GDB "
"has, some with solutions, some without."
msgstr ""

#: ../../WritingAnLLVMPass.rst:1387
msgid ""
"Inline functions have bogus stack information.  In general, GDB does a "
"pretty good job getting stack traces and stepping through inline "
"functions.  When a pass is dynamically loaded however, it somehow "
"completely loses this capability.  The only solution I know of is to de-"
"inline a function (move it from the body of a class to a ``.cpp`` file)."
msgstr ""

#: ../../WritingAnLLVMPass.rst:1393
msgid ""
"Restarting the program breaks breakpoints.  After following the "
"information above, you have succeeded in getting some breakpoints planted"
" in your pass. Nex thing you know, you restart the program (i.e., you "
"type \"``run``\" again), and you start getting errors about breakpoints "
"being unsettable.  The only way I have found to \"fix\" this problem is "
"to delete the breakpoints that are already set in your pass, run the "
"program, and re-set the breakpoints once execution stops in "
"``PassManager::run``."
msgstr ""

#: ../../WritingAnLLVMPass.rst:1401
msgid ""
"Hopefully these tips will help with common case debugging situations.  If"
" you'd like to contribute some tips of your own, just contact `Chris "
"<mailto:sabre@nondot.org>`_."
msgstr ""

#: ../../WritingAnLLVMPass.rst:1406
msgid "Future extensions planned"
msgstr ""

#: ../../WritingAnLLVMPass.rst:1408
msgid ""
"Although the LLVM Pass Infrastructure is very capable as it stands, and "
"does some nifty stuff, there are things we'd like to add in the future.  "
"Here is where we are going:"
msgstr ""

#: ../../WritingAnLLVMPass.rst:1415
msgid "Multithreaded LLVM"
msgstr ""

#: ../../WritingAnLLVMPass.rst:1417
msgid ""
"Multiple CPU machines are becoming more common and compilation can never "
"be fast enough: obviously we should allow for a multithreaded compiler.  "
"Because of the semantics defined for passes above (specifically they "
"cannot maintain state across invocations of their ``run*`` methods), a "
"nice clean way to implement a multithreaded compiler would be for the "
"``PassManager`` class to create multiple instances of each pass object, "
"and allow the separate instances to be hacking on different parts of the "
"program at the same time."
msgstr ""

#: ../../WritingAnLLVMPass.rst:1425
msgid ""
"This implementation would prevent each of the passes from having to "
"implement multithreaded constructs, requiring only the LLVM core to have "
"locking in a few places (for global resources).  Although this is a "
"simple extension, we simply haven't had time (or multiprocessor machines,"
" thus a reason) to implement this. Despite that, we have kept the LLVM "
"passes SMP ready, and you should too."
msgstr ""

