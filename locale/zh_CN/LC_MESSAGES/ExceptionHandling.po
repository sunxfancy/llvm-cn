# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2003-2016, LLVM Project
# This file is distributed under the same license as the LLVM package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2016.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: LLVM 3.8\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2016-04-17 11:36+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.3.3\n"

#: ../../ExceptionHandling.rst:3
msgid "Exception Handling in LLVM"
msgstr "LLVM中的异常处理"

#: ../../ExceptionHandling.rst:9
msgid "Introduction"
msgstr ""

#: ../../ExceptionHandling.rst:11
msgid ""
"This document is the central repository for all information pertaining to"
" exception handling in LLVM.  It describes the format that LLVM exception"
" handling information takes, which is useful for those interested in "
"creating front-ends or dealing directly with the information.  Further, "
"this document provides specific examples of what exception handling "
"information is used for in C and C++."
msgstr ""

#: ../../ExceptionHandling.rst:19
msgid "Itanium ABI Zero-cost Exception Handling"
msgstr ""

#: ../../ExceptionHandling.rst:21
msgid ""
"Exception handling for most programming languages is designed to recover "
"from conditions that rarely occur during general use of an application.  "
"To that end, exception handling should not interfere with the main flow "
"of an application's algorithm by performing checkpointing tasks, such as "
"saving the current pc or register state."
msgstr ""

#: ../../ExceptionHandling.rst:27
msgid ""
"The Itanium ABI Exception Handling Specification defines a methodology "
"for providing outlying data in the form of exception tables without "
"inlining speculative exception handling code in the flow of an "
"application's main algorithm.  Thus, the specification is said to add "
"\"zero-cost\" to the normal execution of an application."
msgstr ""

#: ../../ExceptionHandling.rst:33
msgid ""
"A more complete description of the Itanium ABI exception handling runtime"
" support of can be found at `Itanium C++ ABI: Exception Handling "
"<http://mentorembedded.github.com/cxx-abi/abi-eh.html>`_. A description "
"of the exception frame format can be found at `Exception Frames "
"<http://refspecs.linuxfoundation.org/LSB_3.0.0/LSB-Core-generic/LSB-Core-"
"generic/ehframechpt.html>`_, with details of the DWARF 4 specification at"
" `DWARF 4 Standard <http://dwarfstd.org/Dwarf4Std.php>`_.  A description "
"for the C++ exception table formats can be found at `Exception Handling "
"Tables <http://mentorembedded.github.com/cxx-abi/exceptions.pdf>`_."
msgstr ""

#: ../../ExceptionHandling.rst:44
msgid "Setjmp/Longjmp Exception Handling"
msgstr ""

#: ../../ExceptionHandling.rst:46
msgid ""
"Setjmp/Longjmp (SJLJ) based exception handling uses LLVM intrinsics "
"`llvm.eh.sjlj.setjmp`_ and `llvm.eh.sjlj.longjmp`_ to handle control flow"
" for exception handling."
msgstr ""

#: ../../ExceptionHandling.rst:50
msgid ""
"For each function which does exception processing --- be it "
"``try``/``catch`` blocks or cleanups --- that function registers itself "
"on a global frame list. When exceptions are unwinding, the runtime uses "
"this list to identify which functions need processing."
msgstr ""

#: ../../ExceptionHandling.rst:55
msgid ""
"Landing pad selection is encoded in the call site entry of the function "
"context. The runtime returns to the function via `llvm.eh.sjlj.longjmp`_,"
" where a switch table transfers control to the appropriate landing pad "
"based on the index stored in the function context."
msgstr ""

#: ../../ExceptionHandling.rst:60
msgid ""
"In contrast to DWARF exception handling, which encodes exception regions "
"and frame information in out-of-line tables, SJLJ exception handling "
"builds and removes the unwind frame context at runtime. This results in "
"faster exception handling at the expense of slower execution when no "
"exceptions are thrown. As exceptions are, by their nature, intended for "
"uncommon code paths, DWARF exception handling is generally preferred to "
"SJLJ."
msgstr ""

#: ../../ExceptionHandling.rst:68
msgid "Windows Runtime Exception Handling"
msgstr ""

#: ../../ExceptionHandling.rst:70
msgid ""
"LLVM supports handling exceptions produced by the Windows runtime, but it"
" requires a very different intermediate representation. It is not based "
"on the \":ref:`landingpad <i_landingpad>`\" instruction like the other "
"two models, and is described later in this document under :ref:`wineh`."
msgstr ""

#: ../../ExceptionHandling.rst:76
msgid "Overview"
msgstr ""

#: ../../ExceptionHandling.rst:78
msgid ""
"When an exception is thrown in LLVM code, the runtime does its best to "
"find a handler suited to processing the circumstance."
msgstr ""

#: ../../ExceptionHandling.rst:81
msgid ""
"The runtime first attempts to find an *exception frame* corresponding to "
"the function where the exception was thrown.  If the programming language"
" supports exception handling (e.g. C++), the exception frame contains a "
"reference to an exception table describing how to process the exception."
"  If the language does not support exception handling (e.g. C), or if the"
" exception needs to be forwarded to a prior activation, the exception "
"frame contains information about how to unwind the current activation and"
" restore the state of the prior activation.  This process is repeated "
"until the exception is handled. If the exception is not handled and no "
"activations remain, then the application is terminated with an "
"appropriate error message."
msgstr ""

#: ../../ExceptionHandling.rst:92
msgid ""
"Because different programming languages have different behaviors when "
"handling exceptions, the exception handling ABI provides a mechanism for "
"supplying *personalities*. An exception handling personality is defined "
"by way of a *personality function* (e.g. ``__gxx_personality_v0`` in "
"C++), which receives the context of the exception, an *exception "
"structure* containing the exception object type and value, and a "
"reference to the exception table for the current function.  The "
"personality function for the current compile unit is specified in a "
"*common exception frame*."
msgstr ""

#: ../../ExceptionHandling.rst:101
msgid ""
"The organization of an exception table is language dependent. For C++, an"
" exception table is organized as a series of code ranges defining what to"
" do if an exception occurs in that range. Typically, the information "
"associated with a range defines which types of exception objects (using "
"C++ *type info*) that are handled in that range, and an associated action"
" that should take place. Actions typically pass control to a *landing "
"pad*."
msgstr ""

#: ../../ExceptionHandling.rst:108
msgid ""
"A landing pad corresponds roughly to the code found in the ``catch`` "
"portion of a ``try``/``catch`` sequence. When execution resumes at a "
"landing pad, it receives an *exception structure* and a *selector value* "
"corresponding to the *type* of exception thrown. The selector is then "
"used to determine which *catch* should actually process the exception."
msgstr ""

#: ../../ExceptionHandling.rst:115
msgid "LLVM Code Generation"
msgstr ""

#: ../../ExceptionHandling.rst:117
msgid ""
"From a C++ developer's perspective, exceptions are defined in terms of "
"the ``throw`` and ``try``/``catch`` statements. In this section we will "
"describe the implementation of LLVM exception handling in terms of C++ "
"examples."
msgstr ""

#: ../../ExceptionHandling.rst:122
msgid "Throw"
msgstr ""

#: ../../ExceptionHandling.rst:124
msgid ""
"Languages that support exception handling typically provide a ``throw`` "
"operation to initiate the exception process. Internally, a ``throw`` "
"operation breaks down into two steps."
msgstr ""

#: ../../ExceptionHandling.rst:128
msgid ""
"A request is made to allocate exception space for an exception structure."
" This structure needs to survive beyond the current activation. This "
"structure will contain the type and value of the object being thrown."
msgstr ""

#: ../../ExceptionHandling.rst:132
msgid ""
"A call is made to the runtime to raise the exception, passing the "
"exception structure as an argument."
msgstr ""

#: ../../ExceptionHandling.rst:135
msgid ""
"In C++, the allocation of the exception structure is done by the "
"``__cxa_allocate_exception`` runtime function. The exception raising is "
"handled by ``__cxa_throw``. The type of the exception is represented "
"using a C++ RTTI structure."
msgstr ""

#: ../../ExceptionHandling.rst:141
msgid "Try/Catch"
msgstr ""

#: ../../ExceptionHandling.rst:143
msgid ""
"A call within the scope of a *try* statement can potentially raise an "
"exception. In those circumstances, the LLVM C++ front-end replaces the "
"call with an ``invoke`` instruction. Unlike a call, the ``invoke`` has "
"two potential continuation points:"
msgstr ""

#: ../../ExceptionHandling.rst:148
msgid "where to continue when the call succeeds as per normal, and"
msgstr ""

#: ../../ExceptionHandling.rst:150
msgid ""
"where to continue if the call raises an exception, either by a throw or "
"the unwinding of a throw"
msgstr ""

#: ../../ExceptionHandling.rst:153
msgid ""
"The term used to define the place where an ``invoke`` continues after an "
"exception is called a *landing pad*. LLVM landing pads are conceptually "
"alternative function entry points where an exception structure reference "
"and a type info index are passed in as arguments. The landing pad saves "
"the exception structure reference and then proceeds to select the catch "
"block that corresponds to the type info of the exception object."
msgstr ""

#: ../../ExceptionHandling.rst:160
msgid ""
"The LLVM :ref:`i_landingpad` is used to convey information about the "
"landing pad to the back end. For C++, the ``landingpad`` instruction "
"returns a pointer and integer pair corresponding to the pointer to the "
"*exception structure* and the *selector value* respectively."
msgstr ""

#: ../../ExceptionHandling.rst:165
msgid ""
"The ``landingpad`` instruction looks for a reference to the personality "
"function to be used for this ``try``/``catch`` sequence in the parent "
"function's attribute list. The instruction contains a list of *cleanup*, "
"*catch*, and *filter* clauses. The exception is tested against the "
"clauses sequentially from first to last. The clauses have the following "
"meanings:"
msgstr ""

#: ../../ExceptionHandling.rst:171
msgid "``catch <type> @ExcType``"
msgstr ""

#: ../../ExceptionHandling.rst:173
msgid ""
"This clause means that the landingpad block should be entered if the "
"exception being thrown is of type ``@ExcType`` or a subtype of "
"``@ExcType``. For C++, ``@ExcType`` is a pointer to the "
"``std::type_info`` object (an RTTI object) representing the C++ exception"
" type."
msgstr ""

#: ../../ExceptionHandling.rst:178
msgid ""
"If ``@ExcType`` is ``null``, any exception matches, so the landingpad "
"should always be entered. This is used for C++ catch-all blocks "
"(\"``catch (...)``\")."
msgstr ""

#: ../../ExceptionHandling.rst:182
msgid ""
"When this clause is matched, the selector value will be equal to the "
"value returned by \"``@llvm.eh.typeid.for(i8* @ExcType)``\". This will "
"always be a positive value."
msgstr ""

#: ../../ExceptionHandling.rst:186
msgid "``filter <type> [<type> @ExcType1, ..., <type> @ExcTypeN]``"
msgstr ""

#: ../../ExceptionHandling.rst:188
msgid ""
"This clause means that the landingpad should be entered if the exception "
"being thrown does *not* match any of the types in the list (which, for "
"C++, are again specified as ``std::type_info`` pointers)."
msgstr ""

#: ../../ExceptionHandling.rst:192
msgid ""
"C++ front-ends use this to implement C++ exception specifications, such "
"as \"``void foo() throw (ExcType1, ..., ExcTypeN) { ... }``\"."
msgstr ""

#: ../../ExceptionHandling.rst:195
msgid "When this clause is matched, the selector value will be negative."
msgstr ""

#: ../../ExceptionHandling.rst:197
msgid ""
"The array argument to ``filter`` may be empty; for example, \"``[0 x "
"i8**] undef``\". This means that the landingpad should always be entered."
" (Note that such a ``filter`` would not be equivalent to \"``catch i8* "
"null``\", because ``filter`` and ``catch`` produce negative and positive "
"selector values respectively.)"
msgstr ""

#: ../../ExceptionHandling.rst:203
msgid "``cleanup``"
msgstr ""

#: ../../ExceptionHandling.rst:205
msgid "This clause means that the landingpad should always be entered."
msgstr ""

#: ../../ExceptionHandling.rst:207
msgid "C++ front-ends use this for calling objects' destructors."
msgstr ""

#: ../../ExceptionHandling.rst:209
msgid "When this clause is matched, the selector value will be zero."
msgstr ""

#: ../../ExceptionHandling.rst:211
msgid ""
"The runtime may treat \"``cleanup``\" differently from \"``catch <type> "
"null``\"."
msgstr ""

#: ../../ExceptionHandling.rst:214
msgid ""
"In C++, if an unhandled exception occurs, the language runtime will call "
"``std::terminate()``, but it is implementation-defined whether the "
"runtime unwinds the stack and calls object destructors first. For "
"example, the GNU C++ unwinder does not call object destructors when an "
"unhandled exception occurs. The reason for this is to improve "
"debuggability: it ensures that ``std::terminate()`` is called from the "
"context of the ``throw``, so that this context is not lost by unwinding "
"the stack. A runtime will typically implement this by searching for a "
"matching non-``cleanup`` clause, and aborting if it does not find one, "
"before entering any landingpad blocks."
msgstr ""

#: ../../ExceptionHandling.rst:224
msgid ""
"Once the landing pad has the type info selector, the code branches to the"
" code for the first catch. The catch then checks the value of the type "
"info selector against the index of type info for that catch.  Since the "
"type info index is not known until all the type infos have been gathered "
"in the backend, the catch code must call the `llvm.eh.typeid.for`_ "
"intrinsic to determine the index for a given type info. If the catch "
"fails to match the selector then control is passed on to the next catch."
msgstr ""

#: ../../ExceptionHandling.rst:232
msgid ""
"Finally, the entry and exit of catch code is bracketed with calls to "
"``__cxa_begin_catch`` and ``__cxa_end_catch``."
msgstr ""

#: ../../ExceptionHandling.rst:235
msgid ""
"``__cxa_begin_catch`` takes an exception structure reference as an "
"argument and returns the value of the exception object."
msgstr ""

#: ../../ExceptionHandling.rst:238
msgid "``__cxa_end_catch`` takes no arguments. This function:"
msgstr ""

#: ../../ExceptionHandling.rst:240
msgid ""
"Locates the most recently caught exception and decrements its handler "
"count,"
msgstr ""

#: ../../ExceptionHandling.rst:243
msgid ""
"Removes the exception from the *caught* stack if the handler count goes "
"to zero, and"
msgstr ""

#: ../../ExceptionHandling.rst:246
msgid ""
"Destroys the exception if the handler count goes to zero and the "
"exception was not re-thrown by throw."
msgstr ""

#: ../../ExceptionHandling.rst:251
msgid ""
"a rethrow from within the catch may replace this call with a "
"``__cxa_rethrow``."
msgstr ""

#: ../../ExceptionHandling.rst:255
msgid "Cleanups"
msgstr ""

#: ../../ExceptionHandling.rst:257
msgid ""
"A cleanup is extra code which needs to be run as part of unwinding a "
"scope.  C++ destructors are a typical example, but other languages and "
"language extensions provide a variety of different kinds of cleanups. In "
"general, a landing pad may need to run arbitrary amounts of cleanup code "
"before actually entering a catch block. To indicate the presence of "
"cleanups, a :ref:`i_landingpad` should have a *cleanup* clause.  "
"Otherwise, the unwinder will not stop at the landing pad if there are no "
"catches or filters that require it to."
msgstr ""

#: ../../ExceptionHandling.rst:267
msgid ""
"Do not allow a new exception to propagate out of the execution of a "
"cleanup. This can corrupt the internal state of the unwinder.  Different "
"languages describe different high-level semantics for these situations: "
"for example, C++ requires that the process be terminated, whereas Ada "
"cancels both exceptions and throws a third."
msgstr ""

#: ../../ExceptionHandling.rst:273
msgid ""
"When all cleanups are finished, if the exception is not handled by the "
"current function, resume unwinding by calling the :ref:`resume "
"instruction <i_resume>`, passing in the result of the ``landingpad`` "
"instruction for the original landing pad."
msgstr ""

#: ../../ExceptionHandling.rst:279
msgid "Throw Filters"
msgstr ""

#: ../../ExceptionHandling.rst:281
msgid ""
"C++ allows the specification of which exception types may be thrown from "
"a function. To represent this, a top level landing pad may exist to "
"filter out invalid types. To express this in LLVM code the "
":ref:`i_landingpad` will have a filter clause. The clause consists of an "
"array of type infos. ``landingpad`` will return a negative value if the "
"exception does not match any of the type infos. If no match is found then"
" a call to ``__cxa_call_unexpected`` should be made, otherwise "
"``_Unwind_Resume``.  Each of these functions requires a reference to the "
"exception structure.  Note that the most general form of a ``landingpad``"
" instruction can have any number of catch, cleanup, and filter clauses "
"(though having more than one cleanup is pointless). The LLVM C++ front-"
"end can generate such ``landingpad`` instructions due to inlining "
"creating nested exception handling scopes."
msgstr ""

#: ../../ExceptionHandling.rst:298
msgid "Restrictions"
msgstr ""

#: ../../ExceptionHandling.rst:300
msgid ""
"The unwinder delegates the decision of whether to stop in a call frame to"
" that call frame's language-specific personality function. Not all "
"unwinders guarantee that they will stop to perform cleanups. For example,"
" the GNU C++ unwinder doesn't do so unless the exception is actually "
"caught somewhere further up the stack."
msgstr ""

#: ../../ExceptionHandling.rst:306
msgid ""
"In order for inlining to behave correctly, landing pads must be prepared "
"to handle selector results that they did not originally advertise. "
"Suppose that a function catches exceptions of type ``A``, and it's "
"inlined into a function that catches exceptions of type ``B``. The "
"inliner will update the ``landingpad`` instruction for the inlined "
"landing pad to include the fact that ``B`` is also caught. If that "
"landing pad assumes that it will only be entered to catch an ``A``, it's "
"in for a rude awakening.  Consequently, landing pads must test for the "
"selector results they understand and then resume exception propagation "
"with the `resume instruction <LangRef.html#i_resume>`_ if none of the "
"conditions match."
msgstr ""

#: ../../ExceptionHandling.rst:318
msgid "Exception Handling Intrinsics"
msgstr ""

#: ../../ExceptionHandling.rst:320
msgid ""
"In addition to the ``landingpad`` and ``resume`` instructions, LLVM uses "
"several intrinsic functions (name prefixed with ``llvm.eh``) to provide "
"exception handling information at various points in generated code."
msgstr ""

#: ../../ExceptionHandling.rst:327
msgid "``llvm.eh.typeid.for``"
msgstr ""

#: ../../ExceptionHandling.rst:334
msgid ""
"This intrinsic returns the type info index in the exception table of the "
"current function.  This value can be used to compare against the result "
"of ``landingpad`` instruction.  The single argument is a reference to a "
"type info."
msgstr ""

#: ../../ExceptionHandling.rst:338
msgid "Uses of this intrinsic are generated by the C++ front-end."
msgstr ""

#: ../../ExceptionHandling.rst:343
msgid "``llvm.eh.begincatch``"
msgstr ""

#: ../../ExceptionHandling.rst:350
msgid ""
"This intrinsic marks the beginning of catch handling code within the "
"blocks following a ``landingpad`` instruction.  The exact behavior of "
"this function depends on the compilation target and the personality "
"function associated with the ``landingpad`` instruction."
msgstr ""

#: ../../ExceptionHandling.rst:355
msgid ""
"The first argument to this intrinsic is a pointer that was previously "
"extracted from the aggregate return value of the ``landingpad`` "
"instruction.  The second argument to the intrinsic is a pointer to stack "
"space where the exception object should be stored. The runtime handles "
"the details of copying the exception object into the slot. If the second "
"parameter is null, no copy occurs."
msgstr ""

#: ../../ExceptionHandling.rst:361 ../../ExceptionHandling.rst:394
msgid ""
"Uses of this intrinsic are generated by the C++ front-end.  Many targets "
"will use implementation-specific functions (such as "
"``__cxa_begin_catch``) instead of this intrinsic.  The intrinsic is "
"provided for targets that require a more abstract interface."
msgstr ""

#: ../../ExceptionHandling.rst:366
msgid ""
"When used in the native Windows C++ exception handling implementation, "
"this intrinsic serves as a placeholder to delimit code before a catch "
"handler is outlined.  When the handler is is outlined, this intrinsic "
"will be replaced by instructions that retrieve the exception object "
"pointer from the frame allocation block."
msgstr ""

#: ../../ExceptionHandling.rst:376
msgid "``llvm.eh.endcatch``"
msgstr ""

#: ../../ExceptionHandling.rst:383
msgid ""
"This intrinsic marks the end of catch handling code within the current "
"block, which will be a successor of a block which called "
"``llvm.eh.begincatch''. The exact behavior of this function depends on "
"the compilation target and the personality function associated with the "
"corresponding ``landingpad`` instruction."
msgstr ""

#: ../../ExceptionHandling.rst:389
msgid ""
"There may be more than one call to ``llvm.eh.endcatch`` for any given "
"call to ``llvm.eh.begincatch`` with each ``llvm.eh.endcatch`` call "
"corresponding to the end of a different control path.  All control paths "
"following a call to ``llvm.eh.begincatch`` must reach a call to "
"``llvm.eh.endcatch``."
msgstr ""

#: ../../ExceptionHandling.rst:399
msgid ""
"When used in the native Windows C++ exception handling implementation, "
"this intrinsic serves as a placeholder to delimit code before a catch "
"handler is outlined.  After the handler is outlined, this intrinsic is "
"simply removed."
msgstr ""

#: ../../ExceptionHandling.rst:407
msgid "``llvm.eh.exceptionpointer``"
msgstr ""

#: ../../ExceptionHandling.rst:414
msgid ""
"This intrinsic retrieves a pointer to the exception caught by the given "
"``catchpad``."
msgstr ""

#: ../../ExceptionHandling.rst:419
msgid "SJLJ Intrinsics"
msgstr ""

#: ../../ExceptionHandling.rst:421
msgid ""
"The ``llvm.eh.sjlj`` intrinsics are used internally within LLVM's "
"backend.  Uses of them are generated by the backend's ``SjLjEHPrepare`` "
"pass."
msgstr ""

#: ../../ExceptionHandling.rst:428
msgid "``llvm.eh.sjlj.setjmp``"
msgstr ""

#: ../../ExceptionHandling.rst:434
msgid ""
"For SJLJ based exception handling, this intrinsic forces register saving "
"for the current function and stores the address of the following "
"instruction for use as a destination address by `llvm.eh.sjlj.longjmp`_. "
"The buffer format and the overall functioning of this intrinsic is "
"compatible with the GCC ``__builtin_setjmp`` implementation allowing code"
" built with the clang and GCC to interoperate."
msgstr ""

#: ../../ExceptionHandling.rst:441
msgid ""
"The single parameter is a pointer to a five word buffer in which the "
"calling context is saved. The front end places the frame pointer in the "
"first word, and the target implementation of this intrinsic should place "
"the destination address for a `llvm.eh.sjlj.longjmp`_ in the second word."
" The following three words are available for use in a target-specific "
"manner."
msgstr ""

#: ../../ExceptionHandling.rst:450
msgid "``llvm.eh.sjlj.longjmp``"
msgstr ""

#: ../../ExceptionHandling.rst:456
msgid ""
"For SJLJ based exception handling, the ``llvm.eh.sjlj.longjmp`` intrinsic"
" is used to implement ``__builtin_longjmp()``. The single parameter is a "
"pointer to a buffer populated by `llvm.eh.sjlj.setjmp`_. The frame "
"pointer and stack pointer are restored from the buffer, then control is "
"transferred to the destination address."
msgstr ""

#: ../../ExceptionHandling.rst:463
msgid "``llvm.eh.sjlj.lsda``"
msgstr ""

#: ../../ExceptionHandling.rst:469
msgid ""
"For SJLJ based exception handling, the ``llvm.eh.sjlj.lsda`` intrinsic "
"returns the address of the Language Specific Data Area (LSDA) for the "
"current function. The SJLJ front-end code stores this address in the "
"exception handling function context for use by the runtime."
msgstr ""

#: ../../ExceptionHandling.rst:475
msgid "``llvm.eh.sjlj.callsite``"
msgstr ""

#: ../../ExceptionHandling.rst:481
msgid ""
"For SJLJ based exception handling, the ``llvm.eh.sjlj.callsite`` "
"intrinsic identifies the callsite value associated with the following "
"``invoke`` instruction. This is used to ensure that landing pad entries "
"in the LSDA are generated in matching order."
msgstr ""

#: ../../ExceptionHandling.rst:487
msgid "Asm Table Formats"
msgstr ""

#: ../../ExceptionHandling.rst:489
msgid ""
"There are two tables that are used by the exception handling runtime to "
"determine which actions should be taken when an exception is thrown."
msgstr ""

#: ../../ExceptionHandling.rst:493
msgid "Exception Handling Frame"
msgstr ""

#: ../../ExceptionHandling.rst:495
msgid ""
"An exception handling frame ``eh_frame`` is very similar to the unwind "
"frame used by DWARF debug info. The frame contains all the information "
"necessary to tear down the current frame and restore the state of the "
"prior frame. There is an exception handling frame for each function in a "
"compile unit, plus a common exception handling frame that defines "
"information common to all functions in the unit."
msgstr ""

#: ../../ExceptionHandling.rst:502
msgid ""
"The format of this call frame information (CFI) is often platform-"
"dependent, however. ARM, for example, defines their own format. Apple has"
" their own compact unwind info format.  On Windows, another format is "
"used for all architectures since 32-bit x86.  LLVM will emit whatever "
"information is required by the target."
msgstr ""

#: ../../ExceptionHandling.rst:509
msgid "Exception Tables"
msgstr ""

#: ../../ExceptionHandling.rst:511
msgid ""
"An exception table contains information about what actions to take when "
"an exception is thrown in a particular part of a function's code. This is"
" typically referred to as the language-specific data area (LSDA). The "
"format of the LSDA table is specific to the personality function, but the"
" majority of personalities out there use a variation of the tables "
"consumed by ``__gxx_personality_v0``. There is one exception table per "
"function, except leaf functions and functions that have calls only to "
"non-throwing functions. They do not need an exception table."
msgstr ""

#: ../../ExceptionHandling.rst:523
msgid "Exception Handling using the Windows Runtime"
msgstr ""

#: ../../ExceptionHandling.rst:526
msgid "Background on Windows exceptions"
msgstr ""

#: ../../ExceptionHandling.rst:528
msgid ""
"Interacting with exceptions on Windows is significantly more complicated "
"than on Itanium C++ ABI platforms. The fundamental difference between the"
" two models is that Itanium EH is designed around the idea of "
"\"successive unwinding,\" while Windows EH is not."
msgstr ""

#: ../../ExceptionHandling.rst:533
msgid ""
"Under Itanium, throwing an exception typically involes allocating thread "
"local memory to hold the exception, and calling into the EH runtime. The "
"runtime identifies frames with appropriate exception handling actions, "
"and successively resets the register context of the current thread to the"
" most recently active frame with actions to run. In LLVM, execution "
"resumes at a ``landingpad`` instruction, which produces register values "
"provided by the runtime. If a function is only cleaning up allocated "
"resources, the function is responsible for calling ``_Unwind_Resume`` to "
"transition to the next most recently active frame after it is finished "
"cleaning up. Eventually, the frame responsible for handling the exception"
" calls ``__cxa_end_catch`` to destroy the exception, release its memory, "
"and resume normal control flow."
msgstr ""

#: ../../ExceptionHandling.rst:545
msgid ""
"The Windows EH model does not use these successive register context "
"resets. Instead, the active exception is typically described by a frame "
"on the stack. In the case of C++ exceptions, the exception object is "
"allocated in stack memory and its address is passed to "
"``__CxxThrowException``. General purpose structured exceptions (SEH) are "
"more analogous to Linux signals, and they are dispatched by userspace "
"DLLs provided with Windows. Each frame on the stack has an assigned EH "
"personality routine, which decides what actions to take to handle the "
"exception. There are a few major personalities for C and C++ code: the "
"C++ personality (``__CxxFrameHandler3``) and the SEH personalities "
"(``_except_handler3``, ``_except_handler4``, and "
"``__C_specific_handler``). All of them implement cleanups by calling back"
" into a \"funclet\" contained in the parent function."
msgstr ""

#: ../../ExceptionHandling.rst:557
msgid ""
"Funclets, in this context, are regions of the parent function that can be"
" called as though they were a function pointer with a very special "
"calling convention. The frame pointer of the parent frame is passed into "
"the funclet either using the standard EBP register or as the first "
"parameter register, depending on the architecture. The funclet implements"
" the EH action by accessing local variables in memory through the frame "
"pointer, and returning some appropriate value, continuing the EH process."
"  No variables live in to or out of the funclet can be allocated in "
"registers."
msgstr ""

#: ../../ExceptionHandling.rst:566
msgid ""
"The C++ personality also uses funclets to contain the code for catch "
"blocks (i.e. all user code between the braces in ``catch (Type obj) { ..."
" }``). The runtime must use funclets for catch bodies because the C++ "
"exception object is allocated in a child stack frame of the function "
"handling the exception. If the runtime rewound the stack back to frame of"
" the catch, the memory holding the exception would be overwritten quickly"
" by subsequent function calls.  The use of funclets also allows "
"``__CxxFrameHandler3`` to implement rethrow without resorting to TLS. "
"Instead, the runtime throws a special exception, and then uses SEH "
"(``__try / __except``) to resume execution with new information in the "
"child frame."
msgstr ""

#: ../../ExceptionHandling.rst:577
msgid ""
"In other words, the successive unwinding approach is incompatible with "
"Visual C++ exceptions and general purpose Windows exception handling. "
"Because the C++ exception object lives in stack memory, LLVM cannot "
"provide a custom personality function that uses landingpads.  Similarly, "
"SEH does not provide any mechanism to rethrow an exception or continue "
"unwinding.  Therefore, LLVM must use the IR constructs described later in"
" this document to implement compatible exception handling."
msgstr ""

#: ../../ExceptionHandling.rst:586
msgid "SEH filter expressions"
msgstr ""

#: ../../ExceptionHandling.rst:588
msgid ""
"The SEH personality functions also use funclets to implement filter "
"expressions, which allow executing arbitrary user code to decide which "
"exceptions to catch. Filter expressions should not be confused with the "
"``filter`` clause of the LLVM ``landingpad`` instruction.  Typically "
"filter expressions are used to determine if the exception came from a "
"particular DLL or code region, or if code faulted while accessing a "
"particular memory address range. LLVM does not currently have IR to "
"represent filter expressions because it is difficult to represent their "
"control dependencies.  Filter expressions run during the first phase of "
"EH, before cleanups run, making it very difficult to build a faithful "
"control flow graph.  For now, the new EH instructions cannot represent "
"SEH filter expressions, and frontends must outline them ahead of time. "
"Local variables of the parent function can be escaped and accessed using "
"the ``llvm.localescape`` and ``llvm.localrecover`` intrinsics."
msgstr ""

#: ../../ExceptionHandling.rst:603
msgid "New exception handling instructions"
msgstr ""

#: ../../ExceptionHandling.rst:605
msgid ""
"The primary design goal of the new EH instructions is to support funclet "
"generation while preserving information about the CFG so that SSA "
"formation still works.  As a secondary goal, they are designed to be "
"generic across MSVC and Itanium C++ exceptions. They make very few "
"assumptions about the data required by the personality, so long as it "
"uses the familiar core EH actions: catch, cleanup, and terminate.  "
"However, the new instructions are hard to modify without knowing details "
"of the EH personality. While they can be used to represent Itanium EH, "
"the landingpad model is strictly better for optimization purposes."
msgstr ""

#: ../../ExceptionHandling.rst:615
msgid ""
"The following new instructions are considered \"exception handling "
"pads\", in that they must be the first non-phi instruction of a basic "
"block that may be the unwind destination of an EH flow edge: "
"``catchswitch``, ``catchpad``, and ``cleanuppad``. As with landingpads, "
"when entering a try scope, if the frontend encounters a call site that "
"may throw an exception, it should emit an invoke that unwinds to a "
"``catchswitch`` block. Similarly, inside the scope of a C++ object with a"
" destructor, invokes should unwind to a ``cleanuppad``."
msgstr ""

#: ../../ExceptionHandling.rst:624
msgid ""
"New instructions are also used to mark the points where control is "
"transferred out of a catch/cleanup handler (which will correspond to "
"exits from the generated funclet).  A catch handler which reaches its end"
" by normal execution executes a ``catchret`` instruction, which is a "
"terminator indicating where in the function control is returned to.  A "
"cleanup handler which reaches its end by normal execution executes a "
"``cleanupret`` instruction, which is a terminator indicating where the "
"active exception will unwind to next."
msgstr ""

#: ../../ExceptionHandling.rst:632
msgid ""
"Each of these new EH pad instructions has a way to identify which action "
"should be considered after this action. The ``catchswitch`` instruction "
"is a terminator and has an unwind destination operand analogous to the "
"unwind destination of an invoke.  The ``cleanuppad`` instruction is not a"
" terminator, so the unwind destination is stored on the ``cleanupret`` "
"instruction instead. Successfully executing a catch handler should resume"
" normal control flow, so neither ``catchpad`` nor ``catchret`` "
"instructions can unwind. All of these \"unwind edges\" may refer to a "
"basic block that contains an EH pad instruction, or they may unwind to "
"the caller.  Unwinding to the caller has roughly the same semantics as "
"the ``resume`` instruction in the landingpad model. When inlining through"
" an invoke, instructions that unwind to the caller are hooked up to "
"unwind to the unwind destination of the call site."
msgstr ""

#: ../../ExceptionHandling.rst:645
msgid ""
"Putting things together, here is a hypothetical lowering of some C++ that"
" uses all of the new IR instructions:"
msgstr ""

#: ../../ExceptionHandling.rst:712
msgid "Funclet parent tokens"
msgstr ""

#: ../../ExceptionHandling.rst:714
msgid ""
"In order to produce tables for EH personalities that use funclets, it is "
"necessary to recover the nesting that was present in the source. This "
"funclet parent relationship is encoded in the IR using tokens produced by"
" the new \"pad\" instructions. The token operand of a \"pad\" or \"ret\" "
"instruction indicates which funclet it is in, or \"none\" if it is not "
"nested within another funclet."
msgstr ""

#: ../../ExceptionHandling.rst:720
msgid ""
"The ``catchpad`` and ``cleanuppad`` instructions establish new funclets, "
"and their tokens are consumed by other \"pad\" instructions to establish "
"membership. The ``catchswitch`` instruction does not create a funclet, "
"but it produces a token that is always consumed by its immediate "
"successor ``catchpad`` instructions. This ensures that every catch "
"handler modelled by a ``catchpad`` belongs to exactly one "
"``catchswitch``, which models the dispatch point after a C++ try."
msgstr ""

#: ../../ExceptionHandling.rst:728
msgid ""
"Here is an example of what this nesting looks like using some "
"hypothetical C++ code:"
msgstr ""

#: ../../ExceptionHandling.rst:776
msgid ""
"The \"inner\" ``catchswitch`` consumes ``%1`` which is produced by the "
"outer catchswitch."
msgstr ""

#: ../../ExceptionHandling.rst:782
msgid "Funclet transitions"
msgstr ""

#: ../../ExceptionHandling.rst:784
msgid ""
"The EH tables for personalities that use funclets make implicit use of "
"the funclet nesting relationship to encode unwind destinations, and so "
"are constrained in the set of funclet transitions they can represent.  "
"The related LLVM IR instructions accordingly have constraints that ensure"
" encodability of the EH edges in the flow graph."
msgstr ""

#: ../../ExceptionHandling.rst:790
msgid ""
"A ``catchswitch``, ``catchpad``, or ``cleanuppad`` is said to be "
"\"entered\" when it executes.  It may subsequently be \"exited\" by any "
"of the following means:"
msgstr ""

#: ../../ExceptionHandling.rst:794
msgid ""
"A ``catchswitch`` is immediately exited when none of its constituent "
"``catchpad``\\ s are appropriate for the in-flight exception and it "
"unwinds to its unwind destination or the caller."
msgstr ""

#: ../../ExceptionHandling.rst:797
msgid ""
"A ``catchpad`` and its parent ``catchswitch`` are both exited when a "
"``catchret`` from the ``catchpad`` is executed."
msgstr ""

#: ../../ExceptionHandling.rst:799
msgid "A ``cleanuppad`` is exited when a ``cleanupret`` from it is executed."
msgstr ""

#: ../../ExceptionHandling.rst:800
msgid ""
"Any of these pads is exited when control unwinds to the function's "
"caller, either by a ``call`` which unwinds all the way to the function's "
"caller, a nested ``catchswitch`` marked \"``unwinds to caller``\", or a "
"nested ``cleanuppad``\\ 's ``cleanupret`` marked \"``unwinds to "
"caller\"``."
msgstr ""

#: ../../ExceptionHandling.rst:804
msgid ""
"Any of these pads is exited when an unwind edge (from an ``invoke``, "
"nested ``catchswitch``, or nested ``cleanuppad``\\ 's ``cleanupret``) "
"unwinds to a destination pad that is not a descendant of the given pad."
msgstr ""

#: ../../ExceptionHandling.rst:808
msgid ""
"Note that the ``ret`` instruction is *not* a valid way to exit a funclet "
"pad; it is undefined behavior to execute a ``ret`` when a pad has been "
"entered but not exited."
msgstr ""

#: ../../ExceptionHandling.rst:812
msgid ""
"A single unwind edge may exit any number of pads (with the restrictions "
"that the edge from a ``catchswitch`` must exit at least itself, and the "
"edge from a ``cleanupret`` must exit at least its ``cleanuppad``), and "
"then must enter exactly one pad, which must be distinct from all the "
"exited pads.  The parent of the pad that an unwind edge enters must be "
"the most-recently-entered not-yet-exited pad (after exiting from any pads"
" that the unwind edge exits), or \"none\" if there is no such pad.  This "
"ensures that the stack of executing funclets at run-time always "
"corresponds to some path in the funclet pad tree that the parent tokens "
"encode."
msgstr ""

#: ../../ExceptionHandling.rst:822
msgid ""
"All unwind edges which exit any given funclet pad (including "
"``cleanupret`` edges exiting their ``cleanuppad`` and ``catchswitch`` "
"edges exiting their ``catchswitch``) must share the same unwind "
"destination.  Similarly, any funclet pad which may be exited by unwind to"
" caller must not be exited by any exception edges which unwind anywhere "
"other than the caller.  This ensures that each funclet as a whole has "
"only one unwind destination, which EH tables for funclet personalities "
"may require.  Note that any unwind edge which exits a ``catchpad`` also "
"exits its parent ``catchswitch``, so this implies that for any given "
"``catchswitch``, its unwind destination must also be the unwind "
"destination of any unwind edge that exits any of its constituent "
"``catchpad``\\s.  Because ``catchswitch`` has no ``nounwind`` variant, "
"and because IR producers are not *required* to annotate calls which will "
"not unwind as ``nounwind``, it is legal to nest a ``call`` or an "
"\"``unwind to caller``\\ \" ``catchswitch`` within a funclet pad that has"
" an unwind destination other than caller; it is undefined behavior for "
"such a ``call`` or ``catchswitch`` to unwind."
msgstr ""

#: ../../ExceptionHandling.rst:839
msgid ""
"Finally, the funclet pads' unwind destinations cannot form a cycle.  This"
" ensures that EH lowering can construct \"try regions\" with a tree-like "
"structure, which funclet-based personalities may require."
msgstr ""

