# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2003-2016, LLVM Project
# This file is distributed under the same license as the LLVM package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2016.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: LLVM 3.8\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2016-04-17 11:36+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.3.3\n"

#: ../../Passes.rst:32
msgid "LLVM's Analysis and Transform Passes"
msgstr ""

#: ../../Passes.rst:38
msgid "Introduction"
msgstr ""

#: ../../Passes.rst:40
msgid ""
"This document serves as a high level summary of the optimization features"
" that LLVM provides.  Optimizations are implemented as Passes that "
"traverse some portion of a program to either collect information or "
"transform the program. The table below divides the passes that LLVM "
"provides into three categories. Analysis passes compute information that "
"other passes can use or for debugging or program visualization purposes."
"  Transform passes can use (or invalidate) the analysis passes.  "
"Transform passes all mutate the program in some way. Utility passes "
"provides some utility but don't otherwise fit categorization. For example"
" passes to extract functions to bitcode or write a module to bitcode are "
"neither analysis nor transform passes.  The table of contents above "
"provides a quick summary of each pass and links to the more complete pass"
" description later in the document."
msgstr ""

#: ../../Passes.rst:54
msgid "Analysis Passes"
msgstr ""

#: ../../Passes.rst:56
msgid "This section describes the LLVM Analysis Passes."
msgstr ""

#: ../../Passes.rst:59
msgid "``-aa-eval``: Exhaustive Alias Analysis Precision Evaluator"
msgstr ""

#: ../../Passes.rst:61
msgid ""
"This is a simple N^2 alias analysis accuracy evaluator.  Basically, for "
"each function in the program, it simply queries to see how the alias "
"analysis implementation answers alias queries between each pair of "
"pointers in the function."
msgstr ""

#: ../../Passes.rst:66
msgid ""
"This is inspired and adapted from code by: Naveen Neelakantam, Francesco "
"Spadini, and Wojciech Stryjewski."
msgstr ""

#: ../../Passes.rst:70
msgid "``-basicaa``: Basic Alias Analysis (stateless AA impl)"
msgstr ""

#: ../../Passes.rst:72
msgid ""
"A basic alias analysis pass that implements identities (two different "
"globals cannot alias, etc), but does no stateful analysis."
msgstr ""

#: ../../Passes.rst:76
msgid "``-basiccg``: Basic CallGraph Construction"
msgstr ""

#: ../../Passes.rst:78 ../../Passes.rst:279
msgid "Yet to be written."
msgstr ""

#: ../../Passes.rst:81
msgid "``-count-aa``: Count Alias Analysis Query Responses"
msgstr ""

#: ../../Passes.rst:83
msgid ""
"A pass which can be used to count how many alias queries are being made "
"and how the alias analysis implementation being used responds."
msgstr ""

#: ../../Passes.rst:87
msgid "``-da``: Dependence Analysis"
msgstr ""

#: ../../Passes.rst:89
msgid ""
"Dependence analysis framework, which is used to detect dependences in "
"memory accesses."
msgstr ""

#: ../../Passes.rst:93
msgid "``-debug-aa``: AA use debugger"
msgstr ""

#: ../../Passes.rst:95
msgid ""
"This simple pass checks alias analysis users to ensure that if they "
"create a new value, they do not query AA without informing it of the "
"value.  It acts as a shim over any other AA pass you want."
msgstr ""

#: ../../Passes.rst:99
msgid ""
"Yes keeping track of every value in the program is expensive, but this is"
" a debugging pass."
msgstr ""

#: ../../Passes.rst:103
msgid "``-domfrontier``: Dominance Frontier Construction"
msgstr ""

#: ../../Passes.rst:105
msgid ""
"This pass is a simple dominator construction algorithm for finding "
"forward dominator frontiers."
msgstr ""

#: ../../Passes.rst:109
msgid "``-domtree``: Dominator Tree Construction"
msgstr ""

#: ../../Passes.rst:111
msgid ""
"This pass is a simple dominator construction algorithm for finding "
"forward dominators."
msgstr ""

#: ../../Passes.rst:116
msgid "``-dot-callgraph``: Print Call Graph to \"dot\" file"
msgstr ""

#: ../../Passes.rst:118
msgid ""
"This pass, only available in ``opt``, prints the call graph into a "
"``.dot`` graph.  This graph can then be processed with the \"dot\" tool "
"to convert it to postscript or some other suitable format."
msgstr ""

#: ../../Passes.rst:123
msgid "``-dot-cfg``: Print CFG of function to \"dot\" file"
msgstr ""

#: ../../Passes.rst:125
msgid ""
"This pass, only available in ``opt``, prints the control flow graph into "
"a ``.dot`` graph.  This graph can then be processed with the "
":program:`dot` tool to convert it to postscript or some other suitable "
"format."
msgstr ""

#: ../../Passes.rst:130
msgid ""
"``-dot-cfg-only``: Print CFG of function to \"dot\" file (with no "
"function bodies)"
msgstr ""

#: ../../Passes.rst:132
msgid ""
"This pass, only available in ``opt``, prints the control flow graph into "
"a ``.dot`` graph, omitting the function bodies.  This graph can then be "
"processed with the :program:`dot` tool to convert it to postscript or "
"some other suitable format."
msgstr ""

#: ../../Passes.rst:138
msgid "``-dot-dom``: Print dominance tree of function to \"dot\" file"
msgstr ""

#: ../../Passes.rst:140
msgid ""
"This pass, only available in ``opt``, prints the dominator tree into a "
"``.dot`` graph.  This graph can then be processed with the :program:`dot`"
" tool to convert it to postscript or some other suitable format."
msgstr ""

#: ../../Passes.rst:145
msgid ""
"``-dot-dom-only``: Print dominance tree of function to \"dot\" file (with"
" no function bodies)"
msgstr ""

#: ../../Passes.rst:147
msgid ""
"This pass, only available in ``opt``, prints the dominator tree into a "
"``.dot`` graph, omitting the function bodies.  This graph can then be "
"processed with the :program:`dot` tool to convert it to postscript or "
"some other suitable format."
msgstr ""

#: ../../Passes.rst:152
msgid "``-dot-postdom``: Print postdominance tree of function to \"dot\" file"
msgstr ""

#: ../../Passes.rst:154
msgid ""
"This pass, only available in ``opt``, prints the post dominator tree into"
" a ``.dot`` graph.  This graph can then be processed with the "
":program:`dot` tool to convert it to postscript or some other suitable "
"format."
msgstr ""

#: ../../Passes.rst:159
msgid ""
"``-dot-postdom-only``: Print postdominance tree of function to \"dot\" "
"file (with no function bodies)"
msgstr ""

#: ../../Passes.rst:161
msgid ""
"This pass, only available in ``opt``, prints the post dominator tree into"
" a ``.dot`` graph, omitting the function bodies.  This graph can then be "
"processed with the :program:`dot` tool to convert it to postscript or "
"some other suitable format."
msgstr ""

#: ../../Passes.rst:167
msgid "``-globalsmodref-aa``: Simple mod/ref analysis for globals"
msgstr ""

#: ../../Passes.rst:169
msgid ""
"This simple pass provides alias and mod/ref information for global values"
" that do not have their address taken, and keeps track of whether "
"functions read or write memory (are \"pure\").  For this simple (but very"
" common) case, we can provide pretty accurate and useful information."
msgstr ""

#: ../../Passes.rst:175
msgid "``-instcount``: Counts the various types of ``Instruction``\\ s"
msgstr ""

#: ../../Passes.rst:177
msgid "This pass collects the count of all instructions and reports them."
msgstr ""

#: ../../Passes.rst:180
msgid "``-intervals``: Interval Partition Construction"
msgstr ""

#: ../../Passes.rst:182
msgid ""
"This analysis calculates and represents the interval partition of a "
"function, or a preexisting interval partition."
msgstr ""

#: ../../Passes.rst:185
msgid ""
"In this way, the interval partition may be used to reduce a flow graph "
"down to its degenerate single node interval partition (unless it is "
"irreducible)."
msgstr ""

#: ../../Passes.rst:189
msgid "``-iv-users``: Induction Variable Users"
msgstr ""

#: ../../Passes.rst:191
msgid ""
"Bookkeeping for \"interesting\" users of expressions computed from "
"induction variables."
msgstr ""

#: ../../Passes.rst:195
msgid "``-lazy-value-info``: Lazy Value Information Analysis"
msgstr ""

#: ../../Passes.rst:197
msgid "Interface for lazy computation of value constraint information."
msgstr ""

#: ../../Passes.rst:200
msgid "``-libcall-aa``: LibCall Alias Analysis"
msgstr ""

#: ../../Passes.rst:202
msgid "LibCall Alias Analysis."
msgstr ""

#: ../../Passes.rst:205
msgid "``-lint``: Statically lint-checks LLVM IR"
msgstr ""

#: ../../Passes.rst:207
msgid ""
"This pass statically checks for common and easily-identified constructs "
"which produce undefined or likely unintended behavior in LLVM IR."
msgstr ""

#: ../../Passes.rst:210
msgid ""
"It is not a guarantee of correctness, in two ways.  First, it isn't "
"comprehensive.  There are checks which could be done statically which are"
" not yet implemented.  Some of these are indicated by TODO comments, but "
"those aren't comprehensive either.  Second, many conditions cannot be "
"checked statically.  This pass does no dynamic instrumentation, so it "
"can't check for all possible problems."
msgstr ""

#: ../../Passes.rst:217
msgid ""
"Another limitation is that it assumes all code will be executed.  A store"
" through a null pointer in a basic block which is never reached is "
"harmless, but this pass will warn about it anyway."
msgstr ""

#: ../../Passes.rst:221
msgid ""
"Optimization passes may make conditions that this pass checks for more or"
" less obvious.  If an optimization pass appears to be introducing a "
"warning, it may be that the optimization pass is merely exposing an "
"existing condition in the code."
msgstr ""

#: ../../Passes.rst:226
msgid ""
"This code may be run before :ref:`instcombine <passes-instcombine>`.  In "
"many cases, instcombine checks for the same kinds of things and turns "
"instructions with undefined behavior into unreachable (or equivalent).  "
"Because of this, this pass makes some effort to look through bitcasts and"
" so on."
msgstr ""

#: ../../Passes.rst:232
msgid "``-loops``: Natural Loop Information"
msgstr ""

#: ../../Passes.rst:234
msgid ""
"This analysis is used to identify natural loops and determine the loop "
"depth of various nodes of the CFG.  Note that the loops identified may "
"actually be several natural loops that share the same header node... not "
"just a single natural loop."
msgstr ""

#: ../../Passes.rst:240
msgid "``-memdep``: Memory Dependence Analysis"
msgstr ""

#: ../../Passes.rst:242
msgid ""
"An analysis that determines, for a given memory operation, what preceding"
" memory operations it depends on.  It builds on alias analysis "
"information, and tries to provide a lazy, caching interface to a common "
"kind of alias information query."
msgstr ""

#: ../../Passes.rst:248
msgid "``-module-debuginfo``: Decodes module-level debug info"
msgstr ""

#: ../../Passes.rst:250
msgid ""
"This pass decodes the debug info metadata in a module and prints in a "
"(sufficiently-prepared-) human-readable form."
msgstr ""

#: ../../Passes.rst:253
msgid ""
"For example, run this pass from ``opt`` along with the ``-analyze`` "
"option, and it'll print to standard output."
msgstr ""

#: ../../Passes.rst:257
msgid "``-no-aa``: No Alias Analysis (always returns 'may' alias)"
msgstr ""

#: ../../Passes.rst:259
msgid ""
"This is the default implementation of the Alias Analysis interface.  It "
"always returns \"I don't know\" for alias queries.  NoAA is unlike other "
"alias analysis implementations, in that it does not chain to a previous "
"analysis.  As such it doesn't follow many of the rules that other alias "
"analyses must."
msgstr ""

#: ../../Passes.rst:265
msgid "``-postdomfrontier``: Post-Dominance Frontier Construction"
msgstr ""

#: ../../Passes.rst:267
msgid ""
"This pass is a simple post-dominator construction algorithm for finding "
"post-dominator frontiers."
msgstr ""

#: ../../Passes.rst:271
msgid "``-postdomtree``: Post-Dominator Tree Construction"
msgstr ""

#: ../../Passes.rst:273
msgid ""
"This pass is a simple post-dominator construction algorithm for finding "
"post-dominators."
msgstr ""

#: ../../Passes.rst:277
msgid "``-print-alias-sets``: Alias Set Printer"
msgstr ""

#: ../../Passes.rst:282
msgid "``-print-callgraph``: Print a call graph"
msgstr ""

#: ../../Passes.rst:284
msgid ""
"This pass, only available in ``opt``, prints the call graph to standard "
"error in a human-readable form."
msgstr ""

#: ../../Passes.rst:288
msgid "``-print-callgraph-sccs``: Print SCCs of the Call Graph"
msgstr ""

#: ../../Passes.rst:290
msgid ""
"This pass, only available in ``opt``, prints the SCCs of the call graph "
"to standard error in a human-readable form."
msgstr ""

#: ../../Passes.rst:294
msgid "``-print-cfg-sccs``: Print SCCs of each function CFG"
msgstr ""

#: ../../Passes.rst:296
msgid ""
"This pass, only available in ``opt``, printsthe SCCs of each function CFG"
" to standard error in a human-readable fom."
msgstr ""

#: ../../Passes.rst:300
msgid "``-print-dom-info``: Dominator Info Printer"
msgstr ""

#: ../../Passes.rst:302
msgid "Dominator Info Printer."
msgstr ""

#: ../../Passes.rst:305
msgid ""
"``-print-externalfnconstants``: Print external fn callsites passed "
"constants"
msgstr ""

#: ../../Passes.rst:307
msgid ""
"This pass, only available in ``opt``, prints out call sites to external "
"functions that are called with constant arguments.  This can be useful "
"when looking for standard library functions we should constant fold or "
"handle in alias analyses."
msgstr ""

#: ../../Passes.rst:313
msgid "``-print-function``: Print function to stderr"
msgstr ""

#: ../../Passes.rst:315
msgid ""
"The ``PrintFunctionPass`` class is designed to be pipelined with other "
"``FunctionPasses``, and prints out the functions of the module as they "
"are processed."
msgstr ""

#: ../../Passes.rst:320
msgid "``-print-module``: Print module to stderr"
msgstr ""

#: ../../Passes.rst:322
msgid "This pass simply prints out the entire module when it is executed."
msgstr ""

#: ../../Passes.rst:327
msgid "``-print-used-types``: Find Used Types"
msgstr ""

#: ../../Passes.rst:329
msgid ""
"This pass is used to seek out all of the types in use by the program.  "
"Note that this analysis explicitly does not include types only used by "
"the symbol table."
msgstr ""

#: ../../Passes.rst:334
msgid "``-regions``: Detect single entry single exit regions"
msgstr ""

#: ../../Passes.rst:336
msgid ""
"The ``RegionInfo`` pass detects single entry single exit regions in a "
"function, where a region is defined as any subgraph that is connected to "
"the remaining graph at only two spots.  Furthermore, an hierarchical "
"region tree is built."
msgstr ""

#: ../../Passes.rst:341
msgid "``-scalar-evolution``: Scalar Evolution Analysis"
msgstr ""

#: ../../Passes.rst:343
msgid ""
"The ``ScalarEvolution`` analysis can be used to analyze and catagorize "
"scalar expressions in loops.  It specializes in recognizing general "
"induction variables, representing them with the abstract and opaque "
"``SCEV`` class. Given this analysis, trip counts of loops and other "
"important properties can be obtained."
msgstr ""

#: ../../Passes.rst:349
msgid ""
"This analysis is primarily useful for induction variable substitution and"
" strength reduction."
msgstr ""

#: ../../Passes.rst:353
msgid "``-scev-aa``: ScalarEvolution-based Alias Analysis"
msgstr ""

#: ../../Passes.rst:355
msgid "Simple alias analysis implemented in terms of ``ScalarEvolution`` queries."
msgstr ""

#: ../../Passes.rst:357
msgid ""
"This differs from traditional loop dependence analysis in that it tests "
"for dependencies within a single iteration of a loop, rather than "
"dependencies between different iterations."
msgstr ""

#: ../../Passes.rst:361
msgid ""
"``ScalarEvolution`` has a more complete understanding of pointer "
"arithmetic than ``BasicAliasAnalysis``' collection of ad-hoc analyses."
msgstr ""

#: ../../Passes.rst:365
msgid "``-targetdata``: Target Data Layout"
msgstr ""

#: ../../Passes.rst:367
msgid ""
"Provides other passes access to information on how the size and alignment"
" required by the target ABI for various data types."
msgstr ""

#: ../../Passes.rst:371
msgid "Transform Passes"
msgstr ""

#: ../../Passes.rst:373
msgid "This section describes the LLVM Transform Passes."
msgstr ""

#: ../../Passes.rst:376
msgid "``-adce``: Aggressive Dead Code Elimination"
msgstr ""

#: ../../Passes.rst:378
msgid ""
"ADCE aggressively tries to eliminate code.  This pass is similar to "
":ref:`DCE <passes-dce>` but it assumes that values are dead until proven "
"otherwise.  This is similar to :ref:`SCCP <passes-sccp>`, except applied "
"to the liveness of values."
msgstr ""

#: ../../Passes.rst:384
msgid "``-always-inline``: Inliner for ``always_inline`` functions"
msgstr ""

#: ../../Passes.rst:386
msgid ""
"A custom inliner that handles only functions that are marked as \"always "
"inline\"."
msgstr ""

#: ../../Passes.rst:390
msgid "``-argpromotion``: Promote 'by reference' arguments to scalars"
msgstr ""

#: ../../Passes.rst:392
msgid ""
"This pass promotes \"by reference\" arguments to be \"by value\" "
"arguments.  In practice, this means looking for internal functions that "
"have pointer arguments.  If it can prove, through the use of alias "
"analysis, that an argument is *only* loaded, then it can pass the value "
"into the function instead of the address of the value.  This can cause "
"recursive simplification of code and lead to the elimination of allocas "
"(especially in C++ template code like the STL)."
msgstr ""

#: ../../Passes.rst:400
msgid ""
"This pass also handles aggregate arguments that are passed into a "
"function, scalarizing them if the elements of the aggregate are only "
"loaded.  Note that it refuses to scalarize aggregates which would require"
" passing in more than three operands to the function, because passing "
"thousands of operands for a large array or structure is unprofitable!"
msgstr ""

#: ../../Passes.rst:406
msgid ""
"Note that this transformation could also be done for arguments that are "
"only stored to (returning the value instead), but does not currently.  "
"This case would be best handled when and if LLVM starts supporting "
"multiple return values from functions."
msgstr ""

#: ../../Passes.rst:412
msgid "``-bb-vectorize``: Basic-Block Vectorization"
msgstr ""

#: ../../Passes.rst:414
msgid ""
"This pass combines instructions inside basic blocks to form vector "
"instructions.  It iterates over each basic block, attempting to pair "
"compatible instructions, repeating this process until no additional pairs"
" are selected for vectorization.  When the outputs of some pair of "
"compatible instructions are used as inputs by some other pair of "
"compatible instructions, those pairs are part of a potential "
"vectorization chain.  Instruction pairs are only fused into vector "
"instructions when they are part of a chain longer than some threshold "
"length.  Moreover, the pass attempts to find the best possible chain for "
"each pair of compatible instructions.  These heuristics are intended to "
"prevent vectorization in cases where it would not yield a performance "
"increase of the resulting code."
msgstr ""

#: ../../Passes.rst:427
msgid "``-block-placement``: Profile Guided Basic Block Placement"
msgstr ""

#: ../../Passes.rst:429
msgid ""
"This pass is a very simple profile guided basic block placement "
"algorithm.  The idea is to put frequently executed blocks together at the"
" start of the function and hopefully increase the number of fall-through "
"conditional branches.  If there is no profile information for a "
"particular function, this pass basically orders blocks in depth-first "
"order."
msgstr ""

#: ../../Passes.rst:436
msgid "``-break-crit-edges``: Break critical edges in CFG"
msgstr ""

#: ../../Passes.rst:438
msgid ""
"Break all of the critical edges in the CFG by inserting a dummy basic "
"block. It may be \"required\" by passes that cannot deal with critical "
"edges.  This transformation obviously invalidates the CFG, but can update"
" forward dominator (set, immediate dominators, tree, and frontier) "
"information."
msgstr ""

#: ../../Passes.rst:444
msgid "``-codegenprepare``: Optimize for code generation"
msgstr ""

#: ../../Passes.rst:446
msgid ""
"This pass munges the code in the input function to better prepare it for "
"SelectionDAG-based code generation.  This works around limitations in its"
" basic-block-at-a-time approach.  It should eventually be removed."
msgstr ""

#: ../../Passes.rst:451
msgid "``-constmerge``: Merge Duplicate Global Constants"
msgstr ""

#: ../../Passes.rst:453
msgid ""
"Merges duplicate global constants together into a single constant that is"
" shared.  This is useful because some passes (i.e., TraceValues) insert a"
" lot of string constants into the program, regardless of whether or not "
"an existing string is available."
msgstr ""

#: ../../Passes.rst:459
msgid "``-constprop``: Simple constant propagation"
msgstr ""

#: ../../Passes.rst:461
msgid ""
"This pass implements constant propagation and merging.  It looks for "
"instructions involving only constant operands and replaces them with a "
"constant value instead of an instruction.  For example:"
msgstr ""

#: ../../Passes.rst:469
msgid "becomes"
msgstr ""

#: ../../Passes.rst:475
msgid ""
"NOTE: this pass has a habit of making definitions be dead.  It is a good "
"idea to run a :ref:`Dead Instruction Elimination <passes-die>` pass "
"sometime after running this pass."
msgstr ""

#: ../../Passes.rst:482
msgid "``-dce``: Dead Code Elimination"
msgstr ""

#: ../../Passes.rst:484
msgid ""
"Dead code elimination is similar to :ref:`dead instruction elimination "
"<passes-die>`, but it rechecks instructions that were used by removed "
"instructions to see if they are newly dead."
msgstr ""

#: ../../Passes.rst:489
msgid "``-deadargelim``: Dead Argument Elimination"
msgstr ""

#: ../../Passes.rst:491
msgid ""
"This pass deletes dead arguments from internal functions.  Dead argument "
"elimination removes arguments which are directly dead, as well as "
"arguments only passed into function calls as dead arguments of other "
"functions.  This pass also deletes dead arguments in a similar way."
msgstr ""

#: ../../Passes.rst:496
msgid ""
"This pass is often useful as a cleanup pass to run after aggressive "
"interprocedural passes, which add possibly-dead arguments."
msgstr ""

#: ../../Passes.rst:500
msgid "``-deadtypeelim``: Dead Type Elimination"
msgstr ""

#: ../../Passes.rst:502
msgid ""
"This pass is used to cleanup the output of GCC.  It eliminate names for "
"types that are unused in the entire translation unit, using the "
":ref:`find used types <passes-print-used-types>` pass."
msgstr ""

#: ../../Passes.rst:509
msgid "``-die``: Dead Instruction Elimination"
msgstr ""

#: ../../Passes.rst:511
msgid ""
"Dead instruction elimination performs a single pass over the function, "
"removing instructions that are obviously dead."
msgstr ""

#: ../../Passes.rst:515
msgid "``-dse``: Dead Store Elimination"
msgstr ""

#: ../../Passes.rst:517
msgid ""
"A trivial dead store elimination that only considers basic-block local "
"redundant stores."
msgstr ""

#: ../../Passes.rst:523
msgid "``-functionattrs``: Deduce function attributes"
msgstr ""

#: ../../Passes.rst:525
msgid ""
"A simple interprocedural pass which walks the call-graph, looking for "
"functions which do not access or only read non-local memory, and marking "
"them ``readnone``/``readonly``.  In addition, it marks function arguments"
" (of pointer type) \"``nocapture``\" if a call to the function does not "
"create any copies of the pointer value that outlive the call.  This more "
"or less means that the pointer is only dereferenced, and not returned "
"from the function or stored in a global.  This pass is implemented as a "
"bottom-up traversal of the call-graph."
msgstr ""

#: ../../Passes.rst:535
msgid "``-globaldce``: Dead Global Elimination"
msgstr ""

#: ../../Passes.rst:537
msgid ""
"This transform is designed to eliminate unreachable internal globals from"
" the program.  It uses an aggressive algorithm, searching out globals "
"that are known to be alive.  After it finds all of the globals which are "
"needed, it deletes whatever is left over.  This allows it to delete "
"recursive chunks of the program which are unreachable."
msgstr ""

#: ../../Passes.rst:544
msgid "``-globalopt``: Global Variable Optimizer"
msgstr ""

#: ../../Passes.rst:546
msgid ""
"This pass transforms simple global variables that never have their "
"address taken.  If obviously true, it marks read/write globals as "
"constant, deletes variables only stored to, etc."
msgstr ""

#: ../../Passes.rst:551
msgid "``-gvn``: Global Value Numbering"
msgstr ""

#: ../../Passes.rst:553
msgid ""
"This pass performs global value numbering to eliminate fully and "
"partially redundant instructions.  It also performs redundant load "
"elimination."
msgstr ""

#: ../../Passes.rst:559
msgid "``-indvars``: Canonicalize Induction Variables"
msgstr ""

#: ../../Passes.rst:561
msgid ""
"This transformation analyzes and transforms the induction variables (and "
"computations derived from them) into simpler forms suitable for "
"subsequent analysis and transformation."
msgstr ""

#: ../../Passes.rst:565
msgid ""
"This transformation makes the following changes to each loop with an "
"identifiable induction variable:"
msgstr ""

#: ../../Passes.rst:568
msgid ""
"All loops are transformed to have a *single* canonical induction variable"
" which starts at zero and steps by one."
msgstr ""

#: ../../Passes.rst:570
msgid ""
"The canonical induction variable is guaranteed to be the first PHI node "
"in the loop header block."
msgstr ""

#: ../../Passes.rst:572
msgid "Any pointer arithmetic recurrences are raised to use array subscripts."
msgstr ""

#: ../../Passes.rst:574
msgid ""
"If the trip count of a loop is computable, this pass also makes the "
"following changes:"
msgstr ""

#: ../../Passes.rst:577
msgid ""
"The exit condition for the loop is canonicalized to compare the induction"
" value against the exit value.  This turns loops like:"
msgstr ""

#: ../../Passes.rst:590
msgid ""
"Any use outside of the loop of an expression derived from the indvar is "
"changed to compute the derived value outside of the loop, eliminating the"
" dependence on the exit value of the induction variable.  If the only "
"purpose of the loop is to compute the exit value of some derived "
"expression, this transformation will make the loop dead."
msgstr ""

#: ../../Passes.rst:596
msgid ""
"This transformation should be followed by strength reduction after all of"
" the desired loop transformations have been performed.  Additionally, on "
"targets where it is profitable, the loop could be transformed to count "
"down to zero (the \"do loop\" optimization)."
msgstr ""

#: ../../Passes.rst:602
msgid "``-inline``: Function Integration/Inlining"
msgstr ""

#: ../../Passes.rst:604
msgid "Bottom-up inlining of functions into callees."
msgstr ""

#: ../../Passes.rst:609
msgid "``-instcombine``: Combine redundant instructions"
msgstr ""

#: ../../Passes.rst:611
msgid ""
"Combine instructions to form fewer, simple instructions.  This pass does "
"not modify the CFG. This pass is where algebraic simplification happens."
msgstr ""

#: ../../Passes.rst:614
msgid "This pass combines things like:"
msgstr ""

#: ../../Passes.rst:621
msgid "into:"
msgstr ""

#: ../../Passes.rst:627
msgid "This is a simple worklist driven algorithm."
msgstr ""

#: ../../Passes.rst:629
msgid ""
"This pass guarantees that the following canonicalizations are performed "
"on the program:"
msgstr ""

#: ../../Passes.rst:632
msgid ""
"If a binary operator has a constant operand, it is moved to the right-"
"hand side."
msgstr ""

#: ../../Passes.rst:634
msgid ""
"Bitwise operators with constant operands are always grouped so that "
"shifts are performed first, then ``or``\\ s, then ``and``\\ s, then "
"``xor``\\ s."
msgstr ""

#: ../../Passes.rst:636
msgid ""
"Compare instructions are converted from ``<``, ``>``, ``≤``, or ``≥`` to "
"``=`` or ``≠`` if possible."
msgstr ""

#: ../../Passes.rst:638
msgid ""
"All ``cmp`` instructions on boolean values are replaced with logical "
"operations."
msgstr ""

#: ../../Passes.rst:640
msgid "``add X, X`` is represented as ``mul X, 2`` ⇒ ``shl X, 1``"
msgstr ""

#: ../../Passes.rst:641
msgid ""
"Multiplies with a constant power-of-two argument are transformed into "
"shifts."
msgstr ""

#: ../../Passes.rst:643
msgid "… etc."
msgstr ""

#: ../../Passes.rst:645
msgid ""
"This pass can also simplify calls to specific well-known function calls "
"(e.g. runtime library functions).  For example, a call ``exit(3)`` that "
"occurs within the ``main()`` function can be transformed into simply "
"``return 3``. Whether or not library calls are simplified is controlled "
"by the :ref:`-functionattrs <passes-functionattrs>` pass and LLVM's "
"knowledge of library calls on different targets."
msgstr ""

#: ../../Passes.rst:653
msgid "``-internalize``: Internalize Global Symbols"
msgstr ""

#: ../../Passes.rst:655
msgid ""
"This pass loops over all of the functions in the input module, looking "
"for a main function.  If a main function is found, all other functions "
"and all global variables with initializers are marked as internal."
msgstr ""

#: ../../Passes.rst:660
msgid "``-ipconstprop``: Interprocedural constant propagation"
msgstr ""

#: ../../Passes.rst:662
msgid ""
"This pass implements an *extremely* simple interprocedural constant "
"propagation pass.  It could certainly be improved in many different ways,"
" like using a worklist.  This pass makes arguments dead, but does not "
"remove them.  The existing dead argument elimination pass should be run "
"after this to clean up the mess."
msgstr ""

#: ../../Passes.rst:669
msgid "``-ipsccp``: Interprocedural Sparse Conditional Constant Propagation"
msgstr ""

#: ../../Passes.rst:671
msgid ""
"An interprocedural variant of :ref:`Sparse Conditional Constant "
"Propagation <passes-sccp>`."
msgstr ""

#: ../../Passes.rst:675
msgid "``-jump-threading``: Jump Threading"
msgstr ""

#: ../../Passes.rst:677
msgid ""
"Jump threading tries to find distinct threads of control flow running "
"through a basic block.  This pass looks at blocks that have multiple "
"predecessors and multiple successors.  If one or more of the predecessors"
" of the block can be proven to always cause a jump to one of the "
"successors, we forward the edge from the predecessor to the successor by "
"duplicating the contents of this block."
msgstr ""

#: ../../Passes.rst:684
msgid "An example of when this can occur is code like this:"
msgstr ""

#: ../../Passes.rst:693
msgid ""
"In this case, the unconditional branch at the end of the first if can be "
"revectored to the false side of the second if."
msgstr ""

#: ../../Passes.rst:697
msgid "``-lcssa``: Loop-Closed SSA Form Pass"
msgstr ""

#: ../../Passes.rst:699
msgid ""
"This pass transforms loops by placing phi nodes at the end of the loops "
"for all values that are live across the loop boundary.  For example, it "
"turns the left into the right code:"
msgstr ""

#: ../../Passes.rst:714
msgid ""
"This is still valid LLVM; the extra phi nodes are purely redundant, and "
"will be trivially eliminated by ``InstCombine``.  The major benefit of "
"this transformation is that it makes many other loop optimizations, such "
"as ``LoopUnswitch``\\ ing, simpler."
msgstr ""

#: ../../Passes.rst:722
msgid "``-licm``: Loop Invariant Code Motion"
msgstr ""

#: ../../Passes.rst:724
msgid ""
"This pass performs loop invariant code motion, attempting to remove as "
"much code from the body of a loop as possible.  It does this by either "
"hoisting code into the preheader block, or by sinking code to the exit "
"blocks if it is safe. This pass also promotes must-aliased memory "
"locations in the loop to live in registers, thus hoisting and sinking "
"\"invariant\" loads and stores."
msgstr ""

#: ../../Passes.rst:730
msgid "This pass uses alias analysis for two purposes:"
msgstr ""

#: ../../Passes.rst:732
msgid ""
"Moving loop invariant loads and calls out of loops.  If we can determine "
"that a load or call inside of a loop never aliases anything stored to, we"
" can hoist it or sink it like any other instruction."
msgstr ""

#: ../../Passes.rst:736
msgid ""
"Scalar Promotion of Memory.  If there is a store instruction inside of "
"the loop, we try to move the store to happen AFTER the loop instead of "
"inside of the loop.  This can only happen if a few conditions are true:"
msgstr ""

#: ../../Passes.rst:740
msgid "The pointer stored through is loop invariant."
msgstr ""

#: ../../Passes.rst:741
msgid ""
"There are no stores or loads in the loop which *may* alias the pointer. "
"There are no calls in the loop which mod/ref the pointer."
msgstr ""

#: ../../Passes.rst:744
msgid ""
"If these conditions are true, we can promote the loads and stores in the "
"loop of the pointer to use a temporary alloca'd variable.  We then use "
"the :ref:`mem2reg <passes-mem2reg>` functionality to construct the "
"appropriate SSA form for the variable."
msgstr ""

#: ../../Passes.rst:750
msgid "``-loop-deletion``: Delete dead loops"
msgstr ""

#: ../../Passes.rst:752
msgid ""
"This file implements the Dead Loop Deletion Pass.  This pass is "
"responsible for eliminating loops with non-infinite computable trip "
"counts that have no side effects or volatile instructions, and do not "
"contribute to the computation of the function's return value."
msgstr ""

#: ../../Passes.rst:760
msgid "``-loop-extract``: Extract loops into new functions"
msgstr ""

#: ../../Passes.rst:762
msgid ""
"A pass wrapper around the ``ExtractLoop()`` scalar transformation to "
"extract each top-level loop into its own new function.  If the loop is "
"the *only* loop in a given function, it is not touched.  This is a pass "
"most useful for debugging via bugpoint."
msgstr ""

#: ../../Passes.rst:768
msgid "``-loop-extract-single``: Extract at most one loop into a new function"
msgstr ""

#: ../../Passes.rst:770
msgid ""
"Similar to :ref:`Extract loops into new functions <passes-loop-extract>`,"
" this pass extracts one natural loop from the program into a function if "
"it can. This is used by :program:`bugpoint`."
msgstr ""

#: ../../Passes.rst:775
msgid "``-loop-reduce``: Loop Strength Reduction"
msgstr ""

#: ../../Passes.rst:777
msgid ""
"This pass performs a strength reduction on array references inside loops "
"that have as one or more of their components the loop induction variable."
"  This is accomplished by creating a new value to hold the initial value "
"of the array access for the first iteration, and then creating a new GEP "
"instruction in the loop to increment the value by the appropriate amount."
msgstr ""

#: ../../Passes.rst:784
msgid "``-loop-rotate``: Rotate Loops"
msgstr ""

#: ../../Passes.rst:786
msgid "A simple loop rotation transformation."
msgstr ""

#: ../../Passes.rst:789
msgid "``-loop-simplify``: Canonicalize natural loops"
msgstr ""

#: ../../Passes.rst:791
msgid ""
"This pass performs several transformations to transform natural loops "
"into a simpler form, which makes subsequent analyses and transformations "
"simpler and more effective."
msgstr ""

#: ../../Passes.rst:795
msgid ""
"Loop pre-header insertion guarantees that there is a single, non-critical"
" entry edge from outside of the loop to the loop header.  This simplifies"
" a number of analyses and transformations, such as :ref:`LICM <passes-"
"licm>`."
msgstr ""

#: ../../Passes.rst:799
msgid ""
"Loop exit-block insertion guarantees that all exit blocks from the loop "
"(blocks which are outside of the loop that have predecessors inside of "
"the loop) only have predecessors from inside of the loop (and are thus "
"dominated by the loop header).  This simplifies transformations such as "
"store-sinking that are built into LICM."
msgstr ""

#: ../../Passes.rst:805
msgid "This pass also guarantees that loops will have exactly one backedge."
msgstr ""

#: ../../Passes.rst:807
msgid ""
"Note that the :ref:`simplifycfg <passes-simplifycfg>` pass will clean up "
"blocks which are split out but end up being unnecessary, so usage of this"
" pass should not pessimize generated code."
msgstr ""

#: ../../Passes.rst:811
msgid ""
"This pass obviously modifies the CFG, but updates loop information and "
"dominator information."
msgstr ""

#: ../../Passes.rst:815
msgid "``-loop-unroll``: Unroll loops"
msgstr ""

#: ../../Passes.rst:817
msgid ""
"This pass implements a simple loop unroller.  It works best when loops "
"have been canonicalized by the :ref:`indvars <passes-indvars>` pass, "
"allowing it to determine the trip counts of loops easily."
msgstr ""

#: ../../Passes.rst:822
msgid "``-loop-unswitch``: Unswitch loops"
msgstr ""

#: ../../Passes.rst:824
msgid ""
"This pass transforms loops that contain branches on loop-invariant "
"conditions to have multiple loops.  For example, it turns the left into "
"the right code:"
msgstr ""

#: ../../Passes.rst:836
msgid ""
"This can increase the size of the code exponentially (doubling it every "
"time a loop is unswitched) so we only unswitch if the resultant code will"
" be smaller than a threshold."
msgstr ""

#: ../../Passes.rst:840
msgid ""
"This pass expects :ref:`LICM <passes-licm>` to be run before it to hoist "
"invariant conditions out of the loop, to make the unswitching opportunity"
" obvious."
msgstr ""

#: ../../Passes.rst:845
msgid "``-loweratomic``: Lower atomic intrinsics to non-atomic form"
msgstr ""

#: ../../Passes.rst:847
msgid ""
"This pass lowers atomic intrinsics to non-atomic form for use in a known "
"non-preemptible environment."
msgstr ""

#: ../../Passes.rst:850
msgid ""
"The pass does not verify that the environment is non-preemptible (in "
"general this would require knowledge of the entire call graph of the "
"program including any libraries which may not be available in bitcode "
"form); it simply lowers every atomic intrinsic."
msgstr ""

#: ../../Passes.rst:856
msgid "``-lowerinvoke``: Lower invokes to calls, for unwindless code generators"
msgstr ""

#: ../../Passes.rst:858
msgid ""
"This transformation is designed for use by code generators which do not "
"yet support stack unwinding.  This pass converts ``invoke`` instructions "
"to ``call`` instructions, so that any exception-handling ``landingpad`` "
"blocks become dead code (which can be removed by running the "
"``-simplifycfg`` pass afterwards)."
msgstr ""

#: ../../Passes.rst:865
msgid "``-lowerswitch``: Lower ``SwitchInst``\\ s to branches"
msgstr ""

#: ../../Passes.rst:867
msgid ""
"Rewrites switch instructions with a sequence of branches, which allows "
"targets to get away with not implementing the switch instruction until it"
" is convenient."
msgstr ""

#: ../../Passes.rst:874
msgid "``-mem2reg``: Promote Memory to Register"
msgstr ""

#: ../../Passes.rst:876
msgid ""
"This file promotes memory references to be register references.  It "
"promotes alloca instructions which only have loads and stores as uses.  "
"An ``alloca`` is transformed by using dominator frontiers to place phi "
"nodes, then traversing the function in depth-first order to rewrite loads"
" and stores as appropriate. This is just the standard SSA construction "
"algorithm to construct \"pruned\" SSA form."
msgstr ""

#: ../../Passes.rst:884
msgid "``-memcpyopt``: MemCpy Optimization"
msgstr ""

#: ../../Passes.rst:886
msgid ""
"This pass performs various transformations related to eliminating "
"``memcpy`` calls, or transforming sets of stores into ``memset``\\ s."
msgstr ""

#: ../../Passes.rst:890
msgid "``-mergefunc``: Merge Functions"
msgstr ""

#: ../../Passes.rst:892
msgid "This pass looks for equivalent functions that are mergable and folds them."
msgstr ""

#: ../../Passes.rst:894
msgid ""
"Total-ordering is introduced among the functions set: we define "
"comparison that answers for every two functions which of them is greater."
" It allows to arrange functions into the binary tree."
msgstr ""

#: ../../Passes.rst:898
msgid "For every new function we check for equivalent in tree."
msgstr ""

#: ../../Passes.rst:900
msgid ""
"If equivalent exists we fold such functions. If both functions are "
"overridable, we move the functionality into a new internal function and "
"leave two overridable thunks to it."
msgstr ""

#: ../../Passes.rst:904
msgid "If there is no equivalent, then we add this function to tree."
msgstr ""

#: ../../Passes.rst:906
msgid ""
"Lookup routine has O(log(n)) complexity, while whole merging process has "
"complexity of O(n*log(n))."
msgstr ""

#: ../../Passes.rst:909
msgid "Read :doc:`this <MergeFunctions>` article for more details."
msgstr ""

#: ../../Passes.rst:914
msgid "``-mergereturn``: Unify function exit nodes"
msgstr ""

#: ../../Passes.rst:916
msgid ""
"Ensure that functions have at most one ``ret`` instruction in them. "
"Additionally, it keeps track of which node is the new exit node of the "
"CFG."
msgstr ""

#: ../../Passes.rst:920
msgid "``-partial-inliner``: Partial Inliner"
msgstr ""

#: ../../Passes.rst:922
msgid ""
"This pass performs partial inlining, typically by inlining an ``if`` "
"statement that surrounds the body of the function."
msgstr ""

#: ../../Passes.rst:926
msgid "``-prune-eh``: Remove unused exception handling info"
msgstr ""

#: ../../Passes.rst:928
msgid ""
"This file implements a simple interprocedural pass which walks the call-"
"graph, turning invoke instructions into call instructions if and only if "
"the callee cannot throw an exception.  It implements this as a bottom-up "
"traversal of the call-graph."
msgstr ""

#: ../../Passes.rst:934
msgid "``-reassociate``: Reassociate expressions"
msgstr ""

#: ../../Passes.rst:936
msgid ""
"This pass reassociates commutative expressions in an order that is "
"designed to promote better constant propagation, GCSE, :ref:`LICM "
"<passes-licm>`, PRE, etc."
msgstr ""

#: ../../Passes.rst:939
msgid "For example: 4 + (x + 5) ⇒ x + (4 + 5)"
msgstr ""

#: ../../Passes.rst:941
msgid ""
"In the implementation of this algorithm, constants are assigned rank = 0,"
" function arguments are rank = 1, and other values are assigned ranks "
"corresponding to the reverse post order traversal of current function "
"(starting at 2), which effectively gives values in deep loops higher rank"
" than values not in loops."
msgstr ""

#: ../../Passes.rst:948
msgid "``-reg2mem``: Demote all values to stack slots"
msgstr ""

#: ../../Passes.rst:950
msgid ""
"This file demotes all registers to memory references.  It is intended to "
"be the inverse of :ref:`mem2reg <passes-mem2reg>`.  By converting to "
"``load`` instructions, the only values live across basic blocks are "
"``alloca`` instructions and ``load`` instructions before ``phi`` nodes.  "
"It is intended that this should make CFG hacking much easier.  To make "
"later hacking easier, the entry block is split into two, such that all "
"introduced ``alloca`` instructions (and nothing else) are in the entry "
"block."
msgstr ""

#: ../../Passes.rst:959
msgid "``-scalarrepl``: Scalar Replacement of Aggregates (DT)"
msgstr ""

#: ../../Passes.rst:961
msgid ""
"The well-known scalar replacement of aggregates transformation.  This "
"transform breaks up ``alloca`` instructions of aggregate type (structure "
"or array) into individual ``alloca`` instructions for each member if "
"possible.  Then, if possible, it transforms the individual ``alloca`` "
"instructions into nice clean scalar SSA form."
msgstr ""

#: ../../Passes.rst:967
msgid ""
"This combines a simple scalar replacement of aggregates algorithm with "
"the :ref:`mem2reg <passes-mem2reg>` algorithm because they often "
"interact, especially for C++ programs.  As such, iterating between "
"``scalarrepl``, then :ref:`mem2reg <passes-mem2reg>` until we run out of "
"things to promote works well."
msgstr ""

#: ../../Passes.rst:976
msgid "``-sccp``: Sparse Conditional Constant Propagation"
msgstr ""

#: ../../Passes.rst:978
msgid ""
"Sparse conditional constant propagation and merging, which can be "
"summarized as:"
msgstr ""

#: ../../Passes.rst:981
msgid "Assumes values are constant unless proven otherwise"
msgstr ""

#: ../../Passes.rst:982
msgid "Assumes BasicBlocks are dead unless proven otherwise"
msgstr ""

#: ../../Passes.rst:983
msgid "Proves values to be constant, and replaces them with constants"
msgstr ""

#: ../../Passes.rst:984
msgid "Proves conditional branches to be unconditional"
msgstr ""

#: ../../Passes.rst:986
msgid ""
"Note that this pass has a habit of making definitions be dead.  It is a "
"good idea to run a :ref:`DCE <passes-dce>` pass sometime after running "
"this pass."
msgstr ""

#: ../../Passes.rst:992
msgid "``-simplifycfg``: Simplify the CFG"
msgstr ""

#: ../../Passes.rst:994
msgid "Performs dead code elimination and basic block merging.  Specifically:"
msgstr ""

#: ../../Passes.rst:996
msgid "Removes basic blocks with no predecessors."
msgstr ""

#: ../../Passes.rst:997
msgid ""
"Merges a basic block into its predecessor if there is only one and the "
"predecessor only has one successor."
msgstr ""

#: ../../Passes.rst:999
msgid "Eliminates PHI nodes for basic blocks with a single predecessor."
msgstr ""

#: ../../Passes.rst:1000
msgid "Eliminates a basic block that only contains an unconditional branch."
msgstr ""

#: ../../Passes.rst:1003
msgid "``-sink``: Code sinking"
msgstr ""

#: ../../Passes.rst:1005
msgid ""
"This pass moves instructions into successor blocks, when possible, so "
"that they aren't executed on paths where their results aren't needed."
msgstr ""

#: ../../Passes.rst:1009
msgid "``-strip``: Strip all symbols from a module"
msgstr ""

#: ../../Passes.rst:1011
msgid "Performs code stripping.  This transformation can delete:"
msgstr ""

#: ../../Passes.rst:1013 ../../Passes.rst:1028 ../../Passes.rst:1051
#: ../../Passes.rst:1066
msgid "names for virtual registers"
msgstr ""

#: ../../Passes.rst:1014 ../../Passes.rst:1029 ../../Passes.rst:1052
#: ../../Passes.rst:1067
msgid "symbols for internal globals and functions"
msgstr ""

#: ../../Passes.rst:1015 ../../Passes.rst:1030 ../../Passes.rst:1053
#: ../../Passes.rst:1068
msgid "debug information"
msgstr ""

#: ../../Passes.rst:1017
msgid ""
"Note that this transformation makes code much less readable, so it should"
" only be used in situations where the strip utility would be used, such "
"as reducing code size or making it harder to reverse engineer code."
msgstr ""

#: ../../Passes.rst:1022
msgid "``-strip-dead-debug-info``: Strip debug info for unused symbols"
msgstr ""

#: ../../Passes.rst:1026
msgid "performs code stripping. this transformation can delete:"
msgstr ""

#: ../../Passes.rst:1032
msgid ""
"note that this transformation makes code much less readable, so it should"
" only be used in situations where the strip utility would be used, such "
"as reducing code size or making it harder to reverse engineer code."
msgstr ""

#: ../../Passes.rst:1037
msgid "``-strip-dead-prototypes``: Strip Unused Function Prototypes"
msgstr ""

#: ../../Passes.rst:1039
msgid ""
"This pass loops over all of the functions in the input module, looking "
"for dead declarations and removes them.  Dead declarations are "
"declarations of functions for which no implementation is available (i.e.,"
" declarations for unused library functions)."
msgstr ""

#: ../../Passes.rst:1045
msgid "``-strip-debug-declare``: Strip all ``llvm.dbg.declare`` intrinsics"
msgstr ""

#: ../../Passes.rst:1049 ../../Passes.rst:1064
msgid "This pass implements code stripping.  Specifically, it can delete:"
msgstr ""

#: ../../Passes.rst:1055 ../../Passes.rst:1070
msgid ""
"Note that this transformation makes code much less readable, so it should"
" only be used in situations where the 'strip' utility would be used, such"
" as reducing code size or making it harder to reverse engineer code."
msgstr ""

#: ../../Passes.rst:1060
msgid "``-strip-nondebug``: Strip all symbols, except dbg symbols, from a module"
msgstr ""

#: ../../Passes.rst:1075
msgid "``-tailcallelim``: Tail Call Elimination"
msgstr ""

#: ../../Passes.rst:1077
msgid ""
"This file transforms calls of the current function (self recursion) "
"followed by a return instruction with a branch to the entry of the "
"function, creating a loop.  This pass also implements the following "
"extensions to the basic algorithm:"
msgstr ""

#: ../../Passes.rst:1082
msgid ""
"Trivial instructions between the call and return do not prevent the "
"transformation from taking place, though currently the analysis cannot "
"support moving any really useful instructions (only dead ones)."
msgstr ""

#: ../../Passes.rst:1085
msgid ""
"This pass transforms functions that are prevented from being tail "
"recursive by an associative expression to use an accumulator variable, "
"thus compiling the typical naive factorial or fib implementation into "
"efficient code."
msgstr ""

#: ../../Passes.rst:1088
msgid ""
"TRE is performed if the function returns void, if the return returns the "
"result returned by the call, or if the function returns a run-time "
"constant on all exits from the function.  It is possible, though "
"unlikely, that the return returns something else (like constant 0), and "
"can still be TRE'd.  It can be TRE'd if *all other* return instructions "
"in the function return the exact same value."
msgstr ""

#: ../../Passes.rst:1094
msgid ""
"If it can prove that callees do not access theier caller stack frame, "
"they are marked as eligible for tail call elimination (by the code "
"generator)."
msgstr ""

#: ../../Passes.rst:1098
msgid "Utility Passes"
msgstr ""

#: ../../Passes.rst:1100
msgid "This section describes the LLVM Utility Passes."
msgstr ""

#: ../../Passes.rst:1103
msgid "``-deadarghaX0r``: Dead Argument Hacking (BUGPOINT USE ONLY; DO NOT USE)"
msgstr ""

#: ../../Passes.rst:1105
msgid ""
"Same as dead argument elimination, but deletes arguments to functions "
"which are external.  This is only for use by :doc:`bugpoint <Bugpoint>`."
msgstr ""

#: ../../Passes.rst:1109
msgid "``-extract-blocks``: Extract Basic Blocks From Module (for bugpoint use)"
msgstr ""

#: ../../Passes.rst:1111
msgid ""
"This pass is used by bugpoint to extract all blocks from the module into "
"their own functions."
msgstr ""

#: ../../Passes.rst:1115
msgid "``-instnamer``: Assign names to anonymous instructions"
msgstr ""

#: ../../Passes.rst:1117
msgid ""
"This is a little utility pass that gives instructions names, this is "
"mostly useful when diffing the effect of an optimization because deleting"
" an unnamed instruction can change all other instruction numbering, "
"making the diff very noisy."
msgstr ""

#: ../../Passes.rst:1125
msgid "``-verify``: Module Verifier"
msgstr ""

#: ../../Passes.rst:1127
msgid ""
"Verifies an LLVM IR code.  This is useful to run after an optimization "
"which is undergoing testing.  Note that llvm-as verifies its input before"
" emitting bitcode, and also that malformed bitcode is likely to make LLVM"
" crash.  All language front-ends are therefore encouraged to verify their"
" output before performing optimizing transformations."
msgstr ""

#: ../../Passes.rst:1133
msgid "Both of a binary operator's parameters are of the same type."
msgstr ""

#: ../../Passes.rst:1134
msgid "Verify that the indices of mem access instructions match other operands."
msgstr ""

#: ../../Passes.rst:1135
msgid ""
"Verify that arithmetic and other things are only performed on first-class"
" types.  Verify that shifts and logicals only happen on integrals f.e."
msgstr ""

#: ../../Passes.rst:1137
msgid "All of the constants in a switch statement are of the correct type."
msgstr ""

#: ../../Passes.rst:1138
msgid "The code is in valid SSA form."
msgstr ""

#: ../../Passes.rst:1139
msgid ""
"It is illegal to put a label into any other type (like a structure) or to"
" return one."
msgstr ""

#: ../../Passes.rst:1141
#, python-format
msgid ""
"Only phi nodes can be self referential: ``%x = add i32 %x``, ``%x`` is "
"invalid."
msgstr ""

#: ../../Passes.rst:1143
msgid "PHI nodes must have an entry for each predecessor, with no extras."
msgstr ""

#: ../../Passes.rst:1144
msgid "PHI nodes must be the first thing in a basic block, all grouped together."
msgstr ""

#: ../../Passes.rst:1145
msgid "PHI nodes must have at least one entry."
msgstr ""

#: ../../Passes.rst:1146
msgid "All basic blocks should only end with terminator insts, not contain them."
msgstr ""

#: ../../Passes.rst:1147
msgid "The entry node to a function must not have predecessors."
msgstr ""

#: ../../Passes.rst:1148
msgid "All Instructions must be embedded into a basic block."
msgstr ""

#: ../../Passes.rst:1149
msgid "Functions cannot take a void-typed parameter."
msgstr ""

#: ../../Passes.rst:1150
msgid "Verify that a function's argument list agrees with its declared type."
msgstr ""

#: ../../Passes.rst:1151
msgid "It is illegal to specify a name for a void value."
msgstr ""

#: ../../Passes.rst:1152
msgid "It is illegal to have an internal global value with no initializer."
msgstr ""

#: ../../Passes.rst:1153
msgid ""
"It is illegal to have a ``ret`` instruction that returns a value that "
"does not agree with the function return value type."
msgstr ""

#: ../../Passes.rst:1155
msgid "Function call argument types match the function prototype."
msgstr ""

#: ../../Passes.rst:1156
msgid "All other things that are tested by asserts spread about the code."
msgstr ""

#: ../../Passes.rst:1158
msgid ""
"Note that this does not provide full security verification (like Java), "
"but instead just tries to ensure that code is well-formed."
msgstr ""

#: ../../Passes.rst:1162
msgid "``-view-cfg``: View CFG of function"
msgstr ""

#: ../../Passes.rst:1164
msgid "Displays the control flow graph using the GraphViz tool."
msgstr ""

#: ../../Passes.rst:1167
msgid "``-view-cfg-only``: View CFG of function (with no function bodies)"
msgstr ""

#: ../../Passes.rst:1169
msgid ""
"Displays the control flow graph using the GraphViz tool, but omitting "
"function bodies."
msgstr ""

#: ../../Passes.rst:1173
msgid "``-view-dom``: View dominance tree of function"
msgstr ""

#: ../../Passes.rst:1175
msgid "Displays the dominator tree using the GraphViz tool."
msgstr ""

#: ../../Passes.rst:1178
msgid ""
"``-view-dom-only``: View dominance tree of function (with no function "
"bodies)"
msgstr ""

#: ../../Passes.rst:1180
msgid ""
"Displays the dominator tree using the GraphViz tool, but omitting "
"function bodies."
msgstr ""

#: ../../Passes.rst:1184
msgid "``-view-postdom``: View postdominance tree of function"
msgstr ""

#: ../../Passes.rst:1186
msgid "Displays the post dominator tree using the GraphViz tool."
msgstr ""

#: ../../Passes.rst:1189
msgid ""
"``-view-postdom-only``: View postdominance tree of function (with no "
"function bodies)"
msgstr ""

#: ../../Passes.rst:1191
msgid ""
"Displays the post dominator tree using the GraphViz tool, but omitting "
"function bodies."
msgstr ""

