# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2003-2016, LLVM Project
# This file is distributed under the same license as the LLVM package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2016.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: LLVM 3.8\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2016-04-17 11:36+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.3.3\n"

#: ../../Vectorizers.rst:3
msgid "Auto-Vectorization in LLVM"
msgstr ""

#: ../../Vectorizers.rst:8
msgid ""
"LLVM has two vectorizers: The :ref:`Loop Vectorizer <loop-vectorizer>`, "
"which operates on Loops, and the :ref:`SLP Vectorizer <slp-vectorizer>`. "
"These vectorizers focus on different optimization opportunities and use "
"different techniques. The SLP vectorizer merges multiple scalars that are"
" found in the code into vectors while the Loop Vectorizer widens "
"instructions in loops to operate on multiple consecutive iterations."
msgstr ""

#: ../../Vectorizers.rst:16
msgid "Both the Loop Vectorizer and the SLP Vectorizer are enabled by default."
msgstr ""

#: ../../Vectorizers.rst:21
msgid "The Loop Vectorizer"
msgstr ""

#: ../../Vectorizers.rst:24 ../../Vectorizers.rst:410
msgid "Usage"
msgstr ""

#: ../../Vectorizers.rst:26
msgid ""
"The Loop Vectorizer is enabled by default, but it can be disabled through"
" clang using the command line flag:"
msgstr ""

#: ../../Vectorizers.rst:34
msgid "Command line flags"
msgstr ""

#: ../../Vectorizers.rst:36
msgid ""
"The loop vectorizer uses a cost model to decide on the optimal "
"vectorization factor and unroll factor. However, users of the vectorizer "
"can force the vectorizer to use specific values. Both 'clang' and 'opt' "
"support the flags below."
msgstr ""

#: ../../Vectorizers.rst:40
msgid ""
"Users can control the vectorization SIMD width using the command line "
"flag \"-force-vector-width\"."
msgstr ""

#: ../../Vectorizers.rst:47
msgid ""
"Users can control the unroll factor using the command line flag \"-force-"
"vector-unroll\""
msgstr ""

#: ../../Vectorizers.rst:55
msgid "Pragma loop hint directives"
msgstr ""

#: ../../Vectorizers.rst:57
msgid ""
"The ``#pragma clang loop`` directive allows loop vectorization hints to "
"be specified for the subsequent for, while, do-while, or c++11 range-"
"based for loop. The directive allows vectorization and interleaving to be"
" enabled or disabled. Vector width as well as interleave count can also "
"be manually specified. The following example explicitly enables "
"vectorization and interleaving:"
msgstr ""

#: ../../Vectorizers.rst:71
msgid ""
"The following example implicitly enables vectorization and interleaving "
"by specifying a vector width and interleaving count:"
msgstr ""

#: ../../Vectorizers.rst:81
msgid ""
"See the Clang `language extensions "
"<http://clang.llvm.org/docs/LanguageExtensions.html#extensions-for-loop-"
"hint-optimizations>`_ for details."
msgstr ""

#: ../../Vectorizers.rst:87
msgid "Diagnostics"
msgstr ""

#: ../../Vectorizers.rst:89
msgid ""
"Many loops cannot be vectorized including loops with complicated control "
"flow, unvectorizable types, and unvectorizable calls. The loop vectorizer"
" generates optimization remarks which can be queried using command line "
"options to identify and diagnose loops that are skipped by the loop-"
"vectorizer."
msgstr ""

#: ../../Vectorizers.rst:94
msgid "Optimization remarks are enabled using:"
msgstr ""

#: ../../Vectorizers.rst:96
msgid ""
"``-Rpass=loop-vectorize`` identifies loops that were successfully "
"vectorized."
msgstr ""

#: ../../Vectorizers.rst:98
msgid ""
"``-Rpass-missed=loop-vectorize`` identifies loops that failed "
"vectorization and indicates if vectorization was specified."
msgstr ""

#: ../../Vectorizers.rst:101
msgid ""
"``-Rpass-analysis=loop-vectorize`` identifies the statements that caused "
"vectorization to fail."
msgstr ""

#: ../../Vectorizers.rst:104
msgid "Consider the following loop:"
msgstr ""

#: ../../Vectorizers.rst:117
msgid "The command line ``-Rpass-missed=loop-vectorized`` prints the remark:"
msgstr ""

#: ../../Vectorizers.rst:123
msgid ""
"And the command line ``-Rpass-analysis=loop-vectorize`` indicates that "
"the switch statement cannot be vectorized."
msgstr ""

#: ../../Vectorizers.rst:132
msgid ""
"To ensure line and column numbers are produced include the command line "
"options ``-gline-tables-only`` and ``-gcolumn-info``. See the Clang `user"
" manual <http://clang.llvm.org/docs/UsersManual.html#options-to-emit-"
"optimization-reports>`_ for details"
msgstr ""

#: ../../Vectorizers.rst:138
msgid "Features"
msgstr ""

#: ../../Vectorizers.rst:140
msgid ""
"The LLVM Loop Vectorizer has a number of features that allow it to "
"vectorize complex loops."
msgstr ""

#: ../../Vectorizers.rst:144
msgid "Loops with unknown trip count"
msgstr ""

#: ../../Vectorizers.rst:146
msgid ""
"The Loop Vectorizer supports loops with an unknown trip count. In the "
"loop below, the iteration ``start`` and ``finish`` points are unknown, "
"and the Loop Vectorizer has a mechanism to vectorize loops that do not "
"start at zero. In this example, 'n' may not be a multiple of the vector "
"width, and the vectorizer has to execute the last few iterations as "
"scalar code. Keeping a scalar copy of the loop increases the code size."
msgstr ""

#: ../../Vectorizers.rst:161
msgid "Runtime Checks of Pointers"
msgstr ""

#: ../../Vectorizers.rst:163
msgid ""
"In the example below, if the pointers A and B point to consecutive "
"addresses, then it is illegal to vectorize the code because some elements"
" of A will be written before they are read from array B."
msgstr ""

#: ../../Vectorizers.rst:167
msgid ""
"Some programmers use the 'restrict' keyword to notify the compiler that "
"the pointers are disjointed, but in our example, the Loop Vectorizer has "
"no way of knowing that the pointers A and B are unique. The Loop "
"Vectorizer handles this loop by placing code that checks, at runtime, if "
"the arrays A and B point to disjointed memory locations. If arrays A and "
"B overlap, then the scalar version of the loop is executed."
msgstr ""

#: ../../Vectorizers.rst:183
msgid "Reductions"
msgstr ""

#: ../../Vectorizers.rst:185
msgid ""
"In this example the ``sum`` variable is used by consecutive iterations of"
" the loop. Normally, this would prevent vectorization, but the vectorizer"
" can detect that 'sum' is a reduction variable. The variable 'sum' "
"becomes a vector of integers, and at the end of the loop the elements of "
"the array are added together to create the correct result. We support a "
"number of different reduction operations, such as addition, "
"multiplication, XOR, AND and OR."
msgstr ""

#: ../../Vectorizers.rst:201
msgid "We support floating point reduction operations when `-ffast-math` is used."
msgstr ""

#: ../../Vectorizers.rst:204
msgid "Inductions"
msgstr ""

#: ../../Vectorizers.rst:206
msgid ""
"In this example the value of the induction variable ``i`` is saved into "
"an array. The Loop Vectorizer knows to vectorize induction variables."
msgstr ""

#: ../../Vectorizers.rst:217
msgid "If Conversion"
msgstr ""

#: ../../Vectorizers.rst:219
msgid ""
"The Loop Vectorizer is able to \"flatten\" the IF statement in the code "
"and generate a single stream of instructions. The Loop Vectorizer "
"supports any control flow in the innermost loop. The innermost loop may "
"contain complex nesting of IFs, ELSEs and even GOTOs."
msgstr ""

#: ../../Vectorizers.rst:235
msgid "Pointer Induction Variables"
msgstr ""

#: ../../Vectorizers.rst:237
msgid ""
"This example uses the \"accumulate\" function of the standard c++ "
"library. This loop uses C++ iterators, which are pointers, and not "
"integer indices. The Loop Vectorizer detects pointer induction variables "
"and can vectorize this loop. This feature is important because many C++ "
"programs use iterators."
msgstr ""

#: ../../Vectorizers.rst:249
msgid "Reverse Iterators"
msgstr ""

#: ../../Vectorizers.rst:251
msgid "The Loop Vectorizer can vectorize loops that count backwards."
msgstr ""

#: ../../Vectorizers.rst:261
msgid "Scatter / Gather"
msgstr ""

#: ../../Vectorizers.rst:263
msgid ""
"The Loop Vectorizer can vectorize code that becomes a sequence of scalar "
"instructions that scatter/gathers memory."
msgstr ""

#: ../../Vectorizers.rst:273
msgid ""
"In many situations the cost model will inform LLVM that this is not "
"beneficial and LLVM will only vectorize such code if forced with \"-mllvm"
" -force-vector-width=#\"."
msgstr ""

#: ../../Vectorizers.rst:277
msgid "Vectorization of Mixed Types"
msgstr ""

#: ../../Vectorizers.rst:279
msgid ""
"The Loop Vectorizer can vectorize programs with mixed types. The "
"Vectorizer cost model can estimate the cost of the type conversion and "
"decide if vectorization is profitable."
msgstr ""

#: ../../Vectorizers.rst:291
msgid "Global Structures Alias Analysis"
msgstr ""

#: ../../Vectorizers.rst:293
msgid ""
"Access to global structures can also be vectorized, with alias analysis "
"being used to make sure accesses don't alias. Run-time checks can also be"
" added on pointer access to structure members."
msgstr ""

#: ../../Vectorizers.rst:297
msgid ""
"Many variations are supported, but some that rely on undefined behaviour "
"being ignored (as other compilers do) are still being left un-vectorized."
msgstr ""

#: ../../Vectorizers.rst:310
msgid "Vectorization of function calls"
msgstr ""

#: ../../Vectorizers.rst:312
msgid ""
"The Loop Vectorize can vectorize intrinsic math functions. See the table "
"below for a list of these functions."
msgstr ""

#: ../../Vectorizers.rst:316
msgid "pow"
msgstr ""

#: ../../Vectorizers.rst:316
msgid "exp"
msgstr ""

#: ../../Vectorizers.rst:316
msgid "exp2"
msgstr ""

#: ../../Vectorizers.rst:318
msgid "sin"
msgstr ""

#: ../../Vectorizers.rst:318
msgid "cos"
msgstr ""

#: ../../Vectorizers.rst:318
msgid "sqrt"
msgstr ""

#: ../../Vectorizers.rst:320
msgid "log"
msgstr ""

#: ../../Vectorizers.rst:320
msgid "log2"
msgstr ""

#: ../../Vectorizers.rst:320
msgid "log10"
msgstr ""

#: ../../Vectorizers.rst:322
msgid "fabs"
msgstr ""

#: ../../Vectorizers.rst:322
msgid "floor"
msgstr ""

#: ../../Vectorizers.rst:322
msgid "ceil"
msgstr ""

#: ../../Vectorizers.rst:324
msgid "fma"
msgstr ""

#: ../../Vectorizers.rst:324
msgid "trunc"
msgstr ""

#: ../../Vectorizers.rst:324
msgid "nearbyint"
msgstr ""

#: ../../Vectorizers.rst:326
msgid "fmuladd"
msgstr ""

#: ../../Vectorizers.rst:329
msgid ""
"The loop vectorizer knows about special instructions on the target and "
"will vectorize a loop containing a function call that maps to the "
"instructions. For example, the loop below will be vectorized on Intel x86"
" if the SSE4.1 roundps instruction is available."
msgstr ""

#: ../../Vectorizers.rst:342
msgid "Partial unrolling during vectorization"
msgstr ""

#: ../../Vectorizers.rst:344
msgid ""
"Modern processors feature multiple execution units, and only programs "
"that contain a high degree of parallelism can fully utilize the entire "
"width of the machine. The Loop Vectorizer increases the instruction level"
" parallelism (ILP) by performing partial-unrolling of loops."
msgstr ""

#: ../../Vectorizers.rst:349
msgid ""
"In the example below the entire array is accumulated into the variable "
"'sum'. This is inefficient because only a single execution port can be "
"used by the processor. By unrolling the code the Loop Vectorizer allows "
"two or more execution ports to be used simultaneously."
msgstr ""

#: ../../Vectorizers.rst:363
msgid ""
"The Loop Vectorizer uses a cost model to decide when it is profitable to "
"unroll loops. The decision to unroll the loop depends on the register "
"pressure and the generated code size."
msgstr ""

#: ../../Vectorizers.rst:367
msgid "Performance"
msgstr ""

#: ../../Vectorizers.rst:369
msgid ""
"This section shows the execution time of Clang on a simple benchmark: "
"`gcc-loops <http://llvm.org/viewvc/llvm-project/test-"
"suite/trunk/SingleSource/UnitTests/Vectorizer/>`_. This benchmarks is a "
"collection of loops from the GCC autovectorization `page "
"<http://gcc.gnu.org/projects/tree-ssa/vectorization.html>`_ by Dorit "
"Nuzman."
msgstr ""

#: ../../Vectorizers.rst:374
msgid ""
"The chart below compares GCC-4.7, ICC-13, and Clang-SVN with and without "
"loop vectorization at -O3, tuned for \"corei7-avx\", running on a "
"Sandybridge iMac. The Y-axis shows the time in msec. Lower is better. The"
" last column shows the geomean of all the kernels."
msgstr ""

#: ../../Vectorizers.rst:379
msgid ""
"And Linpack-pc with the same configuration. Result is Mflops, higher is "
"better."
msgstr ""

#: ../../Vectorizers.rst:386
msgid "The SLP Vectorizer"
msgstr ""

#: ../../Vectorizers.rst:389
msgid "Details"
msgstr ""

#: ../../Vectorizers.rst:391
msgid ""
"The goal of SLP vectorization (a.k.a. superword-level parallelism) is to "
"combine similar independent instructions into vector instructions. Memory"
" accesses, arithmetic operations, comparison operations, PHI-nodes, can "
"all be vectorized using this technique."
msgstr ""

#: ../../Vectorizers.rst:396
msgid ""
"For example, the following function performs very similar operations on "
"its inputs (a1, b1) and (a2, b2). The basic-block vectorizer may combine "
"these into vector operations."
msgstr ""

#: ../../Vectorizers.rst:407
msgid ""
"The SLP-vectorizer processes the code bottom-up, across basic blocks, in "
"search of scalars to combine."
msgstr ""

#: ../../Vectorizers.rst:412
msgid ""
"The SLP Vectorizer is enabled by default, but it can be disabled through "
"clang using the command line flag:"
msgstr ""

#: ../../Vectorizers.rst:419
msgid ""
"LLVM has a second basic block vectorization phase which is more compile-"
"time intensive (The BB vectorizer). This optimization can be enabled "
"through clang using the command line flag:"
msgstr ""

