# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2003-2016, LLVM Project
# This file is distributed under the same license as the LLVM package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2016.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: LLVM 3.8\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2016-04-17 11:36+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.3.3\n"

#: ../../tutorial/OCamlLangImpl7.rst:3
msgid "Kaleidoscope: Extending the Language: Mutable Variables"
msgstr ""

#: ../../tutorial/OCamlLangImpl7.rst:9
msgid "Chapter 7 Introduction"
msgstr ""

#: ../../tutorial/OCamlLangImpl7.rst:11
msgid ""
"Welcome to Chapter 7 of the \"`Implementing a language with LLVM "
"<index.html>`_\" tutorial. In chapters 1 through 6, we've built a very "
"respectable, albeit simple, `functional programming language "
"<http://en.wikipedia.org/wiki/Functional_programming>`_. In our journey, "
"we learned some parsing techniques, how to build and represent an AST, "
"how to build LLVM IR, and how to optimize the resultant code as well as "
"JIT compile it."
msgstr ""

#: ../../tutorial/OCamlLangImpl7.rst:19
msgid ""
"While Kaleidoscope is interesting as a functional language, the fact that"
" it is functional makes it \"too easy\" to generate LLVM IR for it. In "
"particular, a functional language makes it very easy to build LLVM IR "
"directly in `SSA form "
"<http://en.wikipedia.org/wiki/Static_single_assignment_form>`_. Since "
"LLVM requires that the input code be in SSA form, this is a very nice "
"property and it is often unclear to newcomers how to generate code for an"
" imperative language with mutable variables."
msgstr ""

#: ../../tutorial/OCamlLangImpl7.rst:28
msgid ""
"The short (and happy) summary of this chapter is that there is no need "
"for your front-end to build SSA form: LLVM provides highly tuned and well"
" tested support for this, though the way it works is a bit unexpected for"
" some."
msgstr ""

#: ../../tutorial/OCamlLangImpl7.rst:34
msgid "Why is this a hard problem?"
msgstr ""

#: ../../tutorial/OCamlLangImpl7.rst:36
msgid ""
"To understand why mutable variables cause complexities in SSA "
"construction, consider this extremely simple C example:"
msgstr ""

#: ../../tutorial/OCamlLangImpl7.rst:51
msgid ""
"In this case, we have the variable \"X\", whose value depends on the path"
" executed in the program. Because there are two different possible values"
" for X before the return instruction, a PHI node is inserted to merge the"
" two values. The LLVM IR that we want for this example looks like this:"
msgstr ""

#: ../../tutorial/OCamlLangImpl7.rst:78
msgid ""
"In this example, the loads from the G and H global variables are explicit"
" in the LLVM IR, and they live in the then/else branches of the if "
"statement (cond\\_true/cond\\_false). In order to merge the incoming "
"values, the X.2 phi node in the cond\\_next block selects the right value"
" to use based on where control flow is coming from: if control flow comes"
" from the cond\\_false block, X.2 gets the value of X.1. Alternatively, "
"if control flow comes from cond\\_true, it gets the value of X.0. The "
"intent of this chapter is not to explain the details of SSA form. For "
"more information, see one of the many `online references "
"<http://en.wikipedia.org/wiki/Static_single_assignment_form>`_."
msgstr ""

#: ../../tutorial/OCamlLangImpl7.rst:89
msgid ""
"The question for this article is \"who places the phi nodes when lowering"
" assignments to mutable variables?\". The issue here is that LLVM "
"*requires* that its IR be in SSA form: there is no \"non-ssa\" mode for "
"it. However, SSA construction requires non-trivial algorithms and data "
"structures, so it is inconvenient and wasteful for every front-end to "
"have to reproduce this logic."
msgstr ""

#: ../../tutorial/OCamlLangImpl7.rst:97
msgid "Memory in LLVM"
msgstr ""

#: ../../tutorial/OCamlLangImpl7.rst:99
msgid ""
"The 'trick' here is that while LLVM does require all register values to "
"be in SSA form, it does not require (or permit) memory objects to be in "
"SSA form. In the example above, note that the loads from G and H are "
"direct accesses to G and H: they are not renamed or versioned. This "
"differs from some other compiler systems, which do try to version memory "
"objects. In LLVM, instead of encoding dataflow analysis of memory into "
"the LLVM IR, it is handled with `Analysis Passes "
"<../WritingAnLLVMPass.html>`_ which are computed on demand."
msgstr ""

#: ../../tutorial/OCamlLangImpl7.rst:108
msgid ""
"With this in mind, the high-level idea is that we want to make a stack "
"variable (which lives in memory, because it is on the stack) for each "
"mutable object in a function. To take advantage of this trick, we need to"
" talk about how LLVM represents stack variables."
msgstr ""

#: ../../tutorial/OCamlLangImpl7.rst:113
msgid ""
"In LLVM, all memory accesses are explicit with load/store instructions, "
"and it is carefully designed not to have (or need) an \"address-of\" "
"operator. Notice how the type of the @G/@H global variables is actually "
"\"i32\\*\" even though the variable is defined as \"i32\". What this "
"means is that @G defines *space* for an i32 in the global data area, but "
"its *name* actually refers to the address for that space. Stack variables"
" work the same way, except that instead of being declared with global "
"variable definitions, they are declared with the `LLVM alloca instruction"
" <../LangRef.html#alloca-instruction>`_:"
msgstr ""

#: ../../tutorial/OCamlLangImpl7.rst:134
msgid ""
"This code shows an example of how you can declare and manipulate a stack "
"variable in the LLVM IR. Stack memory allocated with the alloca "
"instruction is fully general: you can pass the address of the stack slot "
"to functions, you can store it in other variables, etc. In our example "
"above, we could rewrite the example to use the alloca technique to avoid "
"using a PHI node:"
msgstr ""

#: ../../tutorial/OCamlLangImpl7.rst:166
msgid ""
"With this, we have discovered a way to handle arbitrary mutable variables"
" without the need to create Phi nodes at all:"
msgstr ""

#: ../../tutorial/OCamlLangImpl7.rst:169
msgid "Each mutable variable becomes a stack allocation."
msgstr ""

#: ../../tutorial/OCamlLangImpl7.rst:170
msgid "Each read of the variable becomes a load from the stack."
msgstr ""

#: ../../tutorial/OCamlLangImpl7.rst:171
msgid "Each update of the variable becomes a store to the stack."
msgstr ""

#: ../../tutorial/OCamlLangImpl7.rst:172
msgid "Taking the address of a variable just uses the stack address directly."
msgstr ""

#: ../../tutorial/OCamlLangImpl7.rst:175
msgid ""
"While this solution has solved our immediate problem, it introduced "
"another one: we have now apparently introduced a lot of stack traffic for"
" very simple and common operations, a major performance problem. "
"Fortunately for us, the LLVM optimizer has a highly-tuned optimization "
"pass named \"mem2reg\" that handles this case, promoting allocas like "
"this into SSA registers, inserting Phi nodes as appropriate. If you run "
"this example through the pass, for example, you'll get:"
msgstr ""

#: ../../tutorial/OCamlLangImpl7.rst:206
msgid ""
"The mem2reg pass implements the standard \"iterated dominance frontier\" "
"algorithm for constructing SSA form and has a number of optimizations "
"that speed up (very common) degenerate cases. The mem2reg optimization "
"pass is the answer to dealing with mutable variables, and we highly "
"recommend that you depend on it. Note that mem2reg only works on "
"variables in certain circumstances:"
msgstr ""

#: ../../tutorial/OCamlLangImpl7.rst:213
msgid ""
"mem2reg is alloca-driven: it looks for allocas and if it can handle them,"
" it promotes them. It does not apply to global variables or heap "
"allocations."
msgstr ""

#: ../../tutorial/OCamlLangImpl7.rst:216
msgid ""
"mem2reg only looks for alloca instructions in the entry block of the "
"function. Being in the entry block guarantees that the alloca is only "
"executed once, which makes analysis simpler."
msgstr ""

#: ../../tutorial/OCamlLangImpl7.rst:219
msgid ""
"mem2reg only promotes allocas whose uses are direct loads and stores. If "
"the address of the stack object is passed to a function, or if any funny "
"pointer arithmetic is involved, the alloca will not be promoted."
msgstr ""

#: ../../tutorial/OCamlLangImpl7.rst:223
msgid ""
"mem2reg only works on allocas of `first class <../LangRef.html#first-"
"class-types>`_ values (such as pointers, scalars and vectors), and only "
"if the array size of the allocation is 1 (or missing in the .ll file). "
"mem2reg is not capable of promoting structs or arrays to registers. Note "
"that the \"scalarrepl\" pass is more powerful and can promote structs, "
"\"unions\", and arrays in many cases."
msgstr ""

#: ../../tutorial/OCamlLangImpl7.rst:231
msgid ""
"All of these properties are easy to satisfy for most imperative "
"languages, and we'll illustrate it below with Kaleidoscope. The final "
"question you may be asking is: should I bother with this nonsense for my "
"front-end? Wouldn't it be better if I just did SSA construction directly,"
" avoiding use of the mem2reg optimization pass? In short, we strongly "
"recommend that you use this technique for building SSA form, unless there"
" is an extremely good reason not to. Using this technique is:"
msgstr ""

#: ../../tutorial/OCamlLangImpl7.rst:240
msgid ""
"Proven and well tested: clang uses this technique for local mutable "
"variables. As such, the most common clients of LLVM are using this to "
"handle a bulk of their variables. You can be sure that bugs are found "
"fast and fixed early."
msgstr ""

#: ../../tutorial/OCamlLangImpl7.rst:244
msgid ""
"Extremely Fast: mem2reg has a number of special cases that make it fast "
"in common cases as well as fully general. For example, it has fast-paths "
"for variables that are only used in a single block, variables that only "
"have one assignment point, good heuristics to avoid insertion of unneeded"
" phi nodes, etc."
msgstr ""

#: ../../tutorial/OCamlLangImpl7.rst:249
msgid ""
"Needed for debug info generation: `Debug information in LLVM "
"<../SourceLevelDebugging.html>`_ relies on having the address of the "
"variable exposed so that debug info can be attached to it. This technique"
" dovetails very naturally with this style of debug info."
msgstr ""

#: ../../tutorial/OCamlLangImpl7.rst:254
msgid ""
"If nothing else, this makes it much easier to get your front-end up and "
"running, and is very simple to implement. Lets extend Kaleidoscope with "
"mutable variables now!"
msgstr ""

#: ../../tutorial/OCamlLangImpl7.rst:259
msgid "Mutable Variables in Kaleidoscope"
msgstr ""

#: ../../tutorial/OCamlLangImpl7.rst:261
msgid ""
"Now that we know the sort of problem we want to tackle, lets see what "
"this looks like in the context of our little Kaleidoscope language. We're"
" going to add two features:"
msgstr ""

#: ../../tutorial/OCamlLangImpl7.rst:265
msgid "The ability to mutate variables with the '=' operator."
msgstr ""

#: ../../tutorial/OCamlLangImpl7.rst:266
msgid "The ability to define new variables."
msgstr ""

#: ../../tutorial/OCamlLangImpl7.rst:268
msgid ""
"While the first item is really what this is about, we only have variables"
" for incoming arguments as well as for induction variables, and "
"redefining those only goes so far :). Also, the ability to define new "
"variables is a useful thing regardless of whether you will be mutating "
"them. Here's a motivating example that shows how we could use these:"
msgstr ""

#: ../../tutorial/OCamlLangImpl7.rst:299
msgid ""
"In order to mutate variables, we have to change our existing variables to"
" use the \"alloca trick\". Once we have that, we'll add our new operator,"
" then extend Kaleidoscope to support new variable definitions."
msgstr ""

#: ../../tutorial/OCamlLangImpl7.rst:304
msgid "Adjusting Existing Variables for Mutation"
msgstr ""

#: ../../tutorial/OCamlLangImpl7.rst:306
msgid ""
"The symbol table in Kaleidoscope is managed at code generation time by "
"the '``named_values``' map. This map currently keeps track of the LLVM "
"\"Value\\*\" that holds the double value for the named variable. In order"
" to support mutation, we need to change this slightly, so that it "
"``named_values`` holds the *memory location* of the variable in question."
" Note that this change is a refactoring: it changes the structure of the "
"code, but does not (by itself) change the behavior of the compiler. All "
"of these changes are isolated in the Kaleidoscope code generator."
msgstr ""

#: ../../tutorial/OCamlLangImpl7.rst:316
msgid ""
"At this point in Kaleidoscope's development, it only supports variables "
"for two things: incoming arguments to functions and the induction "
"variable of 'for' loops. For consistency, we'll allow mutation of these "
"variables in addition to other user-defined variables. This means that "
"these will both need memory locations."
msgstr ""

#: ../../tutorial/OCamlLangImpl7.rst:322
msgid ""
"To start our transformation of Kaleidoscope, we'll change the "
"``named_values`` map so that it maps to AllocaInst\\* instead of "
"Value\\*. Once we do this, the C++ compiler will tell us what parts of "
"the code we need to update:"
msgstr ""

#: ../../tutorial/OCamlLangImpl7.rst:327
msgid ""
"**Note:** the ocaml bindings currently model both ``Value*``'s and "
"``AllocInst*``'s as ``Llvm.llvalue``'s, but this may change in the future"
" to be more type safe."
msgstr ""

#: ../../tutorial/OCamlLangImpl7.rst:335
msgid ""
"Also, since we will need to create these alloca's, we'll use a helper "
"function that ensures that the allocas are created in the entry block of "
"the function:"
msgstr ""

#: ../../tutorial/OCamlLangImpl7.rst:347
msgid ""
"This funny looking code creates an ``Llvm.llbuilder`` object that is "
"pointing at the first instruction of the entry block. It then creates an "
"alloca with the expected name and returns it. Because all values in "
"Kaleidoscope are doubles, there is no need to pass in a type to use."
msgstr ""

#: ../../tutorial/OCamlLangImpl7.rst:352
msgid ""
"With this in place, the first functionality change we want to make is to "
"variable references. In our new scheme, variables live on the stack, so "
"code generating a reference to them actually needs to produce a load from"
" the stack slot:"
msgstr ""

#: ../../tutorial/OCamlLangImpl7.rst:368
msgid ""
"As you can see, this is pretty straightforward. Now we need to update the"
" things that define the variables to set up the alloca. We'll start with "
"``codegen_expr Ast.For ...`` (see the `full code listing <#id1>`_ for the"
" unabridged code):"
msgstr ""

#: ../../tutorial/OCamlLangImpl7.rst:409
msgid ""
"This code is virtually identical to the code `before we allowed mutable "
"variables <OCamlLangImpl5.html#code-generation-for-the-for-loop>`_. The "
"big difference is that we no longer have to construct a PHI node, and we "
"use load/store to access the variable as needed."
msgstr ""

#: ../../tutorial/OCamlLangImpl7.rst:414
msgid ""
"To support mutable argument variables, we need to also make allocas for "
"them. The code for this is also pretty simple:"
msgstr ""

#: ../../tutorial/OCamlLangImpl7.rst:437
msgid ""
"For each argument, we make an alloca, store the input value to the "
"function into the alloca, and register the alloca as the memory location "
"for the argument. This method gets invoked by ``Codegen.codegen_func`` "
"right after it sets up the entry block for the function."
msgstr ""

#: ../../tutorial/OCamlLangImpl7.rst:442
msgid ""
"The final missing piece is adding the mem2reg pass, which allows us to "
"get good codegen once again:"
msgstr ""

#: ../../tutorial/OCamlLangImpl7.rst:464
msgid ""
"It is interesting to see what the code looks like before and after the "
"mem2reg optimization runs. For example, this is the before/after code for"
" our recursive fib function. Before the optimization:"
msgstr ""

#: ../../tutorial/OCamlLangImpl7.rst:498
msgid ""
"Here there is only one variable (x, the input argument) but you can still"
" see the extremely simple-minded code generation strategy we are using. "
"In the entry block, an alloca is created, and the initial input value is "
"stored into it. Each reference to the variable does a reload from the "
"stack. Also, note that we didn't modify the if/then/else expression, so "
"it still inserts a PHI node. While we could make an alloca for it, it is "
"actually easier to create a PHI node for it, so we still just make the "
"PHI."
msgstr ""

#: ../../tutorial/OCamlLangImpl7.rst:507
msgid "Here is the code after the mem2reg pass runs:"
msgstr ""

#: ../../tutorial/OCamlLangImpl7.rst:534
msgid ""
"This is a trivial case for mem2reg, since there are no redefinitions of "
"the variable. The point of showing this is to calm your tension about "
"inserting such blatent inefficiencies :)."
msgstr ""

#: ../../tutorial/OCamlLangImpl7.rst:538
msgid "After the rest of the optimizers run, we get:"
msgstr ""

#: ../../tutorial/OCamlLangImpl7.rst:561
msgid ""
"Here we see that the simplifycfg pass decided to clone the return "
"instruction into the end of the 'else' block. This allowed it to "
"eliminate some branches and the PHI node."
msgstr ""

#: ../../tutorial/OCamlLangImpl7.rst:565
msgid ""
"Now that all symbol table references are updated to use stack variables, "
"we'll add the assignment operator."
msgstr ""

#: ../../tutorial/OCamlLangImpl7.rst:569
msgid "New Assignment Operator"
msgstr ""

#: ../../tutorial/OCamlLangImpl7.rst:571
msgid ""
"With our current framework, adding a new assignment operator is really "
"simple. We will parse it just like any other binary operator, but handle "
"it internally (instead of allowing the user to define it). The first step"
" is to set a precedence:"
msgstr ""

#: ../../tutorial/OCamlLangImpl7.rst:587
msgid ""
"Now that the parser knows the precedence of the binary operator, it takes"
" care of all the parsing and AST generation. We just need to implement "
"codegen for the assignment operator. This looks like:"
msgstr ""

#: ../../tutorial/OCamlLangImpl7.rst:604
msgid ""
"Unlike the rest of the binary operators, our assignment operator doesn't "
"follow the \"emit LHS, emit RHS, do computation\" model. As such, it is "
"handled as a special case before the other binary operators are handled. "
"The other strange thing is that it requires the LHS to be a variable. It "
"is invalid to have \"(x+1) = expr\" - only things like \"x = expr\" are "
"allowed."
msgstr ""

#: ../../tutorial/OCamlLangImpl7.rst:625
msgid ""
"Once we have the variable, codegen'ing the assignment is straightforward:"
" we emit the RHS of the assignment, create a store, and return the "
"computed value. Returning a value allows for chained assignments like \"X"
" = (Y = Z)\"."
msgstr ""

#: ../../tutorial/OCamlLangImpl7.rst:630
msgid ""
"Now that we have an assignment operator, we can mutate loop variables and"
" arguments. For example, we can now run code like this:"
msgstr ""

#: ../../tutorial/OCamlLangImpl7.rst:649
msgid ""
"When run, this example prints \"123\" and then \"4\", showing that we did"
" actually mutate the value! Okay, we have now officially implemented our "
"goal: getting this to work requires SSA construction in the general case."
" However, to be really useful, we want the ability to define our own "
"local variables, lets add this next!"
msgstr ""

#: ../../tutorial/OCamlLangImpl7.rst:656
msgid "User-defined Local Variables"
msgstr ""

#: ../../tutorial/OCamlLangImpl7.rst:658
msgid ""
"Adding var/in is just like any other other extensions we made to "
"Kaleidoscope: we extend the lexer, the parser, the AST and the code "
"generator. The first step for adding our new 'var/in' construct is to "
"extend the lexer. As before, this is pretty trivial, the code looks like "
"this:"
msgstr ""

#: ../../tutorial/OCamlLangImpl7.rst:681
msgid ""
"The next step is to define the AST node that we will construct. For "
"var/in, it looks like this:"
msgstr ""

#: ../../tutorial/OCamlLangImpl7.rst:692
msgid ""
"var/in allows a list of names to be defined all at once, and each name "
"can optionally have an initializer value. As such, we capture this "
"information in the VarNames vector. Also, var/in has a body, this body is"
" allowed to access the variables defined by the var/in."
msgstr ""

#: ../../tutorial/OCamlLangImpl7.rst:697
msgid ""
"With this in place, we can define the parser pieces. The first thing we "
"do is add it as a primary expression:"
msgstr ""

#: ../../tutorial/OCamlLangImpl7.rst:738
msgid ""
"Now that we can parse and represent the code, we need to support emission"
" of LLVM IR for it. This code starts out with:"
msgstr ""

#: ../../tutorial/OCamlLangImpl7.rst:753
msgid ""
"Basically it loops over all the variables, installing them one at a time."
" For each variable we put into the symbol table, we remember the previous"
" value that we replace in OldBindings."
msgstr ""

#: ../../tutorial/OCamlLangImpl7.rst:788
msgid ""
"There are more comments here than code. The basic idea is that we emit "
"the initializer, create the alloca, then update the symbol table to point"
" to it. Once all the variables are installed in the symbol table, we "
"evaluate the body of the var/in expression:"
msgstr ""

#: ../../tutorial/OCamlLangImpl7.rst:798
msgid "Finally, before returning, we restore the previous variable bindings:"
msgstr ""

#: ../../tutorial/OCamlLangImpl7.rst:810
msgid ""
"The end result of all of this is that we get properly scoped variable "
"definitions, and we even (trivially) allow mutation of them :)."
msgstr ""

#: ../../tutorial/OCamlLangImpl7.rst:813
msgid ""
"With this, we completed what we set out to do. Our nice iterative fib "
"example from the intro compiles and runs just fine. The mem2reg pass "
"optimizes all of our stack variables into SSA registers, inserting PHI "
"nodes where needed, and our front-end remains simple: no \"iterated "
"dominance frontier\" computation anywhere in sight."
msgstr ""

#: ../../tutorial/OCamlLangImpl7.rst:820
msgid "Full Code Listing"
msgstr ""

#: ../../tutorial/OCamlLangImpl7.rst:822
msgid ""
"Here is the complete code listing for our running example, enhanced with "
"mutable variables and var/in support. To build this example, use:"
msgstr ""

#: ../../tutorial/OCamlLangImpl7.rst:832
msgid "Here is the code:"
msgstr ""

#: ../../tutorial/OCamlLangImpl7.rst:840
msgid "\\_tags:"
msgstr ""

#: ../../tutorial/OCamlLangImpl7.rst:854
msgid "myocamlbuild.ml:"
msgstr ""

#: ../../tutorial/OCamlLangImpl7.rst:883
msgid "token.ml:"
msgstr ""

#: ../../tutorial/OCamlLangImpl7.rst:947
msgid "lexer.ml:"
msgstr ""

#: ../../tutorial/OCamlLangImpl7.rst:990
msgid "ast.ml:"
msgstr ""

#: ../../tutorial/OCamlLangImpl7.rst:1215
msgid "parser.ml:"
msgstr ""

#: ../../tutorial/OCamlLangImpl7.rst:1589
msgid "codegen.ml:"
msgstr ""

#: ../../tutorial/OCamlLangImpl7.rst:1642
msgid "toplevel.ml:"
msgstr ""

#: ../../tutorial/OCamlLangImpl7.rst:1703
msgid "toy.ml:"
msgstr ""

#: ../../tutorial/OCamlLangImpl7.rst:1720
msgid "bindings.c"
msgstr ""

#: ../../tutorial/OCamlLangImpl7.rst:1722
msgid "`Next: Conclusion and other useful LLVM tidbits <OCamlLangImpl8.html>`_"
msgstr ""

