# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2003-2016, LLVM Project
# This file is distributed under the same license as the LLVM package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2016.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: LLVM 3.8\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2016-04-17 11:36+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.3.3\n"

#: ../../tutorial/OCamlLangImpl3.rst:3
msgid "Kaleidoscope: Code generation to LLVM IR"
msgstr ""

#: ../../tutorial/OCamlLangImpl3.rst:9
msgid "Chapter 3 Introduction"
msgstr ""

#: ../../tutorial/OCamlLangImpl3.rst:11
msgid ""
"Welcome to Chapter 3 of the \"`Implementing a language with LLVM "
"<index.html>`_\" tutorial. This chapter shows you how to transform the "
"`Abstract Syntax Tree <OCamlLangImpl2.html>`_, built in Chapter 2, into "
"LLVM IR. This will teach you a little bit about how LLVM does things, as "
"well as demonstrate how easy it is to use. It's much more work to build a"
" lexer and parser than it is to generate LLVM IR code. :)"
msgstr ""

#: ../../tutorial/OCamlLangImpl3.rst:18
msgid ""
"**Please note**: the code in this chapter and later require LLVM 2.3 or "
"LLVM SVN to work. LLVM 2.2 and before will not work with it."
msgstr ""

#: ../../tutorial/OCamlLangImpl3.rst:22
msgid "Code Generation Setup"
msgstr ""

#: ../../tutorial/OCamlLangImpl3.rst:24
msgid ""
"In order to generate LLVM IR, we want some simple setup to get started. "
"First we define virtual code generation (codegen) methods in each AST "
"class:"
msgstr ""

#: ../../tutorial/OCamlLangImpl3.rst:34
msgid ""
"The ``Codegen.codegen_expr`` function says to emit IR for that AST node "
"along with all the things it depends on, and they all return an LLVM "
"Value object. \"Value\" is the class used to represent a \"`Static Single"
" Assignment (SSA) "
"<http://en.wikipedia.org/wiki/Static_single_assignment_form>`_ register\""
" or \"SSA value\" in LLVM. The most distinct aspect of SSA values is that"
" their value is computed as the related instruction executes, and it does"
" not get a new value until (and if) the instruction re-executes. In other"
" words, there is no way to \"change\" an SSA value. For more information,"
" please read up on `Static Single Assignment "
"<http://en.wikipedia.org/wiki/Static_single_assignment_form>`_ - the "
"concepts are really quite natural once you grok them."
msgstr ""

#: ../../tutorial/OCamlLangImpl3.rst:47
msgid ""
"The second thing we want is an \"Error\" exception like we used for the "
"parser, which will be used to report errors found during code generation "
"(for example, use of an undeclared parameter):"
msgstr ""

#: ../../tutorial/OCamlLangImpl3.rst:61
msgid ""
"The static variables will be used during code generation. "
"``Codgen.the_module`` is the LLVM construct that contains all of the "
"functions and global variables in a chunk of code. In many ways, it is "
"the top-level structure that the LLVM IR uses to contain code."
msgstr ""

#: ../../tutorial/OCamlLangImpl3.rst:66
msgid ""
"The ``Codegen.builder`` object is a helper object that makes it easy to "
"generate LLVM instructions. Instances of the `IRBuilder "
"<http://llvm.org/doxygen/IRBuilder_8h-source.html>`_ class keep track of "
"the current place to insert instructions and has methods to create new "
"instructions."
msgstr ""

#: ../../tutorial/OCamlLangImpl3.rst:72
msgid ""
"The ``Codegen.named_values`` map keeps track of which values are defined "
"in the current scope and what their LLVM representation is. (In other "
"words, it is a symbol table for the code). In this form of Kaleidoscope, "
"the only things that can be referenced are function parameters. As such, "
"function parameters will be in this map when generating code for their "
"function body."
msgstr ""

#: ../../tutorial/OCamlLangImpl3.rst:79
msgid ""
"With these basics in place, we can start talking about how to generate "
"code for each expression. Note that this assumes that the "
"``Codgen.builder`` has been set up to generate code *into* something. For"
" now, we'll assume that this has already been done, and we'll just use it"
" to emit code."
msgstr ""

#: ../../tutorial/OCamlLangImpl3.rst:86
msgid "Expression Code Generation"
msgstr ""

#: ../../tutorial/OCamlLangImpl3.rst:88
msgid ""
"Generating LLVM code for expression nodes is very straightforward: less "
"than 30 lines of commented code for all four of our expression nodes. "
"First we'll do numeric literals:"
msgstr ""

#: ../../tutorial/OCamlLangImpl3.rst:96
msgid ""
"In the LLVM IR, numeric constants are represented with the ``ConstantFP``"
" class, which holds the numeric value in an ``APFloat`` internally "
"(``APFloat`` has the capability of holding floating point constants of "
"Arbitrary Precision). This code basically just creates and returns a "
"``ConstantFP``. Note that in the LLVM IR that constants are all uniqued "
"together and shared. For this reason, the API uses \"the foo::get(..)\" "
"idiom instead of \"new foo(..)\" or \"foo::Create(..)\"."
msgstr ""

#: ../../tutorial/OCamlLangImpl3.rst:110
msgid ""
"References to variables are also quite simple using LLVM. In the simple "
"version of Kaleidoscope, we assume that the variable has already been "
"emitted somewhere and its value is available. In practice, the only "
"values that can be in the ``Codegen.named_values`` map are function "
"arguments. This code simply checks to see that the specified name is in "
"the map (if not, an unknown variable is being referenced) and returns the"
" value for it. In future chapters, we'll add support for `loop induction "
"variables <LangImpl5.html#for-loop-expression>`_ in the symbol table, and"
" for `local variables <LangImpl7.html#user-defined-local-variables>`_."
msgstr ""

#: ../../tutorial/OCamlLangImpl3.rst:137
msgid ""
"Binary operators start to get more interesting. The basic idea here is "
"that we recursively emit code for the left-hand side of the expression, "
"then the right-hand side, then we compute the result of the binary "
"expression. In this code, we do a simple switch on the opcode to create "
"the right LLVM instruction."
msgstr ""

#: ../../tutorial/OCamlLangImpl3.rst:143
msgid ""
"In the example above, the LLVM builder class is starting to show its "
"value. IRBuilder knows where to insert the newly created instruction, all"
" you have to do is specify what instruction to create (e.g. with "
"``Llvm.create_add``), which operands to use (``lhs`` and ``rhs`` here) "
"and optionally provide a name for the generated instruction."
msgstr ""

#: ../../tutorial/OCamlLangImpl3.rst:149
msgid ""
"One nice thing about LLVM is that the name is just a hint. For instance, "
"if the code above emits multiple \"addtmp\" variables, LLVM will "
"automatically provide each one with an increasing, unique numeric suffix."
" Local value names for instructions are purely optional, but it makes it "
"much easier to read the IR dumps."
msgstr ""

#: ../../tutorial/OCamlLangImpl3.rst:155
msgid ""
"`LLVM instructions <../LangRef.html#instruction-reference>`_ are "
"constrained by strict rules: for example, the Left and Right operators of"
" an `add instruction <../LangRef.html#add-instruction>`_ must have the "
"same type, and the result type of the add must match the operand types. "
"Because all values in Kaleidoscope are doubles, this makes for very "
"simple code for add, sub and mul."
msgstr ""

#: ../../tutorial/OCamlLangImpl3.rst:162
msgid ""
"On the other hand, LLVM specifies that the `fcmp instruction "
"<../LangRef.html#fcmp-instruction>`_ always returns an 'i1' value (a one "
"bit integer). The problem with this is that Kaleidoscope wants the value "
"to be a 0.0 or 1.0 value. In order to get these semantics, we combine the"
" fcmp instruction with a `uitofp instruction <../LangRef.html#uitofp-to-"
"instruction>`_. This instruction converts its input integer into a "
"floating point value by treating the input as an unsigned value. In "
"contrast, if we used the `sitofp instruction <../LangRef.html#sitofp-to-"
"instruction>`_, the Kaleidoscope '<' operator would return 0.0 and -1.0, "
"depending on the input value."
msgstr ""

#: ../../tutorial/OCamlLangImpl3.rst:190
msgid ""
"Code generation for function calls is quite straightforward with LLVM. "
"The code above initially does a function name lookup in the LLVM Module's"
" symbol table. Recall that the LLVM Module is the container that holds "
"all of the functions we are JIT'ing. By giving each function the same "
"name as what the user specifies, we can use the LLVM symbol table to "
"resolve function names for us."
msgstr ""

#: ../../tutorial/OCamlLangImpl3.rst:197
msgid ""
"Once we have the function to call, we recursively codegen each argument "
"that is to be passed in, and create an LLVM `call instruction "
"<../LangRef.html#call-instruction>`_. Note that LLVM uses the native C "
"calling conventions by default, allowing these calls to also call into "
"standard library functions like \"sin\" and \"cos\", with no additional "
"effort."
msgstr ""

#: ../../tutorial/OCamlLangImpl3.rst:204
msgid ""
"This wraps up our handling of the four basic expressions that we have so "
"far in Kaleidoscope. Feel free to go in and add some more. For example, "
"by browsing the `LLVM language reference <../LangRef.html>`_ you'll find "
"several other interesting instructions that are really easy to plug into "
"our basic framework."
msgstr ""

#: ../../tutorial/OCamlLangImpl3.rst:211
msgid "Function Code Generation"
msgstr ""

#: ../../tutorial/OCamlLangImpl3.rst:213
msgid ""
"Code generation for prototypes and functions must handle a number of "
"details, which make their code less beautiful than expression code "
"generation, but allows us to illustrate some important points. First, "
"lets talk about code generation for prototypes: they are used both for "
"function bodies and external function declarations. The code starts with:"
msgstr ""

#: ../../tutorial/OCamlLangImpl3.rst:230
msgid ""
"This code packs a lot of power into a few lines. Note first that this "
"function returns a \"Function\\*\" instead of a \"Value\\*\" (although at"
" the moment they both are modeled by ``llvalue`` in ocaml). Because a "
"\"prototype\" really talks about the external interface for a function "
"(not the value computed by an expression), it makes sense for it to "
"return the LLVM Function it corresponds to when codegen'd."
msgstr ""

#: ../../tutorial/OCamlLangImpl3.rst:237
msgid ""
"The call to ``Llvm.function_type`` creates the ``Llvm.llvalue`` that "
"should be used for a given Prototype. Since all function arguments in "
"Kaleidoscope are of type double, the first line creates a vector of \"N\""
" LLVM double types. It then uses the ``Llvm.function_type`` method to "
"create a function type that takes \"N\" doubles as arguments, returns one"
" double as a result, and that is not vararg (that uses the function "
"``Llvm.var_arg_function_type``). Note that Types in LLVM are uniqued just"
" like ``Constant``'s are, so you don't \"new\" a type, you \"get\" it."
msgstr ""

#: ../../tutorial/OCamlLangImpl3.rst:246
msgid ""
"The final line above checks if the function has already been defined in "
"``Codegen.the_module``. If not, we will create it."
msgstr ""

#: ../../tutorial/OCamlLangImpl3.rst:253
msgid ""
"This indicates the type and name to use, as well as which module to "
"insert into. By default we assume a function has "
"``Llvm.Linkage.ExternalLinkage``. \"`external linkage "
"<../LangRef.html#linkage>`_\" means that the function may be defined "
"outside the current module and/or that it is callable by functions "
"outside the module. The \"``name``\" passed in is the name the user "
"specified: this name is registered in \"``Codegen.the_module``\"s symbol "
"table, which is used by the function call code above."
msgstr ""

#: ../../tutorial/OCamlLangImpl3.rst:262
msgid ""
"In Kaleidoscope, I choose to allow redefinitions of functions in two "
"cases: first, we want to allow 'extern'ing a function more than once, as "
"long as the prototypes for the externs match (since all arguments have "
"the same type, we just have to check that the number of arguments match)."
" Second, we want to allow 'extern'ing a function and then defining a body"
" for it. This is useful when defining mutually recursive functions."
msgstr ""

#: ../../tutorial/OCamlLangImpl3.rst:285
msgid ""
"In order to verify the logic above, we first check to see if the pre-"
"existing function is \"empty\". In this case, empty means that it has no "
"basic blocks in it, which means it has no body. If it has no body, it is "
"a forward declaration. Since we don't allow anything after a full "
"definition of the function, the code rejects this case. If the previous "
"reference to a function was an 'extern', we simply verify that the number"
" of arguments for that definition and this one match up. If not, we emit "
"an error."
msgstr ""

#: ../../tutorial/OCamlLangImpl3.rst:304
msgid ""
"The last bit of code for prototypes loops over all of the arguments in "
"the function, setting the name of the LLVM Argument objects to match, and"
" registering the arguments in the ``Codegen.named_values`` map for future"
" use by the ``Ast.Variable`` variant. Once this is set up, it returns the"
" Function object to the caller. Note that we don't check for conflicting "
"argument names here (e.g. \"extern foo(a b a)\"). Doing so would be very "
"straight-forward with the mechanics we have already used above."
msgstr ""

#: ../../tutorial/OCamlLangImpl3.rst:320
msgid ""
"Code generation for function definitions starts out simply enough: we "
"just codegen the prototype (Proto) and verify that it is ok. We then "
"clear out the ``Codegen.named_values`` map to make sure that there isn't "
"anything in it from the last function we compiled. Code generation of the"
" prototype ensures that there is an LLVM Function object that is ready to"
" go for us."
msgstr ""

#: ../../tutorial/OCamlLangImpl3.rst:336
msgid ""
"Now we get to the point where the ``Codegen.builder`` is set up. The "
"first line creates a new `basic block "
"<http://en.wikipedia.org/wiki/Basic_block>`_ (named \"entry\"), which is "
"inserted into ``the_function``. The second line then tells the builder "
"that new instructions should be inserted into the end of the new basic "
"block. Basic blocks in LLVM are an important part of functions that "
"define the `Control Flow Graph "
"<http://en.wikipedia.org/wiki/Control_flow_graph>`_. Since we don't have "
"any control flow, our functions will only contain one block at this "
"point. We'll fix this in `Chapter 5 <OCamlLangImpl5.html>`_ :)."
msgstr ""

#: ../../tutorial/OCamlLangImpl3.rst:359
msgid ""
"Once the insertion point is set up, we call the ``Codegen.codegen_func`` "
"method for the root expression of the function. If no error happens, this"
" emits code to compute the expression into the entry block and returns "
"the value that was computed. Assuming no error, we then create an LLVM "
"`ret instruction <../LangRef.html#ret-instruction>`_, which completes the"
" function. Once the function is built, we call "
"``Llvm_analysis.assert_valid_function``, which is provided by LLVM. This "
"function does a variety of consistency checks on the generated code, to "
"determine if our compiler is doing everything right. Using this is "
"important: it can catch a lot of bugs. Once the function is finished and "
"validated, we return it."
msgstr ""

#: ../../tutorial/OCamlLangImpl3.rst:377
msgid ""
"The only piece left here is handling of the error case. For simplicity, "
"we handle this by merely deleting the function we produced with the "
"``Llvm.delete_function`` method. This allows the user to redefine a "
"function that they incorrectly typed in before: if we didn't delete it, "
"it would live in the symbol table, with a body, preventing future "
"redefinition."
msgstr ""

#: ../../tutorial/OCamlLangImpl3.rst:384
msgid ""
"This code does have a bug, though. Since the ``Codegen.codegen_proto`` "
"can return a previously defined forward declaration, our code can "
"actually delete a forward declaration. There are a number of ways to fix "
"this bug, see what you can come up with! Here is a testcase:"
msgstr ""

#: ../../tutorial/OCamlLangImpl3.rst:396
msgid "Driver Changes and Closing Thoughts"
msgstr ""

#: ../../tutorial/OCamlLangImpl3.rst:398
msgid ""
"For now, code generation to LLVM doesn't really get us much, except that "
"we can look at the pretty IR calls. The sample code inserts calls to "
"Codegen into the \"``Toplevel.main_loop``\", and then dumps out the LLVM "
"IR. This gives a nice way to look at the LLVM IR for simple functions. "
"For example:"
msgstr ""

#: ../../tutorial/OCamlLangImpl3.rst:414
msgid ""
"Note how the parser turns the top-level expression into anonymous "
"functions for us. This will be handy when we add `JIT support "
"<OCamlLangImpl4.html#adding-a-jit-compiler>`_ in the next chapter. Also "
"note that the code is very literally transcribed, no optimizations are "
"being performed. We will `add optimizations <OCamlLangImpl4.html#trivial-"
"constant-folding>`_ explicitly in the next chapter."
msgstr ""

#: ../../tutorial/OCamlLangImpl3.rst:437
msgid ""
"This shows some simple arithmetic. Notice the striking similarity to the "
"LLVM builder calls that we use to create the instructions."
msgstr ""

#: ../../tutorial/OCamlLangImpl3.rst:452
msgid ""
"This shows some function calls. Note that this function will take a long "
"time to execute if you call it. In the future we'll add conditional "
"control flow to actually make recursion useful :)."
msgstr ""

#: ../../tutorial/OCamlLangImpl3.rst:470
msgid "This shows an extern for the libm \"cos\" function, and a call to it."
msgstr ""

#: ../../tutorial/OCamlLangImpl3.rst:510
msgid ""
"When you quit the current demo, it dumps out the IR for the entire module"
" generated. Here you can see the big picture with all the functions "
"referencing each other."
msgstr ""

#: ../../tutorial/OCamlLangImpl3.rst:514
msgid ""
"This wraps up the third chapter of the Kaleidoscope tutorial. Up next, "
"we'll describe how to `add JIT codegen and optimizer support "
"<OCamlLangImpl4.html>`_ to this so we can actually start running code!"
msgstr ""

#: ../../tutorial/OCamlLangImpl3.rst:520
msgid "Full Code Listing"
msgstr ""

#: ../../tutorial/OCamlLangImpl3.rst:522
msgid ""
"Here is the complete code listing for our running example, enhanced with "
"the LLVM code generator. Because this uses the LLVM libraries, we need to"
" link them in. To do this, we use the `llvm-config <http://llvm.org/cmds"
"/llvm-config.html>`_ tool to inform our makefile/command line about which"
" options to use:"
msgstr ""

#: ../../tutorial/OCamlLangImpl3.rst:535
msgid "Here is the code:"
msgstr ""

#: ../../tutorial/OCamlLangImpl3.rst:541
msgid "\\_tags:"
msgstr ""

#: ../../tutorial/OCamlLangImpl3.rst:551
msgid "myocamlbuild.ml:"
msgstr ""

#: ../../tutorial/OCamlLangImpl3.rst:570
msgid "token.ml:"
msgstr ""

#: ../../tutorial/OCamlLangImpl3.rst:626
msgid "lexer.ml:"
msgstr ""

#: ../../tutorial/OCamlLangImpl3.rst:655
msgid "ast.ml:"
msgstr ""

#: ../../tutorial/OCamlLangImpl3.rst:781
msgid "parser.ml:"
msgstr ""

#: ../../tutorial/OCamlLangImpl3.rst:885
msgid "codegen.ml:"
msgstr ""

#: ../../tutorial/OCamlLangImpl3.rst:928
msgid "toplevel.ml:"
msgstr ""

#: ../../tutorial/OCamlLangImpl3.rst:958
msgid "toy.ml:"
msgstr ""

#: ../../tutorial/OCamlLangImpl3.rst:960
msgid "`Next: Adding JIT and Optimizer Support <OCamlLangImpl4.html>`_"
msgstr ""

