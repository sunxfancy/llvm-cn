# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2003-2016, LLVM Project
# This file is distributed under the same license as the LLVM package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2016.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: LLVM 3.8\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2016-04-17 11:36+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.3.3\n"

#: ../../tutorial/OCamlLangImpl5.rst:3
msgid "Kaleidoscope: Extending the Language: Control Flow"
msgstr ""

#: ../../tutorial/OCamlLangImpl5.rst:9
msgid "Chapter 5 Introduction"
msgstr ""

#: ../../tutorial/OCamlLangImpl5.rst:11
msgid ""
"Welcome to Chapter 5 of the \"`Implementing a language with LLVM "
"<index.html>`_\" tutorial. Parts 1-4 described the implementation of the "
"simple Kaleidoscope language and included support for generating LLVM IR,"
" followed by optimizations and a JIT compiler. Unfortunately, as "
"presented, Kaleidoscope is mostly useless: it has no control flow other "
"than call and return. This means that you can't have conditional branches"
" in the code, significantly limiting its power. In this episode of "
"\"build that compiler\", we'll extend Kaleidoscope to have an "
"if/then/else expression plus a simple 'for' loop."
msgstr ""

#: ../../tutorial/OCamlLangImpl5.rst:22
msgid "If/Then/Else"
msgstr ""

#: ../../tutorial/OCamlLangImpl5.rst:24
msgid ""
"Extending Kaleidoscope to support if/then/else is quite straightforward. "
"It basically requires adding lexer support for this \"new\" concept to "
"the lexer, parser, AST, and LLVM code emitter. This example is nice, "
"because it shows how easy it is to \"grow\" a language over time, "
"incrementally extending it as new ideas are discovered."
msgstr ""

#: ../../tutorial/OCamlLangImpl5.rst:30
msgid ""
"Before we get going on \"how\" we add this extension, lets talk about "
"\"what\" we want. The basic idea is that we want to be able to write this"
" sort of thing:"
msgstr ""

#: ../../tutorial/OCamlLangImpl5.rst:42
msgid ""
"In Kaleidoscope, every construct is an expression: there are no "
"statements. As such, the if/then/else expression needs to return a value "
"like any other. Since we're using a mostly functional form, we'll have it"
" evaluate its conditional, then return the 'then' or 'else' value based "
"on how the condition was resolved. This is very similar to the C \"?:\" "
"expression."
msgstr ""

#: ../../tutorial/OCamlLangImpl5.rst:49
msgid ""
"The semantics of the if/then/else expression is that it evaluates the "
"condition to a boolean equality value: 0.0 is considered to be false and "
"everything else is considered to be true. If the condition is true, the "
"first subexpression is evaluated and returned, if the condition is false,"
" the second subexpression is evaluated and returned. Since Kaleidoscope "
"allows side-effects, this behavior is important to nail down."
msgstr ""

#: ../../tutorial/OCamlLangImpl5.rst:57
msgid ""
"Now that we know what we \"want\", lets break this down into its "
"constituent pieces."
msgstr ""

#: ../../tutorial/OCamlLangImpl5.rst:61
msgid "Lexer Extensions for If/Then/Else"
msgstr ""

#: ../../tutorial/OCamlLangImpl5.rst:63
msgid ""
"The lexer extensions are straightforward. First we add new variants for "
"the relevant tokens:"
msgstr ""

#: ../../tutorial/OCamlLangImpl5.rst:71
msgid ""
"Once we have that, we recognize the new keywords in the lexer. This is "
"pretty simple stuff:"
msgstr ""

#: ../../tutorial/OCamlLangImpl5.rst:88
msgid "AST Extensions for If/Then/Else"
msgstr ""

#: ../../tutorial/OCamlLangImpl5.rst:90
msgid "To represent the new expression we add a new AST variant for it:"
msgstr ""

#: ../../tutorial/OCamlLangImpl5.rst:99
msgid "The AST variant just has pointers to the various subexpressions."
msgstr ""

#: ../../tutorial/OCamlLangImpl5.rst:102
msgid "Parser Extensions for If/Then/Else"
msgstr ""

#: ../../tutorial/OCamlLangImpl5.rst:104
msgid ""
"Now that we have the relevant tokens coming from the lexer and we have "
"the AST node to build, our parsing logic is relatively straightforward. "
"First we define a new parsing function:"
msgstr ""

#: ../../tutorial/OCamlLangImpl5.rst:118
msgid "Next we hook it up as a primary expression:"
msgstr ""

#: ../../tutorial/OCamlLangImpl5.rst:131
msgid "LLVM IR for If/Then/Else"
msgstr ""

#: ../../tutorial/OCamlLangImpl5.rst:133
msgid ""
"Now that we have it parsing and building the AST, the final piece is "
"adding LLVM code generation support. This is the most interesting part of"
" the if/then/else example, because this is where it starts to introduce "
"new concepts. All of the code above has been thoroughly described in "
"previous chapters."
msgstr ""

#: ../../tutorial/OCamlLangImpl5.rst:139
msgid ""
"To motivate the code we want to produce, lets take a look at a simple "
"example. Consider:"
msgstr ""

#: ../../tutorial/OCamlLangImpl5.rst:148
msgid ""
"If you disable optimizations, the code you'll (soon) get from "
"Kaleidoscope looks like this:"
msgstr ""

#: ../../tutorial/OCamlLangImpl5.rst:175
msgid ""
"To visualize the control flow graph, you can use a nifty feature of the "
"LLVM '`opt <http://llvm.org/cmds/opt.html>`_' tool. If you put this LLVM "
"IR into \"t.ll\" and run \"``llvm-as < t.ll | opt -analyze -view-cfg``\","
" `a window will pop up <../ProgrammersManual.html#viewing-graphs-while-"
"debugging-code>`_ and you'll see this graph:"
msgstr ""

#: ../../tutorial/OCamlLangImpl5.rst:185
msgid "Example CFG"
msgstr ""

#: ../../tutorial/OCamlLangImpl5.rst:187
msgid ""
"Another way to get this is to call \"``Llvm_analysis.view_function_cfg "
"f``\" or \"``Llvm_analysis.view_function_cfg_only f``\" (where ``f`` is a"
" \"``Function``\") either by inserting actual calls into the code and "
"recompiling or by calling these in the debugger. LLVM has many nice "
"features for visualizing various graphs."
msgstr ""

#: ../../tutorial/OCamlLangImpl5.rst:194
msgid ""
"Getting back to the generated code, it is fairly simple: the entry block "
"evaluates the conditional expression (\"x\" in our case here) and "
"compares the result to 0.0 with the \"``fcmp one``\" instruction ('one' "
"is \"Ordered and Not Equal\"). Based on the result of this expression, "
"the code jumps to either the \"then\" or \"else\" blocks, which contain "
"the expressions for the true/false cases."
msgstr ""

#: ../../tutorial/OCamlLangImpl5.rst:201
msgid ""
"Once the then/else blocks are finished executing, they both branch back "
"to the 'ifcont' block to execute the code that happens after the "
"if/then/else. In this case the only thing left to do is to return to the "
"caller of the function. The question then becomes: how does the code know"
" which expression to return?"
msgstr ""

#: ../../tutorial/OCamlLangImpl5.rst:207
msgid ""
"The answer to this question involves an important SSA operation: the `Phi"
" operation "
"<http://en.wikipedia.org/wiki/Static_single_assignment_form>`_. If you're"
" not familiar with SSA, `the wikipedia article "
"<http://en.wikipedia.org/wiki/Static_single_assignment_form>`_ is a good "
"introduction and there are various other introductions to it available on"
" your favorite search engine. The short version is that \"execution\" of "
"the Phi operation requires \"remembering\" which block control came from."
" The Phi operation takes on the value corresponding to the input control "
"block. In this case, if control comes in from the \"then\" block, it gets"
" the value of \"calltmp\". If control comes from the \"else\" block, it "
"gets the value of \"calltmp1\"."
msgstr ""

#: ../../tutorial/OCamlLangImpl5.rst:220
msgid ""
"At this point, you are probably starting to think \"Oh no! This means my "
"simple and elegant front-end will have to start generating SSA form in "
"order to use LLVM!\". Fortunately, this is not the case, and we strongly "
"advise *not* implementing an SSA construction algorithm in your front-end"
" unless there is an amazingly good reason to do so. In practice, there "
"are two sorts of values that float around in code written for your "
"average imperative programming language that might need Phi nodes:"
msgstr ""

#: ../../tutorial/OCamlLangImpl5.rst:229
msgid "Code that involves user variables: ``x = 1; x = x + 1;``"
msgstr ""

#: ../../tutorial/OCamlLangImpl5.rst:230
msgid ""
"Values that are implicit in the structure of your AST, such as the Phi "
"node in this case."
msgstr ""

#: ../../tutorial/OCamlLangImpl5.rst:233
msgid ""
"In `Chapter 7 <OCamlLangImpl7.html>`_ of this tutorial (\"mutable "
"variables\"), we'll talk about #1 in depth. For now, just believe me that"
" you don't need SSA construction to handle this case. For #2, you have "
"the choice of using the techniques that we will describe for #1, or you "
"can insert Phi nodes directly, if convenient. In this case, it is really "
"really easy to generate the Phi node, so we choose to do it directly."
msgstr ""

#: ../../tutorial/OCamlLangImpl5.rst:240
msgid "Okay, enough of the motivation and overview, lets generate code!"
msgstr ""

#: ../../tutorial/OCamlLangImpl5.rst:243
msgid "Code Generation for If/Then/Else"
msgstr ""

#: ../../tutorial/OCamlLangImpl5.rst:245
msgid ""
"In order to generate code for this, we implement the ``Codegen`` method "
"for ``IfExprAST``:"
msgstr ""

#: ../../tutorial/OCamlLangImpl5.rst:259
msgid ""
"This code is straightforward and similar to what we saw before. We emit "
"the expression for the condition, then compare that value to zero to get "
"a truth value as a 1-bit (bool) value."
msgstr ""

#: ../../tutorial/OCamlLangImpl5.rst:273
msgid ""
"As opposed to the `C++ tutorial <LangImpl5.html>`_, we have to build our "
"basic blocks bottom up since we can't have dangling BasicBlocks. We start"
" off by saving a pointer to the first block (which might not be the entry"
" block), which we'll need to build a conditional branch later. We do this"
" by asking the ``builder`` for the current BasicBlock. The fourth line "
"gets the current Function object that is being built. It gets this by the"
" ``start_bb`` for its \"parent\" (the function it is currently embedded "
"into)."
msgstr ""

#: ../../tutorial/OCamlLangImpl5.rst:282
msgid ""
"Once it has that, it creates one block. It is automatically appended into"
" the function's list of blocks."
msgstr ""

#: ../../tutorial/OCamlLangImpl5.rst:296
msgid ""
"We move the builder to start inserting into the \"then\" block. Strictly "
"speaking, this call moves the insertion point to be at the end of the "
"specified block. However, since the \"then\" block is empty, it also "
"starts out by inserting at the beginning of the block. :)"
msgstr ""

#: ../../tutorial/OCamlLangImpl5.rst:301
msgid ""
"Once the insertion point is set, we recursively codegen the \"then\" "
"expression from the AST."
msgstr ""

#: ../../tutorial/OCamlLangImpl5.rst:304
msgid ""
"The final line here is quite subtle, but is very important. The basic "
"issue is that when we create the Phi node in the merge block, we need to "
"set up the block/value pairs that indicate how the Phi will work. "
"Importantly, the Phi node expects to have an entry for each predecessor "
"of the block in the CFG. Why then, are we getting the current block when "
"we just set it to ThenBB 5 lines above? The problem is that the \"Then\" "
"expression may actually itself change the block that the Builder is "
"emitting into if, for example, it contains a nested \"if/then/else\" "
"expression. Because calling Codegen recursively could arbitrarily change "
"the notion of the current block, we are required to get an up-to-date "
"value for code that will set up the Phi node."
msgstr ""

#: ../../tutorial/OCamlLangImpl5.rst:327
msgid ""
"Code generation for the 'else' block is basically identical to codegen "
"for the 'then' block."
msgstr ""

#: ../../tutorial/OCamlLangImpl5.rst:338
msgid ""
"The first two lines here are now familiar: the first adds the \"merge\" "
"block to the Function object. The second changes the insertion point so "
"that newly created code will go into the \"merge\" block. Once that is "
"done, we need to create the PHI node and set up the block/value pairs for"
" the PHI."
msgstr ""

#: ../../tutorial/OCamlLangImpl5.rst:350
msgid ""
"Once the blocks are created, we can emit the conditional branch that "
"chooses between them. Note that creating new blocks does not implicitly "
"affect the IRBuilder, so it is still inserting into the block that the "
"condition went into. This is why we needed to save the \"start\" block."
msgstr ""

#: ../../tutorial/OCamlLangImpl5.rst:367
msgid ""
"To finish off the blocks, we create an unconditional branch to the merge "
"block. One interesting (and very important) aspect of the LLVM IR is that"
" it `requires all basic blocks to be \"terminated\" "
"<../LangRef.html#functionstructure>`_ with a `control flow instruction "
"<../LangRef.html#terminators>`_ such as return or branch. This means that"
" all control flow, *including fall throughs* must be made explicit in the"
" LLVM IR. If you violate this rule, the verifier will emit an error."
msgstr ""

#: ../../tutorial/OCamlLangImpl5.rst:376
msgid ""
"Finally, the CodeGen function returns the phi node as the value computed "
"by the if/then/else expression. In our example above, this returned value"
" will feed into the code for the top-level function, which will create "
"the return instruction."
msgstr ""

#: ../../tutorial/OCamlLangImpl5.rst:381
msgid ""
"Overall, we now have the ability to execute conditional code in "
"Kaleidoscope. With this extension, Kaleidoscope is a fairly complete "
"language that can calculate a wide variety of numeric functions. Next up "
"we'll add another useful expression that is familiar from non-functional "
"languages..."
msgstr ""

#: ../../tutorial/OCamlLangImpl5.rst:388
msgid "'for' Loop Expression"
msgstr ""

#: ../../tutorial/OCamlLangImpl5.rst:390
msgid ""
"Now that we know how to add basic control flow constructs to the "
"language, we have the tools to add more powerful things. Lets add "
"something more aggressive, a 'for' expression:"
msgstr ""

#: ../../tutorial/OCamlLangImpl5.rst:404
msgid ""
"This expression defines a new variable (\"i\" in this case) which "
"iterates from a starting value, while the condition (\"i < n\" in this "
"case) is true, incrementing by an optional step value (\"1.0\" in this "
"case). If the step value is omitted, it defaults to 1.0. While the loop "
"is true, it executes its body expression. Because we don't have anything "
"better to return, we'll just define the loop as always returning 0.0. In "
"the future when we have mutable variables, it will get more useful."
msgstr ""

#: ../../tutorial/OCamlLangImpl5.rst:412
msgid ""
"As before, lets talk about the changes that we need to Kaleidoscope to "
"support this."
msgstr ""

#: ../../tutorial/OCamlLangImpl5.rst:416
msgid "Lexer Extensions for the 'for' Loop"
msgstr ""

#: ../../tutorial/OCamlLangImpl5.rst:418
msgid "The lexer extensions are the same sort of thing as for if/then/else:"
msgstr ""

#: ../../tutorial/OCamlLangImpl5.rst:439
msgid "AST Extensions for the 'for' Loop"
msgstr ""

#: ../../tutorial/OCamlLangImpl5.rst:441
msgid ""
"The AST variant is just as simple. It basically boils down to capturing "
"the variable name and the constituent expressions in the node."
msgstr ""

#: ../../tutorial/OCamlLangImpl5.rst:452
msgid "Parser Extensions for the 'for' Loop"
msgstr ""

#: ../../tutorial/OCamlLangImpl5.rst:454
msgid ""
"The parser code is also fairly standard. The only interesting thing here "
"is handling of the optional step value. The parser code handles it by "
"checking to see if the second comma is present. If not, it sets the step "
"value to null in the AST node:"
msgstr ""

#: ../../tutorial/OCamlLangImpl5.rst:492
msgid "LLVM IR for the 'for' Loop"
msgstr ""

#: ../../tutorial/OCamlLangImpl5.rst:494
msgid ""
"Now we get to the good part: the LLVM IR we want to generate for this "
"thing. With the simple example above, we get this LLVM IR (note that this"
" dump is generated with optimizations disabled for clarity):"
msgstr ""

#: ../../tutorial/OCamlLangImpl5.rst:525
msgid ""
"This loop contains all the same constructs we saw before: a phi node, "
"several expressions, and some basic blocks. Lets see how this fits "
"together."
msgstr ""

#: ../../tutorial/OCamlLangImpl5.rst:530
msgid "Code Generation for the 'for' Loop"
msgstr ""

#: ../../tutorial/OCamlLangImpl5.rst:532
msgid ""
"The first part of Codegen is very simple: we just output the start "
"expression for the loop value:"
msgstr ""

#: ../../tutorial/OCamlLangImpl5.rst:543
msgid ""
"With this out of the way, the next step is to set up the LLVM basic block"
" for the start of the loop body. In the case above, the whole loop body "
"is one block, but remember that the body code itself could consist of "
"multiple blocks (e.g. if it contains an if/then/else or a for/in "
"expression)."
msgstr ""

#: ../../tutorial/OCamlLangImpl5.rst:561
msgid ""
"This code is similar to what we saw for if/then/else. Because we will "
"need it to create the Phi node, we remember the block that falls through "
"into the loop. Once we have that, we create the actual block that starts "
"the loop and create an unconditional branch for the fall-through between "
"the two blocks."
msgstr ""

#: ../../tutorial/OCamlLangImpl5.rst:575
msgid ""
"Now that the \"preheader\" for the loop is set up, we switch to emitting "
"code for the loop body. To begin with, we move the insertion point and "
"create the PHI node for the loop induction variable. Since we already "
"know the incoming value for the starting value, we add it to the Phi "
"node. Note that the Phi will eventually get a second value for the "
"backedge, but we can't set it up yet (because it doesn't exist!)."
msgstr ""

#: ../../tutorial/OCamlLangImpl5.rst:597
msgid ""
"Now the code starts to get more interesting. Our 'for' loop introduces a "
"new variable to the symbol table. This means that our symbol table can "
"now contain either function arguments or loop variables. To handle this, "
"before we codegen the body of the loop, we add the loop variable as the "
"current value for its name. Note that it is possible that there is a "
"variable of the same name in the outer scope. It would be easy to make "
"this an error (emit an error and return null if there is already an entry"
" for VarName) but we choose to allow shadowing of variables. In order to "
"handle this correctly, we remember the Value that we are potentially "
"shadowing in ``old_val`` (which will be None if there is no shadowed "
"variable)."
msgstr ""

#: ../../tutorial/OCamlLangImpl5.rst:609
msgid ""
"Once the loop variable is set into the symbol table, the code recursively"
" codegen's the body. This allows the body to use the loop variable: any "
"references to it will naturally find it in the symbol table."
msgstr ""

#: ../../tutorial/OCamlLangImpl5.rst:626
msgid ""
"Now that the body is emitted, we compute the next value of the iteration "
"variable by adding the step value, or 1.0 if it isn't present. "
"'``next_var``' will be the value of the loop variable on the next "
"iteration of the loop."
msgstr ""

#: ../../tutorial/OCamlLangImpl5.rst:640
msgid ""
"Finally, we evaluate the exit value of the loop, to determine whether the"
" loop should exit. This mirrors the condition evaluation for the "
"if/then/else statement."
msgstr ""

#: ../../tutorial/OCamlLangImpl5.rst:656
msgid ""
"With the code for the body of the loop complete, we just need to finish "
"up the control flow for it. This code remembers the end block (for the "
"phi node), then creates the block for the loop exit (\"afterloop\"). "
"Based on the value of the exit condition, it creates a conditional branch"
" that chooses between executing the loop again and exiting the loop. Any "
"future code is emitted in the \"afterloop\" block, so it sets the "
"insertion position to it."
msgstr ""

#: ../../tutorial/OCamlLangImpl5.rst:678
msgid ""
"The final code handles various cleanups: now that we have the "
"\"``next_var``\" value, we can add the incoming value to the loop PHI "
"node. After that, we remove the loop variable from the symbol table, so "
"that it isn't in scope after the for loop. Finally, code generation of "
"the for loop always returns 0.0, so that is what we return from "
"``Codegen.codegen_expr``."
msgstr ""

#: ../../tutorial/OCamlLangImpl5.rst:685
msgid ""
"With this, we conclude the \"adding control flow to Kaleidoscope\" "
"chapter of the tutorial. In this chapter we added two control flow "
"constructs, and used them to motivate a couple of aspects of the LLVM IR "
"that are important for front-end implementors to know. In the next "
"chapter of our saga, we will get a bit crazier and add `user-defined "
"operators <OCamlLangImpl6.html>`_ to our poor innocent language."
msgstr ""

#: ../../tutorial/OCamlLangImpl5.rst:693
msgid "Full Code Listing"
msgstr ""

#: ../../tutorial/OCamlLangImpl5.rst:695
msgid ""
"Here is the complete code listing for our running example, enhanced with "
"the if/then/else and for expressions.. To build this example, use:"
msgstr ""

#: ../../tutorial/OCamlLangImpl5.rst:705
msgid "Here is the code:"
msgstr ""

#: ../../tutorial/OCamlLangImpl5.rst:713
msgid "\\_tags:"
msgstr ""

#: ../../tutorial/OCamlLangImpl5.rst:727
msgid "myocamlbuild.ml:"
msgstr ""

#: ../../tutorial/OCamlLangImpl5.rst:750
msgid "token.ml:"
msgstr ""

#: ../../tutorial/OCamlLangImpl5.rst:811
msgid "lexer.ml:"
msgstr ""

#: ../../tutorial/OCamlLangImpl5.rst:846
msgid "ast.ml:"
msgstr ""

#: ../../tutorial/OCamlLangImpl5.rst:1008
msgid "parser.ml:"
msgstr ""

#: ../../tutorial/OCamlLangImpl5.rst:1237
msgid "codegen.ml:"
msgstr ""

#: ../../tutorial/OCamlLangImpl5.rst:1290
msgid "toplevel.ml:"
msgstr ""

#: ../../tutorial/OCamlLangImpl5.rst:1347
msgid "toy.ml:"
msgstr ""

#: ../../tutorial/OCamlLangImpl5.rst:1358
msgid "bindings.c"
msgstr ""

#: ../../tutorial/OCamlLangImpl5.rst:1360
msgid ""
"`Next: Extending the language: user-defined operators "
"<OCamlLangImpl6.html>`_"
msgstr ""

