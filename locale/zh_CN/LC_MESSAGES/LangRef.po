# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2003-2016, LLVM Project
# This file is distributed under the same license as the LLVM package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2016.
#
msgid ""
msgstr ""
"Project-Id-Version: LLVM 3.8\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2016-04-17 11:36+0800\n"
"PO-Revision-Date: 2019-05-30 11:27-0700\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.3.3\n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: zh\n"
"X-Generator: Poedit 2.2.3\n"

#: ../../LangRef.rst:3
msgid "LLVM Language Reference Manual"
msgstr "LLVM 语法参考手册"

#: ../../LangRef.rst:10
msgid "Abstract"
msgstr "摘要"

#: ../../LangRef.rst:12
msgid "This document is a reference manual for the LLVM assembly language. LLVM is a Static Single Assignment (SSA) based representation that provides type safety, low-level operations, flexibility, and the capability of representing 'all' high-level languages cleanly. It is the common code representation used throughout all phases of the LLVM compilation strategy."
msgstr "这份文档是LLVM汇编语言的语法参考手册，LLVM汇编语言是一种静态单赋值（SSA）的中间代码表示，提供了类型安全检查，低层次的操作符，具有灵活和清晰表达‘几乎所有’高级语言的能力。同时，它也是LLVM编译后端优化中各个阶段的一种通用代码表达形式。"

#: ../../LangRef.rst:20
msgid "Introduction"
msgstr "简介"

#: ../../LangRef.rst:22
msgid ""
"The LLVM code representation is designed to be used in three different forms: as an in-memory compiler IR, as an on-disk bitcode representation (suitable for fast loading by a Just-In-Time compiler), and as a human readable assembly language representation. This allows LLVM to provide a powerful intermediate representation for efficient compiler transformations and analysis, while providing a natural means to debug and visualize the transformations. The three different forms of LLVM are all equivalent. This document describes the human readable representation and "
"notation."
msgstr "LLVM的中间代码表示被设计成用在以下三种不同的情况下：作为一种编译器内存中的中间代码（IR），作为一种保存在磁盘中的字节码形式（适合被JIT编译器快速装载），作为一种人类可读的汇编语言（译者注：编译器中的内存形式是一种指针链式的图结构，而磁盘中的字节码则是将这种图结构串行化存储后的结果，人类可读的即是类似汇编文件的格式）。这为LLVM编译器的高效转换和分析提供了一种强有力的中间表达形式，同时也提供了一种很自然的方法来调试和可视化分析编译后的代码。这三种不同的LLVM中间代码的形式是完全等价的，这份文档就在描述人类可读的形式和其所用到的符号。"

#: ../../LangRef.rst:32
msgid ""
"The LLVM representation aims to be light-weight and low-level while being expressive, typed, and extensible at the same time. It aims to be a \"universal IR\" of sorts, by being at a low enough level that high-level ideas may be cleanly mapped to it (similar to how microprocessors are \"universal IR's\", allowing many source languages to be mapped to them). By providing type information, LLVM can be used as the target of optimizations: for example, through pointer analysis, it can be proven that a C automatic variable is never accessed outside of the current function, "
"allowing it to be promoted to a simple SSA value instead of a memory location."
msgstr "LLVM中间字节码表示的目标是，成为一种轻量级和低层次的，同时有表现力的、类型化的并且可扩展的中间语言，更要成为一种 “通用中间表示（IR）”，并且是足够低层次的，这样才能让高层次的语言设计能够清晰地映射到这种中间表示上（就像微处理器指令——机器码，也可以看做是一种中间表示，允许源代码映射到它们上）。通过提供类型信息，LLVM可以被用在后端优化过程上。例如：通过指针分析，如果可以证明某个C++语言中的自动变量是从没存取过函数外的外部变量的，这时这个变量就可以用一个简单的SSA变量来替代（用寄存器替代一个内存地址）。"

#: ../../LangRef.rst:46
msgid "Well-Formedness"
msgstr "良好的结构"

#: ../../LangRef.rst:48
msgid "It is important to note that this document describes 'well formed' LLVM assembly language. There is a difference between what the parser accepts and what is considered 'well formed'. For example, the following instruction is syntactically okay, but not well formed:"
msgstr "要强调的一点是，这份文档描述的是一种“良好结构的”LLVM汇编语言。解析器接受的和我们认为的“良好格式化的”稍有不同。（译者注：良好结构其实就是静态单赋值，SSA格式）例如，下面的指令在语法构成上是合理的，但结构却并不是良好的："

#: ../../LangRef.rst:57
#, python-format
msgid "because the definition of ``%x`` does not dominate all of its uses. The LLVM infrastructure provides a verification pass that may be used to verify that an LLVM module is well formed. This pass is automatically run by the parser after parsing input assembly and by the optimizer before it outputs bitcode. The violations pointed out by the verifier pass indicate bugs in transformation passes or input to the parser."
msgstr "因为 ``%x`` 的定义并没有在其全部用到的位置，独占同一个含义。LLVM 基础设施提供了一个校验Pass，可以用来检验一个LLVM模块是否是“良好结构的”。这一过程会在解析器解析输入的汇编指令后，以及优化器输出字节码前自动运行。并且被验证过程标出违反的地方会在转换过程或输入到解析器时报错。"

#: ../../LangRef.rst:67
msgid "Identifiers"
msgstr "标识符"

#: ../../LangRef.rst:69
msgid "LLVM identifiers come in two basic types: global and local. Global identifiers (functions, global variables) begin with the ``'@'`` character. Local identifiers (register names, types) begin with the ``'%'`` character. Additionally, there are three different formats for identifiers, for different purposes:"
msgstr "LLVM的标识符可以分为两大类：全局标识符和局部标识符。全局标识符（例如函数、全局变量）会以 ``‘@’`` 开始，而本地标识符（例如寄存器名、类型名）会以 ``‘%’`` 开始。进一步说，对于不同的目标，有三种不同的标识符格式："

#: ../../LangRef.rst:75
#, python-format
msgid ""
"Named values are represented as a string of characters with their prefix. For example, ``%foo``, ``@DivisionByZero``, ``%a.really.long.identifier``. The actual regular expression used is '``[%@][-a-zA-Z$._][-a-zA-Z$._0-9]*``'. Identifiers that require other characters in their names can be surrounded with quotes. Special characters may be escaped using ``\"\\xx\"`` where ``xx`` is the ASCII code for the character in hexadecimal. In this way, any character can be used in a name value, even quotes themselves. The ``\"\\01\"`` prefix can be used on global variables to "
"suppress mangling."
msgstr "带有特殊字符前缀的字符串代表了命名值。例如 ``%foo``, ``@DivisionByZero``, ``%a.really.long.identifier``。而实际的用正则表达式可表示为‘ ``[%@][-a-zA-Z$._][-a-zA-Z$._0-9]*`` ’。在标识符中需要用其他正则式中以外的字符时，可以用引号引起来表示。特殊字符可以使用转义符转义，如 ``\"\\xx\"`` ，xx是其对应的十六进制ASCII码。用这种方法，全部字符都可以被用于名称变量，即使是引号本身。 ``\"\\01\"`` 前缀可以被用在全局变量上，来防止名称改写。"

#: ../../LangRef.rst:84
msgid "Unnamed values are represented as an unsigned numeric value with their prefix. For example, ``%12``, ``@2``, ``%44``."
msgstr "带有特殊前缀的无符号整数表示一个未命名的变量。例如 ``%12``, ``@2``, ``%44`` 。"

#: ../../LangRef.rst:86
msgid "Constants, which are described in the section Constants_ below."
msgstr "常量的表示，会在下面的 Constants_ 一节提到。"

#: ../../LangRef.rst:88
msgid "LLVM requires that values start with a prefix for two reasons: Compilers don't need to worry about name clashes with reserved words, and the set of reserved words may be expanded in the future without penalty. Additionally, unnamed identifiers allow a compiler to quickly come up with a temporary variable without having to avoid symbol table conflicts."
msgstr "LLVM需要带有特殊前缀的变量有两个原因：编译器不需要担心名称和保留字冲突，并且保留字集可以在日后安全地扩展。此外，未命名的标识符允许编译器快速找到一个临时变量而无需担心去防止符号表冲突。"

#: ../../LangRef.rst:95
msgid "Reserved words in LLVM are very similar to reserved words in other languages. There are keywords for different opcodes ('``add``', '``bitcast``', '``ret``', etc...), for primitive type names ('``void``', '``i32``', etc...), and others. These reserved words cannot conflict with variable names, because none of them start with a prefix character (``'%'`` or ``'@'``)."
msgstr "LLVM中的保留字和其他语言中保留字非常相似。有对不同的操作码的关键字 （例如 '``add``', '``bitcast``', '``ret``' 等 ）、基本类型名 （如 '``void``', '``i32``' 等）。这些保留字不会和变量名冲突，由于他们没有一个是以特殊字符开头的（ ``'%'`` 或 ``'@'`` ）。"

#: ../../LangRef.rst:102
#, python-format
msgid "Here is an example of LLVM code to multiply the integer variable '``%X``' by 8:"
msgstr "这里是一个LLVM字节码示例，给整数变量 '``%X``' 乘8:"

#: ../../LangRef.rst:105
msgid "The easy way:"
msgstr "最简单的方式："

#: ../../LangRef.rst:111
msgid "After strength reduction:"
msgstr "强度折减法(strength reduction):"

#: ../../LangRef.rst:117
msgid "And the hard way:"
msgstr "以及复杂的方式："

#: ../../LangRef.rst:125
#, python-format
msgid "This last way of multiplying ``%X`` by 8 illustrates several important lexical features of LLVM:"
msgstr "最后一种对 ``%X`` 乘8的方式展示了几个重要的LLVM词法特性:"

#: ../../LangRef.rst:128
msgid "Comments are delimited with a '``;``' and go until the end of line."
msgstr "注释用 '``;``' 分隔，直到行尾。"

#: ../../LangRef.rst:129
msgid "Unnamed temporaries are created when the result of a computation is not assigned to a named value."
msgstr "如果计算结果未赋值给一个带有名字的变量，则会创建一个未命名的临时变量。"

#: ../../LangRef.rst:131
msgid "Unnamed temporaries are numbered sequentially (using a per-function incrementing counter, starting with 0). Note that basic blocks and unnamed function parameters are included in this numbering. For example, if the entry basic block is not given a label name and all function parameters are named, then it will get number 0."
msgstr "未命名的临时变量会按顺序编号（每个函数有一个递增计数器，从0开始）。请注意，此编号中也会分配给基本块（Basic Block）和未命名的函数参数。如果没有为入口基本块（Entry Basic Block）指定名称并且所有函数参数也都已命名，那么它将获得数字0。"

#: ../../LangRef.rst:137
msgid "It also shows a convention that we follow in this document. When demonstrating instructions, we will follow an instruction with a comment that defines the type and name of value produced."
msgstr "它还显示了我们在本文档中遵循的约定。在接下来展示LLVM指令时，我们将为每条指令写一句注释，该注释定义了所生成的值的类型和名称。"

#: ../../LangRef.rst:142
msgid "High Level Structure"
msgstr "高层次结构"

#: ../../LangRef.rst:145
msgid "Module Structure"
msgstr "模块结构"

#: ../../LangRef.rst:147
msgid "LLVM programs are composed of ``Module``'s, each of which is a translation unit of the input programs. Each module consists of functions, global variables, and symbol table entries. Modules may be combined together with the LLVM linker, which merges function (and global variable) definitions, resolves forward declarations, and merges symbol table entries. Here is an example of the \"hello world\" module:"
msgstr "LLVM程序由 ``Module`` 组成，每个都是输入程序的翻译单元。每个模块由函数，全局变量和符号表条目组成。模块可以与LLVM链接器组合在一起，LLVM链接器合并函数（和全局变量）定义，解析前向声明，并合并符号表条目。以下是“hello world“模块的示例："

#: ../../LangRef.rst:176
msgid "This example is made up of a :ref:`global variable <globalvars>` named \"``.str``\", an external declaration of the \"``puts``\" function, a :ref:`function definition <functionstructure>` for \"``main``\" and :ref:`named metadata <namedmetadatastructure>` \"``foo``\"."
msgstr "这个例子包含一个叫做 \"``.str``\" 的 :ref:`global variable <globalvars>` ，一个外部声明的 \"``puts``\" 函数， \"``main``\" 函数的 :ref:`function definition <functionstructure>` 和命名为 \"``foo``\" 的 :ref: `named metadata <namedmetadatastructure>` 。"

#: ../../LangRef.rst:181
msgid "In general, a module is made up of a list of global values (where both functions and global variables are global values). Global values are represented by a pointer to a memory location (in this case, a pointer to an array of char, and a pointer to a function), and have one of the following :ref:`linkage types <linkage>`."
msgstr "通常，模块由全局值列表组成（其中函数和全局变量都是全局值）。全局值由指向内存位置的指针（在本例中为指向char数组的指针和指向函数的指针）表示，并具有以下之一 :ref:`linkage types <linkage>` 。"

#: ../../LangRef.rst:190
msgid "Linkage Types"
msgstr "链接类型"

#: ../../LangRef.rst:192
msgid "All Global Variables and Functions have one of the following types of linkage:"
msgstr "全部的全局变量和函数都有下面任一链接类型："

#: ../../LangRef.rst:200
msgid "``private``"
msgstr ""

#: ../../LangRef.rst:196
#, fuzzy
msgid "Global values with \"``private``\" linkage are only directly accessible by objects in the current module. In particular, linking code into a module with an private global value may cause the private to be renamed as necessary to avoid collisions. Because the symbol is private to the module, all references can be updated. This doesn't show up in any symbol table in the object file."
msgstr "具有 \"``private``\" 链接符号的全局变量只能由当前模块中的对象直接访问。特别是，将代码链接到具有私有全局值的模块可能会导致私有被重命名以避免冲突。由于该符号是模块专用的，因此可以更新所有引用。这不会显示在目标文件的任何符号表中。"

#: ../../LangRef.rst:204
msgid "``internal``"
msgstr ""

#: ../../LangRef.rst:203
msgid "Similar to private, but the value shows as a local symbol (``STB_LOCAL`` in the case of ELF) in the object file. This corresponds to the notion of the '``static``' keyword in C."
msgstr "与private类似，但该值在对象文件中显示为本地符号（在ELF的情况下为``STB_LOCAL``）。这对应于C中'``static``'关键字的概念。"

#: ../../LangRef.rst:214
msgid "``available_externally``"
msgstr ""

#: ../../LangRef.rst:207
msgid ""
"Globals with \"``available_externally``\" linkage are never emitted into the object file corresponding to the LLVM module. From the linker's perspective, an ``available_externally`` global is equivalent to an external declaration. They exist to allow inlining and other optimizations to take place given knowledge of the definition of the global, which is known to be somewhere outside the module. Globals with ``available_externally`` linkage are allowed to be discarded at will, and allow inlining and other optimizations. This linkage type is only allowed on definitions, "
"not declarations."
msgstr "具有\\“``available_externally`` \\”链接的全局变量永远不会发送到与LLVM模块对应的目标文件中。从链接器的角度来看，``available_externally``全局等同于外部声明。它们的存在允许在知道全局定义的情况下进行内联和其他优化，已知该定义位于模块之外的某个位置。具有``available_externally``链接的全局变量允许随意丢弃，并允许内联和其他优化。此链接类型仅允许定义，而不是声明。"

#: ../../LangRef.rst:227
msgid "``linkonce``"
msgstr ""

#: ../../LangRef.rst:217
msgid ""
"Globals with \"``linkonce``\" linkage are merged with other globals of the same name when linkage occurs. This can be used to implement some forms of inline functions, templates, or other code which must be generated in each translation unit that uses it, but where the body may be overridden with a more definitive definition later. Unreferenced ``linkonce`` globals are allowed to be discarded. Note that ``linkonce`` linkage does not actually allow the optimizer to inline the body of this function into callers because it doesn't know if this definition of the function "
"is the definitive definition within the program or whether it will be overridden by a stronger definition. To enable inlining and other optimizations, use \"``linkonce_odr``\" linkage."
msgstr "当链接发生时，具有\\“``linkonce`` \\”链接的全局变量与其他同名的全局变量合并。这可以用于实现某些形式的内联函数，模板或其他代码，这些代码必须在使用它的每个翻译单元中生成，但是稍后可以用更明确的定义覆盖正文。允许丢弃未引用的``linkonce``全局变量。请注意，``linkonce``链接实际上不允许优化器将此函数的主体内联到调用者中，因为它不知道函数的这个定义是否是程序中的确定定义，或者它是否会被a覆盖更强的定义。要启用内联和其他优化，请使用\\“``linkonce_odr`` \\”链接。"

#: ../../LangRef.rst:232
msgid "``weak``"
msgstr ""

#: ../../LangRef.rst:230
msgid "\"``weak``\" linkage has the same merging semantics as ``linkonce`` linkage, except that unreferenced globals with ``weak`` linkage may not be discarded. This is used for globals that are declared \"weak\" in C source code."
msgstr "\\```weak`` \\“链接具有与``linkonce``链接相同的合并语义，除了没有丢弃带有``weak``链接的未引用的全局变量。这用于在C源代码中声明为“弱”的全局变量。"

#: ../../LangRef.rst:242
msgid "``common``"
msgstr ""

#: ../../LangRef.rst:235
msgid "\"``common``\" linkage is most similar to \"``weak``\" linkage, but they are used for tentative definitions in C, such as \"``int X;``\" at global scope. Symbols with \"``common``\" linkage are merged in the same way as ``weak symbols``, and they may not be deleted if unreferenced. ``common`` symbols may not have an explicit section, must have a zero initializer, and may not be marked ':ref:`constant <globalvars>`'. Functions and aliases may not have common linkage."
msgstr "\\```common`` \\“链接最类似于```weak`` \\”链接，但它们用于C中的暂定定义，例如\\“``int X;``\\”at global范围。带有“`common`` \\”链接的符号以与“弱符号”相同的方式合并，如果未引用则不能删除它们。 ``common``符号可能没有明确的部分，必须有一个零初始值，并且可能没有标记'：ref：`constant <globalvars>`'。函数和别名可能没有共同的链接。"

#: ../../LangRef.rst:251
msgid "``appending``"
msgstr ""

#: ../../LangRef.rst:247
msgid "\"``appending``\" linkage may only be applied to global variables of pointer to array type. When two global variables with appending linkage are linked together, the two global arrays are appended together. This is the LLVM, typesafe, equivalent of having the system linker append together \"sections\" with identical names when .o files are linked."
msgstr "\\```appending`` \\“链接可能只适用于指向数组类型的指针的全局变量。当两个具有附加链接的全局变量链接在一起时，两个全局数组将附加在一起。这是LLVM，类型安全，相当于当.o文件链接时，系统链接器将“sections”与相同的名称附加在一起。"

#: ../../LangRef.rst:255
msgid "``extern_weak``"
msgstr ""

#: ../../LangRef.rst:254
msgid "The semantics of this linkage follow the ELF object file model: the symbol is weak until linked, if not linked, the symbol becomes null instead of being an undefined reference."
msgstr "此链接的语义遵循ELF目标文件模型：符号在链接之前是弱的，如果没有链接，则符号变为空而不是未定义的引用。"

#: ../../LangRef.rst:263
msgid "``linkonce_odr``, ``weak_odr``"
msgstr ""

#: ../../LangRef.rst:258
msgid "Some languages allow differing globals to be merged, such as two functions with different semantics. Other languages, such as ``C++``, ensure that only equivalent globals are ever merged (the \"one definition rule\" --- \"ODR\"). Such languages can use the ``linkonce_odr`` and ``weak_odr`` linkage types to indicate that the global will only be merged with equivalent globals. These linkage types are otherwise the same as their non-``odr`` versions."
msgstr "有些语言允许合并不同的全局变量，例如具有不同语义的两个函数。其他语言，例如``C ++``，确保只合并等效的全局变量（“一个定义规则”---“ODR”）。这些语言可以使用``linkonce_odr``和``weak_odr``链接类型来指示全局只会与等效的全局变量合并。这些链接类型与其非``````版本相同。"

#: ../../LangRef.rst:268
msgid "``external``"
msgstr ""

#: ../../LangRef.rst:266
msgid "If none of the above identifiers are used, the global is externally visible, meaning that it participates in linkage and can be used to resolve external symbol references."
msgstr "如果没有使用上述标识符，则全局在外部可见，这意味着它参与链接并可用于解析外部符号引用。"

#: ../../LangRef.rst:270
msgid "It is illegal for a function *declaration* to have any linkage type other than ``external`` or ``extern_weak``."
msgstr "函数*声明*除了``external``或``extern_weak``之外还有任何链接类型是非法的。"

#: ../../LangRef.rst:276
msgid "Calling Conventions"
msgstr "调用约定"

#: ../../LangRef.rst:278
msgid "LLVM :ref:`functions <functionstructure>`, :ref:`calls <i_call>` and :ref:`invokes <i_invoke>` can all have an optional calling convention specified for the call. The calling convention of any pair of dynamic caller/callee must match, or the behavior of the program is undefined. The following calling conventions are supported by LLVM, and more may be added in the future:"
msgstr "LLVM：ref：`functions <functions structure>`，：ref：`calls <i_call>`和：ref：`invokes <i_invoke>`都可以为调用指定一个可选的调用约定。任何一对动态调用者/被调用者的调用约定必须匹配，否则程序的行为是未定义的。 LLVM支持以下调用约定，将来可能会添加更多调用约定："

#: ../../LangRef.rst:289
msgid "\"``ccc``\" - The C calling convention"
msgstr "\"``ccc``\" - C调用约定(C calling convention)"

#: ../../LangRef.rst:286
msgid "This calling convention (the default if no other calling convention is specified) matches the target C calling conventions. This calling convention supports varargs function calls and tolerates some mismatch in the declared prototype and implemented declaration of the function (as does normal C)."
msgstr "此调用约定（如果未指定其他调用约定，则为缺省值）与目标C调用约定匹配。这个调用约定支持varargs函数调用，并容忍声明的原型中的一些不匹配并实现函数的声明（正常C）。"

#: ../../LangRef.rst:299
msgid "\"``fastcc``\" - The fast calling convention"
msgstr "\"``fastcc``\" - 快速调用约定(Fast calling convention)"

#: ../../LangRef.rst:292
msgid "This calling convention attempts to make calls as fast as possible (e.g. by passing things in registers). This calling convention allows the target to use whatever tricks it wants to produce fast code for the target, without having to conform to an externally specified ABI (Application Binary Interface). `Tail calls can only be optimized when this, the GHC or the HiPE convention is used. <CodeGenerator.html#id80>`_ This calling convention does not support varargs and requires the prototype of all callees to exactly match the prototype of the function definition."
msgstr "此调用约定尝试尽可能快地进行调用（例如，通过寄存器中的事物）。此调用约定允许目标使用它想要为目标生成快速代码的任何技巧，而不必遵循外部指定的ABI（应用程序二进制接口）。 `尾调用只能在使用GHC或HiPE约定时进行优化。 <CodeGenerator.html＃id80>`_此调用约定不支持varargs，并要求所有callees的原型与函数定义的原型完全匹配。"

#: ../../LangRef.rst:308
msgid "\"``coldcc``\" - The cold calling convention"
msgstr "\"``coldcc``\" - 冷调用约定（Cold calling convention）"

#: ../../LangRef.rst:302
msgid "This calling convention attempts to make code in the caller as efficient as possible under the assumption that the call is not commonly executed. As such, these calls often preserve all registers so that the call does not break any live ranges in the caller side. This calling convention does not support varargs and requires the prototype of all callees to exactly match the prototype of the function definition. Furthermore the inliner doesn't consider such function calls for inlining."
msgstr "该调用约定试图在调用未被普遍执行的假设下使调用者中的代码尽可能高效。因此，这些调用通常会保留所有寄存器，以便调用不会破坏调用方的任何有效范围。此调用约定不支持varargs，并要求所有callees的原型与函数定义的原型完全匹配。此外，内联器不考虑内联的此类函数调用。"

#: ../../LangRef.rst:327
msgid "\"``cc 10``\" - GHC convention"
msgstr "\"``cc 10``\" - GHC编译器调用约定"

#: ../../LangRef.rst:311
msgid "This calling convention has been implemented specifically for use by the `Glasgow Haskell Compiler (GHC) <http://www.haskell.org/ghc>`_. It passes everything in registers, going to extremes to achieve this by disabling callee save registers. This calling convention should not be used lightly but only for specific situations such as an alternative to the *register pinning* performance technique often used when implementing functional programming languages. At the moment only X86 supports this convention and it has the following limitations:"
msgstr "这个调用约定已经专门用于 `Glasgow Haskell编译器（GHC）<http://www.haskell.org/ghc>`_ 。它通过寄存器传递所有内容，通过禁用被调用者保存寄存器来达到极限。不应轻易使用此调用约定，但仅适用于特定情况，例如在实现函数式编程语言时经常使用的 *寄存器固定* 性能技术的替代方法。目前只有X86支持此约定，它具有以下限制："

#: ../../LangRef.rst:321
msgid "On *X86-32* only supports up to 4 bit type parameters. No floating point types are supported."
msgstr "对于 *X86-32* 仅支持最多4bit类型参数。不支持任何浮点类型。"

#: ../../LangRef.rst:323
msgid "On *X86-64* only supports up to 10 bit type parameters and 6 floating point parameters."
msgstr "对于 * X86-64 * 仅支持最多10bit类型参数和6个浮点参数。"

#: ../../LangRef.rst:326
msgid "This calling convention supports `tail call optimization <CodeGenerator.html#id80>`_ but requires both the caller and callee are using it."
msgstr "这个调用约定支持 `尾调用优化 <CodeGenerator.html#id80>`_ 但是要求调用者和被调用者都使用它。"

#: ../../LangRef.rst:342
msgid "\"``cc 11``\" - The HiPE calling convention"
msgstr "\"``cc 11``\" - HiPE调用约定"

#: ../../LangRef.rst:330
msgid ""
"This calling convention has been implemented specifically for use by the `High-Performance Erlang (HiPE) <http://www.it.uu.se/research/group/hipe/>`_ compiler, *the* native code compiler of the `Ericsson's Open Source Erlang/OTP system <http://www.erlang.org/download.shtml>`_. It uses more registers for argument passing than the ordinary C calling convention and defines no callee-saved registers. The calling convention properly supports `tail call optimization <CodeGenerator.html#id80>`_ but requires that both the caller and the callee use it. It uses a *register "
"pinning* mechanism, similar to GHC's convention, for keeping frequently accessed runtime components pinned to specific hardware registers. At the moment only X86 supports this convention (both 32 and 64 bit)."
msgstr "这个调用约定已经专门用于 `高性能Erlang（HiPE）<http://www.it.uu.se/research/group/hipe/>`_ 编译器，本机代码编译器 `Ericsson's Open Source Erlang/OTP system <http://www.erlang.org/download.shtml>`_ 。它使用了比普通C调用约定更多的寄存器来传递参数，并且没有定义被调用者保存的寄存器。调用约定正确支持`尾调用优化<CodeGenerator.html＃id80>`_但要求调用者和被调用者都使用它。它使用 *寄存器固定* 机制，类似于GHC的惯例，用于将经常访问的运行时组件固定到特定的硬件寄存器。目前只有X86支持这种约定（32位和64位）。"

#: ../../LangRef.rst:347
msgid "\"``webkit_jscc``\" - WebKit's JavaScript calling convention"
msgstr "\\“``webkit_jscc`` \\” -  WebKit的JavaScript调用约定"

#: ../../LangRef.rst:345
msgid "This calling convention has been implemented for `WebKit FTL JIT <https://trac.webkit.org/wiki/FTLJIT>`_. It passes arguments on the stack right to left (as cdecl does), and returns a value in the platform's customary return register."
msgstr "这个调用约定已经实现了`WebKit FTL JIT <https://trac.webkit.org/wiki/FTLJIT>`_。它从右到左传递堆栈中的参数（如cdecl所做），并在平台的惯用返回寄存器中返回一个值。"

#: ../../LangRef.rst:354
msgid "\"``anyregcc``\" - Dynamic calling convention for code patching"
msgstr "\\```anyregcc`` \\“ - 代码修补的动态调用约定"

#: ../../LangRef.rst:350
msgid "This is a special convention that supports patching an arbitrary code sequence in place of a call site. This convention forces the call arguments into registers but allows them to be dynamically allocated. This can currently only be used with calls to llvm.experimental.patchpoint because only this intrinsic records the location of its arguments in a side table. See :doc:`StackMaps`."
msgstr "这是一个特殊的约定，它支持修补任意代码序列来代替调用站点。此约定将调用参数强制转换为寄存器，但允许它们动态分配。这当前只能用于调用llvm.experimental.patchpoint，因为只有这个内部函数在边表中记录其参数的位置。请参阅：doc：`StackMaps`。"

#: ../../LangRef.rst:387
msgid "\"``preserve_mostcc``\" - The `PreserveMost` calling convention"
msgstr "\\```preserve_mostcc`` \\“ - `PreserveMost`调用约定"

#: ../../LangRef.rst:357
msgid "This calling convention attempts to make the code in the caller as unintrusive as possible. This convention behaves identically to the `C` calling convention on how arguments and return values are passed, but it uses a different set of caller/callee-saved registers. This alleviates the burden of saving and recovering a large register set before and after the call in the caller. If the arguments are passed in callee-saved registers, then they will be preserved by the callee across the call. This doesn't apply for values returned in callee-saved registers."
msgstr "此调用约定尝试使调用者中的代码尽可能不引人注目。这个约定的行为与关于如何传递参数和返回值的`C`调用约定相同，但它使用一组不同的调用者/被调用者保存的寄存器。这减轻了在呼叫者呼叫之前和之后保存和恢复大寄存器组的负担。如果参数在被调用者保存的寄存器中传递，则调用者将在整个调用中保留它们。这不适用于被调用者保存的寄存器中返回的值。"

#: ../../LangRef.rst:366
msgid "On X86-64 the callee preserves all general purpose registers, except for R11. R11 can be used as a scratch register. Floating-point registers (XMMs/YMMs) are not preserved and need to be saved by the caller."
msgstr "在X86-64上，被调用者保留所有通用寄存器，R11除外。 R11可用作临时寄存器。浮点寄存器（XMM / YMM）不会被保留，需要由调用者保存。"

#: ../../LangRef.rst:370
msgid ""
"The idea behind this convention is to support calls to runtime functions that have a hot path and a cold path. The hot path is usually a small piece of code that doesn't use many registers. The cold path might need to call out to another function and therefore only needs to preserve the caller-saved registers, which haven't already been saved by the caller. The `PreserveMost` calling convention is very similar to the `cold` calling convention in terms of caller/callee-saved registers, but they are used for different types of function calls. `coldcc` is for function "
"calls that are rarely executed, whereas `preserve_mostcc` function calls are intended to be on the hot path and definitely executed a lot. Furthermore `preserve_mostcc` doesn't prevent the inliner from inlining the function call."
msgstr "此约定背后的想法是支持对具有热路径和冷路径的运行时函数的调用。热路径通常是一小段代码，不使用许多寄存器。冷路径可能需要调用另一个函数，因此只需要保留调用者保存的寄存器，这些寄存器尚未被调用者保存。在调用者/被调用者保存的寄存器方面，`PreserveMost`调用约定非常类似于`cold`调用约定，但它们用于不同类型的函数调用。 `coldcc`用于很少执行的函数调用，而`preserve_mostcc`函数调用则用于热路径并且肯定执行很多。此外，`preserve_mostcc`不会阻止内联器内联函数调用。"

#: ../../LangRef.rst:382
msgid "This calling convention will be used by a future version of the ObjectiveC runtime and should therefore still be considered experimental at this time. Although this convention was created to optimize certain runtime calls to the ObjectiveC runtime, it is not limited to this runtime and might be used by other runtimes in the future too. The current implementation only supports X86-64, but the intention is to support more architectures in the future."
msgstr "此调用约定将由ObjectiveC运行时的未来版本使用，因此此时仍应被视为实验。尽管创建此约定是为了优化对ObjectiveC运行时的某些运行时调用，但它不仅限于此运行时，并且将来也可能被其他运行时使用。当前的实现仅支持X86-64，但目的是在未来支持更多的体系结构。"

#: ../../LangRef.rst:408
msgid "\"``preserve_allcc``\" - The `PreserveAll` calling convention"
msgstr "\\```preserve_allcc`` \\“ - 'PreserveAll`调用约定"

#: ../../LangRef.rst:390
msgid ""
"This calling convention attempts to make the code in the caller even less intrusive than the `PreserveMost` calling convention. This calling convention also behaves identical to the `C` calling convention on how arguments and return values are passed, but it uses a different set of caller/callee-saved registers. This removes the burden of saving and recovering a large register set before and after the call in the caller. If the arguments are passed in callee-saved registers, then they will be preserved by the callee across the call. This doesn't apply for values "
"returned in callee-saved registers."
msgstr "这种调用约定试图使调用者中的代码比`PreserveMost`调用约定更少侵入。这个调用约定的行为与关于如何传递参数和返回值的`C`调用约定相同，但它使用一组不同的调用者/被调用者保存的寄存器。这消除了在调用者中调用之前和之后保存和恢复大型寄存器集的负担。如果参数在被调用者保存的寄存器中传递，则调用者将在整个调用中保留它们。这不适用于被调用者保存的寄存器中返回的值。"

#: ../../LangRef.rst:400
msgid "On X86-64 the callee preserves all general purpose registers, except for R11. R11 can be used as a scratch register. Furthermore it also preserves all floating-point registers (XMMs/YMMs)."
msgstr "在X86-64上，被调用者保留所有通用寄存器，R11除外。 R11可用作临时寄存器。此外，它还保留所有浮点寄存器（XMM / YMM）。"

#: ../../LangRef.rst:404
msgid "The idea behind this convention is to support calls to runtime functions that don't need to call out to any other functions."
msgstr "此约定背后的想法是支持对不需要调用任何其他函数的运行时函数的调用。"

#: ../../LangRef.rst:407
msgid "This calling convention, like the `PreserveMost` calling convention, will be used by a future version of the ObjectiveC runtime and should be considered experimental at this time."
msgstr "这个调用约定，就像`PreserveMost`调用约定一样，将由ObjectiveC运行时的未来版本使用，此时应该被认为是实验性的。"

#: ../../LangRef.rst:428
msgid "\"``cxx_fast_tlscc``\" - The `CXX_FAST_TLS` calling convention for access functions"
msgstr "\\“``cxx_fast_tlscc`` \\” - 访问函数的`CXX_FAST_TLS`调用约定"

#: ../../LangRef.rst:411
msgid "Clang generates an access function to access C++-style TLS. The access function generally has an entry block, an exit block and an initialization block that is run at the first time. The entry and exit blocks can access a few TLS IR variables, each access will be lowered to a platform-specific sequence."
msgstr "Clang生成一个访问函数来访问C ++风格的TLS。访问功能通常具有入口块，出口块和第一次运行的初始化块。进入和退出块可以访问一些TLS IR变量，每个访问将降低到特定于平台的序列。"

#: ../../LangRef.rst:417
msgid "This calling convention aims to minimize overhead in the caller by preserving as many registers as possible (all the registers that are perserved on the fast path, composed of the entry and exit blocks)."
msgstr "该调用约定旨在通过保留尽可能多的寄存器来最小化调用者的开销（所有在快速路径上保持的寄存器，由进入和退出块组成）。"

#: ../../LangRef.rst:421
msgid "This calling convention behaves identical to the `C` calling convention on how arguments and return values are passed, but it uses a different set of caller/callee-saved registers."
msgstr "这个调用约定的行为与关于如何传递参数和返回值的`C`调用约定相同，但它使用一组不同的调用者/被调用者保存的寄存器。"

#: ../../LangRef.rst:425
msgid "Given that each platform has its own lowering sequence, hence its own set of preserved registers, we can't use the existing `PreserveMost`."
msgstr "鉴于每个平台都有自己的降序，因此它自己的保留寄存器集，我们不能使用现有的`PreserveMost`。"

#: ../../LangRef.rst:428
msgid "On X86-64 the callee preserves all general purpose registers, except for RDI and RAX."
msgstr "在X86-64上，被调用者保留所有通用寄存器，RDI和RAX除外。"

#: ../../LangRef.rst:433
msgid "\"``cc <n>``\" - Numbered convention"
msgstr "\\```cc <n>``\\“ - 编号惯例"

#: ../../LangRef.rst:431
msgid "Any calling convention may be specified by number, allowing target-specific calling conventions to be used. Target specific calling conventions start at 64."
msgstr "任何调用约定都可以通过数字指定，允许使用特定于目标的调用约定。目标特定的调用约定从64开始。"

#: ../../LangRef.rst:435
msgid "More calling conventions can be added/defined on an as-needed basis, to support Pascal conventions or any other well-known target-independent convention."
msgstr "可以根据需要添加/定义更多调用约定，以支持Pascal约定或任何其他众所周知的与目标无关的约定。"

#: ../../LangRef.rst:442
msgid "Visibility Styles"
msgstr "符号可见性"

#: ../../LangRef.rst:444
msgid "All Global Variables and Functions have one of the following visibility styles:"
msgstr "任何全局变量和函数都有任一下面的可见性类型："

#: ../../LangRef.rst:452
msgid "\"``default``\" - Default style"
msgstr "\"``default``\" - 默认类型"

#: ../../LangRef.rst:448
msgid "On targets that use the ELF object file format, default visibility means that the declaration is visible to other modules and, in shared libraries, means that the declared entity may be overridden. On Darwin, default visibility means that the declaration is visible to other modules. Default visibility corresponds to \"external linkage\" in the language."
msgstr "在使用ELF目标文件格式的目标上，默认可见性意味着该声明对其他模块可见，并且在共享库中，意味着可以覆盖声明的实体。在Darwin上，默认可见性意味着声明对其他模块可见。默认可见性对应于语言中的“外部链接”。"

#: ../../LangRef.rst:458
msgid "\"``hidden``\" - Hidden style"
msgstr "\"``hidden``\" - 隐藏类型"

#: ../../LangRef.rst:455
msgid "Two declarations of an object with hidden visibility refer to the same object if they are in the same shared object. Usually, hidden visibility indicates that the symbol will not be placed into the dynamic symbol table, so no other module (executable or shared library) can reference it directly."
msgstr "具有隐藏可见性的对象的两个声明如果它们位于同一共享对象中，则引用相同的对象。通常，隐藏的可见性表示该符号不会放入动态符号表中，因此其他模块（可执行文件或共享库）不能直接引用它。"

#: ../../LangRef.rst:464
msgid "\"``protected``\" - Protected style"
msgstr "\"``protected``\" - 保护类型"

#: ../../LangRef.rst:461
msgid "On ELF, protected visibility indicates that the symbol will be placed in the dynamic symbol table, but that references within the defining module will bind to the local symbol. That is, the symbol cannot be overridden by another module."
msgstr "在ELF上，受保护的可见性表示符号将放置在动态符号表中，但定义模块中的引用将绑定到本地符号。也就是说，该符号不能被另一个模块覆盖。"

#: ../../LangRef.rst:466
msgid "A symbol with ``internal`` or ``private`` linkage must have ``default`` visibility."
msgstr "带有``internal``或``private``链接的符号必须具有``default``可见性。"

#: ../../LangRef.rst:472
msgid "DLL Storage Classes"
msgstr "DLL存储类"

#: ../../LangRef.rst:474
msgid "All Global Variables, Functions and Aliases can have one of the following DLL storage class:"
msgstr "所有全局变量，函数和别名都可以具有以下DLL存储类之一："

#: ../../LangRef.rst:480
msgid "``dllimport``"
msgstr "``dllimport``"

#: ../../LangRef.rst:478
msgid "\"``dllimport``\" causes the compiler to reference a function or variable via a global pointer to a pointer that is set up by the DLL exporting the symbol. On Microsoft Windows targets, the pointer name is formed by combining ``__imp_`` and the function or variable name."
msgstr "\\```dllimport`` \\“使编译器通过指向导出符号的DLL设置的指针的全局指针来引用函数或变量。在Microsoft Windows目标上，指针名称是通过组合“__imp_`”和函数或变量名来形成的。"

#: ../../LangRef.rst:488
msgid "``dllexport``"
msgstr "``dllexport``"

#: ../../LangRef.rst:483
msgid "\"``dllexport``\" causes the compiler to provide a global pointer to a pointer in a DLL, so that it can be referenced with the ``dllimport`` attribute. On Microsoft Windows targets, the pointer name is formed by combining ``__imp_`` and the function or variable name. Since this storage class exists for defining a dll interface, the compiler, assembler and linker know it is externally referenced and must refrain from deleting the symbol."
msgstr "\\```dllexport`` \\“使编译器提供指向DLL中指针的全局指针，以便可以使用``dllimport``属性引用它。在Microsoft Windows目标上，指针名称是通过组合“__imp_`”和函数或变量名来形成的。由于此存储类用于定义dll接口，因此编译器，汇编器和链接器知道它是外部引用的，并且必须避免删除该符号。"

#: ../../LangRef.rst:493
msgid "Thread Local Storage Models"
msgstr "本地线程存储模型"

#: ../../LangRef.rst:495
msgid "A variable may be defined as ``thread_local``, which means that it will not be shared by threads (each thread will have a separated copy of the variable). Not all targets support thread-local variables. Optionally, a TLS model may be specified:"
msgstr "变量可以定义为``thread_local``，这意味着它不会被线程共享（每个线程都有一个独立的变量副本）。并非所有目标都支持线程局部变量。 （可选）可以指定TLS模型："

#: ../../LangRef.rst:500
msgid "``localdynamic``"
msgstr ""

#: ../../LangRef.rst:501
msgid "For variables that are only used within the current shared library."
msgstr "对于仅在当前共享库中使用的变量。"

#: ../../LangRef.rst:502
msgid "``initialexec``"
msgstr ""

#: ../../LangRef.rst:503
msgid "For variables in modules that will not be loaded dynamically."
msgstr "对于不会动态加载的模块中的变量。"

#: ../../LangRef.rst:505
msgid "``localexec``"
msgstr ""

#: ../../LangRef.rst:505
msgid "For variables defined in the executable and only used within it."
msgstr "对于可执行文件中定义的变量，仅在其中使用。"

#: ../../LangRef.rst:507
msgid "If no explicit model is given, the \"general dynamic\" model is used."
msgstr "如果没有给出显式模型，则使用“一般动态”模型。"

#: ../../LangRef.rst:509
msgid "The models correspond to the ELF TLS models; see `ELF Handling For Thread-Local Storage <http://people.redhat.com/drepper/tls.pdf>`_ for more information on under which circumstances the different models may be used. The target may choose a different TLS model if the specified model is not supported, or if a better choice of model can be made."
msgstr "模型对应于ELF TLS模型;请参阅“用于线程局部存储的ELF处理”<http://people.redhat.com/drepper/tls.pdf>`_以获取有关在何种情况下可以使用不同模型的更多信息。如果不支持指定的模型，或者可以更好地选择模型，目标可以选择不同的TLS模型。"

#: ../../LangRef.rst:515
msgid "A model can also be specified in an alias, but then it only governs how the alias is accessed. It will not have any effect in the aliasee."
msgstr "模型也可以在别名中指定，但它仅控制别名的访问方式。它对别名没有任何影响。"

#: ../../LangRef.rst:518
msgid "For platforms without linker support of ELF TLS model, the -femulated-tls flag can be used to generate GCC compatible emulated TLS code."
msgstr "对于没有ELF TLS模型的链接器支持的平台，-femulated-tls标志可用于生成GCC兼容的模拟TLS代码。"

#: ../../LangRef.rst:524
msgid "Structure Types"
msgstr "结构类型"

#: ../../LangRef.rst:526
msgid "LLVM IR allows you to specify both \"identified\" and \"literal\" :ref:`structure types <t_struct>`. Literal types are uniqued structurally, but identified types are never uniqued. An :ref:`opaque structural type <t_opaque>` can also be used to forward declare a type that is not yet available."
msgstr "LLVM IR允许您指定\\“identify \\”和\\“literal \\”：ref：`structure types <t_struct>`。文字类型在结构上是独一无二的，但识别的类型从未是唯一的。答：ref：`opaque structure type <t_opaque>`也可用于转发声明尚未可用的类型。"

#: ../../LangRef.rst:531
msgid "An example of an identified structure specification is:"
msgstr "一个结构类型的规范示例是："

#: ../../LangRef.rst:537
msgid "Prior to the LLVM 3.0 release, identified types were structurally uniqued. Only literal types are uniqued in recent versions of LLVM."
msgstr "在LLVM 3.0发布之前，已识别的类型在结构上是独一无二的。在最近的LLVM版本中，只有文字类型是唯一的。"

#: ../../LangRef.rst:543
msgid "Global Variables"
msgstr "全局变量"

#: ../../LangRef.rst:545
msgid "Global variables define regions of memory allocated at compilation time instead of run-time."
msgstr "全局变量定义了在编译时内存分配的范围，替代运行时分配。"

#: ../../LangRef.rst:548
msgid "Global variable definitions must be initialized."
msgstr "全局变量的定义必须被初始化。"

#: ../../LangRef.rst:550
msgid "Global variables in other translation units can also be declared, in which case they don't have an initializer."
msgstr "也可以声明其他翻译单元中的全局变量，在这种情况下，它们没有初始化程序。"

#: ../../LangRef.rst:553
msgid "Either global variable definitions or declarations may have an explicit section to be placed in and may have an optional explicit alignment specified."
msgstr "全局变量定义或声明可以具有要放置的显式部分，并且可以指定可选的显式对齐。"

#: ../../LangRef.rst:556
msgid "A variable may be defined as a global ``constant``, which indicates that the contents of the variable will **never** be modified (enabling better optimization, allowing the global data to be placed in the read-only section of an executable, etc). Note that variables that need runtime initialization cannot be marked ``constant`` as there is a store to the variable."
msgstr "变量可以定义为全局“常量”，表示变量的内容将永远不会被修改（实现更好的优化，允许全局数据放在一个只读部分中）可执行文件等）。请注意，需要运行时初始化的变量不能标记为“常量”，因为存储了变量。"

#: ../../LangRef.rst:563
msgid "LLVM explicitly allows *declarations* of global variables to be marked constant, even if the final definition of the global is not. This capability can be used to enable slightly better optimization of the program, but requires the language definition to guarantee that optimizations based on the 'constantness' are valid for the translation units that do not include the definition."
msgstr "LLVM明确允许将全局变量的*声明*标记为常量，即使全局变量的最终定义不是。此功能可用于稍微更好地优化程序，但需要语言定义以保证基于“常量”的优化对于不包含定义的转换单元有效。"

#: ../../LangRef.rst:570
msgid "As SSA values, global variables define pointer values that are in scope (i.e. they dominate) all basic blocks in the program. Global variables always define a pointer to their \"content\" type because they describe a region of memory, and all memory objects in LLVM are accessed through pointers."
msgstr "作为SSA值，全局变量定义程序中所有基本块的范围内（即它们占主导地位）的指针值。全局变量总是定义指向其“内容”类型的指针，因为它们描述了一个内存区域，LLVM中的所有内存对象都是通过指针访问的。"

#: ../../LangRef.rst:576
msgid "Global variables can be marked with ``unnamed_addr`` which indicates that the address is not significant, only the content. Constants marked like this can be merged with other constants if they have the same initializer. Note that a constant with significant address *can* be merged with a ``unnamed_addr`` constant, the result being a constant whose address is significant."
msgstr "全局变量可以用``unnamed_addr``标记，表示地址不重要，只有内容。如果它们具有相同的初始值，则可以将标记为这样的常量与其他常量合并。请注意，具有重要地址*的常量可以与``unnamed_addr``常量合并，结果是一个地址重要的常量。"

#: ../../LangRef.rst:583
msgid "A global variable may be declared to reside in a target-specific numbered address space. For targets that support them, address spaces may affect how optimizations are performed and/or what target instructions are used to access the variable. The default address space is zero. The address space qualifier must precede any other attributes."
msgstr "可以声明全局变量驻留在特定于目标的编号地址空间中。对于支持它们的目标，地址空间可能会影响优化的执行方式和/或用于访问变量的目标指令。默认地址空间为零。地址空间限定符必须位于任何其他属性之前。"

#: ../../LangRef.rst:589
msgid "LLVM allows an explicit section to be specified for globals. If the target supports it, it will emit globals to the section specified. Additionally, the global can placed in a comdat if the target has the necessary support."
msgstr "LLVM允许为全局变量指定显式部分。如果目标支持它，它将向指定的部分发出全局变量。此外，如果目标具有必要的支持，则全局可以放置在comdat中。"

#: ../../LangRef.rst:594
msgid "By default, global initializers are optimized by assuming that global variables defined within the module are not modified from their initial values before the start of the global initializer. This is true even for variables potentially accessible from outside the module, including those with external linkage or appearing in ``@llvm.used`` or dllexported variables. This assumption may be suppressed by marking the variable with ``externally_initialized``."
msgstr "默认情况下，通过假设模块中定义的全局变量未在全局初始化程序启动之前从其初始值进行修改来优化全局初始化程序。即使对于可能从模块外部访问的变量也是如此，包括那些具有外部链接或出现在``@llvm.used``或dllexported变量中的变量。通过用``external_initialized``标记变量可以抑制这种假设。"

#: ../../LangRef.rst:602
msgid ""
"An explicit alignment may be specified for a global, which must be a power of 2. If not present, or if the alignment is set to zero, the alignment of the global is set by the target to whatever it feels convenient. If an explicit alignment is specified, the global is forced to have exactly that alignment. Targets and optimizers are not allowed to over-align the global if the global has an assigned section. In this case, the extra alignment could be observable: for example, code could assume that the globals are densely packed in their section and try to iterate over "
"them as an array, alignment padding would break this iteration. The maximum alignment is ``1 << 29``."
msgstr "可以为全局指定显式对齐，其必须是2的幂。如果不存在，或者如果对齐设置为零，则全局的对齐由目标设置为感觉方便的任何对齐。如果指定了显式对齐，则强制全局具有该对齐。如果全局具有指定的部分，则不允许目标和优化器过度对齐全局。在这种情况下，额外的对齐可以是可观察的：例如，代码可以假设全局变量在它们的部分中密集打包并尝试作为数组迭代它们，对齐填充将破坏此迭代。最大对齐是“1 << 29``。"

#: ../../LangRef.rst:613
msgid "Globals can also have a :ref:`DLL storage class <dllstorageclass>`."
msgstr "Globals还可以有一个：ref：`DLL存储类<dllstorageclass>`。"

#: ../../LangRef.rst:615
msgid "Variables and aliases can have a :ref:`Thread Local Storage Model <tls_model>`."
msgstr "变量和别名可以有：ref：`Thread Local Storage Model <tls_model>`。"

#: ../../LangRef.rst:618 ../../LangRef.rst:706 ../../LangRef.rst:718 ../../LangRef.rst:738 ../../LangRef.rst:778 ../../LangRef.rst:871 ../../LangRef.rst:1487
msgid "Syntax::"
msgstr "语法::"

#: ../../LangRef.rst:626
msgid "For example, the following defines a global in a numbered address space with an initializer, section, and alignment:"
msgstr "例如，以下定义了带有初始值设定项，节和对齐的编号地址空间中的全局："

#: ../../LangRef.rst:633
msgid "The following example just declares a global variable"
msgstr "以下示例仅声明一个全局变量"

#: ../../LangRef.rst:639
msgid "The following example defines a thread-local global with the ``initialexec`` TLS model:"
msgstr "以下示例使用``initialexec`` TLS模型定义线程局部全局："

#: ../../LangRef.rst:649
msgid "Functions"
msgstr "函数"

#: ../../LangRef.rst:651
msgid ""
"LLVM function definitions consist of the \"``define``\" keyword, an optional :ref:`linkage type <linkage>`, an optional :ref:`visibility style <visibility>`, an optional :ref:`DLL storage class <dllstorageclass>`, an optional :ref:`calling convention <callingconv>`, an optional ``unnamed_addr`` attribute, a return type, an optional :ref:`parameter attribute <paramattrs>` for the return type, a function name, a (possibly empty) argument list (each with optional :ref:`parameter attributes <paramattrs>`), optional :ref:`function attributes <fnattrs>`, an optional "
"section, an optional alignment, an optional :ref:`comdat <langref_comdats>`, an optional :ref:`garbage collector name <gc>`, an optional :ref:`prefix <prefixdata>`, an optional :ref:`prologue <prologuedata>`, an optional :ref:`personality <personalityfn>`, an optional list of attached :ref:`metadata <metadata>`, an opening curly brace, a list of basic blocks, and a closing curly brace."
msgstr ""
"LLVM函数定义包含```````\\“关键字，可选：ref：`linkage type <linkage>`，可选：ref：`visibility style <visibility>`，可选：ref：`DLL存储类<dllstorageclass>`，一个可选的：ref：`调用约定<callingconv>`，一个可选的``unnamed_addr``属性，一个返回类型，一个可选的：ref：`参数属性<paramattrs>`用于返回类型，一个函数名，一个（可能是空的）参数列表（每个都有可选的：ref：`参数attributes <paramattrs>`），可选：ref：`function attributes <fnattrs>`，一个可选的部分，一个可选的对齐，一个可选的： ref：`comdat <langref_comdats>`，一个可选的：ref：`垃圾收集器名称<gc>`，一个可选的：ref："
"`prefix <prefixdata>`，一个可选的：ref：`prologue <prologuedata>`，一个可选的： ref：`personality <personalityfn>`，附加的可选列表：ref：`metadata <metadata>`，一个开头大括号，一个基本块列表和一个结束大括号。"

#: ../../LangRef.rst:667
msgid ""
"LLVM function declarations consist of the \"``declare``\" keyword, an optional :ref:`linkage type <linkage>`, an optional :ref:`visibility style <visibility>`, an optional :ref:`DLL storage class <dllstorageclass>`, an optional :ref:`calling convention <callingconv>`, an optional ``unnamed_addr`` attribute, a return type, an optional :ref:`parameter attribute <paramattrs>` for the return type, a function name, a possibly empty list of arguments, an optional alignment, an optional :ref:`garbage collector name <gc>`, an optional :ref:`prefix <prefixdata>`, and an "
"optional :ref:`prologue <prologuedata>`."
msgstr "LLVM函数声明由“````声明``\\”关键字组成，可选：ref：`linkage type <linkage>`，可选：ref：`visibility style <visibility>`，可选：ref：`DLL存储类<dllstorageclass>`，一个可选的：ref：`调用约定<callingconv>`，一个可选的``unnamed_addr``属性，一个返回类型，一个可选的：ref：`参数属性<paramattrs>`用于返回类型，一个函数名，一个可能是空的参数列表，一个可选的对齐，一个可选的：ref：`垃圾收集器名称<gc>`，一个可选的：ref：`prefix <prefixdata>`，还有一个可选的：ref：`prologue < prologuedata>`。"

#: ../../LangRef.rst:677
msgid ""
"A function definition contains a list of basic blocks, forming the CFG (Control Flow Graph) for the function. Each basic block may optionally start with a label (giving the basic block a symbol table entry), contains a list of instructions, and ends with a :ref:`terminator <terminators>` instruction (such as a branch or function return). If an explicit label is not provided, a block is assigned an implicit numbered label, using the next value from the same counter as used for unnamed temporaries (:ref:`see above<identifiers>`). For example, if a function entry block "
"does not have an explicit label, it will be assigned label \"%0\", then the first unnamed temporary in that block will be \"%1\", etc."
msgstr "函数定义包含基本块列表，形成函数的CFG（控制流图）。每个基本块可以可选地以标签开始（给基本块一个符号表条目），包含指令列表，并以：ref：`terminator <terminators>'指令（例如分支或函数返回）结束。如果未提供显式标签，则为块分配隐式编号标签，使用与未命名临时值相同的计数器中的下一个值（：ref：`参见上面的<identifiers>`）。例如，如果函数输入块没有显式标签，则会为其分配标签\\“％0 \\”，然后该块中的第一个未命名临时标签将为\\“％1 \\”，等等。"

#: ../../LangRef.rst:687
msgid "The first basic block in a function is special in two ways: it is immediately executed on entrance to the function, and it is not allowed to have predecessor basic blocks (i.e. there can not be any branches to the entry block of a function). Because the block can have no predecessors, it also cannot have any :ref:`PHI nodes <i_phi>`."
msgstr "函数中的第一个基本块在两个方面是特殊的：它在函数入口处立即执行，并且不允许具有先前的基本块（即，函数的入口块不能有任何分支）。因为块可以没有前辈，所以它也不能有任何：ref：`PHI nodes <i_phi>`。"

#: ../../LangRef.rst:693
msgid "LLVM allows an explicit section to be specified for functions. If the target supports it, it will emit functions to the section specified. Additionally, the function can be placed in a COMDAT."
msgstr "LLVM允许为函数指定显式部分。如果目标支持它，它将向指定的部分发出函数。此外，该功能可以放在COMDAT中。"

#: ../../LangRef.rst:697
msgid "An explicit alignment may be specified for a function. If not present, or if the alignment is set to zero, the alignment of the function is set by the target to whatever it feels convenient. If an explicit alignment is specified, the function is forced to have at least that much alignment. All alignments must be a power of 2."
msgstr "可以为函数指定显式对齐。如果不存在，或者对齐设置为零，则目标将功能的对齐设置为感觉方便的任何对齐。如果指定了显式对齐，则强制该函数至少具有那么多对齐。所有对齐必须是2的幂。"

#: ../../LangRef.rst:703
msgid "If the ``unnamed_addr`` attribute is given, the address is known to not be significant and two identical functions can be merged."
msgstr "如果给出 ``unnamed_addr`` 属性，则知道该地址不重要，并且可以合并两个相同的函数。"

#: ../../LangRef.rst:715
msgid "The argument list is a comma separated sequence of arguments where each argument is of the following form:"
msgstr "参数列表是以逗号分隔的参数序列，其中每个参数的格式如下："

#: ../../LangRef.rst:726
msgid "Aliases"
msgstr "别名"

#: ../../LangRef.rst:728
msgid "Aliases, unlike function or variables, don't create any new data. They are just a new symbol and metadata for an existing position."
msgstr "与函数或变量不同，别名不会创建任何新数据。它们只是现有职位的新符号和元数据。"

#: ../../LangRef.rst:731
msgid "Aliases have a name and an aliasee that is either a global value or a constant expression."
msgstr "别名具有名称和别名，可以是全局值或常量表达式。"

#: ../../LangRef.rst:734
msgid "Aliases may have an optional :ref:`linkage type <linkage>`, an optional :ref:`visibility style <visibility>`, an optional :ref:`DLL storage class <dllstorageclass>` and an optional :ref:`tls model <tls_model>`."
msgstr "别名可能有一个可选的 :ref:`linkage type <linkage>` ，一个可选的 :ref:`visibility style <visibility>` ，一个可选的 :ref:`DLL storage class <dllstorageclass>` 和一个可选的 :ref:`tls model <tls_model>` 。"

#: ../../LangRef.rst:742
msgid "The linkage must be one of ``private``, ``internal``, ``linkonce``, ``weak``, ``linkonce_odr``, ``weak_odr``, ``external``. Note that some system linkers might not correctly handle dropping a weak symbol that is aliased."
msgstr "连接必须是``private``，``internal``，``linkonce``，``weak``，``linkonce_odr``，``weak_odr``，``external``。请注意，某些系统链接器可能无法正确处理丢弃别名的弱符号。"

#: ../../LangRef.rst:746
msgid "Aliases that are not ``unnamed_addr`` are guaranteed to have the same address as the aliasee expression. ``unnamed_addr`` ones are only guaranteed to point to the same content."
msgstr "不是“unnamed_addr” 的别名保证与别名表达式具有相同的地址。 ``unnamed_addr`` 只能保证指向相同的内容。"

#: ../../LangRef.rst:750
msgid "Since aliases are only a second name, some restrictions apply, of which some can only be checked when producing an object file:"
msgstr "由于别名只是第二个名称，因此应用了一些限制，其中一些限制只能在生成目标文件时进行检查："

#: ../../LangRef.rst:753
msgid "The expression defining the aliasee must be computable at assembly time. Since it is just a name, no relocations can be used."
msgstr "定义别名的表达式必须在汇编时可计算。由于它只是一个名称，因此不能使用重定位。"

#: ../../LangRef.rst:756
msgid "No alias in the expression can be weak as the possibility of the intermediate alias being overridden cannot be represented in an object file."
msgstr "表达式中的别名可能较弱，因为中间别名被覆盖的可能性无法在目标文件中表示。"

#: ../../LangRef.rst:760
msgid "No global value in the expression can be a declaration, since that would require a relocation, which is not possible."
msgstr "表达式中没有全局值可以是声明，因为这将需要重定位，这是不可能的。"

#: ../../LangRef.rst:766
msgid "Comdats"
msgstr ""

#: ../../LangRef.rst:768
msgid "Comdat IR provides access to COFF and ELF object file COMDAT functionality."
msgstr "Comdat IR提供对COFF和ELF目标文件COMDAT功能的访问。"

#: ../../LangRef.rst:770
msgid "Comdats have a name which represents the COMDAT key. All global objects that specify this key will only end up in the final object file if the linker chooses that key over some other key. Aliases are placed in the same COMDAT that their aliasee computes to, if any."
msgstr "Comdats的名称代表COMDAT密钥。如果链接器通过某个其他键选择该键，则指定此键的所有全局对象将仅在最终目标文件中结束。别名被放置在其别名计算到的同一个COMDAT中，如果有的话。"

#: ../../LangRef.rst:775
msgid "Comdats have a selection kind to provide input on how the linker should choose between keys in two different object files."
msgstr "Comdats有一种选择类型可以提供有关链接器应如何在两个不同目标文件中的键之间进行选择的输入。"

#: ../../LangRef.rst:782
msgid "The selection kind must be one of the following:"
msgstr "选择类型必须是以下之一："

#: ../../LangRef.rst:784
msgid "``any``"
msgstr ""

#: ../../LangRef.rst:785
msgid "The linker may choose any COMDAT key, the choice is arbitrary."
msgstr "链接器可以选择任何COMDAT键，选择是任意的。"

#: ../../LangRef.rst:787
msgid "``exactmatch``"
msgstr ""

#: ../../LangRef.rst:787
msgid "The linker may choose any COMDAT key but the sections must contain the same data."
msgstr "链接器可以选择任何COMDAT密钥，但这些部分必须包含相同的数据。"

#: ../../LangRef.rst:789
msgid "``largest``"
msgstr ""

#: ../../LangRef.rst:790
msgid "The linker will choose the section containing the largest COMDAT key."
msgstr "链接器将选择包含最大COMDAT密钥的部分。"

#: ../../LangRef.rst:791
msgid "``noduplicates``"
msgstr ""

#: ../../LangRef.rst:792
msgid "The linker requires that only section with this COMDAT key exist."
msgstr "链接器要求只存在具有此COMDAT键的节。"

#: ../../LangRef.rst:795
msgid "``samesize``"
msgstr ""

#: ../../LangRef.rst:794
msgid "The linker may choose any COMDAT key but the sections must contain the same amount of data."
msgstr "链接器可以选择任何COMDAT密钥，但这些部分必须包含相同数量的数据。"

#: ../../LangRef.rst:797
msgid "Note that the Mach-O platform doesn't support COMDATs and ELF only supports ``any`` as a selection kind."
msgstr "请注意，Mach-O平台不支持COMDAT，ELF仅支持``any``作为选择类型。"

#: ../../LangRef.rst:800
msgid "Here is an example of a COMDAT group where a function will only be selected if the COMDAT key's section is the largest:"
msgstr "以下是COMDAT组的示例，其中仅在COMDAT键的部分最大时才选择函数："

#: ../../LangRef.rst:812
msgid "As a syntactic sugar the ``$name`` can be omitted if the name is the same as the global name:"
msgstr "作为语法糖，如果名称与全局名称相同，则可以省略``$ name``："

#: ../../LangRef.rst:821
msgid "In a COFF object file, this will create a COMDAT section with selection kind ``IMAGE_COMDAT_SELECT_LARGEST`` containing the contents of the ``@foo`` symbol and another COMDAT section with selection kind ``IMAGE_COMDAT_SELECT_ASSOCIATIVE`` which is associated with the first COMDAT section and contains the contents of the ``@bar`` symbol."
msgstr "在COFF目标文件中，这将创建一个COMDAT部分，其中包含选择类型``IMAGE_COMDAT_SELECT_LARGEST``，其中包含``@ foo``符号的内容，另一个COMDAT部分包含选择类型``IMAGE_COMDAT_SELECT_ASSOCIATIVE``，该部分与第一个相关联COMDAT部分包含``@bar``符号的内容。"

#: ../../LangRef.rst:827
msgid "There are some restrictions on the properties of the global object. It, or an alias to it, must have the same name as the COMDAT group when targeting COFF. The contents and size of this object may be used during link-time to determine which COMDAT groups get selected depending on the selection kind. Because the name of the object must match the name of the COMDAT group, the linkage of the global object must not be local; local symbols can get renamed if a collision occurs in the symbol table."
msgstr "全局对象的属性有一些限制。它或它的别名在定位COFF时必须与COMDAT组具有相同的名称。可以在链接时使用此对象的内容和大小来确定根据选择类型选择哪些COMDAT组。因为对象的名称必须与COMDAT组的名称匹配，所以全局对象的链接不能是本地的;如果符号表中发生冲突，则可以重命名本地符号。"

#: ../../LangRef.rst:836
msgid "The combined use of COMDATS and section attributes may yield surprising results. For example:"
msgstr "COMDATS和部分属性的组合使用可能会产生令人惊讶的结果。例如："

#: ../../LangRef.rst:846
msgid "From the object file perspective, this requires the creation of two sections with the same name. This is necessary because both globals belong to different COMDAT groups and COMDATs, at the object file level, are represented by sections."
msgstr "从目标文件的角度来看，这需要创建两个具有相同名称的部分。这是必要的，因为两个全局变量属于不同的COMDAT组，并且在目标文件级别的COMDAT由部分表示。"

#: ../../LangRef.rst:851
msgid "Note that certain IR constructs like global variables and functions may create COMDATs in the object file in addition to any which are specified using COMDAT IR. This arises when the code generator is configured to emit globals in individual sections (e.g. when `-data-sections` or `-function-sections` is supplied to `llc`)."
msgstr "请注意，除了使用COMDAT IR指定的任何IR构造之外，某些IR构造（如全局变量和函数）可以在目标文件中创建COMDAT。当代码生成器配置为在各个部分中发出全局变量时（例如，当`-data-sections`或`-function-sections`被提供给`llc`时），就会出现这种情况。"

#: ../../LangRef.rst:860
msgid "Named Metadata"
msgstr "命名元数据"

#: ../../LangRef.rst:862
msgid "Named metadata is a collection of metadata. :ref:`Metadata nodes <metadata>` (but not metadata strings) are the only valid operands for a named metadata."
msgstr "命名元数据是元数据的集合。 ：ref：`元数据节点<元数据>`（但不是元数据字符串）是命名元数据的唯一有效操作数。"

#: ../../LangRef.rst:866
msgid "Named metadata are represented as a string of characters with the metadata prefix. The rules for metadata names are the same as for identifiers, but quoted names are not allowed. ``\"\\xx\"`` type escapes are still valid, which allows any character to be part of a name."
msgstr "命名元数据表示为带有元数据前缀的字符串。元数据名称的规则与标识符的规则相同，但不允许使用引号。 ``\\“\\ xx \\```类型转义符仍然有效，它允许任何字符成为名称的一部分。"

#: ../../LangRef.rst:883
msgid "Parameter Attributes"
msgstr "参数属性"

#: ../../LangRef.rst:885
msgid "The return type and each parameter of a function type may have a set of *parameter attributes* associated with them. Parameter attributes are used to communicate additional information about the result or parameters of a function. Parameter attributes are considered to be part of the function, not of the function type, so functions with different parameter attributes can have the same function type."
msgstr "返回类型和函数类型的每个参数可以具有一组与它们相关联的*参数属性*。参数属性用于传递有关函数结果或参数的其他信息。参数属性被认为是函数的一部分，而不是函数类型，因此具有不同参数属性的函数可以具有相同的函数类型。"

#: ../../LangRef.rst:892
msgid "Parameter attributes are simple keywords that follow the type specified. If multiple parameter attributes are needed, they are space separated. For example:"
msgstr "参数属性是遵循指定类型的简单关键字。如果需要多个参数属性，则它们是空格分隔的。例如："

#: ../../LangRef.rst:902
msgid "Note that any attributes for the function result (``nounwind``, ``readonly``) come immediately after the argument list."
msgstr "请注意，函数结果的任何属性（``nounwind``，``readonly``）都紧跟在参数列表之后。"

#: ../../LangRef.rst:905
msgid "Currently, only the following parameter attributes are defined:"
msgstr "目前，仅定义了以下参数属性："

#: ../../LangRef.rst:910
msgid "``zeroext``"
msgstr ""

#: ../../LangRef.rst:908
msgid "This indicates to the code generator that the parameter or return value should be zero-extended to the extent required by the target's ABI (which is usually 32-bits, but is 8-bits for a i1 on x86-64) by the caller (for a parameter) or the callee (for a return value)."
msgstr "这向代码生成器指示参数或返回值应该被零扩展到目标的ABI（通常为32位，但x86-64上的i1为8位）所需的范围（调用者）（对于参数）或被调用者（对于返回值）。"

#: ../../LangRef.rst:915
msgid "``signext``"
msgstr ""

#: ../../LangRef.rst:913
msgid "This indicates to the code generator that the parameter or return value should be sign-extended to the extent required by the target's ABI (which is usually 32-bits) by the caller (for a parameter) or the callee (for a return value)."
msgstr "这向代码生成器指示参数或返回值应该被调用者（对于参数）或被调用者（对于返回值）符号扩展到目标的ABI（通常是32位）所需的范围。 。"

#: ../../LangRef.rst:922
msgid "``inreg``"
msgstr ""

#: ../../LangRef.rst:918
msgid "This indicates that this parameter or return value should be treated in a special target-dependent fashion while emitting code for a function call or return (usually, by putting it in a register as opposed to memory, though some targets use it to distinguish between two different kinds of registers). Use of this attribute is target-specific."
msgstr "这表明该参数或返回值应以特定的目标依赖方式处理，同时为函数调用或返回发出代码（通常，通过将其放入寄存器而不是内存，尽管某些目标使用它来区分两个不同种类的寄存器）。使用此属性是特定于目标的。"

#: ../../LangRef.rst:940
msgid "``byval``"
msgstr ""

#: ../../LangRef.rst:925
msgid ""
"This indicates that the pointer parameter should really be passed by value to the function. The attribute implies that a hidden copy of the pointee is made between the caller and the callee, so the callee is unable to modify the value in the caller. This attribute is only valid on LLVM pointer arguments. It is generally used to pass structs and arrays by value, but is also valid on pointers to scalars. The copy is considered to belong to the caller not the callee (for example, ``readonly`` functions should not write to ``byval`` parameters). This is not a valid "
"attribute for return values."
msgstr "这表明指针参数确实应该通过值传递给函数。该属性意味着在调用者和被调用者之间建立了一个隐藏的指针对象副本，因此被调用者无法修改调用者中的值。此属性仅对LLVM指针参数有效。它通常用于按值传递结构和数组，但对指向标量的指针也有效。该副本被认为属于调用者而不是被调用者（例如，``readonly``函数不应该写入``byval``参数）。这不是返回值的有效属性。"

#: ../../LangRef.rst:936
msgid "The byval attribute also supports specifying an alignment with the align attribute. It indicates the alignment of the stack slot to form and the known alignment of the pointer specified to the call site. If the alignment is not specified, then the code generator makes a target-specific assumption."
msgstr "byval属性还支持使用align属性指定对齐方式。它指示要形成的堆栈槽的对齐以及指定给调用站点的指针的已知对齐。如果未指定对齐，则代码生成器会进行特定于目标的假设。"

#: ../../LangRef.rst:944
msgid "``inalloca``"
msgstr ""

#: ../../LangRef.rst:946
msgid "The ``inalloca`` argument attribute allows the caller to take the address of outgoing stack arguments. An ``inalloca`` argument must be a pointer to stack memory produced by an ``alloca`` instruction. The alloca, or argument allocation, must also be tagged with the inalloca keyword. Only the last argument may have the ``inalloca`` attribute, and that argument is guaranteed to be passed in memory."
msgstr "``inalloca``参数属性允许调用者获取传出堆栈参数的地址。 ``inalloca``参数必须是指向由``alloca``指令产生的堆栈内存的指针。 alloca或参数分配也必须使用inalloca关键字进行标记。只有最后一个参数可能具有``inalloca``属性，并且该参数保证在内存中传递。"

#: ../../LangRef.rst:953
msgid "An argument allocation may be used by a call at most once because the call may deallocate it. The ``inalloca`` attribute cannot be used in conjunction with other attributes that affect argument storage, like ``inreg``, ``nest``, ``sret``, or ``byval``. The ``inalloca`` attribute also disables LLVM's implicit lowering of large aggregate return values, which means that frontend authors must lower them with ``sret`` pointers."
msgstr "最多一次调用可以使用一个参数分配，因为该调用可以解除分配。 ``inalloca``属性不能与影响参数存储的其他属性一起使用，例如``inreg``，`````，``sret``或``byval``。 ``inalloca``属性也禁用LLVM隐式降低大聚合返回值，这意味着前端作者必须用``sret``指针降低它们。"

#: ../../LangRef.rst:961
msgid "When the call site is reached, the argument allocation must have been the most recent stack allocation that is still live, or the results are undefined. It is possible to allocate additional stack space after an argument allocation and before its call site, but it must be cleared off with :ref:`llvm.stackrestore <int_stackrestore>`."
msgstr "到达调用站点时，参数分配必须是仍处于活动状态的最新堆栈分配，或者结果未定义。在参数分配之后和调用站点之前可以分配额外的堆栈空间，但必须使用以下命令清除它：ref：`llvm.stackrestore <int_stackrestore>`。"

#: ../../LangRef.rst:968
msgid "See :doc:`InAlloca` for more information on how to use this attribute."
msgstr "有关如何使用此属性的更多信息，请参阅：doc：`InAlloca`。"

#: ../../LangRef.rst:978
msgid "``sret``"
msgstr ""

#: ../../LangRef.rst:972
msgid "This indicates that the pointer parameter specifies the address of a structure that is the return value of the function in the source program. This pointer must be guaranteed by the caller to be valid: loads and stores to the structure may be assumed by the callee not to trap and to be properly aligned. This may only be applied to the first parameter. This is not a valid attribute for return values."
msgstr "这表示指针参数指定结构的地址，该结构是源程序中函数的返回值。调用者必须保证该指针有效：被调用者可以假定对结构的加载和存储不要陷阱并且要正确对齐。这可能仅适用于第一个参数。这不是返回值的有效属性。"

#: ../../LangRef.rst:985
msgid "``align <n>``"
msgstr ""

#: ../../LangRef.rst:981
msgid "This indicates that the pointer value may be assumed by the optimizer to have the specified alignment."
msgstr "这表示优化器可以假定指针值具有指定的对齐。"

#: ../../LangRef.rst:984
msgid "Note that this attribute has additional semantics when combined with the ``byval`` attribute."
msgstr "请注意，当与``byval``属性结合使用时，此属性具有其他语义。"

#: ../../LangRef.rst:1008
msgid "``noalias``"
msgstr ""

#: ../../LangRef.rst:990
msgid "This indicates that objects accessed via pointer values :ref:`based <pointeraliasing>` on the argument or return value are not also accessed, during the execution of the function, via pointer values not *based* on the argument or return value. The attribute on a return value also has additional semantics described below. The caller shares the responsibility with the callee for ensuring that these requirements are met. For further details, please see the discussion of the NoAlias response in :ref:`alias analysis <Must, May, or No>`."
msgstr "这表示通过指针值访问的对象：参数或返回值上的ref：`based <pointeraliasing>`在执行函数期间，也不会通过参数或返回值的指针值* * *来访问。返回值的属性还具有下面描述的其他语义。呼叫者与被呼叫者共同承担责任，以确保满足这些要求。有关详细信息，请参阅NoAlias响应的讨论：ref：`alias analysis <Must，May，No>`。"

#: ../../LangRef.rst:999
msgid "Note that this definition of ``noalias`` is intentionally similar to the definition of ``restrict`` in C99 for function arguments."
msgstr "注意，``noalias``的这个定义有意类似于C99中``restrict``的定义，用于函数参数。"

#: ../../LangRef.rst:1002
msgid "For function return values, C99's ``restrict`` is not meaningful, while LLVM's ``noalias`` is. Furthermore, the semantics of the ``noalias`` attribute on return values are stronger than the semantics of the attribute when used on function arguments. On function return values, the ``noalias`` attribute indicates that the function acts like a system memory allocation function, returning a pointer to allocated storage disjoint from the storage for any other object accessible to the caller."
msgstr "对于函数返回值，C99的``restrict``没有意义，而LLVM的``noalias``是。此外，当在函数参数上使用时，返回值上的``noalias``属性的语义强于属性的语义。在函数返回值上，“noalias”属性表示该函数的作用类似于系统内存分配函数，返回指向已分配存储的指针，该存储与存储器不相交，可用于调用者可访问的任何其他对象。"

#: ../../LangRef.rst:1013
msgid "``nocapture``"
msgstr ""

#: ../../LangRef.rst:1011
msgid "This indicates that the callee does not make any copies of the pointer that outlive the callee itself. This is not a valid attribute for return values."
msgstr "这表明被调用者没有生成比被调用者本身更长的指针的任何副本。这不是返回值的有效属性。"

#: ../../LangRef.rst:1020
msgid "``nest``"
msgstr ""

#: ../../LangRef.rst:1018
msgid "This indicates that the pointer parameter can be excised using the :ref:`trampoline intrinsics <int_trampoline>`. This is not a valid attribute for return values and can only be applied to one parameter."
msgstr "这表明可以使用：ref：`trampoline intrinsics <int_trampoline>`删除指针参数。这不是返回值的有效属性，只能应用于一个参数。"

#: ../../LangRef.rst:1029
msgid "``returned``"
msgstr ""

#: ../../LangRef.rst:1023
msgid "This indicates that the function always returns the argument as its return value. This is an optimization hint to the code generator when generating the caller, allowing tail call optimization and omission of register saves and restores in some cases; it is not checked or enforced when generating the callee. The parameter and the function return type must be valid operands for the :ref:`bitcast instruction <i_bitcast>`. This is not a valid attribute for return values and can only be applied to one parameter."
msgstr "这表示该函数始终返回参数作为其返回值。这是在生成调用者时对代码生成器的优化提示，允许尾调用优化和在某些情况下省略寄存器保存和恢复;生成被调用者时不会检查或强制执行。参数和函数返回类型必须是：ref：`bitcast指令<i_bitcast>`的有效操作数。这不是返回值的有效属性，只能应用于一个参数。"

#: ../../LangRef.rst:1036
msgid "``nonnull``"
msgstr ""

#: ../../LangRef.rst:1032
msgid "This indicates that the parameter or return pointer is not null. This attribute may only be applied to pointer typed parameters. This is not checked or enforced by LLVM, the caller must ensure that the pointer passed in is non-null, or the callee must ensure that the returned pointer is non-null."
msgstr "这表示参数或返回指针不为空。此属性仅可应用于指针类型的参数。 LLVM不会检查或强制执行此操作，调用者必须确保传入的指针为非null，否则被调用者必须确保返回的指针为非null。"

#: ../../LangRef.rst:1047
msgid "``dereferenceable(<n>)``"
msgstr ""

#: ../../LangRef.rst:1039
msgid ""
"This indicates that the parameter or return pointer is dereferenceable. This attribute may only be applied to pointer typed parameters. A pointer that is dereferenceable can be loaded from speculatively without a risk of trapping. The number of bytes known to be dereferenceable must be provided in parentheses. It is legal for the number of bytes to be less than the size of the pointee type. The ``nonnull`` attribute does not imply dereferenceability (consider a pointer to one element past the end of an array), however ``dereferenceable(<n>)`` does imply ``nonnull`` in "
"``addrspace(0)`` (which is the default address space)."
msgstr "这表示参数或返回指针是可解除引用的。此属性仅可应用于指针类型的参数。可以从推测性地加载可解除引用的指针而没有陷阱的风险。必须在括号中提供已知可解除引用的字节数。字节数小于指针类型的大小是合法的。 ``nonnull``属性并不意味着解除引用性（考虑指向一个元素超过数组末尾的指针），然而``dereferenceable（<n>）``确实暗示``addnull``在``addrspace（0） ）``（这是默认的地址空间）。"

#: ../../LangRef.rst:1060
msgid "``dereferenceable_or_null(<n>)``"
msgstr ""

#: ../../LangRef.rst:1050
msgid ""
"This indicates that the parameter or return value isn't both non-null and non-dereferenceable (up to ``<n>`` bytes) at the same time. All non-null pointers tagged with ``dereferenceable_or_null(<n>)`` are ``dereferenceable(<n>)``. For address space 0 ``dereferenceable_or_null(<n>)`` implies that a pointer is exactly one of ``dereferenceable(<n>)`` or ``null``, and in other address spaces ``dereferenceable_or_null(<n>)`` implies that a pointer is at least one of ``dereferenceable(<n>)`` or ``null`` (i.e. it may be both ``null`` and ``dereferenceable(<n>)``). This "
"attribute may only be applied to pointer typed parameters."
msgstr "这表明参数或返回值不是同时非空和不可解除引用（最多为“<n>”字节）。所有用``dereferenceable_or_null（<n>）``标记的非空指针都是``dereferenceable（<n>）``。对于地址空间0``dereferenceable_or_null（<n>）``意味着指针恰好是``dereferenceable（<n>）``或``null``之一，而在其他地址空间中``dereferenceable_or_null（<n >）``暗示一个指针至少是一个``dereferenceable（<n>）``或``null``（即它可能都是``null``和``dereferenceable（<n>）` `）。此属性仅可应用于指针类型的参数。"

#: ../../LangRef.rst:1065
msgid "Garbage Collector Strategy Names"
msgstr "垃圾收集器策略名称"

#: ../../LangRef.rst:1067
msgid "Each function may specify a garbage collector strategy name, which is simply a string:"
msgstr "每个函数都可以指定一个垃圾收集器策略名称，它只是一个字符串："

#: ../../LangRef.rst:1074
msgid "The supported values of *name* includes those :ref:`built in to LLVM <builtin-gc-strategies>` and any provided by loaded plugins. Specifying a GC strategy will cause the compiler to alter its output in order to support the named garbage collection algorithm. Note that LLVM itself does not contain a garbage collector, this functionality is restricted to generating machine code which can interoperate with a collector provided externally."
msgstr "支持的* name *值包括：ref：`内置于LLVM <builtin-gc-strategies>`以及由加载的插件提供的任何值。指定GC策略将导致编译器更改其输出以支持命名的垃圾收集算法。请注意，LLVM本身不包含垃圾收集器，此功能仅限于生成可与外部提供的收集器互操作的机器代码。"

#: ../../LangRef.rst:1084
msgid "Prefix Data"
msgstr "前缀数据"

#: ../../LangRef.rst:1086
msgid "Prefix data is data associated with a function which the code generator will emit immediately before the function's entrypoint. The purpose of this feature is to allow frontends to associate language-specific runtime metadata with specific functions and make it available through the function pointer while still allowing the function pointer to be called."
msgstr "前缀数据是与函数关联的数据，代码生成器将在函数入口点之前立即发出该函数。此功能的目的是允许前端将特定于语言的运行时元数据与特定函数相关联，并通过函数指针使其可用，同时仍允许调用函数指针。"

#: ../../LangRef.rst:1093
msgid "To access the data for a given function, a program may bitcast the function pointer to a pointer to the constant's type and dereference index -1. This implies that the IR symbol points just past the end of the prefix data. For instance, take the example of a function annotated with a single ``i32``,"
msgstr "为了访问给定函数的数据，程序可以将函数指针连接到指向常量类型和解引用索引-1的指针。这意味着IR符号指向刚好超过前缀数据的末尾。例如，以一个单独的``i32``注释的函数为例，"

#: ../../LangRef.rst:1103
msgid "The prefix data can be referenced as,"
msgstr "前缀数据可以引用为，"

#: ../../LangRef.rst:1111
msgid "Prefix data is laid out as if it were an initializer for a global variable of the prefix data's type. The function will be placed such that the beginning of the prefix data is aligned. This means that if the size of the prefix data is not a multiple of the alignment size, the function's entrypoint will not be aligned. If alignment of the function's entrypoint is desired, padding must be added to the prefix data."
msgstr "前缀数据的布局就好像它是前缀数据类型的全局变量的初始值设定项。将放置该函数，使得前缀数据的开头对齐。这意味着如果前缀数据的大小不是对齐大小的倍数，则函数的入口点将不会对齐。如果需要对齐函数的入口点，则必须将填充添加到前缀数据中。"

#: ../../LangRef.rst:1119
msgid "A function may have prefix data but no body. This has similar semantics to the ``available_externally`` linkage in that the data may be used by the optimizers but will not be emitted in the object file."
msgstr "一个函数可能有前缀数据但没有正文。这与``available_externally``链接具有相似的语义，因为优化器可以使用数据，但不会在目标文件中发出数据。"

#: ../../LangRef.rst:1126
msgid "Prologue Data"
msgstr "序言数据"

#: ../../LangRef.rst:1128
msgid "The ``prologue`` attribute allows arbitrary code (encoded as bytes) to be inserted prior to the function body. This can be used for enabling function hot-patching and instrumentation."
msgstr "``prologue``属性允许在函数体之前插入任意代码（编码为字节）。这可用于启用功能热修补和仪表。"

#: ../../LangRef.rst:1132
msgid ""
"To maintain the semantics of ordinary function calls, the prologue data must have a particular format. Specifically, it must begin with a sequence of bytes which decode to a sequence of machine instructions, valid for the module's target, which transfer control to the point immediately succeeding the prologue data, without performing any other visible action. This allows the inliner and other passes to reason about the semantics of the function definition without needing to reason about the prologue data. Obviously this makes the format of the prologue data highly "
"target dependent."
msgstr "为了维护普通函数调用的语义，序言数据必须具有特定的格式。具体来说，它必须以一系列字节开始，这些字节序列解码为一系列机器指令，对模块的目标有效，将控制转移到紧接在序言数据之后的点，而不执行任何其他可见操作。这允许内联器和其他传递来推断函数定义的语义，而无需推理序言数据。显然，这使得序言数据的格式高度依赖于目标。"

#: ../../LangRef.rst:1141
msgid "A trivial example of valid prologue data for the x86 architecture is ``i8 144``, which encodes the ``nop`` instruction:"
msgstr "x86架构的有效序言数据的一个简单例子是``i8 144``，它编码``nop``指令："

#: ../../LangRef.rst:1148
msgid "Generally prologue data can be formed by encoding a relative branch instruction which skips the metadata, as in this example of valid prologue data for the x86_64 architecture, where the first two bytes encode ``jmp .+10``:"
msgstr "通常，序列数据可以通过编码跳过元数据的相对分支指令来形成，如x86_64体系结构的有效序言数据的示例，其中前两个字节编码“jmp。+ 10``："

#: ../../LangRef.rst:1158
msgid "A function may have prologue data but no body. This has similar semantics to the ``available_externally`` linkage in that the data may be used by the optimizers but will not be emitted in the object file."
msgstr "一个函数可能有序言数据，但没有正文。这与``available_externally``链接具有相似的语义，因为优化器可以使用数据，但不会在目标文件中发出数据。"

#: ../../LangRef.rst:1165
msgid "Personality Function"
msgstr "人格功能"

#: ../../LangRef.rst:1167
msgid "The ``personality`` attribute permits functions to specify what function to use for exception handling."
msgstr "``personality``属性允许函数指定用于异常处理的函数。"

#: ../../LangRef.rst:1173
msgid "Attribute Groups"
msgstr "属性组"

#: ../../LangRef.rst:1175
msgid "Attribute groups are groups of attributes that are referenced by objects within the IR. They are important for keeping ``.ll`` files readable, because a lot of functions will use the same set of attributes. In the degenerative case of a ``.ll`` file that corresponds to a single ``.c`` file, the single attribute group will capture the important command line flags used to build that file."
msgstr "属性组是IR中对象引用的属性组。它们对于保持`.ll``文件可读是很重要的，因为很多函数都会使用相同的属性集。在``.ll``文件的退化情况下，对应于单个``.c``文件，单个属性组将捕获用于构建该文件的重要命令行标志。"

#: ../../LangRef.rst:1181
msgid "An attribute group is a module-level object. To use an attribute group, an object references the attribute group's ID (e.g. ``#37``). An object may refer to more than one attribute group. In that situation, the attributes from the different groups are merged."
msgstr "属性组是模块级对象。要使用属性组，对象引用属性组的ID（例如``＃37``）。对象可以指代多个属性组。在这种情况下，合并来自不同组的属性。"

#: ../../LangRef.rst:1186
msgid "Here is an example of attribute groups for a function that should always be inlined, has a stack alignment of 4, and which shouldn't use SSE instructions:"
msgstr "下面是一个函数的属性组示例，它应该始终内联，堆栈对齐为4，并且不应使用SSE指令："

#: ../../LangRef.rst:1203
msgid "Function Attributes"
msgstr "功能属性"

#: ../../LangRef.rst:1205
msgid "Function attributes are set to communicate additional information about a function. Function attributes are considered to be part of the function, not of the function type, so functions with different function attributes can have the same function type."
msgstr "设置函数属性以传达有关函数的其他信息。函数属性被认为是函数的一部分，而不是函数类型，因此具有不同函数属性的函数可以具有相同的函数类型。"

#: ../../LangRef.rst:1210
msgid "Function attributes are simple keywords that follow the type specified. If multiple attributes are needed, they are space separated. For example:"
msgstr "函数属性是遵循指定类型的简单关键字。如果需要多个属性，则它们是空格分隔的。例如："

#: ../../LangRef.rst:1224
msgid "``alignstack(<n>)``"
msgstr ""

#: ../../LangRef.rst:1222
msgid "This attribute indicates that, when emitting the prologue and epilogue, the backend should forcibly align the stack pointer. Specify the desired alignment, which must be a power of two, in parentheses."
msgstr "此属性表示，在发出序言和结尾时，后端应强制对齐堆栈指针。在括号中指定所需的对齐，该对齐必须是2的幂。"

#: ../../LangRef.rst:1228
msgid "``alwaysinline``"
msgstr ""

#: ../../LangRef.rst:1227
msgid "This attribute indicates that the inliner should attempt to inline this function into callers whenever possible, ignoring any active inlining size threshold for this caller."
msgstr "此属性指示内联器应尽可能尝试将此函数内联到调用方，忽略此调用方的任何活动内联大小阈值。"

#: ../../LangRef.rst:1234
msgid "``builtin``"
msgstr ""

#: ../../LangRef.rst:1231
msgid "This indicates that the callee function at a call site should be recognized as a built-in function, even though the function's declaration uses the ``nobuiltin`` attribute. This is only valid at call sites for direct calls to functions that are declared with the ``nobuiltin`` attribute."
msgstr "这表明调用站点的被调用函数应该被识别为内置函数，即使函数的声明使用``nobuiltin``属性。这仅在调用站点有效，用于直接调用使用``nobuiltin``属性声明的函数。"

#: ../../LangRef.rst:1239
msgid "``cold``"
msgstr ""

#: ../../LangRef.rst:1237
msgid "This attribute indicates that this function is rarely called. When computing edge weights, basic blocks post-dominated by a cold function call are also considered to be cold; and, thus, given low weight."
msgstr "此属性表示很少调用此函数。在计算边缘权重时，由冷函数调用支配的基本块也被认为是冷的;因此，重量轻。"

#: ../../LangRef.rst:1244
msgid "``convergent``"
msgstr ""

#: ../../LangRef.rst:1242
msgid "This attribute indicates that the callee is dependent on a convergent thread execution pattern under certain parallel execution models. Transformations that are execution model agnostic may not make the execution of a convergent operation control dependent on any additional values."
msgstr "此属性指示被调用者在某些并行执行模型下依赖于收敛线程执行模式。与执行模型无关的转换可能不会使收敛操作控制的执行依赖于任何附加值。"

#: ../../LangRef.rst:1248
msgid "``inaccessiblememonly``"
msgstr ""

#: ../../LangRef.rst:1247
msgid "This attribute indicates that the function may only access memory that is not accessible by the module being compiled. This is a weaker form of ``readnone``."
msgstr "此属性指示该函数只能访问正在编译的模块无法访问的内存。这是一种较弱的``readnone``形式。"

#: ../../LangRef.rst:1252
msgid "``inaccessiblemem_or_argmemonly``"
msgstr ""

#: ../../LangRef.rst:1251
msgid "This attribute indicates that the function may only access memory that is either not accessible by the module being compiled, or is pointed to by its pointer arguments. This is a weaker form of  ``argmemonly``"
msgstr "此属性指示该函数只能访问正在编译的模块无法访问的内存，或者由其指针参数指向的内存。这是一种较弱的形式``argmemonly``"

#: ../../LangRef.rst:1257
msgid "``inlinehint``"
msgstr ""

#: ../../LangRef.rst:1255
msgid "This attribute indicates that the source code contained a hint that inlining this function is desirable (such as the \"inline\" keyword in C/C++). It is just a hint; it imposes no requirements on the inliner."
msgstr "此属性表示源代码包含一个暗示，希望内联此函数（例如C / C ++中的\\“inline \\”关键字）。这只是一个提示;它对内衬没有任何要求。"

#: ../../LangRef.rst:1265
msgid "``jumptable``"
msgstr ""

#: ../../LangRef.rst:1260
msgid "This attribute indicates that the function should be added to a jump-instruction table at code-generation time, and that all address-taken references to this function should be replaced with a reference to the appropriate jump-instruction-table function pointer. Note that this creates a new pointer for the original function, which means that code that depends on function-pointer identity can break. So, any function annotated with ``jumptable`` must also be ``unnamed_addr``."
msgstr "该属性表示该函数应该在代码生成时添加到跳转指令表中，并且应该用对相应的跳转指令表函数指针的引用替换对该函数的所有地址引用。请注意，这会为原始函数创建一个新指针，这意味着依赖于函数指针标识的代码可能会中断。因此，任何用``jumptable``注释的函数也必须是``unnamed_addr``。"

#: ../../LangRef.rst:1270
msgid "``minsize``"
msgstr ""

#: ../../LangRef.rst:1268
msgid "This attribute suggests that optimization passes and code generator passes make choices that keep the code size of this function as small as possible and perform optimizations that may sacrifice runtime performance in order to minimize the size of the generated code."
msgstr "此属性表明优化传递和代码生成器传递做出选择，使该函数的代码大小尽可能小，并执行可能牺牲运行时性能的优化，以便最小化生成的代码的大小。"

#: ../../LangRef.rst:1273
msgid "``naked``"
msgstr ""

#: ../../LangRef.rst:1273
msgid "This attribute disables prologue / epilogue emission for the function. This can have very system-specific consequences."
msgstr "此属性禁用该功能的序言/结尾发射。这可能会产生特定于系统的后果。"

#: ../../LangRef.rst:1279
msgid "``nobuiltin``"
msgstr ""

#: ../../LangRef.rst:1276
msgid "This indicates that the callee function at a call site is not recognized as a built-in function. LLVM will retain the original call and not replace it with equivalent code based on the semantics of the built-in function, unless the call site uses the ``builtin`` attribute. This is valid at call sites and on function declarations and definitions."
msgstr "这表示呼叫站点的被叫方功能未被识别为内置功能。 LLVM将保留原始调用，而不是基于内置函数的语义将其替换为等效代码，除非调用站点使用``builtin``属性。这在调用站点以及函数声明和定义中有效。"

#: ../../LangRef.rst:1290
msgid "``noduplicate``"
msgstr ""

#: ../../LangRef.rst:1282
msgid "This attribute indicates that calls to the function cannot be duplicated. A call to a ``noduplicate`` function may be moved within its parent function, but may not be duplicated within its parent function."
msgstr "此属性表示无法复制对函数的调用。对``noduplicate``函数的调用可以在其父函数内移动，但不能在其父函数内复制。"

#: ../../LangRef.rst:1287
msgid "A function containing a ``noduplicate`` call may still be an inlining candidate, provided that the call is not duplicated by inlining. That implies that the function has internal linkage and only has one call site, so the original call is dead after inlining."
msgstr "包含``noduplicate``调用的函数可能仍然是内联候选者，前提是该调用不是通过内联复制的。这意味着该函数具有内部链接，并且只有一个调用站点，因此内联后原始调用已经死亡。"

#: ../../LangRef.rst:1292
msgid "``noimplicitfloat``"
msgstr ""

#: ../../LangRef.rst:1293
msgid "This attributes disables implicit floating point instructions."
msgstr "此属性禁用隐式浮点指令。"

#: ../../LangRef.rst:1296
msgid "``noinline``"
msgstr ""

#: ../../LangRef.rst:1295
msgid "This attribute indicates that the inliner should never inline this function in any situation. This attribute may not be used together with the ``alwaysinline`` attribute."
msgstr "此属性指示内联器在任何情况下都不应该内联此函数。此属性不能与``alwaysinline``属性一起使用。"

#: ../../LangRef.rst:1300
msgid "``nonlazybind``"
msgstr ""

#: ../../LangRef.rst:1299
msgid "This attribute suppresses lazy symbol binding for the function. This may make calls to the function faster, at the cost of extra program startup time if the function is not called during program startup."
msgstr "此属性禁止该函数的延迟符号绑定。如果在程序启动期间未调用该函数，则可能会以额外的程序启动时间为代价更快地调用该函数。"

#: ../../LangRef.rst:1303
msgid "``noredzone``"
msgstr ""

#: ../../LangRef.rst:1303
msgid "This attribute indicates that the code generator should not use a red zone, even if the target-specific ABI normally permits it."
msgstr "此属性表示代码生成器不应使用红色区域，即使特定于目标的ABI通常允许它。"

#: ../../LangRef.rst:1307
msgid "``noreturn``"
msgstr ""

#: ../../LangRef.rst:1306
msgid "This function attribute indicates that the function never returns normally. This produces undefined behavior at runtime if the function ever does dynamically return."
msgstr "此函数属性表示函数永远不会正常返回。如果函数动态返回，则会在运行时生成未定义的行为。"

#: ../../LangRef.rst:1311
msgid "``norecurse``"
msgstr ""

#: ../../LangRef.rst:1310
msgid "This function attribute indicates that the function does not call itself either directly or indirectly down any possible call path. This produces undefined behavior at runtime if the function ever does recurse."
msgstr "此函数属性指示该函数不会直接或间接调用任何可能的调用路径。如果函数执行递归，这会在运行时产生未定义的行为。"

#: ../../LangRef.rst:1318
msgid "``nounwind``"
msgstr ""

#: ../../LangRef.rst:1314
msgid "This function attribute indicates that the function never raises an exception. If the function does raise an exception, its runtime behavior is undefined. However, functions marked nounwind may still trap or generate asynchronous exceptions. Exception handling schemes that are recognized by LLVM to handle asynchronous exceptions, such as SEH, will still provide their implementation defined semantics."
msgstr "此函数属性表示该函数从不引发异常。如果函数确实引发异常，则其运行时行为未定义。但是，标记为nounwind的函数仍可能陷阱或生成异步异常。 LLVM识别以处理异步异常（例如SEH）的异常处理方案仍将提供其实现定义的语义。"

#: ../../LangRef.rst:1330
msgid "``optnone``"
msgstr ""

#: ../../LangRef.rst:1321
msgid "This function attribute indicates that most optimization passes will skip this function, with the exception of interprocedural optimization passes. Code generation defaults to the \"fast\" instruction selector. This attribute cannot be used together with the ``alwaysinline`` attribute; this attribute is also incompatible with the ``minsize`` attribute and the ``optsize`` attribute."
msgstr "此函数属性指示大多数优化过程将跳过此函数，但过程间优化过程除外。代码生成默认为“快速”指令选择器。该属性不能与``alwaysinline``属性一起使用;此属性也与``minsize``属性和``optsize``属性不兼容。"

#: ../../LangRef.rst:1328
msgid "This attribute requires the ``noinline`` attribute to be specified on the function as well, so the function is never inlined into any caller. Only functions with the ``alwaysinline`` attribute are valid candidates for inlining into the body of this function."
msgstr "此属性也需要在函数上指定``noinline``属性，因此该函数永远不会内联到任何调用者。只有具有``alwaysinline``属性的函数才是内联到此函数体内的有效候选者。"

#: ../../LangRef.rst:1335
msgid "``optsize``"
msgstr ""

#: ../../LangRef.rst:1333
msgid "This attribute suggests that optimization passes and code generator passes make choices that keep the code size of this function low, and otherwise do optimizations specifically to reduce code size as long as they do not significantly impact runtime performance."
msgstr "此属性表明优化传递和代码生成器传递会做出选择，使此函数的代码大小保持较低，否则只要它们不会显着影响运行时性能，就会专门进行优化以减少代码大小。"

#: ../../LangRef.rst:1348
msgid "``readnone``"
msgstr ""

#: ../../LangRef.rst:1338
msgid "On a function, this attribute indicates that the function computes its result (or decides to unwind an exception) based strictly on its arguments, without dereferencing any pointer arguments or otherwise accessing any mutable state (e.g. memory, control registers, etc) visible to caller functions. It does not write through any pointer arguments (including ``byval`` arguments) and never changes any state visible to callers. This means that it cannot unwind exceptions by calling the ``C++`` exception throwing methods."
msgstr "在函数上，此属性指示函数严格基于其参数计算其结果（或决定解除异常），而不取消引用任何指针参数或以其他方式访问调用者可见的任何可变状态（例如，内存，控制寄存器等）功能。它不会通过任何指针参数（包括``byval``参数）写入，也不会更改调用者可见的任何状态。这意味着它不能通过调用``C ++``异常抛出方法来展开异常。"

#: ../../LangRef.rst:1347
msgid "On an argument, this attribute indicates that the function does not dereference that pointer argument, even though it may read or write the memory that the pointer points to if accessed through other pointers."
msgstr "在一个参数上，该属性指示该函数不取消引用该指针参数，即使它可以读取或写入指针指向的内存（如果通过其他指针访问）。"

#: ../../LangRef.rst:1362
msgid "``readonly``"
msgstr ""

#: ../../LangRef.rst:1351
msgid "On a function, this attribute indicates that the function does not write through any pointer arguments (including ``byval`` arguments) or otherwise modify any state (e.g. memory, control registers, etc) visible to caller functions. It may dereference pointer arguments and read state that may be set in the caller. A readonly function always returns the same value (or unwinds an exception identically) when called with the same set of arguments and global state. It cannot unwind an exception by calling the ``C++`` exception throwing methods."
msgstr "在函数上，此属性指示函数不通过任何指针参数（包括``byval``参数）写入或以其他方式修改调用函数可见的任何状态（例如，内存，控制寄存器等）。它可以取消引用可以在调用者中设置的指针参数和读取状态。当使用相同的参数集和全局状态调用时，只读函数始终返回相同的值（或相同地展开异常）。它不能通过调用``C ++``异常抛出方法来解除异常。"

#: ../../LangRef.rst:1361
msgid "On an argument, this attribute indicates that the function does not write through this pointer argument, even though it may write to the memory that the pointer points to."
msgstr "在参数上，此属性指示函数不会通过此指针参数进行写入，即使它可能会写入指针指向的内存。"

#: ../../LangRef.rst:1370
msgid "``argmemonly``"
msgstr ""

#: ../../LangRef.rst:1365
msgid "This attribute indicates that the only memory accesses inside function are loads and stores from objects pointed to by its pointer-typed arguments, with arbitrary offsets. Or in other words, all memory operations in the function can refer to memory only using pointers based on its function arguments. Note that ``argmemonly`` can be used together with ``readonly`` attribute in order to specify that function reads only from its arguments."
msgstr "此属性指示函数内部唯一的内存访问是从其指针类型参数指向的对象加载和存储，具有任意偏移。或者换句话说，函数中的所有内存操作只能使用基于其函数参数的指针来引用内存。请注意，``argmemonly``可以与``readonly``属性一起使用，以指定该函数只从其参数中读取。"

#: ../../LangRef.rst:1375
msgid "``returns_twice``"
msgstr ""

#: ../../LangRef.rst:1373
msgid "This attribute indicates that this function can return twice. The C ``setjmp`` is an example of such a function. The compiler disables some optimizations (like tail calls) in the caller of these functions."
msgstr "此属性表示此函数可以返回两次。 C``setjmp``就是这样一个函数的一个例子。编译器禁用这些函数调用者中的一些优化（如尾调用）。"

#: ../../LangRef.rst:1384
msgid "``safestack``"
msgstr ""

#: ../../LangRef.rst:1378
msgid "This attribute indicates that `SafeStack <http://clang.llvm.org/docs/SafeStack.html>`_ protection is enabled for this function."
msgstr "此属性表示为此功能启用了“SafeStack <http://clang.llvm.org/docs/SafeStack.html>`_ protection。"

#: ../../LangRef.rst:1382
msgid "If a function that has a ``safestack`` attribute is inlined into a function that doesn't have a ``safestack`` attribute or which has an ``ssp``, ``sspstrong`` or ``sspreq`` attribute, then the resulting function will have a ``safestack`` attribute."
msgstr "如果一个具有``safestack``属性的函数被内联到一个没有``safestack``属性或者有一个``ssp``，``sspstrong``或``sspreq``的函数中。属性，然后生成的函数将具有``safestack``属性。"

#: ../../LangRef.rst:1387
msgid "``sanitize_address``"
msgstr ""

#: ../../LangRef.rst:1387
msgid "This attribute indicates that AddressSanitizer checks (dynamic address safety analysis) are enabled for this function."
msgstr "此属性指示已为此功能启用AddressSanitizer检查（动态地址安全性分析）。"

#: ../../LangRef.rst:1390
msgid "``sanitize_memory``"
msgstr ""

#: ../../LangRef.rst:1390
msgid "This attribute indicates that MemorySanitizer checks (dynamic detection of accesses to uninitialized memory) are enabled for this function."
msgstr "此属性指示对此功能启用了MemorySanitizer检查（对未初始化内存的访问的动态检测）。"

#: ../../LangRef.rst:1393
msgid "``sanitize_thread``"
msgstr ""

#: ../../LangRef.rst:1393
msgid "This attribute indicates that ThreadSanitizer checks (dynamic thread safety analysis) are enabled for this function."
msgstr "此属性指示为此函数启用了ThreadSanitizer检查（动态线程安全分析）。"

#: ../../LangRef.rst:1412
msgid "``ssp``"
msgstr ""

#: ../../LangRef.rst:1396
msgid "This attribute indicates that the function should emit a stack smashing protector. It is in the form of a \"canary\" --- a random value placed on the stack before the local variables that's checked upon return from the function to see if it has been overwritten. A heuristic is used to determine if a function needs stack protectors or not. The heuristic used will enable protectors for functions with:"
msgstr "此属性表示该函数应发出堆栈粉碎保护器。它以“canary”的形式出现 - 在从函数返回时检查的局部变量之前放置在堆栈上的随机值，以查看它是否被覆盖。启发式用于确定函数是否需要堆栈保护程序。使用的启发式方法将为以下功能启用保护器："

#: ../../LangRef.rst:1403
msgid "Character arrays larger than ``ssp-buffer-size`` (default 8)."
msgstr "字符数组大于``ssp-buffer-size``（默认为8）。"

#: ../../LangRef.rst:1404
msgid "Aggregates containing character arrays larger than ``ssp-buffer-size``."
msgstr "包含大于`ssp-buffer-size``的字符数组的聚合。"

#: ../../LangRef.rst:1405
msgid "Calls to alloca() with variable sizes or constant sizes greater than ``ssp-buffer-size``."
msgstr "使用大于`ssp-buffer-size``的可变大小或常量大小调用alloca（）。"

#: ../../LangRef.rst:1408
msgid "Variables that are identified as requiring a protector will be arranged on the stack such that they are adjacent to the stack protector guard."
msgstr "被识别为需要保护器的变量将被布置在堆叠上，使得它们与堆叠保护器防护装置相邻。"

#: ../../LangRef.rst:1411
msgid "If a function that has an ``ssp`` attribute is inlined into a function that doesn't have an ``ssp`` attribute, then the resulting function will have an ``ssp`` attribute."
msgstr "如果一个具有``ssp``属性的函数被内联到一个没有``ssp``属性的函数中，那么结果函数将具有``ssp``属性。"

#: ../../LangRef.rst:1432
msgid "``sspreq``"
msgstr ""

#: ../../LangRef.rst:1415
msgid "This attribute indicates that the function should *always* emit a stack smashing protector. This overrides the ``ssp`` function attribute."
msgstr "此属性表示该函数应*始终*发出堆栈粉碎保护器。这会覆盖``ssp``函数属性。"

#: ../../LangRef.rst:1419 ../../LangRef.rst:1445
msgid "Variables that are identified as requiring a protector will be arranged on the stack such that they are adjacent to the stack protector guard. The specific layout rules are:"
msgstr "被识别为需要保护器的变量将被布置在堆叠上，使得它们与堆叠保护器防护装置相邻。具体的布局规则是："

#: ../../LangRef.rst:1423 ../../LangRef.rst:1449
msgid "Large arrays and structures containing large arrays (``>= ssp-buffer-size``) are closest to the stack protector."
msgstr "包含大数组（``= ssp-buffer-size``）的大型数组和结构最接近堆栈保护程序。"

#: ../../LangRef.rst:1425 ../../LangRef.rst:1451
msgid "Small arrays and structures containing small arrays (``< ssp-buffer-size``) are 2nd closest to the protector."
msgstr "包含小数组的小数组和结构（``<ssp-buffer-size``）距离保护器最近。"

#: ../../LangRef.rst:1427 ../../LangRef.rst:1453
msgid "Variables that have had their address taken are 3rd closest to the protector."
msgstr "获取地址的变量距保护器最近。"

#: ../../LangRef.rst:1430
msgid "If a function that has an ``sspreq`` attribute is inlined into a function that doesn't have an ``sspreq`` attribute or which has an ``ssp`` or ``sspstrong`` attribute, then the resulting function will have an ``sspreq`` attribute."
msgstr "如果一个具有``sspreq``属性的函数被内联到一个没有``sspreq``属性或者有一个``ssp``或``sspstrong``属性的函数中，那么结果函数将有一个``sspreq``属性。"

#: ../../LangRef.rst:1459
msgid "``sspstrong``"
msgstr ""

#: ../../LangRef.rst:1435
msgid "This attribute indicates that the function should emit a stack smashing protector. This attribute causes a strong heuristic to be used when determining if a function needs stack protectors. The strong heuristic will enable protectors for functions with:"
msgstr "此属性表示该函数应发出堆栈粉碎保护器。在确定函数是否需要堆栈保护程序时，此属性会导致使用强启发式算法。强大的启发式功能可以为以下功能提供保护："

#: ../../LangRef.rst:1440
msgid "Arrays of any size and type"
msgstr "任何大小和类型的数组"

#: ../../LangRef.rst:1441
msgid "Aggregates containing an array of any size and type."
msgstr "包含任何大小和类型的数组的聚合。"

#: ../../LangRef.rst:1442
msgid "Calls to alloca()."
msgstr ""

#: ../../LangRef.rst:1443
msgid "Local variables that have had their address taken."
msgstr "已经获取其地址的局部变量。"

#: ../../LangRef.rst:1456
msgid "This overrides the ``ssp`` function attribute."
msgstr "这会覆盖``ssp``函数属性。"

#: ../../LangRef.rst:1458
msgid "If a function that has an ``sspstrong`` attribute is inlined into a function that doesn't have an ``sspstrong`` attribute, then the resulting function will have an ``sspstrong`` attribute."
msgstr "如果一个具有``sspstrong``属性的函数被内联到一个没有``sspstrong``属性的函数中，那么结果函数将具有一个``sspstrong``属性。"

#: ../../LangRef.rst:1464
msgid "``\"thunk\"``"
msgstr "``\\ “咚\\”``"

#: ../../LangRef.rst:1462
msgid "This attribute indicates that the function will delegate to some other function with a tail call. The prototype of a thunk should not be used for optimization purposes. The caller is expected to cast the thunk prototype to match the thunk target prototype."
msgstr "此属性指示函数将通过尾调用委托给其他函数。 thunk的原型不应该用于优化目的。调用者应该投射thunk原型以匹配thunk目标原型。"

#: ../../LangRef.rst:1472
msgid "``uwtable``"
msgstr ""

#: ../../LangRef.rst:1467
msgid "This attribute indicates that the ABI being targeted requires that an unwind table entry be produced for this function even if we can show that no exceptions passes by it. This is normally the case for the ELF x86-64 abi, but it can be disabled for some compilation units."
msgstr "此属性指示要定向的ABI要求为此函数生成展开表条目，即使我们可以显示没有异常通过它。这通常是ELF x86-64 abi的情况，但是对于某些编译单元可以禁用它。"

#: ../../LangRef.rst:1477
msgid "Operand Bundles"
msgstr "操作数捆绑"

#: ../../LangRef.rst:1479
msgid "Note: operand bundles are a work in progress, and they should be considered experimental at this time."
msgstr "注意：操作数捆绑包是一项正在进行的工作，此时它们应被视为实验性的。"

#: ../../LangRef.rst:1482
msgid "Operand bundles are tagged sets of SSA values that can be associated with certain LLVM instructions (currently only ``call`` s and ``invoke`` s).  In a way they are like metadata, but dropping them is incorrect and will change program semantics."
msgstr "操作数包是标记的SSA值集，可以与某些LLVM指令相关联（目前只有``call``和``invoke``）。在某种程度上，它们就像元数据，但删除它们是不正确的，并将改变程序语义。"

#: ../../LangRef.rst:1494
msgid "Operand bundles are **not** part of a function's signature, and a given function may be called from multiple places with different kinds of operand bundles.  This reflects the fact that the operand bundles are conceptually a part of the ``call`` (or ``invoke``), not the callee being dispatched to."
msgstr "操作数包不是函数签名的一部分，并且可以从具有不同类型操作数包的多个位置调用给定函数。这反映了操作数bundle在概念上是``call``（或``invoke``）的一部分，而不是被调度的被调用者。"

#: ../../LangRef.rst:1500
msgid ""
"Operand bundles are a generic mechanism intended to support runtime-introspection-like functionality for managed languages.  While the exact semantics of an operand bundle depend on the bundle tag, there are certain limitations to how much the presence of an operand bundle can influence the semantics of a program.  These restrictions are described as the semantics of an \"unknown\" operand bundle.  As long as the behavior of an operand bundle is describable within these restrictions, LLVM does not need to have special knowledge of the operand bundle to not miscompile "
"programs containing it."
msgstr "操作数捆绑包是一种通用机制，旨在支持托管语言的类似运行时内省功能。虽然操作数包的确切语义依赖于bundle标记，但操作数包的存在可以影响程序语义的程度有一些限制。这些限制被描述为“未知”操作数包的语义。只要操作数包的行为在这些限制内是可描述的，LLVM就不需要具有操作数包的特殊知识就不会错误编译包含它的程序。"

#: ../../LangRef.rst:1510
msgid "The bundle operands for an unknown operand bundle escape in unknown ways before control is transferred to the callee or invokee."
msgstr "在将控制转移到被调用方或调用方之前，未知操作数包的包操作数以未知方式转义。"

#: ../../LangRef.rst:1512
msgid "Calls and invokes with operand bundles have unknown read / write effect on the heap on entry and exit (even if the call target is ``readnone`` or ``readonly``), unless they're overriden with callsite specific attributes."
msgstr "使用操作数包进行调用和调用在进入和退出时对堆具有未知的读/写效果（即使调用目标是``readnone``或``readonly``），除非它们被callsite特定属性覆盖。"

#: ../../LangRef.rst:1516
msgid "An operand bundle at a call site cannot change the implementation of the called function.  Inter-procedural optimizations work as usual as long as they take into account the first two properties."
msgstr "调用站点上的操作数包不能更改被调用函数的实现。程序间优化照常工作，只要它们考虑前两个属性即可。"

#: ../../LangRef.rst:1520
msgid "More specific types of operand bundles are described below."
msgstr "下面描述更具体类型的操作数束。"

#: ../../LangRef.rst:1523
msgid "Deoptimization Operand Bundles"
msgstr ""

#: ../../LangRef.rst:1525
msgid "Deoptimization operand bundles are characterized by the ``\"deopt\"`` operand bundle tag.  These operand bundles represent an alternate \"safe\" continuation for the call site they're attached to, and can be used by a suitable runtime to deoptimize the compiled frame at the specified call site.  There can be at most one ``\"deopt\"`` operand bundle attached to a call site.  Exact details of deoptimization is out of scope for the language reference, but it usually involves rewriting a compiled frame into a set of interpreted frames."
msgstr "去优化操作数包的特点是``\\“deopt \\”``操作数包标签。这些操作数包代表它们所附加的调用站点的备用“安全”延续，并且可由合适的运行时用于在指定的调用站点处对已编译的帧进行去优化。最多可以有一个``\\“deopt \\”``操作数包附加到一个调用站点。去优化的确切细节超出了语言参考的范围，但它通常涉及将编译的帧重写为一组解释的帧。"

#: ../../LangRef.rst:1534
msgid "From the compiler's perspective, deoptimization operand bundles make the call sites they're attached to at least ``readonly``.  They read through all of their pointer typed operands (even if they're not otherwise escaped) and the entire visible heap.  Deoptimization operand bundles do not capture their operands except during deoptimization, in which case control will not be returned to the compiled frame."
msgstr "从编译器的角度来看，去优化操作数捆绑使得它们所附着的调用站点至少是“只读”。他们读取了所有指针类型的操作数（即使它们没有被转义）和整个可见堆。除非在去优化期间，去优化操作数包不捕获它们的操作数，在这种情况下，控制将不会返回到编译的帧。"

#: ../../LangRef.rst:1542
msgid "The inliner knows how to inline through calls that have deoptimization operand bundles.  Just like inlining through a normal call site involves composing the normal and exceptional continuations, inlining through a call site with a deoptimization operand bundle needs to appropriately compose the \"safe\" deoptimization continuation.  The inliner does this by prepending the parent's deoptimization continuation to every deoptimization continuation in the inlined body. E.g. inlining ``@f`` into ``@g`` in the following example"
msgstr "内联器知道如何内联具有去优化操作数束的调用。就像通过正常调用站点内联涉及组成正常和异常延续一样，通过具有去优化操作数束的调用站点内联需要适当地组成“安全”去优化延续。内联器通过将父级的去优化继续前置于内联体中的每个去优化延续来实现此目的。例如，在以下示例中将``@ f``内联到``@ g``中"

#: ../../LangRef.rst:1565
msgid "will result in"
msgstr "会导致"

#: ../../LangRef.rst:1576
msgid "It is the frontend's responsibility to structure or encode the deoptimization state in a way that syntactically prepending the caller's deoptimization state to the callee's deoptimization state is semantically equivalent to composing the caller's deoptimization continuation after the callee's deoptimization continuation."
msgstr "前端的责任是以一种方式构造或编码去优化状态，在语法上将调用者的去优化状态置于被调用者的去优化状态在语义上等同于在被调用者的去优化继续之后组成调用者的去优化连续。"

#: ../../LangRef.rst:1585
msgid "Funclet Operand Bundles"
msgstr ""

#: ../../LangRef.rst:1587
msgid "Funclet operand bundles are characterized by the ``\"funclet\"`` operand bundle tag.  These operand bundles indicate that a call site is within a particular funclet.  There can be at most one ``\"funclet\"`` operand bundle attached to a call site and it must have exactly one bundle operand."
msgstr "Funclet操作数包的特点是``\\“funclet \\”``操作数包标签。这些操作数捆绑表示呼叫站点位于特定的funclet内。最多可以有一个``\\“funclet \\”``操作数包附加到一个调用站点，它必须只有一个操作数操作数。"

#: ../../LangRef.rst:1593
msgid "If any funclet EH pads have been \"entered\" but not \"exited\" (per the `description in the EH doc\\ <ExceptionHandling.html#wineh-constraints>`_), it is undefined behavior to execute a ``call`` or ``invoke`` which:"
msgstr "如果任何funclet EH pad已经“输入”但没有“退出”（根据EH doc \\ <ExceptionHandling.html＃wineh-constraints>`_中的`描述），执行a是未定义的行为``call``或``invoke``："

#: ../../LangRef.rst:1597
msgid "does not have a ``\"funclet\"`` bundle and is not a ``call`` to a nounwind intrinsic, or"
msgstr "没有``\\“funclet \\```bundle而不是对`nounwind内在的``call``，或者"

#: ../../LangRef.rst:1599
msgid "has a ``\"funclet\"`` bundle whose operand is not the most-recently-entered not-yet-exited funclet EH pad."
msgstr "有一个``\\“funclet \\```bundle，其操作数不是最近进入的尚未退出的funclet EH pad。"

#: ../../LangRef.rst:1602
msgid "Similarly, if no funclet EH pads have been entered-but-not-yet-exited, executing a ``call`` or ``invoke`` with a ``\"funclet\"`` bundle is undefined behavior."
msgstr "类似地，如果没有输入funclet EH pad但尚未退出，则使用``\\“funclet \\```bundle执行``call``或``invoke``是未定义的行为。"

#: ../../LangRef.rst:1608
msgid "Module-Level Inline Assembly"
msgstr "模块级内联汇编"

#: ../../LangRef.rst:1610
msgid "Modules may contain \"module-level inline asm\" blocks, which corresponds to the GCC \"file scope inline asm\" blocks. These blocks are internally concatenated by LLVM and treated as a single unit, but may be separated in the ``.ll`` file if desired. The syntax is very simple:"
msgstr "模块可能包含\\“模块级内联asm \\”块，它对应于GCC \\“文件范围内联asm \\”块。这些块在内部由LLVM连接并作为单个单元处理，但如果需要，可以在``.ll``文件中分隔。语法很简单："

#: ../../LangRef.rst:1620
msgid "The strings can contain any character by escaping non-printable characters. The escape sequence used is simply \"\\\\xx\" where \"xx\" is the two digit hex code for the number."
msgstr "字符串可以通过转义不可打印的字符来包含任何字符。使用的转义序列只是\\“\\\\ xx \\”，其中\\“xx \\”是数字的两位十六进制代码。"

#: ../../LangRef.rst:1624
msgid "Note that the assembly string *must* be parseable by LLVM's integrated assembler (unless it is disabled), even when emitting a ``.s`` file."
msgstr "请注意，汇编字符串*必须由LLVM的集成汇编程序解析（除非它被禁用），即使在发出``.s``文件时也是如此。"

#: ../../LangRef.rst:1630
msgid "Data Layout"
msgstr "数据布局"

#: ../../LangRef.rst:1632
msgid "A module may specify a target specific data layout string that specifies how data is to be laid out in memory. The syntax for the data layout is simply:"
msgstr "模块可以指定目标特定数据布局字符串，其指定如何在存储器中布置数据。数据布局的语法很简单："

#: ../../LangRef.rst:1640
msgid "The *layout specification* consists of a list of specifications separated by the minus sign character ('-'). Each specification starts with a letter and may include other information after the letter to define some aspect of the data layout. The specifications accepted are as follows:"
msgstr "*布局规范*由一个由减号字符（' - '）分隔的规范列表组成。每个规范都以字母开头，并且可以在字母后面包含其他信息以定义数据布局的某些方面。接受的规范如下："

#: ../../LangRef.rst:1648
msgid "``E``"
msgstr ""

#: ../../LangRef.rst:1647
msgid "Specifies that the target lays out data in big-endian form. That is, the bits with the most significance have the lowest address location."
msgstr "指定目标以big-endian形式布局数据。也就是说，具有最重要性的位具有最低的地址位置。"

#: ../../LangRef.rst:1652
msgid "``e``"
msgstr ""

#: ../../LangRef.rst:1651
msgid "Specifies that the target lays out data in little-endian form. That is, the bits with the least significance have the lowest address location."
msgstr "指定目标以little-endian形式布局数据。也就是说，具有最小重要性的位具有最低的地址位置。"

#: ../../LangRef.rst:1659
msgid "``S<size>``"
msgstr ""

#: ../../LangRef.rst:1655
msgid "Specifies the natural alignment of the stack in bits. Alignment promotion of stack variables is limited to the natural stack alignment to avoid dynamic stack realignment. The stack alignment must be a multiple of 8-bits. If omitted, the natural stack alignment defaults to \"unspecified\", which does not prevent any alignment promotions."
msgstr "以位为单位指定堆栈的自然对齐方式。堆栈变量的对齐促销仅限于自然堆栈对齐，以避免动态堆栈重新排列。堆栈对齐必须是8位的倍数。如果省略，自然堆栈对齐默认为“未指定”，这不会阻止任何对齐促销。"

#: ../../LangRef.rst:1665
msgid "``p[n]:<size>:<abi>:<pref>``"
msgstr ""

#: ../../LangRef.rst:1662
msgid "This specifies the *size* of a pointer and its ``<abi>`` and ``<pref>``\\erred alignments for address space ``n``. All sizes are in bits. The address space, ``n``, is optional, and if not specified, denotes the default address space 0. The value of ``n`` must be in the range [1,2^23)."
msgstr "这指定了指针的* size *及其地址空间`n``的``<abi>``和``<pref>``错误对齐。所有尺寸均为位。地址空间``n``是可选的，如果没有指定，则表示默认地址空间0.“n``的值必须在[1,2 ^ 23]范围内。"

#: ../../LangRef.rst:1668
msgid "``i<size>:<abi>:<pref>``"
msgstr ""

#: ../../LangRef.rst:1668
msgid "This specifies the alignment for an integer type of a given bit ``<size>``. The value of ``<size>`` must be in the range [1,2^23)."
msgstr "这指定了给定位``<size>``的整数类型的对齐方式。 ``<size>``的值必须在[1,2 ^ 23]范围内。"

#: ../../LangRef.rst:1671
msgid "``v<size>:<abi>:<pref>``"
msgstr ""

#: ../../LangRef.rst:1671
msgid "This specifies the alignment for a vector type of a given bit ``<size>``."
msgstr "这指定了给定位“<size>”`的向量类型的对齐方式。"

#: ../../LangRef.rst:1677
msgid "``f<size>:<abi>:<pref>``"
msgstr ""

#: ../../LangRef.rst:1674
msgid "This specifies the alignment for a floating point type of a given bit ``<size>``. Only values of ``<size>`` that are supported by the target will work. 32 (float) and 64 (double) are supported on all targets; 80 or 128 (different flavors of long double) are also supported on some targets."
msgstr "这指定了给定位``<size>``的浮点类型的对齐方式。只有目标支持的“<size>”值才有效。所有目标都支持32（浮点）和64（双）;某些目标也支持80或128（不同口味的长双）。"

#: ../../LangRef.rst:1679
msgid "``a:<abi>:<pref>``"
msgstr ""

#: ../../LangRef.rst:1680
msgid "This specifies the alignment for an object of aggregate type."
msgstr "这指定了聚合类型对象的对齐方式。"

#: ../../LangRef.rst:1691
msgid "``m:<mangling>``"
msgstr ""

#: ../../LangRef.rst:1682
msgid "If present, specifies that llvm names are mangled in the output. The options are"
msgstr "如果存在，则指定在输出中损坏llvm名称。选项是"

#: ../../LangRef.rst:1685
msgid "``e``: ELF mangling: Private symbols get a ``.L`` prefix."
msgstr "``e``：ELF mangling：私有符号得到一个``.L``前缀。"

#: ../../LangRef.rst:1686
msgid "``m``: Mips mangling: Private symbols get a ``$`` prefix."
msgstr "``m``：Mips mangling：私有符号得到一个``$``前缀。"

#: ../../LangRef.rst:1687
msgid "``o``: Mach-O mangling: Private symbols get ``L`` prefix. Other symbols get a ``_`` prefix."
msgstr "``o``：Mach-O mangling：私有符号得到``L``前缀。其他符号得到一个``_``前缀。"

#: ../../LangRef.rst:1689
msgid "``w``: Windows COFF prefix:  Similar to Mach-O, but stdcall and fastcall functions also get a suffix based on the frame size."
msgstr "``w``：Windows COFF前缀：与Mach-O类似，但stdcall和fastcall函数也根据帧大小得到后缀。"

#: ../../LangRef.rst:1691
msgid "``x``: Windows x86 COFF prefix:  Similar to Windows COFF, but use a ``_`` prefix for ``__cdecl`` functions."
msgstr "``x``：Windows x86 COFF前缀：类似于Windows COFF，但是对``__cdecl``函数使用``_``前缀。"

#: ../../LangRef.rst:1698
msgid "``n<size1>:<size2>:<size3>...``"
msgstr ""

#: ../../LangRef.rst:1694
msgid "This specifies a set of native integer widths for the target CPU in bits. For example, it might contain ``n32`` for 32-bit PowerPC, ``n32:64`` for PowerPC 64, or ``n8:16:32:64`` for X86-64. Elements of this set are considered to support most general arithmetic operations efficiently."
msgstr "它以位为单位指定目标CPU的一组本机整数宽度。例如，它可能包含32位PowerPC的``n32``，PowerPC 64的``n32：64``或X86-64的``n8：16：32：64``。该集合的元素被认为有效地支持大多数通用算术运算。"

#: ../../LangRef.rst:1700
msgid "On every specification that takes a ``<abi>:<pref>``, specifying the ``<pref>`` alignment is optional. If omitted, the preceding ``:`` should be omitted too and ``<pref>`` will be equal to ``<abi>``."
msgstr "在每个带有``<abi>：<pref>``的规范中，指定``<pref>``alignment是可选的。如果省略，前面的``：``也应该省略，``<pref>``将等于``<abi>``。"

#: ../../LangRef.rst:1704
msgid "When constructing the data layout for a given target, LLVM starts with a default set of specifications which are then (possibly) overridden by the specifications in the ``datalayout`` keyword. The default specifications are given in this list:"
msgstr "在为给定目标构造数据布局时，LLVM以一组默认规范开始，然后（可能）被``datalayout``关键字中的规范覆盖。此列表中给出了默认规范："

#: ../../LangRef.rst:1709
msgid "``E`` - big endian"
msgstr ""

#: ../../LangRef.rst:1710
msgid "``p:64:64:64`` - 64-bit pointers with 64-bit alignment."
msgstr "``p：64：64：64``  - 具有64位对齐的64位指针。"

#: ../../LangRef.rst:1711
msgid "``p[n]:64:64:64`` - Other address spaces are assumed to be the same as the default address space."
msgstr "``p [n]：64：64：64``  - 假设其他地址空间与默认地址空间相同。"

#: ../../LangRef.rst:1713
msgid "``S0`` - natural stack alignment is unspecified"
msgstr "``S0``  - 未指定自然堆栈对齐"

#: ../../LangRef.rst:1714
msgid "``i1:8:8`` - i1 is 8-bit (byte) aligned"
msgstr "``i1：8：8``  -  i1是8位（字节）对齐的"

#: ../../LangRef.rst:1715
msgid "``i8:8:8`` - i8 is 8-bit (byte) aligned"
msgstr "``i8：8：8``  -  i8是8位（字节）对齐的"

#: ../../LangRef.rst:1716
msgid "``i16:16:16`` - i16 is 16-bit aligned"
msgstr "``i16：16：16``  -  i16是16位对齐的"

#: ../../LangRef.rst:1717
msgid "``i32:32:32`` - i32 is 32-bit aligned"
msgstr "``i32：32：32``  -  i32是32位对齐的"

#: ../../LangRef.rst:1718
msgid "``i64:32:64`` - i64 has ABI alignment of 32-bits but preferred alignment of 64-bits"
msgstr "``i64：32：64``  -  i64具有32位的ABI对齐，但优选的是64位的对齐"

#: ../../LangRef.rst:1720
msgid "``f16:16:16`` - half is 16-bit aligned"
msgstr "``f16：16：16``  - 一半是16位对齐"

#: ../../LangRef.rst:1721
msgid "``f32:32:32`` - float is 32-bit aligned"
msgstr "``f32：32：32``  -  float是32位对齐的"

#: ../../LangRef.rst:1722
msgid "``f64:64:64`` - double is 64-bit aligned"
msgstr "``f64：64：64``  -  double是64位对齐的"

#: ../../LangRef.rst:1723
msgid "``f128:128:128`` - quad is 128-bit aligned"
msgstr "``f128：128：128``  - 四边形是128位对齐的"

#: ../../LangRef.rst:1724
msgid "``v64:64:64`` - 64-bit vector is 64-bit aligned"
msgstr "``v64：64：64``  -  64位向量是64位对齐的"

#: ../../LangRef.rst:1725
msgid "``v128:128:128`` - 128-bit vector is 128-bit aligned"
msgstr "``v128：128：128``  -  128位向量是128位对齐的"

#: ../../LangRef.rst:1726
msgid "``a:0:64`` - aggregates are 64-bit aligned"
msgstr "``a：0：64``  - 聚合是64位对齐的"

#: ../../LangRef.rst:1728
msgid "When LLVM is determining the alignment for a given type, it uses the following rules:"
msgstr "当LLVM确定给定类型的对齐时，它使用以下规则："

#: ../../LangRef.rst:1731
msgid "If the type sought is an exact match for one of the specifications, that specification is used."
msgstr "如果所寻求的类型与其中一个规范完全匹配，则使用该规范。"

#: ../../LangRef.rst:1733
msgid "If no match is found, and the type sought is an integer type, then the smallest integer type that is larger than the bitwidth of the sought type is used. If none of the specifications are larger than the bitwidth then the largest integer type is used. For example, given the default specifications above, the i7 type will use the alignment of i8 (next largest) while both i65 and i256 will use the alignment of i64 (largest specified)."
msgstr "如果未找到匹配，并且所寻求的类型是整数类型，则使用大于所寻求类型的位宽的最小整数类型。如果没有规范大于位宽，则使用最大整数类型。例如，根据上面的默认规范，i7类型将使用i8（下一个最大）的对齐，而i65和i256将使用i64的对齐（指定的最大值）。"

#: ../../LangRef.rst:1740
msgid "If no match is found, and the type sought is a vector type, then the largest vector type that is smaller than the sought vector type will be used as a fall back. This happens because <128 x double> can be implemented in terms of 64 <2 x double>, for example."
msgstr "如果未找到匹配，并且所寻找的类型是矢量类型，则小于所寻求的矢量类型的最大矢量类型将用作后退。这是因为<128 x double>可以用例如64 <2 x double>来实现。"

#: ../../LangRef.rst:1745
msgid "The function of the data layout string may not be what you expect. Notably, this is not a specification from the frontend of what alignment the code generator should use."
msgstr "数据布局字符串的功能可能不是您所期望的。值得注意的是，这不是来自代码生成器应该使用什么对齐的前端的规范。"

#: ../../LangRef.rst:1749
msgid ""
"Instead, if specified, the target data layout is required to match what the ultimate *code generator* expects. This string is used by the mid-level optimizers to improve code, and this only works if it matches what the ultimate code generator uses. There is no way to generate IR that does not embed this target-specific detail into the IR. If you don't specify the string, the default specifications will be used to generate a Data Layout and the optimization phases will operate accordingly and introduce target specificity into the IR with respect to these default "
"specifications."
msgstr "相反，如果指定，则需要目标数据布局以匹配最终*代码生成器*期望的内容。中级优化器使用此字符串来改进代码，这仅在与最终代码生成器使用的内容匹配时才有效。没有办法生成没有将此特定于目标的细节嵌入IR的IR。如果您未指定字符串，则默认规范将用于生成数据布局，优化阶段将相应地运行，并根据这些默认规范将目标特异性引入IR。"

#: ../../LangRef.rst:1762
msgid "Target Triple"
msgstr "目标三倍"

#: ../../LangRef.rst:1764
msgid "A module may specify a target triple string that describes the target host. The syntax for the target triple is simply:"
msgstr "模块可以指定描述目标主机的目标三元组串。目标三元组的语法很简单："

#: ../../LangRef.rst:1771
msgid "The *target triple* string consists of a series of identifiers delimited by the minus sign character ('-'). The canonical forms are:"
msgstr "* target triple *字符串由一系列由减号字符（' - '）分隔的标识符组成。规范形式是："

#: ../../LangRef.rst:1779
msgid "This information is passed along to the backend so that it generates code for the proper architecture. It's possible to override this on the command line with the ``-mtriple`` command line option."
msgstr "此信息将传递到后端，以便为正确的体系结构生成代码。可以使用``-mtriple``命令行选项在命令行上覆盖它。"

#: ../../LangRef.rst:1786
msgid "Pointer Aliasing Rules"
msgstr "指针别名规则"

#: ../../LangRef.rst:1788
msgid "Any memory access must be done through a pointer value associated with an address range of the memory access, otherwise the behavior is undefined. Pointer values are associated with address ranges according to the following rules:"
msgstr "任何内存访问都必须通过与内存访问的地址范围相关联的指针值来完成，否则行为是未定义的。指针值根据以下规则与地址范围相关联："

#: ../../LangRef.rst:1793
msgid "A pointer value is associated with the addresses associated with any value it is *based* on."
msgstr "指针值与与*基于*的任何值相关联的地址相关联。"

#: ../../LangRef.rst:1795
msgid "An address of a global variable is associated with the address range of the variable's storage."
msgstr "全局变量的地址与变量存储的地址范围相关联。"

#: ../../LangRef.rst:1797
msgid "The result value of an allocation instruction is associated with the address range of the allocated storage."
msgstr "分配指令的结果值与分配的存储的地址范围相关联。"

#: ../../LangRef.rst:1799
msgid "A null pointer in the default address-space is associated with no address."
msgstr "默认地址空间中的空指针与没有地址相关联。"

#: ../../LangRef.rst:1801
msgid "An integer constant other than zero or a pointer value returned from a function not defined within LLVM may be associated with address ranges allocated through mechanisms other than those provided by LLVM. Such ranges shall not overlap with any ranges of addresses allocated by mechanisms provided by LLVM."
msgstr "除了零之外的整数常量或从未在LLVM内定义的函数返回的指针值可以与通过LLVM提供的机制之外的机制分配的地址范围相关联。此类范围不得与LLVM提供的机制分配的任何地址范围重叠。"

#: ../../LangRef.rst:1807
msgid "A pointer value is *based* on another pointer value according to the following rules:"
msgstr "根据以下规则，指针值是*基于*的另一个指针值："

#: ../../LangRef.rst:1810
msgid "A pointer value formed from a ``getelementptr`` operation is *based* on the first value operand of the ``getelementptr``."
msgstr "由``getelementptr``操作形成的指针值是基于``getelementptr``的第一个值操作数的* *。"

#: ../../LangRef.rst:1812
msgid "The result value of a ``bitcast`` is *based* on the operand of the ``bitcast``."
msgstr "“bitcast”的结果值是基于“bitcast”的操作数的* *。"

#: ../../LangRef.rst:1814
msgid "A pointer value formed by an ``inttoptr`` is *based* on all pointer values that contribute (directly or indirectly) to the computation of the pointer's value."
msgstr "由“inttoptr`”形成的指针值是基于所有指针值的* *，这些指针值（直接或间接地）有助于计算指针的值。"

#: ../../LangRef.rst:1817
msgid "The \"*based* on\" relationship is transitive."
msgstr "基于“* * * on”的关系是可传递的。"

#: ../../LangRef.rst:1819
msgid "Note that this definition of *\"based\"* is intentionally similar to the definition of *\"based\"* in C99, though it is slightly weaker."
msgstr "请注意，* \\“based \\”*的这个定义有意类似于C99中* \\“based \\”*的定义，尽管它略微弱一些。"

#: ../../LangRef.rst:1822
msgid "LLVM IR does not associate types with memory. The result type of a ``load`` merely indicates the size and alignment of the memory from which to load, as well as the interpretation of the value. The first operand type of a ``store`` similarly only indicates the size and alignment of the store."
msgstr "LLVM IR不会将类型与内存关联。 “load”的结果类型仅表示要加载的内存的大小和对齐方式，以及值的解释。 “store”的第一个操作数类型同样仅表示商店的大小和对齐方式。"

#: ../../LangRef.rst:1828
msgid "Consequently, type-based alias analysis, aka TBAA, aka ``-fstrict-aliasing``, is not applicable to general unadorned LLVM IR. :ref:`Metadata <metadata>` may be used to encode additional information which specialized optimization passes may use to implement type-based alias analysis."
msgstr "因此，基于类型的别名分析，即TBAA，又名“-fstrict-aliasing”，不适用于一般的非修饰LLVM IR。 ：ref：`元数据<元数据>`可用于编码附加信息，专业优化传递可用于实现基于类型的别名分析。"

#: ../../LangRef.rst:1837
msgid "Volatile Memory Accesses"
msgstr "易失性存储器访问"

#: ../../LangRef.rst:1839
msgid "Certain memory accesses, such as :ref:`load <i_load>`'s, :ref:`store <i_store>`'s, and :ref:`llvm.memcpy <int_memcpy>`'s may be marked ``volatile``. The optimizers must not change the number of volatile operations or change their order of execution relative to other volatile operations. The optimizers *may* change the order of volatile operations relative to non-volatile operations. This is not Java's \"volatile\" and has no cross-thread synchronization behavior."
msgstr "某些内存访问，例如：ref：`load <i_load>`s，：ref：`store <i_store>`s，以及：ref：`llvm.memcpy <int_memcpy>`s可能被标记为``volatile ``。优化器不得更改易失性操作的数量或相对于其他易失性操作更改其执行顺序。优化器*可以*相对于非易失性操作改变易失性操作的顺序。这不是Java的“volatile”，也没有跨线程同步行为。"

#: ../../LangRef.rst:1847
msgid "IR-level volatile loads and stores cannot safely be optimized into llvm.memcpy or llvm.memmove intrinsics even when those intrinsics are flagged volatile. Likewise, the backend should never split or merge target-legal volatile load/store instructions."
msgstr "IR级别的易失性加载和存储无法安全地优化为llvm.memcpy或llvm.memmove内在函数，即使这些内在函数被标记为volatile。同样，后端不应该拆分或合并目标合法的易失性加载/存储指令。"

#: ../../LangRef.rst:1852
msgid "Rationale"
msgstr "合理"

#: ../../LangRef.rst:1854
msgid "Platforms may rely on volatile loads and stores of natively supported data width to be executed as single instruction. For example, in C this holds for an l-value of volatile primitive type with native hardware support, but not necessarily for aggregate types. The frontend upholds these expectations, which are intentionally unspecified in the IR. The rules above ensure that IR transformations do not violate the frontend's contract with the language."
msgstr "平台可以依赖于易失性加载和本机支持的数据宽度的存储作为单个指令执行。例如，在C中，这适用于具有本机硬件支持的易失性原始类型的l值，但不一定适用于聚合类型。前端支持这些期望，这些期望在IR中故意未指定。上述规则确保IR转换不会违反前端与语言的契约。"

#: ../../LangRef.rst:1865
msgid "Memory Model for Concurrent Operations"
msgstr "并发操作的内存模型"

#: ../../LangRef.rst:1867
msgid "The LLVM IR does not define any way to start parallel threads of execution or to register signal handlers. Nonetheless, there are platform-specific ways to create them, and we define LLVM IR's behavior in their presence. This model is inspired by the C++0x memory model."
msgstr "LLVM IR没有定义任何启动并行执行线程或注册信号处理程序的方法。尽管如此，还是有特定于平台的方法来创建它们，我们定义了LLVM IR在其存在时的行为。此模型的灵感来自C ++ 0x内存模型。"

#: ../../LangRef.rst:1872
msgid "For a more informal introduction to this model, see the :doc:`Atomics`."
msgstr "有关此模型的更为非正式的介绍，请参阅：doc：`Atomics`。"

#: ../../LangRef.rst:1874
msgid "We define a *happens-before* partial order as the least partial order that"
msgstr "我们将*发生前*部分顺序定义为最不偏序"

#: ../../LangRef.rst:1877
msgid "Is a superset of single-thread program order, and"
msgstr "是单线程程序的超集，并且"

#: ../../LangRef.rst:1878
msgid "When a *synchronizes-with* ``b``, includes an edge from ``a`` to ``b``. *Synchronizes-with* pairs are introduced by platform-specific techniques, like pthread locks, thread creation, thread joining, etc., and by atomic instructions. (See also :ref:`Atomic Memory Ordering Constraints <ordering>`)."
msgstr "当*与*``b``同步时，包括从``a``到``b``的边。 * Synchronizes-with *对由特定于平台的技术引入，如pthread锁，线程创建，线程连接等，以及原子指令。 （另请参阅：ref：`原子存储器排序约束<ordering>`）。"

#: ../../LangRef.rst:1884
msgid "Note that program order does not introduce *happens-before* edges between a thread and signals executing inside that thread."
msgstr "请注意，程序顺序不会在线程和在该线程内执行的信号之间引入* before-before * edge。"

#: ../../LangRef.rst:1887
msgid "Every (defined) read operation (load instructions, memcpy, atomic loads/read-modify-writes, etc.) R reads a series of bytes written by (defined) write operations (store instructions, atomic stores/read-modify-writes, memcpy, etc.). For the purposes of this section, initialized globals are considered to have a write of the initializer which is atomic and happens before any other read or write of the memory in question. For each byte of a read R, R\\ :sub:`byte` may see any write to the same byte, except:"
msgstr "每个（定义的）读操作（加载指令，memcpy，原子加载/读 - 修改 - 写等）R读取由（定义的）写操作写的一系列字节（存储指令，原子存储/读 - 修改 - 写， memcpy等）。出于本节的目的，初始化的全局变量被认为具有初始化器的写入，该初始化器是原子的并且在对所讨论的存储器的任何其他读取或写入之前发生。对于读R的每个字节，R \\：sub：`byte`可以看到对同一字节的任何写操作，除了："

#: ../../LangRef.rst:1896
msgid "If write\\ :sub:`1`  happens before write\\ :sub:`2`, and write\\ :sub:`2` happens before R\\ :sub:`byte`, then R\\ :sub:`byte` does not see write\\ :sub:`1`."
msgstr "如果写\\：sub：`1`在写\\：sub：`2`之前发生，而写\\：sub：`2`发生在R \\：sub：`byte`之前，那么R \\：sub ：`byte`看不到写\\：sub：`1`。"

#: ../../LangRef.rst:1899
msgid "If R\\ :sub:`byte` happens before write\\ :sub:`3`, then R\\ :sub:`byte` does not see write\\ :sub:`3`."
msgstr "如果在写\\：sub：`3`之前发生R \\：sub：`byte`，则R \\：sub：`byte`看不到写\\：sub：`3`。"

#: ../../LangRef.rst:1902
msgid "Given that definition, R\\ :sub:`byte` is defined as follows:"
msgstr "鉴于该定义，R \\：sub：`byte`定义如下："

#: ../../LangRef.rst:1904
msgid "If R is volatile, the result is target-dependent. (Volatile is supposed to give guarantees which can support ``sig_atomic_t`` in C/C++, and may be used for accesses to addresses that do not behave like normal memory. It does not generally provide cross-thread synchronization.)"
msgstr "如果R是易失性的，则结果与目标有关。 （Volatile应该提供可以在C / C ++中支持``sig_atomic_t``的保证，并且可以用于访问不像普通内存那样的地址。它通常不提供跨线程同步。）"

#: ../../LangRef.rst:1909
msgid "Otherwise, if there is no write to the same byte that happens before R\\ :sub:`byte`, R\\ :sub:`byte` returns ``undef`` for that byte."
msgstr "否则，如果没有写入在R \\：sub：`byte`之前发生的相同字节，则R \\：sub：`byte`将返回该字节的``undef``。"

#: ../../LangRef.rst:1911
msgid "Otherwise, if R\\ :sub:`byte` may see exactly one write, R\\ :sub:`byte` returns the value written by that write."
msgstr "否则，如果R \\：sub：`byte`可能只看到一个写，则R \\：sub：`byte`返回该写入写入的值。"

#: ../../LangRef.rst:1913
msgid "Otherwise, if R is atomic, and all the writes R\\ :sub:`byte` may see are atomic, it chooses one of the values written. See the :ref:`Atomic Memory Ordering Constraints <ordering>` section for additional constraints on how the choice is made."
msgstr "否则，如果R是原子的，并且R \\：sub：`byte`的所有写操作都是原子的，它会选择其中一个写入的值。请参阅：ref：`原子存储器排序约束<ordering>`部分，了解有关如何进行选择的其他限制。"

#: ../../LangRef.rst:1917
msgid "Otherwise R\\ :sub:`byte` returns ``undef``."
msgstr "否则R \\：sub：`byte`返回``undef``。"

#: ../../LangRef.rst:1919
msgid "R returns the value composed of the series of bytes it read. This implies that some bytes within the value may be ``undef`` **without** the entire value being ``undef``. Note that this only defines the semantics of the operation; it doesn't mean that targets will emit more than one instruction to read the series of bytes."
msgstr "R返回由它读取的一系列字节组成的值。这意味着值中的某些字节可能是``undef`` **而没有**整个值是``undef``。注意，这只定义了操作的语义;这并不意味着目标将发出多条指令来读取一系列字节。"

#: ../../LangRef.rst:1925
msgid "Note that in cases where none of the atomic intrinsics are used, this model places only one restriction on IR transformations on top of what is required for single-threaded execution: introducing a store to a byte which might not otherwise be stored is not allowed in general. (Specifically, in the case where another thread might write to and read from an address, introducing a store can change a load that may see exactly one write into a load that may see multiple writes.)"
msgstr "请注意，在没有使用任何原子内在函数的情况下，此模型在单线程执行所需的基础上仅对IR转换设置了一个限制：将存储引入到可能无法存储的字节中是不允许的一般。 （具体来说，在另一个线程可能写入和读取地址的情况下，引入存储可以更改一个负载，该负载可能只看到一个写入可能看到多次写入的负载。）"

#: ../../LangRef.rst:1936
msgid "Atomic Memory Ordering Constraints"
msgstr "原子记忆排序约束"

#: ../../LangRef.rst:1938
msgid ""
"Atomic instructions (:ref:`cmpxchg <i_cmpxchg>`, :ref:`atomicrmw <i_atomicrmw>`, :ref:`fence <i_fence>`, :ref:`atomic load <i_load>`, and :ref:`atomic store <i_store>`) take ordering parameters that determine which other atomic instructions on the same address they *synchronize with*. These semantics are borrowed from Java and C++0x, but are somewhat more colloquial. If these descriptions aren't precise enough, check those specs (see spec references in the :doc:`atomics guide <Atomics>`). :ref:`fence <i_fence>` instructions treat these orderings somewhat differently "
"since they don't take an address. See that instruction's documentation for details."
msgstr "原子指令（：ref：`cmpxchg <i_cmpxchg>`，：ref：`atomicrmw <i_atomicrmw>`，：ref：`fence <i_fence>`，：ref：`atomic load <i_load>`，和：ref：`atomic store <i_store>`）获取排序参数，这些参数确定与*同步的同一地址上的哪些其他原子指令。这些语义是从Java和C ++ 0x借用的，但更加口语化。如果这些描述不够精确，请检查这些规范（参见：doc：`atomics guide <Atomics>`中的规范参考）。 ：ref：`fence <i_fence>`指令对这些排序的处理方式略有不同，因为它们没有地址。有关详细信息，请参阅该说明的文档。"

#: ../../LangRef.rst:1950
msgid "For a simpler introduction to the ordering constraints, see the :doc:`Atomics`."
msgstr "有关排序约束的简单介绍，请参阅：doc：`Atomics`。"

#: ../../LangRef.rst:1958
msgid "``unordered``"
msgstr ""

#: ../../LangRef.rst:1954
msgid "The set of values that can be read is governed by the happens-before partial order. A value cannot be read unless some operation wrote it. This is intended to provide a guarantee strong enough to model Java's non-volatile shared variables. This ordering cannot be specified for read-modify-write operations; it is not strong enough to make them atomic in any interesting way."
msgstr "可以读取的值集由发生在前的部分顺序控制。除非某些操作写入，否则无法读取值。这旨在提供足够强大的保证来模拟Java的非易失性共享变量。无法为读 - 修改 - 写操作指定此排序;它不够强大，不能以任何有趣的方式使它们成为原子。"

#: ../../LangRef.rst:1976
msgid "``monotonic``"
msgstr ""

#: ../../LangRef.rst:1961
msgid ""
"In addition to the guarantees of ``unordered``, there is a single total order for modifications by ``monotonic`` operations on each address. All modification orders must be compatible with the happens-before order. There is no guarantee that the modification orders can be combined to a global total order for the whole program (and this often will not be possible). The read in an atomic read-modify-write operation (:ref:`cmpxchg <i_cmpxchg>` and :ref:`atomicrmw <i_atomicrmw>`) reads the value in the modification order immediately before the value it writes. If one "
"atomic read happens before another atomic read of the same address, the later read must see the same value or a later value in the address's modification order. This disallows reordering of ``monotonic`` (or stronger) operations on the same address. If an address is written ``monotonic``-ally by one thread, and other threads ``monotonic``-ally read that address repeatedly, the other threads must eventually see the write. This corresponds to the C++0x/C1x ``memory_order_relaxed``."
msgstr ""
"除了``unordered``的保证之外，每个地址上的``monotonic``操作都有一个单一的总修改顺序。所有修改订单必须与先前发生的订单兼容。无法保证修改订单可以合并到整个程序的全局总订单中（这通常是不可能的）。读取原子读 - 修改 - 写操作（：ref：`cmpxchg <i_cmpxchg>`和：ref：`atomicrmw <i_atomicrmw>`）在它写入的值之前立即读取修改顺序中的值。如果在同一地址的另一个原子读取之前发生一次原子读取，则后一次读取必须在地址的修改顺序中看到相同的值或更晚的值。这不允许在同一地址上重新排序“单调”（或更强）的操作。如果一个地址被一个线程写成``monotonic``-ally，而其他线程``monotonic``-ally反复读取该地"
"址，其他线程最终必须看到写入。这对应于C ++ 0x / C1x`“memory_order_relaxed``。"

#: ../../LangRef.rst:1980
msgid "``acquire``"
msgstr ""

#: ../../LangRef.rst:1979
msgid "In addition to the guarantees of ``monotonic``, a *synchronizes-with* edge may be formed with a ``release`` operation. This is intended to model C++'s ``memory_order_acquire``."
msgstr "除了``monotonic``的保证之外，可以用``release``操作形成* synchronize-with * edge。这是为了模拟C ++的``memory_order_acquire``。"

#: ../../LangRef.rst:1987
msgid "``release``"
msgstr ""

#: ../../LangRef.rst:1983
msgid "In addition to the guarantees of ``monotonic``, if this operation writes a value which is subsequently read by an ``acquire`` operation, it *synchronizes-with* that operation. (This isn't a complete description; see the C++0x definition of a release sequence.) This corresponds to the C++0x/C1x ``memory_order_release``."
msgstr "除了``monotonic``的保证之外，如果此操作写入一个随后由``acquire``操作读取的值，它*与该操作同步*。 （这不是一个完整的描述;请参阅发布序列的C ++ 0x定义。）这对应于C ++ 0x / C1x`“memory_order_release``。"

#: ../../LangRef.rst:1990
msgid "``acq_rel`` (acquire+release)"
msgstr "``acq_rel``（获得+发布）"

#: ../../LangRef.rst:1990
msgid "Acts as both an ``acquire`` and ``release`` operation on its address. This corresponds to the C++0x/C1x ``memory_order_acq_rel``."
msgstr "在其地址上充当“获取”和“释放”操作。这对应于C ++ 0x / C1x`“memory_order_acq_rel``。"

#: ../../LangRef.rst:2001
msgid "``seq_cst`` (sequentially consistent)"
msgstr "``seq_cst``（顺序一致）"

#: ../../LangRef.rst:1993
msgid "In addition to the guarantees of ``acq_rel`` (``acquire`` for an operation that only reads, ``release`` for an operation that only writes), there is a global total order on all sequentially-consistent operations on all addresses, which is consistent with the *happens-before* partial order and with the modification orders of all the affected addresses. Each sequentially-consistent read sees the last preceding write to the same address in this global order. This corresponds to the C++0x/C1x ``memory_order_seq_cst`` and Java volatile."
msgstr "除了保证``acq_rel``（对于只读操作的``acquire``，对于只写操作的``release``），所有顺序一致的操作都有一个全局总命令。所有地址，与* before-before * partial order以及所有受影响地址的修改顺序一致。每个顺序一致的读取在此全局顺序中查看最后一次写入相同地址。这对应于C ++ 0x / C1x`“memory_order_seq_cst``和Java volatile。"

#: ../../LangRef.rst:2005
msgid "If an atomic operation is marked ``singlethread``, it only *synchronizes with* or participates in modification and seq\\_cst total orderings with other operations running in the same thread (for example, in signal handlers)."
msgstr "如果原子操作被标记为``singlethread``，它只与*同步*或参与修改和seq \\ _ cst总排序与在同一线程中运行的其他操作（例如，在信号处理程序中）。"

#: ../../LangRef.rst:2013
msgid "Fast-Math Flags"
msgstr "快速数学标志"

#: ../../LangRef.rst:2015
msgid "LLVM IR floating-point binary ops (:ref:`fadd <i_fadd>`, :ref:`fsub <i_fsub>`, :ref:`fmul <i_fmul>`, :ref:`fdiv <i_fdiv>`, :ref:`frem <i_frem>`, :ref:`fcmp <i_fcmp>`) have the following flags that can be set to enable otherwise unsafe floating point operations"
msgstr "LLVM IR浮点二进制ops（：ref：`fadd <i_fadd>`，：ref：`fsub <i_fsub>`，：ref：`fmul <i_fmul>`，：ref：`fdiv <i_fdiv>`，：ref ：`frem <i_frem>`，：ref：`fcmp <i_fcmp>`）具有以下标志，可以设置为启用其他不安全的浮点运算"

#: ../../LangRef.rst:2023
msgid "``nnan``"
msgstr ""

#: ../../LangRef.rst:2021
msgid "No NaNs - Allow optimizations to assume the arguments and result are not NaN. Such optimizations are required to retain defined behavior over NaNs, but the value of the result is undefined."
msgstr "无NaN  - 允许优化假设参数和结果不是NaN。需要进行此类优化以保留NaN上定义的行为，但结果的值未定义。"

#: ../../LangRef.rst:2028
msgid "``ninf``"
msgstr ""

#: ../../LangRef.rst:2026
msgid "No Infs - Allow optimizations to assume the arguments and result are not +/-Inf. Such optimizations are required to retain defined behavior over +/-Inf, but the value of the result is undefined."
msgstr "No Infs  - 允许优化假设参数和结果不是+/- Inf。需要进行此类优化以保留+/- Inf上定义的行为，但结果的值未定义。"

#: ../../LangRef.rst:2032
msgid "``nsz``"
msgstr ""

#: ../../LangRef.rst:2031
msgid "No Signed Zeros - Allow optimizations to treat the sign of a zero argument or result as insignificant."
msgstr "No Signed Zeros  - 允许优化将零参数或结果的符号视为无关紧要。"

#: ../../LangRef.rst:2036
msgid "``arcp``"
msgstr ""

#: ../../LangRef.rst:2035
msgid "Allow Reciprocal - Allow optimizations to use the reciprocal of an argument rather than perform division."
msgstr "允许Reciprocal  - 允许优化使用参数的倒数而不是执行除法。"

#: ../../LangRef.rst:2041
msgid "``fast``"
msgstr ""

#: ../../LangRef.rst:2039
msgid "Fast - Allow algebraically equivalent transformations that may dramatically change results in floating point (e.g. reassociate). This flag implies all the others."
msgstr "快速 - 允许代数等效的转换，可能会显着改变浮点结果（例如重新关联）。这个标志暗示了所有其他标志。"

#: ../../LangRef.rst:2046
msgid "Use-list Order Directives"
msgstr "使用清单订单指令"

#: ../../LangRef.rst:2048
msgid "Use-list directives encode the in-memory order of each use-list, allowing the order to be recreated. ``<order-indexes>`` is a comma-separated list of indexes that are assigned to the referenced value's uses. The referenced value's use-list is immediately sorted by these indexes."
msgstr "Use-list指令对每个use-list的内存顺序进行编码，允许重新创建订单。 ``<order-indexes>``是一个逗号分隔的索引列表，分配给引用值的用法。引用值的use-list会立即按这些索引排序。"

#: ../../LangRef.rst:2053
msgid "Use-list directives may appear at function scope or global scope. They are not instructions, and have no effect on the semantics of the IR. When they're at function scope, they must appear after the terminator of the final basic block."
msgstr "Use-list指令可能出现在函数作用域或全局作用域中。它们不是指令，对IR的语义没有影响。当它们处于功能范围时，它们必须出现在最终基本块的终结符之后。"

#: ../../LangRef.rst:2057
msgid "If basic blocks have their address taken via ``blockaddress()`` expressions, ``uselistorder_bb`` can be used to reorder their use-lists from outside their function's scope."
msgstr "如果基本块的地址是通过``blockaddress（）``表达式获取的，则``uselistorder_bb``可用于从其函数范围之外对其使用列表重新排序。"

#: ../../LangRef.rst:2092
msgid "Type System"
msgstr "键入系统"

#: ../../LangRef.rst:2094
msgid "The LLVM type system is one of the most important features of the intermediate representation. Being typed enables a number of optimizations to be performed on the intermediate representation directly, without having to do extra analyses on the side before the transformation. A strong type system makes it easier to read the generated code and enables novel analyses and transformations that are not feasible to perform on normal three address code representations."
msgstr "LLVM类型系统是中间表示的最重要特征之一。通过键入可以直接对中间表示执行多个优化，而无需在转换之前对侧进行额外的分析。强类型系统使得更容易读取生成的代码并实现在正常的三个地址代码表示上不可行的新颖分析和转换。"

#: ../../LangRef.rst:2105
msgid "Void Type"
msgstr "空洞类型"

#: ../../LangRef.rst:2110
msgid "The void type does not represent any value and has no size."
msgstr "void类型不代表任何值，也没有大小。"

#: ../../LangRef.rst:2123
msgid "Function Type"
msgstr "功能类型"

#: ../../LangRef.rst:2128
msgid "The function type can be thought of as a function signature. It consists of a return type and a list of formal parameter types. The return type of a function type is a void type or first class type --- except for :ref:`label <t_label>` and :ref:`metadata <t_metadata>` types."
msgstr "函数类型可以被认为是函数签名。它由返回类型和形式参数类型列表组成。函数类型的返回类型是void类型或第一类类型---除了：ref：`label <t_label>`和：ref：`metadata <t_metadata>`types。"

#: ../../LangRef.rst:2139
msgid "...where '``<parameter list>``' is a comma-separated list of type specifiers. Optionally, the parameter list may include a type ``...``, which indicates that the function takes a variable number of arguments. Variable argument functions can access their arguments with the :ref:`variable argument handling intrinsic <int_varargs>` functions. '``<returntype>``' is any type except :ref:`label <t_label>` and :ref:`metadata <t_metadata>`."
msgstr "...其中'``<参数列表>``'是逗号分隔的类型说明符列表。可选地，参数列表可以包括类型“...”，其指示该函数采用可变数量的参数。变量参数函数可以使用：ref：`变量参数处理内部<int_varargs>`函数来访问它们的参数。 '``<returntype>``'是任何类型，除了：ref：`label <t_label>`和：ref：`metadata <t_metadata>`。"

#: ../../LangRef.rst:2149
msgid "``i32 (i32)``"
msgstr ""

#: ../../LangRef.rst:2149
msgid "function taking an ``i32``, returning an ``i32``"
msgstr "函数取一个``i32``，返回一个``i32``"

#: ../../LangRef.rst:2151
msgid "``float (i16, i32 *) *``"
msgstr ""

#: ../../LangRef.rst:2151
msgid ":ref:`Pointer <t_pointer>` to a function that takes an ``i16`` and a :ref:`pointer <t_pointer>` to ``i32``, returning ``float``."
msgstr "：ref：`Pointer <t_pointer>`一个函数，它接受一个``i16``和一个：ref：`pointer <t_pointer>`到``i32``，返回``float``。"

#: ../../LangRef.rst:2153
msgid "``i32 (i8*, ...)``"
msgstr ""

#: ../../LangRef.rst:2153
msgid "A vararg function that takes at least one :ref:`pointer <t_pointer>` to ``i8`` (char in C), which returns an integer. This is the signature for ``printf`` in LLVM."
msgstr "一个vararg函数，它至少需要一个：ref：`pointer <t_pointer>`到``i8``（C中的char），它返回一个整数。这是LLVM中``printf``的签名。"

#: ../../LangRef.rst:2155
msgid "``{i32, i32} (i32)``"
msgstr ""

#: ../../LangRef.rst:2155
msgid "A function taking an ``i32``, returning a :ref:`structure <t_struct>` containing two ``i32`` values"
msgstr "一个函数取一个``i32``，返回一个：ref：`structure <t_struct>`包含两个``i32``值"

#: ../../LangRef.rst:2161
msgid "First Class Types"
msgstr "头等舱类型"

#: ../../LangRef.rst:2163
msgid "The :ref:`first class <t_firstclass>` types are perhaps the most important. Values of these types are the only ones which can be produced by instructions."
msgstr "：ref：`first class <t_firstclass>`类型也许是最重要的。这些类型的值是唯一可以通过指令生成的值。"

#: ../../LangRef.rst:2170
msgid "Single Value Types"
msgstr "单值类型"

#: ../../LangRef.rst:2172
msgid "These are the types that are valid in registers from CodeGen's perspective."
msgstr "从CodeGen的角度来看，这些是在寄存器中有效的类型。"

#: ../../LangRef.rst:2177
msgid "Integer Type"
msgstr "整数类型"

#: ../../LangRef.rst:2181
msgid "The integer type is a very simple type that simply specifies an arbitrary bit width for the integer type desired. Any bit width from 1 bit to 2\\ :sup:`23`\\ -1 (about 8 million) can be specified."
msgstr "整数类型是一种非常简单的类型，它只是为所需的整数类型指定任意位宽。可以指定从1位到2 \\：sup：`23` \\ -1（大约8百万）的任何位宽。"

#: ../../LangRef.rst:2191
msgid "The number of bits the integer will occupy is specified by the ``N`` value."
msgstr "整数占用的位数由“N`”值指定。"

#: ../../LangRef.rst:2195 ../../LangRef.rst:4361 ../../LangRef.rst:4644 ../../LangRef.rst:6877 ../../LangRef.rst:10686 ../../LangRef.rst:10735 ../../LangRef.rst:10785 ../../LangRef.rst:10835 ../../LangRef.rst:10885 ../../LangRef.rst:10935 ../../LangRef.rst:11059 ../../LangRef.rst:11114 ../../LangRef.rst:11156
msgid "Examples:"
msgstr "例子："

#: ../../LangRef.rst:2198
msgid "``i1``"
msgstr ""

#: ../../LangRef.rst:2198
msgid "a single-bit integer."
msgstr "一位整数。"

#: ../../LangRef.rst:2200
msgid "``i32``"
msgstr ""

#: ../../LangRef.rst:2200
msgid "a 32-bit integer."
msgstr "一个32位整数。"

#: ../../LangRef.rst:2202
msgid "``i1942652``"
msgstr ""

#: ../../LangRef.rst:2202
msgid "a really big integer of over 1 million bits."
msgstr "一个超过100万位的真正大整数。"

#: ../../LangRef.rst:2208
msgid "Floating Point Types"
msgstr "浮点类型"

#: ../../LangRef.rst:2213
msgid "Type"
msgstr "类型"

#: ../../LangRef.rst:2214
msgid "Description"
msgstr "描述"

#: ../../LangRef.rst:2216
msgid "``half``"
msgstr ""

#: ../../LangRef.rst:2217
msgid "16-bit floating point value"
msgstr "16位浮点值"

#: ../../LangRef.rst:2219
msgid "``float``"
msgstr ""

#: ../../LangRef.rst:2220
msgid "32-bit floating point value"
msgstr "32位浮点值"

#: ../../LangRef.rst:2222
msgid "``double``"
msgstr ""

#: ../../LangRef.rst:2223
msgid "64-bit floating point value"
msgstr "64位浮点值"

#: ../../LangRef.rst:2225
msgid "``fp128``"
msgstr ""

#: ../../LangRef.rst:2226
msgid "128-bit floating point value (112-bit mantissa)"
msgstr "128位浮点值（112位尾数）"

#: ../../LangRef.rst:2228
msgid "``x86_fp80``"
msgstr ""

#: ../../LangRef.rst:2229
msgid "80-bit floating point value (X87)"
msgstr "80位浮点值（X87）"

#: ../../LangRef.rst:2231
msgid "``ppc_fp128``"
msgstr ""

#: ../../LangRef.rst:2232
msgid "128-bit floating point value (two 64-bits)"
msgstr "128位浮点值（两个64位）"

#: ../../LangRef.rst:2235
msgid "X86_mmx Type"
msgstr "X86_mmx类型"

#: ../../LangRef.rst:2239
msgid "The x86_mmx type represents a value held in an MMX register on an x86 machine. The operations allowed on it are quite limited: parameters and return values, load and store, and bitcast. User-specified MMX instructions are represented as intrinsic or asm calls with arguments and/or results of this type. There are no arrays, vectors or constants of this type."
msgstr "x86_mmx类型表示x86计算机上MMX寄存器中保存的值。允许的操作非常有限：参数和返回值，加载和存储以及bitcast。用户指定的MMX指令表示为带有参数和/或此类结果的内部或asm调用。没有这种类型的数组，向量或常量。"

#: ../../LangRef.rst:2256
msgid "Pointer Type"
msgstr "指针类型"

#: ../../LangRef.rst:2260
msgid "The pointer type is used to specify memory locations. Pointers are commonly used to reference objects in memory."
msgstr "指针类型用于指定内存位置。指针通常用于引用内存中的对象。"

#: ../../LangRef.rst:2263
msgid "Pointer types may have an optional address space attribute defining the numbered address space where the pointed-to object resides. The default address space is number zero. The semantics of non-zero address spaces are target-specific."
msgstr "指针类型可以具有可选的地址空间属性，该属性定义指向对象所在的编号地址空间。默认地址空间为数字零。非零地址空间的语义是特定于目标的。"

#: ../../LangRef.rst:2268
msgid "Note that LLVM does not permit pointers to void (``void*``) nor does it permit pointers to labels (``label*``). Use ``i8*`` instead."
msgstr "请注意，LLVM不允许指向void（``void *``），也不允许指向标签的指针（``label *``）。请使用``i8 *``。"

#: ../../LangRef.rst:2280
msgid "``[4 x i32]*``"
msgstr ""

#: ../../LangRef.rst:2280
msgid "A :ref:`pointer <t_pointer>` to :ref:`array <t_array>` of four ``i32`` values."
msgstr "答：ref：`pointer <t_pointer>`to：ref：`array <t_array>`四个``i32``值。"

#: ../../LangRef.rst:2282
msgid "``i32 (i32*) *``"
msgstr ""

#: ../../LangRef.rst:2282
msgid "A :ref:`pointer <t_pointer>` to a :ref:`function <t_function>` that takes an ``i32*``, returning an ``i32``."
msgstr "A：ref：`pointer <t_pointer>`到a：ref：`function <t_function>`，它带一个``i32 *``，返回一个``i32``。"

#: ../../LangRef.rst:2284
msgid "``i32 addrspace(5)*``"
msgstr ""

#: ../../LangRef.rst:2284
msgid "A :ref:`pointer <t_pointer>` to an ``i32`` value that resides in address space #5."
msgstr "答：ref：`pointer <t_pointer>`到位于地址空间＃5的``i32``值。"

#: ../../LangRef.rst:2290
msgid "Vector Type"
msgstr "矢量类型"

#: ../../LangRef.rst:2294
msgid "A vector type is a simple derived type that represents a vector of elements. Vector types are used when multiple primitive data are operated in parallel using a single instruction (SIMD). A vector type requires a size (number of elements) and an underlying primitive data type. Vector types are considered :ref:`first class <t_firstclass>`."
msgstr "向量类型是表示元素向量的简单派生类型。当使用单个指令（SIMD）并行操作多个基元数据时，使用矢量类型。向量类型需要大小（元素数量）和基础原始数据类型。考虑向量类型：ref：`first class <t_firstclass>`。"

#: ../../LangRef.rst:2306
msgid "The number of elements is a constant integer value larger than 0; elementtype may be any integer, floating point or pointer type. Vectors of size zero are not allowed."
msgstr "元素数是一个大于0的常数整数值; elementtype可以是任何整数，浮点或指针类型。不允许使用大小为零的向量。"

#: ../../LangRef.rst:2313
msgid "``<4 x i32>``"
msgstr ""

#: ../../LangRef.rst:2313
msgid "Vector of 4 32-bit integer values."
msgstr "向量的4个32位整数值。"

#: ../../LangRef.rst:2315
msgid "``<8 x float>``"
msgstr ""

#: ../../LangRef.rst:2315
msgid "Vector of 8 32-bit floating-point values."
msgstr "向量的8个32位浮点值。"

#: ../../LangRef.rst:2317
msgid "``<2 x i64>``"
msgstr ""

#: ../../LangRef.rst:2317
msgid "Vector of 2 64-bit integer values."
msgstr "矢量2个64位整数值。"

#: ../../LangRef.rst:2319
msgid "``<4 x i64*>``"
msgstr ""

#: ../../LangRef.rst:2319
msgid "Vector of 4 pointers to 64-bit integer values."
msgstr "向量指向64位整数值的向量。"

#: ../../LangRef.rst:2325
msgid "Label Type"
msgstr "标签类型"

#: ../../LangRef.rst:2329
msgid "The label type represents code labels."
msgstr "标签类型代表代码标签。"

#: ../../LangRef.rst:2340
msgid "Token Type"
msgstr "令牌类型"

#: ../../LangRef.rst:2344
msgid "The token type is used when a value is associated with an instruction but all uses of the value must not attempt to introspect or obscure it. As such, it is not appropriate to have a :ref:`phi <i_phi>` or :ref:`select <i_select>` of type token."
msgstr "当值与指令相关联时使用令牌类型，但是值的所有使用都不得试图内省或模糊它。因此，有一个：ref：`phi <i_phi>`或：ref：`select <i_select>`类型令牌是不合适的。"

#: ../../LangRef.rst:2360
msgid "Metadata Type"
msgstr "元数据类型"

#: ../../LangRef.rst:2364
msgid "The metadata type represents embedded metadata. No derived types may be created from metadata except for :ref:`function <t_function>` arguments."
msgstr "元数据类型表示嵌入的元数据。除了：ref：`function <t_function>`arguments之外，不能从元数据创建派生类型。"

#: ../../LangRef.rst:2376
msgid "Aggregate Types"
msgstr "聚合类型"

#: ../../LangRef.rst:2378
msgid "Aggregate Types are a subset of derived types that can contain multiple member types. :ref:`Arrays <t_array>` and :ref:`structs <t_struct>` are aggregate types. :ref:`Vectors <t_vector>` are not considered to be aggregate types."
msgstr "聚合类型是可包含多个成员类型的派生类型的子集。 ：ref：`Arrays <t_array>`和：ref：`structs <t_struct>`是聚合类型。 ：ref：`Vectors <t_vector>`不被认为是聚合类型。"

#: ../../LangRef.rst:2386
msgid "Array Type"
msgstr "数组类型"

#: ../../LangRef.rst:2390
msgid "The array type is a very simple derived type that arranges elements sequentially in memory. The array type requires a size (number of elements) and an underlying data type."
msgstr "数组类型是一种非常简单的派生类型，它在内存中按顺序排列元素。数组类型需要大小（元素数）和基础数据类型。"

#: ../../LangRef.rst:2400
msgid "The number of elements is a constant integer value; ``elementtype`` may be any type with a size."
msgstr "元素数是一个常数整数值; ``elementtype``可以是任何大小的类型。"

#: ../../LangRef.rst:2406
msgid "``[40 x i32]``"
msgstr ""

#: ../../LangRef.rst:2406
msgid "Array of 40 32-bit integer values."
msgstr "40个32位整数值的数组。"

#: ../../LangRef.rst:2408
msgid "``[41 x i32]``"
msgstr ""

#: ../../LangRef.rst:2408
msgid "Array of 41 32-bit integer values."
msgstr "41个32位整数值的数组。"

#: ../../LangRef.rst:2410
msgid "``[4 x i8]``"
msgstr ""

#: ../../LangRef.rst:2410
msgid "Array of 4 8-bit integer values."
msgstr "4个8位整数值的数组。"

#: ../../LangRef.rst:2413
msgid "Here are some examples of multidimensional arrays:"
msgstr "以下是多维数组的一些示例："

#: ../../LangRef.rst:2416
msgid "``[3 x [4 x i32]]``"
msgstr ""

#: ../../LangRef.rst:2416
msgid "3x4 array of 32-bit integer values."
msgstr "3x4 32位整数值数组。"

#: ../../LangRef.rst:2418
msgid "``[12 x [10 x float]]``"
msgstr ""

#: ../../LangRef.rst:2418
msgid "12x10 array of single precision floating point values."
msgstr "12x10单精度浮点值数组。"

#: ../../LangRef.rst:2420
msgid "``[2 x [3 x [4 x i16]]]``"
msgstr ""

#: ../../LangRef.rst:2420
msgid "2x3x4 array of 16-bit integer values."
msgstr "2x3x4 16位整数值数组。"

#: ../../LangRef.rst:2423
msgid "There is no restriction on indexing beyond the end of the array implied by a static type (though there are restrictions on indexing beyond the bounds of an allocated object in some cases). This means that single-dimension 'variable sized array' addressing can be implemented in LLVM with a zero length array type. An implementation of 'pascal style arrays' in LLVM could use the type \"``{ i32, [0 x float]}``\", for example."
msgstr "对静态类型隐含的数组末尾之外的索引没有限制（尽管在某些情况下索引超出了已分配对象的范围）。这意味着可以在具有零长度数组类型的LLVM中实现单维“可变大小的数组”寻址。例如，LLVM中'pascal样式数组'的实现可以使用类型``{i32，[0 x float]}``\\“。"

#: ../../LangRef.rst:2434
msgid "Structure Type"
msgstr "结构类型"

#: ../../LangRef.rst:2438
msgid "The structure type is used to represent a collection of data members together in memory. The elements of a structure may be any type that has a size."
msgstr "结构类型用于在内存中一起表示数据成员的集合。结构的元素可以是具有大小的任何类型。"

#: ../../LangRef.rst:2442
msgid "Structures in memory are accessed using '``load``' and '``store``' by getting a pointer to a field with the '``getelementptr``' instruction. Structures in registers are accessed using the '``extractvalue``' and '``insertvalue``' instructions."
msgstr "通过使用'``getelementptr``'指令获取指向字段的指针，使用'``load``'和'``store``'访问内存中的结构。使用'``extractvalue``'和'``insertvalue``'指令访问寄存器中的结构。"

#: ../../LangRef.rst:2447
msgid "Structures may optionally be \"packed\" structures, which indicate that the alignment of the struct is one byte, and that there is no padding between the elements. In non-packed structs, padding between field types is inserted as defined by the DataLayout string in the module, which is required to match what the underlying code generator expects."
msgstr "结构可以可选地是“打包”结构，其指示结构的对齐是一个字节，并且元素之间没有填充。在非打包的结构中，字段类型之间的填充是按照模块中的DataLayout字符串的定义插入的，这需要与底层代码生成器期望的内容相匹配。"

#: ../../LangRef.rst:2453
msgid "Structures can either be \"literal\" or \"identified\". A literal structure is defined inline with other types (e.g. ``{i32, i32}*``) whereas identified types are always defined at the top level with a name. Literal types are uniqued by their contents and can never be recursive or opaque since there is no way to write one. Identified types can be recursive, can be opaqued, and are never uniqued."
msgstr "结构可以是“文字”或“识别”。文本结构与其他类型内联定义（例如``{i32，i32} *``），而识别的类型总是在顶层定义一个名称。文字类型的内容是唯一的，并且永远不会是递归的或不透明的，因为没有办法写一个。已识别的类型可以是递归的，可以是不透明的，并且从不是唯一的。"

#: ../../LangRef.rst:2470
msgid "``{ i32, i32, i32 }``"
msgstr ""

#: ../../LangRef.rst:2470
msgid "A triple of three ``i32`` values"
msgstr "三个``i32``值的三倍"

#: ../../LangRef.rst:2472
msgid "``{ float, i32 (i32) * }``"
msgstr ""

#: ../../LangRef.rst:2472
msgid "A pair, where the first element is a ``float`` and the second element is a :ref:`pointer <t_pointer>` to a :ref:`function <t_function>` that takes an ``i32``, returning an ``i32``."
msgstr "一对，其中第一个元素是``float``，第二个元素是：ref：`pointer <t_pointer>`到a：ref：`function <t_function>`，它带有一个``i32``，返回一个``i32``。"

#: ../../LangRef.rst:2474
msgid "``<{ i8, i32 }>``"
msgstr ""

#: ../../LangRef.rst:2474
msgid "A packed struct known to be 5 bytes in size."
msgstr "已知的打包结构，大小为5个字节。"

#: ../../LangRef.rst:2480
msgid "Opaque Structure Types"
msgstr "不透明的结构类型"

#: ../../LangRef.rst:2484
msgid "Opaque structure types are used to represent named structure types that do not have a body specified. This corresponds (for example) to the C notion of a forward declared structure."
msgstr "不透明结构类型用于表示未指定主体的命名结构类型。这对应于（例如）前向声明结构的C概念。"

#: ../../LangRef.rst:2498
msgid "``opaque``"
msgstr ""

#: ../../LangRef.rst:2498
msgid "An opaque type."
msgstr "不透明的类型。"

#: ../../LangRef.rst:2504
msgid "Constants"
msgstr "常量"

#: ../../LangRef.rst:2506
msgid "LLVM has several different basic types of constants. This section describes them all and their syntax."
msgstr "LLVM有几种不同的基本类型的常量。本节将介绍它们及其语法。"

#: ../../LangRef.rst:2510
msgid "Simple Constants"
msgstr "简单常量"

#: ../../LangRef.rst:2513
msgid "**Boolean constants**"
msgstr "**布尔常量**"

#: ../../LangRef.rst:2513
msgid "The two strings '``true``' and '``false``' are both valid constants of the ``i1`` type."
msgstr "两个字符串'``true``'和'``false``'都是``i1``类型的有效常量。"

#: ../../LangRef.rst:2517
msgid "**Integer constants**"
msgstr "**整数常数**"

#: ../../LangRef.rst:2516
msgid "Standard integers (such as '4') are constants of the :ref:`integer <t_integer>` type. Negative numbers may be used with integer types."
msgstr "标准整数（例如'4'）是：ref：`integer <t_integer>`类型的常量。负数可以与整数类型一起使用。"

#: ../../LangRef.rst:2525
msgid "**Floating point constants**"
msgstr "**浮点常数**"

#: ../../LangRef.rst:2520
msgid "Floating point constants use standard decimal notation (e.g. 123.421), exponential notation (e.g. 1.23421e+2), or a more precise hexadecimal notation (see below). The assembler requires the exact decimal value of a floating-point constant. For example, the assembler accepts 1.25 but rejects 1.3 because 1.3 is a repeating decimal in binary. Floating point constants must have a :ref:`floating point <t_floating>` type."
msgstr "浮点常数使用标准十进制表示法（例如123.421），指数表示法（例如1.23421e + 2）或更精确的十六进制表示法（见下文）。汇编程序需要浮点常量的精确十进制值。例如，汇编程序接受1.25但拒绝1.3，因为1.3是二进制的重复小数。浮点常量必须具有：ref：`浮点<t_floating>`类型。"

#: ../../LangRef.rst:2528
msgid "**Null pointer constants**"
msgstr "**空指针常量**"

#: ../../LangRef.rst:2528
msgid "The identifier '``null``' is recognized as a null pointer constant and must be of :ref:`pointer type <t_pointer>`."
msgstr "标识符“``null``'被识别为空指针常量，必须是：ref：`pointer type <t_pointer>`。"

#: ../../LangRef.rst:2532
msgid "**Token constants**"
msgstr "**令牌常量**"

#: ../../LangRef.rst:2531
msgid "The identifier '``none``' is recognized as an empty token constant and must be of :ref:`token type <t_token>`."
msgstr "标识符“``none``'被识别为空标记常量，必须是：ref：`token type <t_token>`。"

#: ../../LangRef.rst:2534
msgid ""
"The one non-intuitive notation for constants is the hexadecimal form of floating point constants. For example, the form '``double    0x432ff973cafa8000``' is equivalent to (but harder to read than) '``double 4.5e+15``'. The only time hexadecimal floating point constants are required (and the only time that they are generated by the disassembler) is when a floating point constant must be emitted but it cannot be represented as a decimal floating point number in a reasonable number of digits. For example, NaN's, infinities, and other special values are represented in "
"their IEEE hexadecimal format so that assembly and disassembly do not cause any bits to change in the constants."
msgstr "常量的一个非直观表示法是浮点常量的十六进制形式。例如，形式'``double 0x432ff973cafa8000``'相当于（但更难读）'``double 4.5e + 15``'。唯一需要十六进制浮点常数的时间（以及它们由反汇编程序生成的唯一时间）是必须发出浮点常量但不能表示为合理位数的十进制浮点数。例如，NaN，无穷大和其他特殊值以IEEE十六进制格式表示，因此汇编和反汇编不会导致常量中的任何位更改。"

#: ../../LangRef.rst:2545
msgid ""
"When using the hexadecimal form, constants of types half, float, and double are represented using the 16-digit form shown above (which matches the IEEE754 representation for double); half and float values must, however, be exactly representable as IEEE 754 half and single precision, respectively. Hexadecimal format is always used for long double, and there are three forms of long double. The 80-bit format used by x86 is represented as ``0xK`` followed by 20 hexadecimal digits. The 128-bit format used by PowerPC (two adjacent doubles) is represented by ``0xM`` followed "
"by 32 hexadecimal digits. The IEEE 128-bit format is represented by ``0xL`` followed by 32 hexadecimal digits. Long doubles will only work if they match the long double format on your target. The IEEE 16-bit format (half precision) is represented by ``0xH`` followed by 4 hexadecimal digits. All hexadecimal formats are big-endian (sign bit at the left)."
msgstr "当使用十六进制形式时，half，float和double类型的常量使用上面显示的16位数字表示（匹配IEEE754表示为double）;但是，half和float值必须分别精确表示为IEEE 754半精度和单精度。十六进制格式总是用于long double，并且有三种形式的long double。 x86使用的80位格式表示为“0xK”，后跟20个十六进制数字。 PowerPC使用的128位格式（两个相邻的双精度数）由“0xM”表示，后跟32个十六进制数字。 IEEE 128位格式由“0xL”表示，后跟32个十六进制数字。长双打只有在匹配目标上的长双精度格式时才有效。 IEEE 16位格式（半精度）由“0xH”表示，后跟4个十六进制数字。所有十六进制格式都是big-endian（左边的符号位）。"

#: ../../LangRef.rst:2560
msgid "There are no constants of type x86_mmx."
msgstr "没有类型x86_mmx的常量。"

#: ../../LangRef.rst:2565
msgid "Complex Constants"
msgstr "复杂常数"

#: ../../LangRef.rst:2567
msgid "Complex constants are a (potentially recursive) combination of simple constants and smaller complex constants."
msgstr "复数常量是简单常量和较小复数常量的（可能是递归的）组合。"

#: ../../LangRef.rst:2576
msgid "**Structure constants**"
msgstr "**结构常数**"

#: ../../LangRef.rst:2571
msgid "Structure constants are represented with notation similar to structure type definitions (a comma separated list of elements, surrounded by braces (``{}``)). For example: \"``{ i32 4, float 17.0, i32* @G }``\", where \"``@G``\" is declared as \"``@G = external global i32``\". Structure constants must have :ref:`structure type <t_struct>`, and the number and types of elements must match those specified by the type."
msgstr "结构常量用类似于结构类型定义的符号表示（以逗号分隔的元素列表，用大括号括起来（``{}``））。例如：\\```{i32 4，float 17.0，i32 * @G}``\\“，其中````@ G`` \\”被声明为\\“``@G =外部全局i32`` \\”。结构常量必须具有：ref：`structure type <t_struct>`，元素的数量和类型必须与类型指定的元素相匹配。"

#: ../../LangRef.rst:2585
msgid "**Array constants**"
msgstr "**数组常量**"

#: ../../LangRef.rst:2579
msgid "Array constants are represented with notation similar to array type definitions (a comma separated list of elements, surrounded by square brackets (``[]``)). For example: \"``[ i32 42, i32 11, i32 74 ]``\". Array constants must have :ref:`array type <t_array>`, and the number and types of elements must match those specified by the type. As a special case, character array constants may also be represented as a double-quoted string using the ``c`` prefix. For example: \"``c\"Hello World\\0A\\00\"``\"."
msgstr "数组常量用类似于数组类型定义的符号表示（逗号分隔的元素列表，用方括号括起来（``[]``））。例如：\\“```[i32 42，i32 11，i32 74]``\\”。数组常量必须具有：ref：`array type <t_array>`，元素的数量和类型必须与类型指定的元素相匹配。作为一种特殊情况，字符数组常量也可以使用``c``前缀表示为双引号字符串。例如：\\“``c \\”Hello World \\ 0A \\ 00 \\“``\\”。"

#: ../../LangRef.rst:2592
msgid "**Vector constants**"
msgstr "**矢量常数**"

#: ../../LangRef.rst:2588
msgid "Vector constants are represented with notation similar to vector type definitions (a comma separated list of elements, surrounded by less-than/greater-than's (``<>``)). For example: \"``< i32 42, i32 11, i32 74, i32 100 >``\". Vector constants must have :ref:`vector type <t_vector>`, and the number and types of elements must match those specified by the type."
msgstr "向量常量用符号表示，类似于向量类型定义（以逗号分隔的元素列表，由小于/大于（``<>``）包围）。例如：\\“``<i32 42，i32 11，i32 74，i32 100>``\\”。向量常量必须具有：ref：`vector type <t_vector>`，元素的数量和类型必须与类型指定的元素相匹配。"

#: ../../LangRef.rst:2598
msgid "**Zero initialization**"
msgstr "**零初始化**"

#: ../../LangRef.rst:2595
msgid "The string '``zeroinitializer``' can be used to zero initialize a value to zero of *any* type, including scalar and :ref:`aggregate <t_aggregate>` types. This is often used to avoid having to print large zero initializers (e.g. for large arrays) and is always exactly equivalent to using explicit zero initializers."
msgstr "字符串'``zeroinitializer``'可用于将* any *类型的值初始化为零，包括标量和：ref：`aggregate <t_aggregate>`类型。这通常用于避免必须打印大零初始化器（例如，对于大型阵列），并且始终完全等同于使用显式零初始化器。"

#: ../../LangRef.rst:2606
msgid "**Metadata node**"
msgstr "**元数据节点**"

#: ../../LangRef.rst:2601
msgid "A metadata node is a constant tuple without types. For example: \"``!{!0, !{!2, !0}, !\"test\"}``\". Metadata can reference constant values, for example: \"``!{!0, i32 0, i8* @global, i64 (i64)* @function, !\"str\"}``\". Unlike other typed constants that are meant to be interpreted as part of the instruction stream, metadata is a place to attach additional information such as debug info."
msgstr "元数据节点是没有类型的常量元组。例如：\\“``！{！0，！{！2，！0}，！\\”test \\“}``\\”。元数据可以引用常量值，例如：\\“``！{！0，i32 0，i8 * @global，i64（i64）* @function，！\\”str \\“}``\\”。与其他类型的常量不同，这些常量被解释为指令流的一部分，元数据是附加其他信息（如调试信息）的地方。"

#: ../../LangRef.rst:2609
msgid "Global Variable and Function Addresses"
msgstr "全局变量和函数地址"

#: ../../LangRef.rst:2611
msgid "The addresses of :ref:`global variables <globalvars>` and :ref:`functions <functionstructure>` are always implicitly valid (link-time) constants. These constants are explicitly referenced when the :ref:`identifier for the global <identifiers>` is used and always have :ref:`pointer <t_pointer>` type. For example, the following is a legal LLVM file:"
msgstr "地址：ref：`global variables <globalvars>`和：ref：`functions <functions structure>`总是隐式有效（链接时）常量。当使用：ref：`global <identifiers>`的标识符并且总是具有：ref：`pointer <t_pointer>`type时，显式引用这些常量。例如，以下是合法的LLVM文件："

#: ../../LangRef.rst:2627
msgid "Undefined Values"
msgstr "未定义的值"

#: ../../LangRef.rst:2629
msgid "The string '``undef``' can be used anywhere a constant is expected, and indicates that the user of the value may receive an unspecified bit-pattern. Undefined values may be of any type (other than '``label``' or '``void``') and be used anywhere a constant is permitted."
msgstr "字符串'``undef``'可以在预期的常量的任何地方使用，并指示值的用户可能会收到未指定的位模式。未定义的值可以是任何类型（除了'``label``'或'``void``'），并且可以在允许常量的任何地方使用。"

#: ../../LangRef.rst:2634
msgid "Undefined values are useful because they indicate to the compiler that the program is well defined no matter what value is used. This gives the compiler more freedom to optimize. Here are some examples of (potentially surprising) transformations that are valid (in pseudo IR):"
msgstr "未定义的值很有用，因为它们向编译器指示无论使用什么值，程序都已定义良好。这为编译器提供了更多的优化自由。以下是一些有效的（可能令人惊讶的）转换示例（在伪IR中）："

#: ../../LangRef.rst:2649
msgid "This is safe because all of the output bits are affected by the undef bits. Any output bit can have a zero or one depending on the input bits."
msgstr "这是安全的，因为所有输出位都受undef位的影响。根据输入位，任何输出位都可以为零或一。"

#: ../../LangRef.rst:2663
#, fuzzy, python-format
msgid ""
"These logical operations have bits that are not always affected by the input. For example, if ``%X`` has a zero bit, then the output of the '``and``' operation will always be a zero for that bit, no matter what the corresponding bit from the '``undef``' is. As such, it is unsafe to optimize or assume that the result of the '``and``' is '``undef``'. However, it is safe to assume that all bits of the '``undef``' could be 0, and optimize the '``and``' to 0. Likewise, it is safe to assume that all the bits of the '``undef``' operand to the '``or``' could be set, allowing "
"the '``or``' to be folded to -1."
msgstr "这些逻辑运算具有不总是受输入影响的位。例如，如果 ``％X`` 的位为零，那么 '``and``' 操作的输出将始终为该位的0，无论 '``undef' 中的相应位是什么“是的。因此，优化或假设'`和``'的结果是 '``undef``' 是不安全的。但是，可以安全地假设 '``undef``' 的所有位都可以为0，并将'``和``'优化为0.同样，可以安全地假设'的所有位'可以设置 '``or``' 的 ``undef``' 操作数，允许 '``or``' 折叠为-1。"

#: ../../LangRef.rst:2687
#, python-format
msgid "This set of examples shows that undefined '``select``' (and conditional branch) conditions can go *either way*, but they have to come from one of the two operands. In the ``%A`` example, if ``%X`` and ``%Y`` were both known to have a clear low bit, then ``%A`` would have to have a cleared low bit. However, in the ``%C`` example, the optimizer is allowed to assume that the '``undef``' operand could be the same as ``%Y``, allowing the whole '``select``' to be eliminated."
msgstr "这组例子表明未定义的'``select``'（和条件分支）条件可以* * *，但它们必须来自两个操作数之一。在``％A``示例中，如果已知``％X``和``％Y``都有一个明确的低位，则``％A``必须有一个清零的低位。但是，在``％C``示例中，允许优化器假设'``undef``'操作数可以与``％Y``相同，允许整个'``select``'要被淘汰"

#: ../../LangRef.rst:2714
msgid ""
"This example points out that two '``undef``' operands are not necessarily the same. This can be surprising to people (and also matches C semantics) where they assume that \"``X^X``\" is always zero, even if ``X`` is undefined. This isn't true for a number of reasons, but the short answer is that an '``undef``' \"variable\" can arbitrarily change its value over its \"live range\". This is true because the variable doesn't actually *have a live range*. Instead, the value is logically read from arbitrary registers that happen to be around when needed, so the value is not "
"necessarily consistent over time. In fact, ``%A`` and ``%C`` need to have the same semantics or the core LLVM \"replace all uses with\" concept would not hold."
msgstr "这个例子指出两个'``undef``'操作数不一定相同。这对于人们来说可能是令人惊讶的（并且也与C语义相匹配），他们认为即使``X``未定义，它仍然是“X ^ X`` \\”总是为零。出于多种原因，情况并非如此，但简短的回答是'``undef``'''变量'可以在其“实时范围”上任意改变其值。这是真的，因为变量实际上并没有*有效范围*。相反，该值在逻辑上从任意寄存器中读取，这些寄存器恰好在需要时出现，因此该值不一定随时间变化。实际上，``％A``和``％C``需要具有相同的语义，或者核心LLVM“将所有用途替换为”概念不会成立。"

#: ../../LangRef.rst:2734
msgid ""
"These examples show the crucial difference between an *undefined value* and *undefined behavior*. An undefined value (like '``undef``') is allowed to have an arbitrary bit-pattern. This means that the ``%A`` operation can be constant folded to '``undef``', because the '``undef``' could be an SNaN, and ``fdiv`` is not (currently) defined on SNaN's. However, in the second example, we can make a more aggressive assumption: because the ``undef`` is allowed to be an arbitrary value, we are allowed to assume that it could be zero. Since a divide by zero has *undefined "
"behavior*, we are allowed to assume that the operation does not execute at all. This allows us to delete the divide and all code after it. Because the undefined operation \"can't happen\", the optimizer can assume that it occurs in dead code."
msgstr "这些示例显示了* undefined值*和* undefined behavior *之间的关键区别。未定义的值（如'``undef``'）允许具有任意位模式。这意味着``％A``操作可以不断折叠为'``undef``'，因为'``undef``'可以是SNaN，而``fdiv``不是（当前）定义的在SNaN上。但是，在第二个例子中，我们可以做出更积极的假设：因为允许``undef``是一个任意值，我们可以假设它可以为零。由于除以零具有*未定义的行为*，因此我们可以假设操作根本不执行。这允许我们删除除以及之后的所有代码。因为未定义的操作“不能发生”，优化器可以假设它发生在死代码中。"

#: ../../LangRef.rst:2755
msgid "These examples reiterate the ``fdiv`` example: a store *of* an undefined value can be assumed to not have any effect; we can assume that the value is overwritten with bits that happen to match what was already there. However, a store *to* an undefined location could clobber arbitrary memory, therefore, it has undefined behavior."
msgstr "这些例子重申了``fdiv``示例：可以假定存储* *未定义的值没有任何影响;我们可以假设该值被恰好与已经存在的位匹配的位覆盖。但是，存储*到*未定义的位置可能会破坏任意内存，因此，它具有未定义的行为。"

#: ../../LangRef.rst:2764
msgid "Poison Values"
msgstr "毒药价值观"

#: ../../LangRef.rst:2766
msgid "Poison values are similar to :ref:`undef values <undefvalues>`, however they also represent the fact that an instruction or constant expression that cannot evoke side effects has nevertheless detected a condition that results in undefined behavior."
msgstr "毒性值类似于：ref：`undef values <undefvalues>`，但它们也表示不能引起副作用的指令或常量表达式仍然检测到导致未定义行为的条件。"

#: ../../LangRef.rst:2771
msgid "There is currently no way of representing a poison value in the IR; they only exist when produced by operations such as :ref:`add <i_add>` with the ``nsw`` flag."
msgstr "目前无法在IR中表示毒性值;它们仅在由以下操作生成时才存在：ref：`add <i_add>`带有``nsw``标志。"

#: ../../LangRef.rst:2775
msgid "Poison value behavior is defined in terms of value *dependence*:"
msgstr "毒性价值行为是根据价值*依赖*来定义的："

#: ../../LangRef.rst:2777
msgid "Values other than :ref:`phi <i_phi>` nodes depend on their operands."
msgstr "除以下值之外的值：ref：`phi <i_phi>`节点取决于它们的操作数。"

#: ../../LangRef.rst:2778
msgid ":ref:`Phi <i_phi>` nodes depend on the operand corresponding to their dynamic predecessor basic block."
msgstr "：ref：`Phi <i_phi>`节点依赖于与其动态前驱基本块对应的操作数。"

#: ../../LangRef.rst:2780
msgid "Function arguments depend on the corresponding actual argument values in the dynamic callers of their functions."
msgstr "函数参数取决于其函数的动态调用者中的相应实际参数值。"

#: ../../LangRef.rst:2782
msgid ":ref:`Call <i_call>` instructions depend on the :ref:`ret <i_ret>` instructions that dynamically transfer control back to them."
msgstr "：ref：`Call <i_call>`指令取决于：ref：`ret <i_ret>`指令，它们动态地将控制权交还给它们。"

#: ../../LangRef.rst:2784
msgid ":ref:`Invoke <i_invoke>` instructions depend on the :ref:`ret <i_ret>`, :ref:`resume <i_resume>`, or exception-throwing call instructions that dynamically transfer control back to them."
msgstr "：ref：`Invoke <i_invoke>`指令依赖于：ref：`ret <i_ret>`，：ref：`resume <i_resume>`，或者异常抛出的调用指令，它们动态地将控制权交还给它们。"

#: ../../LangRef.rst:2787
msgid "Non-volatile loads and stores depend on the most recent stores to all of the referenced memory addresses, following the order in the IR (including loads and stores implied by intrinsics such as :ref:`@llvm.memcpy <int_memcpy>`.)"
msgstr "非易失性加载和存储依赖于所有引用的内存地址的最新存储，遵循IR中的顺序（包括内在函数隐含的加载和存储，例如：ref：`@llvm.memcpy <int_memcpy>`。）"

#: ../../LangRef.rst:2791
msgid "An instruction with externally visible side effects depends on the most recent preceding instruction with externally visible side effects, following the order in the IR. (This includes :ref:`volatile operations <volatile>`.)"
msgstr "具有外部可见副作用的指令取决于具有外部可见副作用的最近的前一指令，遵循IR中的顺序。 （这包括：ref：`volatile operations <volatile>`。）"

#: ../../LangRef.rst:2795
msgid "An instruction *control-depends* on a :ref:`terminator instruction <terminators>` if the terminator instruction has multiple successors and the instruction is always executed when control transfers to one of the successors, and may not be executed when control is transferred to another."
msgstr "指令*控制 - 依赖于：ref：`终止符指令<终止符>`如果终结符指令有多个后继，并且指令总是在控制转移到其中一个后继时执行，并且可能在控制转移时不执行到另一个。"

#: ../../LangRef.rst:2800
msgid "Additionally, an instruction also *control-depends* on a terminator instruction if the set of instructions it otherwise depends on would be different if the terminator had transferred control to a different successor."
msgstr "另外，如果终止符已将控制转移到不同的后继者，则如果否则依赖的指令集将是不同的，则指令也*控制 - 依赖于终结符指令。"

#: ../../LangRef.rst:2804
msgid "Dependence is transitive."
msgstr "依赖性是可传递的。"

#: ../../LangRef.rst:2806
msgid "Poison values have the same behavior as :ref:`undef values <undefvalues>`, with the additional effect that any instruction that has a *dependence* on a poison value has undefined behavior."
msgstr "毒性值具有与以下相同的行为：ref：`undef values <undefvalues>`，附加效果是对毒性值具有*依赖*的任何指令都具有未定义的行为。"

#: ../../LangRef.rst:2810
msgid "Here are some examples:"
msgstr "这里有些例子："

#: ../../LangRef.rst:2866
msgid "Addresses of Basic Blocks"
msgstr "基本块的地址"

#: ../../LangRef.rst:2868
msgid "``blockaddress(@function, %block)``"
msgstr ""

#: ../../LangRef.rst:2870
msgid "The '``blockaddress``' constant computes the address of the specified basic block in the specified function, and always has an ``i8*`` type. Taking the address of the entry block is illegal."
msgstr "'``blockaddress``'常量计算指定函数中指定基本块的地址，并且始终具有``i8 *``类型。取入块的地址是非法的。"

#: ../../LangRef.rst:2874
msgid ""
"This value only has defined behavior when used as an operand to the ':ref:`indirectbr <i_indirectbr>`' instruction, or for comparisons against null. Pointer equality tests between labels addresses results in undefined behavior --- though, again, comparison against null is ok, and no label is equal to the null pointer. This may be passed around as an opaque pointer sized value as long as the bits are not inspected. This allows ``ptrtoint`` and arithmetic to be performed on these values so long as the original value is reconstituted before the ``indirectbr`` instruction."
msgstr "当用作'：ref：`indirectbr <i_indirectbr>`'指令的操作数或用于与null进行比较时，该值仅具有已定义的行为。标签之间的指针相等性测试会导致未定义的行为 - 但是，再次，与null的比较是可以的，并且没有标签等于空指针。只要不检查位，这可以作为不透明指针大小的值传递。这允许对这些值执行``ptrtoint``和算术运算，只要在``indirectbr``指令之前重构原始值。"

#: ../../LangRef.rst:2884
msgid "Finally, some targets may provide defined semantics when using the value as the operand to an inline assembly, but that is target specific."
msgstr "最后，当使用值作为内联汇编的操作数时，某些目标可能会提供定义的语义，但这是特定于目标的。"

#: ../../LangRef.rst:2890
msgid "Constant Expressions"
msgstr "常数表达式"

#: ../../LangRef.rst:2892
msgid "Constant expressions are used to allow expressions involving other constants to be used as constants. Constant expressions may be of any :ref:`first class <t_firstclass>` type and may involve any LLVM operation that does not have side effects (e.g. load and call are not supported). The following is the syntax for constant expressions:"
msgstr "常量表达式用于允许将涉及其他常量的表达式用作常量。常量表达式可以是任何：ref：`first class <t_firstclass>`type，并且可能涉及任何没有副作用的LLVM操作（例如，不支持加载和调用）。以下是常量表达式的语法："

#: ../../LangRef.rst:2899
msgid "``trunc (CST to TYPE)``"
msgstr "``trunc（CST to TYPE）``"

#: ../../LangRef.rst:2899
msgid "Truncate a constant to another type. The bit size of CST must be larger than the bit size of TYPE. Both types must be integers."
msgstr "将常量截断为另一种类型。 CST的位大小必须大于TYPE的位大小。两种类型都必须是整数。"

#: ../../LangRef.rst:2902
msgid "``zext (CST to TYPE)``"
msgstr "``zext（CST to TYPE）``"

#: ../../LangRef.rst:2902
msgid "Zero extend a constant to another type. The bit size of CST must be smaller than the bit size of TYPE. Both types must be integers."
msgstr "零将常量扩展为另一种类型。 CST的位大小必须小于TYPE的位大小。两种类型都必须是整数。"

#: ../../LangRef.rst:2905
msgid "``sext (CST to TYPE)``"
msgstr "``sext（CST to TYPE）``"

#: ../../LangRef.rst:2905
msgid "Sign extend a constant to another type. The bit size of CST must be smaller than the bit size of TYPE. Both types must be integers."
msgstr "符号将常量扩展为另一种类型。 CST的位大小必须小于TYPE的位大小。两种类型都必须是整数。"

#: ../../LangRef.rst:2909
msgid "``fptrunc (CST to TYPE)``"
msgstr "``fptrunc（CST to TYPE）``"

#: ../../LangRef.rst:2908
msgid "Truncate a floating point constant to another floating point type. The size of CST must be larger than the size of TYPE. Both types must be floating point."
msgstr "将浮点常量截断为另一个浮点类型。 CST的大小必须大于TYPE的大小。两种类型都必须是浮点数。"

#: ../../LangRef.rst:2913
msgid "``fpext (CST to TYPE)``"
msgstr "``fpext（CST to TYPE）``"

#: ../../LangRef.rst:2912
msgid "Floating point extend a constant to another type. The size of CST must be smaller or equal to the size of TYPE. Both types must be floating point."
msgstr "浮点将常量扩展为另一种类型。 CST的大小必须小于或等于TYPE的大小。两种类型都必须是浮点数。"

#: ../../LangRef.rst:2919
msgid "``fptoui (CST to TYPE)``"
msgstr "``fptoui（CST to TYPE）``"

#: ../../LangRef.rst:2916
msgid "Convert a floating point constant to the corresponding unsigned integer constant. TYPE must be a scalar or vector integer type. CST must be of scalar or vector floating point type. Both CST and TYPE must be scalars, or vectors of the same number of elements. If the value won't fit in the integer type, the results are undefined."
msgstr "将浮点常量转换为相应的无符号整数常量。 TYPE必须是标量或矢量整数类型。 CST必须是标量或矢量浮点类型。 CST和TYPE都必须是标量或具有相同数量元素的向量。如果该值不适合整数类型，则结果未定义。"

#: ../../LangRef.rst:2925
msgid "``fptosi (CST to TYPE)``"
msgstr "``fptosi（CST to TYPE）``"

#: ../../LangRef.rst:2922
msgid "Convert a floating point constant to the corresponding signed integer constant. TYPE must be a scalar or vector integer type. CST must be of scalar or vector floating point type. Both CST and TYPE must be scalars, or vectors of the same number of elements. If the value won't fit in the integer type, the results are undefined."
msgstr "将浮点常量转换为相应的有符号整数常量。 TYPE必须是标量或矢量整数类型。 CST必须是标量或矢量浮点类型。 CST和TYPE都必须是标量或具有相同数量元素的向量。如果该值不适合整数类型，则结果未定义。"

#: ../../LangRef.rst:2931
msgid "``uitofp (CST to TYPE)``"
msgstr "``uitofp（CST to TYPE）``"

#: ../../LangRef.rst:2928
msgid "Convert an unsigned integer constant to the corresponding floating point constant. TYPE must be a scalar or vector floating point type. CST must be of scalar or vector integer type. Both CST and TYPE must be scalars, or vectors of the same number of elements. If the value won't fit in the floating point type, the results are undefined."
msgstr "将无符号整数常量转换为相应的浮点常量。 TYPE必须是标量或向量浮点类型。 CST必须是标量或矢量整数类型。 CST和TYPE都必须是标量或具有相同数量元素的向量。如果该值不适合浮点类型，则结果未定义。"

#: ../../LangRef.rst:2937
msgid "``sitofp (CST to TYPE)``"
msgstr "``sitofp（CST to TYPE）``"

#: ../../LangRef.rst:2934
msgid "Convert a signed integer constant to the corresponding floating point constant. TYPE must be a scalar or vector floating point type. CST must be of scalar or vector integer type. Both CST and TYPE must be scalars, or vectors of the same number of elements. If the value won't fit in the floating point type, the results are undefined."
msgstr "将有符号整数常量转换为相应的浮点常量。 TYPE必须是标量或向量浮点类型。 CST必须是标量或矢量整数类型。 CST和TYPE都必须是标量或具有相同数量元素的向量。如果该值不适合浮点类型，则结果未定义。"

#: ../../LangRef.rst:2942
msgid "``ptrtoint (CST to TYPE)``"
msgstr "``ptrtoint（CST to TYPE）``"

#: ../../LangRef.rst:2940
msgid "Convert a pointer typed constant to the corresponding integer constant. ``TYPE`` must be an integer type. ``CST`` must be of pointer type. The ``CST`` value is zero extended, truncated, or unchanged to make it fit in ``TYPE``."
msgstr "将指针类型常量转换为相应的整数常量。 ``TYPE``必须是整数类型。 ``CST``必须是指针类型。 ``CST``值为零扩展，截断或不变，使其适合``TYPE``。"

#: ../../LangRef.rst:2947
msgid "``inttoptr (CST to TYPE)``"
msgstr "``inttoptr（CST to TYPE）``"

#: ../../LangRef.rst:2945
msgid "Convert an integer constant to a pointer constant. TYPE must be a pointer type. CST must be of integer type. The CST value is zero extended, truncated, or unchanged to make it fit in a pointer size. This one is *really* dangerous!"
msgstr "将整数常量转换为指针常量。 TYPE必须是指针类型。 CST必须是整数类型。 CST值为零扩展，截断或未更改，以使其适合指针大小。这个真的很危险！"

#: ../../LangRef.rst:2951
msgid "``bitcast (CST to TYPE)``"
msgstr "``bitcast（CST to TYPE）``"

#: ../../LangRef.rst:2950
msgid "Convert a constant, CST, to another TYPE. The constraints of the operands are the same as those for the :ref:`bitcast instruction <i_bitcast>`."
msgstr "将常量CST转换为另一个TYPE。操作数的约束与：ref：`bitcast instruction <i_bitcast>`的约束相同。"

#: ../../LangRef.rst:2955
msgid "``addrspacecast (CST to TYPE)``"
msgstr "``addrspacecast（CST to TYPE）``"

#: ../../LangRef.rst:2954
msgid "Convert a constant pointer or constant vector of pointer, CST, to another TYPE in a different address space. The constraints of the operands are the same as those for the :ref:`addrspacecast instruction <i_addrspacecast>`."
msgstr "将指针的常量指针或常量向量CST转换为不同地址空间中的另一个TYPE。操作数的约束与：ref：`addrspacecast instruction <i_addrspacecast>`的约束相同。"

#: ../../LangRef.rst:2960
msgid "``getelementptr (TY, CSTPTR, IDX0, IDX1, ...)``, ``getelementptr inbounds (TY, CSTPTR, IDX0, IDX1, ...)``"
msgstr "``getelementptr（TY，CSTPTR，IDX0，IDX1，...）``，``getelementptr inbounds（TY，CSTPTR，IDX0，IDX1，...）``"

#: ../../LangRef.rst:2958
msgid "Perform the :ref:`getelementptr operation <i_getelementptr>` on constants. As with the :ref:`getelementptr <i_getelementptr>` instruction, the index list may have zero or more indexes, which are required to make sense for the type of \"pointer to TY\"."
msgstr "在常量上执行：ref：`getelementptr operation <i_getelementptr>`。与：ref：`getelementptr <i_getelementptr>`指令一样，索引列表可能有零个或多个索引，这些索引对于指向TY的指针的类型是有意义的。"

#: ../../LangRef.rst:2962
msgid "``select (COND, VAL1, VAL2)``"
msgstr ""

#: ../../LangRef.rst:2963
msgid "Perform the :ref:`select operation <i_select>` on constants."
msgstr "在常量上执行：ref：`select operation <i_select>`。"

#: ../../LangRef.rst:2964
msgid "``icmp COND (VAL1, VAL2)``"
msgstr ""

#: ../../LangRef.rst:2965
msgid "Performs the :ref:`icmp operation <i_icmp>` on constants."
msgstr "对常量执行：ref：`icmp operation <i_icmp>`。"

#: ../../LangRef.rst:2966
msgid "``fcmp COND (VAL1, VAL2)``"
msgstr ""

#: ../../LangRef.rst:2967
msgid "Performs the :ref:`fcmp operation <i_fcmp>` on constants."
msgstr "对常量执行：ref：`fcmp operation <i_fcmp>`。"

#: ../../LangRef.rst:2969
msgid "``extractelement (VAL, IDX)``"
msgstr ""

#: ../../LangRef.rst:2969
msgid "Perform the :ref:`extractelement operation <i_extractelement>` on constants."
msgstr "在常量上执行：ref：`extractelement operation <i_extractelement>`。"

#: ../../LangRef.rst:2972
msgid "``insertelement (VAL, ELT, IDX)``"
msgstr ""

#: ../../LangRef.rst:2972
msgid "Perform the :ref:`insertelement operation <i_insertelement>` on constants."
msgstr "在常量上执行：ref：`insertelement operation <i_insertelement>`。"

#: ../../LangRef.rst:2975
msgid "``shufflevector (VEC1, VEC2, IDXMASK)``"
msgstr ""

#: ../../LangRef.rst:2975
msgid "Perform the :ref:`shufflevector operation <i_shufflevector>` on constants."
msgstr "在常量上执行：ref：`shufflevector operation <i_shufflevector>`。"

#: ../../LangRef.rst:2980
msgid "``extractvalue (VAL, IDX0, IDX1, ...)``"
msgstr ""

#: ../../LangRef.rst:2978
msgid "Perform the :ref:`extractvalue operation <i_extractvalue>` on constants. The index list is interpreted in a similar manner as indices in a ':ref:`getelementptr <i_getelementptr>`' operation. At least one index value must be specified."
msgstr "在常量上执行：ref：`extractvalue operation <i_extractvalue>`。索引列表的解释方式与'：ref：`getelementptr <i_getelementptr>`'操作中的索引类似。必须至少指定一个索引值。"

#: ../../LangRef.rst:2985
msgid "``insertvalue (VAL, ELT, IDX0, IDX1, ...)``"
msgstr ""

#: ../../LangRef.rst:2983
msgid "Perform the :ref:`insertvalue operation <i_insertvalue>` on constants. The index list is interpreted in a similar manner as indices in a ':ref:`getelementptr <i_getelementptr>`' operation. At least one index value must be specified."
msgstr "在常量上执行：ref：`insertvalue operation <i_insertvalue>`。索引列表的解释方式与'：ref：`getelementptr <i_getelementptr>`'操作中的索引类似。必须至少指定一个索引值。"

#: ../../LangRef.rst:2992
msgid "``OPCODE (LHS, RHS)``"
msgstr ""

#: ../../LangRef.rst:2988
msgid "Perform the specified operation of the LHS and RHS constants. OPCODE may be any of the :ref:`binary <binaryops>` or :ref:`bitwise binary <bitwiseops>` operations. The constraints on operands are the same as those for the corresponding instruction (e.g. no bitwise operations on floating point values are allowed)."
msgstr "执行LHS和RHS常量的指定操作。 OPCODE可以是以下任何一个：ref：`binary <binaryops>`或：ref：`bitwise binary <bitwiseops>`operations。对操作数的约束与对应指令的约束相同（例如，不允许对浮点值进行按位运算）。"

#: ../../LangRef.rst:2995
msgid "Other Values"
msgstr "其他价值观"

#: ../../LangRef.rst:3000
msgid "Inline Assembler Expressions"
msgstr "内联汇编程序表达式"

#: ../../LangRef.rst:3002
msgid "LLVM supports inline assembler expressions (as opposed to :ref:`Module-Level Inline Assembly <moduleasm>`) through the use of a special value. This value represents the inline assembler as a template string (containing the instructions to emit), a list of operand constraints (stored as a string), a flag that indicates whether or not the inline asm expression has side effects, and a flag indicating whether the function containing the asm needs to align its stack conservatively."
msgstr "LLVM通过使用特殊值支持内联汇编程序表达式（而不是：ref：`Module-Level Inline Assembly <moduleasm>`）。此值表示内联汇编程序作为模板字符串（包含要发出的指令），操作数约束列表（存储为字符串），指示内联asm表达式是否具有副作用的标志，以及指示是否具有副作用的标志包含asm的函数需要保守地对齐其堆栈。"

#: ../../LangRef.rst:3010
msgid "The template string supports argument substitution of the operands using \"``$``\" followed by a number, to indicate substitution of the given register/memory location, as specified by the constraint string. \"``${NUM:MODIFIER}``\" may also be used, where ``MODIFIER`` is a target-specific annotation for how to print the operand (See :ref:`inline-asm-modifiers`)."
msgstr "模板字符串支持操作数的参数替换，使用\\“``$``\\”后跟一个数字，表示由约束字符串指定的给定寄存器/内存位置的替换。也可以使用``$ {NUM：MODIFIER}``\\“，其中``MODIFIER``是如何打印操作数的特定于目标的注释（参见：ref：`inline-asm-modifiers`） 。"

#: ../../LangRef.rst:3016
msgid "A literal \"``$``\" may be included by using \"``$$``\" in the template. To include other special characters into the output, the usual \"``\\XX``\" escapes may be used, just as in other strings. Note that after template substitution, the resulting assembly string is parsed by LLVM's integrated assembler unless it is disabled -- even when emitting a ``.s`` file -- and thus must contain assembly syntax known to LLVM."
msgstr "在模板中使用\\``$$``\\“可以包含文字”``$``\\“。要在输出中包含其他特殊字符，可以使用通常的“`\\ XX`` \\”转义符，就像在其他字符串中一样。请注意，在模板替换之后，生成的程序集字符串由LLVM的集成汇编程序解析，除非它被禁用 - 即使在发出``.s``文件时 - 因此必须包含LLVM已知的汇编语法。"

#: ../../LangRef.rst:3023
msgid "LLVM's support for inline asm is modeled closely on the requirements of Clang's GCC-compatible inline-asm support. Thus, the feature-set and the constraint and modifier codes listed here are similar or identical to those in GCC's inline asm support. However, to be clear, the syntax of the template and constraint strings described here is *not* the same as the syntax accepted by GCC and Clang, and, while most constraint letters are passed through as-is by Clang, some get translated to other codes when converting from the C source to the LLVM assembly."
msgstr "LLVM对inline asm的支持与Clang的GCC兼容的inline-asm支持的要求密切相关。因此，此处列出的特征集以及约束和修饰符代码与GCC的内联asm支持中的相似或相同。但是，要清楚的是，这里描述的模板和约束字符串的语法与GCC和Clang接受的语法不相同，并且，虽然大多数约束字母由Clang按原样传递，但有些被转换为从C源转换到LLVM程序集时的其他代码。"

#: ../../LangRef.rst:3032
msgid "An example inline assembler expression is:"
msgstr "内联汇编程序表达式的示例是："

#: ../../LangRef.rst:3038
msgid "Inline assembler expressions may **only** be used as the callee operand of a :ref:`call <i_call>` or an :ref:`invoke <i_invoke>` instruction. Thus, typically we have:"
msgstr "内联汇编程序表达式**可以**仅用作：ref：`call <i_call>`或者：ref：`invoke <i_invoke>`指令的被调用者操作数。因此，通常我们有："

#: ../../LangRef.rst:3046
msgid "Inline asms with side effects not visible in the constraint list must be marked as having side effects. This is done through the use of the '``sideeffect``' keyword, like so:"
msgstr "具有在约束列表中不可见的副作用的内联asms必须标记为具有副作用。这是通过使用'``sideeffect``'关键字来完成的，如下所示："

#: ../../LangRef.rst:3054
msgid "In some cases inline asms will contain code that will not work unless the stack is aligned in some way, such as calls or SSE instructions on x86, yet will not contain code that does that alignment within the asm. The compiler should make conservative assumptions about what the asm might contain and should generate its usual stack alignment code in the prologue if the '``alignstack``' keyword is present:"
msgstr "在某些情况下，内联asms将包含无法工作的代码，除非堆栈以某种方式对齐，例如x86上的调用或SSE指令，但不包含在asm中执行该对齐的代码。编译器应该对asm可能包含的内容进行保守的假设，并且如果存在'``alignstack``'关键字，则应该在序言中生成其通常的堆栈对齐代码："

#: ../../LangRef.rst:3065
msgid "Inline asms also support using non-standard assembly dialects. The assumed dialect is ATT. When the '``inteldialect``' keyword is present, the inline asm is using the Intel dialect. Currently, ATT and Intel are the only supported dialects. An example is:"
msgstr "内联asms也支持使用非标准汇编方言。假定的方言是ATT。当存在'``inteldialect``'关键字时，内联asm使用英特尔方言。目前，ATT和英特尔是唯一支持的方言。一个例子是："

#: ../../LangRef.rst:3074
msgid "If multiple keywords appear the '``sideeffect``' keyword must come first, the '``alignstack``' keyword second and the '``inteldialect``' keyword last."
msgstr "如果出现多个关键字，则必须先出现'``sideeffect``'关键字，然后是'``alignstack``'关键字，最后是'``inteldialect``'关键字。"

#: ../../LangRef.rst:3079
msgid "Inline Asm Constraint String"
msgstr "内联Asm约束字符串"

#: ../../LangRef.rst:3081
msgid "The constraint list is a comma-separated string, each element containing one or more constraint codes."
msgstr "约束列表是逗号分隔的字符串，每个元素包含一个或多个约束代码。"

#: ../../LangRef.rst:3084
msgid "For each element in the constraint list an appropriate register or memory operand will be chosen, and it will be made available to assembly template string expansion as ``$0`` for the first constraint in the list, ``$1`` for the second, etc."
msgstr "对于约束列表中的每个元素，将选择一个适当的寄存器或内存操作数，并且它将可用于汇编模板字符串扩展，作为列表中第一个约束的“$ 0`”，第二个约为“$ 1”。等"

#: ../../LangRef.rst:3089
msgid "There are three different types of constraints, which are distinguished by a prefix symbol in front of the constraint code: Output, Input, and Clobber. The constraints must always be given in that order: outputs first, then inputs, then clobbers. They cannot be intermingled."
msgstr "有三种不同类型的约束，它们通过约束代码前面的前缀符号来区分：输出，输入和Clobber。必须始终按顺序给出约束：首先输出，然后输入，然后输入clobbers。他们不能混杂在一起。"

#: ../../LangRef.rst:3094
msgid "There are also three different categories of constraint codes:"
msgstr "还有三种不同类型的约束代码："

#: ../../LangRef.rst:3096
msgid "Register constraint. This is either a register class, or a fixed physical register. This kind of constraint will allocate a register, and if necessary, bitcast the argument or result to the appropriate type."
msgstr "注册约束。这可以是寄存器类，也可以是固定的物理寄存器。这种约束将分配一个寄存器，并在必要时将参数或结果bitcast为适当的类型。"

#: ../../LangRef.rst:3099
msgid "Memory constraint. This kind of constraint is for use with an instruction taking a memory operand. Different constraints allow for different addressing modes used by the target."
msgstr "内存约束。这种约束用于带有内存操作数的指令。不同的约束允许目标使用不同的寻址模式。"

#: ../../LangRef.rst:3102
msgid "Immediate value constraint. This kind of constraint is for an integer or other immediate value which can be rendered directly into an instruction. The various target-specific constraints allow the selection of a value in the proper range for the instruction you wish to use it with."
msgstr "即时价值约束。这种约束是针对整数或其他立即值，可以直接呈现给指令。各种特定于目标的约束允许为您希望使用它的指令选择适当范围内的值。"

#: ../../LangRef.rst:3108
msgid "Output constraints"
msgstr "输出约束"

#: ../../LangRef.rst:3110
msgid "Output constraints are specified by an \"``=``\" prefix (e.g. \"``=r``\"). This indicates that the assembly will write to this operand, and the operand will then be made available as a return value of the ``asm`` expression. Output constraints do not consume an argument from the call instruction. (Except, see below about indirect outputs)."
msgstr "输出约束由\\“``=``\\”前缀指定（例如\\“``= r`` \\”）。这表明程序集将写入此操作数，然后操作数将作为``asm``表达式的返回值。输出约束不使用调用指令中的参数。 （除了以下关于间接输出的内容）。"

#: ../../LangRef.rst:3116
msgid ""
"Normally, it is expected that no output locations are written to by the assembly expression until *all* of the inputs have been read. As such, LLVM may assign the same register to an output and an input. If this is not safe (e.g. if the assembly contains two instructions, where the first writes to one output, and the second reads an input and writes to a second output), then the \"``&``\" modifier must be used (e.g. \"``=&r``\") to specify that the output is an \"early-clobber\" output. Marking an ouput as \"early-clobber\" ensures that LLVM will not use the same "
"register for any inputs (other than an input tied to this output)."
msgstr "通常，在读取所有输入*之前，预期汇编表达式不会写入任何输出位置。因此，LLVM可以将相同的寄存器分配给输出和输入。如果这不安全（例如，如果程序集包含两个指令，第一个写入一个输出，第二个读取输入并写入第二个输出），那么\\“``＆``\\”修饰符必须是使用（例如\\“``=＆r`` \\”）来指定输出是“早期删除”输出。将输出标记为“early-clobber”确保LLVM不会对任何输入使用相同的寄存器（除了与此输出相关的输入）。"

#: ../../LangRef.rst:3127
msgid "Input constraints"
msgstr "输入约束"

#: ../../LangRef.rst:3129
msgid "Input constraints do not have a prefix -- just the constraint codes. Each input constraint will consume one argument from the call instruction. It is not permitted for the asm to write to any input register or memory location (unless that input is tied to an output). Note also that multiple inputs may all be assigned to the same register, if LLVM can determine that they necessarily all contain the same value."
msgstr "输入约束没有前缀 - 只有约束代码。每个输入约束将使用来自调用指令的一个参数。 asm不允许写入任何输入寄存器或存储器位置（除非该输入连接到输出）。另请注意，如果LLVM可以确定它们必须都包含相同的值，则可以将多个输入全部分配给同一寄存器。"

#: ../../LangRef.rst:3136
msgid "Instead of providing a Constraint Code, input constraints may also \"tie\" themselves to an output constraint, by providing an integer as the constraint string. Tied inputs still consume an argument from the call instruction, and take up a position in the asm template numbering as is usual -- they will simply be constrained to always use the same register as the output they've been tied to. For example, a constraint string of \"``=r,0``\" says to assign a register for output, and use that register as an input as well (it being the 0'th constraint)."
msgstr "通过提供整数作为约束字符串，输入约束也可以将它们自身“绑定”到输出约束，而不是提供约束代码。绑定的输入仍然使用来自调用指令的参数，并且像往常一样在asm模板编号中占据一个位置 - 它们将被简单地约束为始终使用与它们所绑定的输出相同的寄存器。例如，约束字符串\\“``= r，0`` \\”表示为输出分配寄存器，并将该寄存器用作输入（它是第0个约束）。"

#: ../../LangRef.rst:3145
msgid "It is permitted to tie an input to an \"early-clobber\" output. In that case, no *other* input may share the same register as the input tied to the early-clobber (even when the other input has the same value)."
msgstr "允许将输入绑定到“early-clobber”输出。在这种情况下，没有* other *输入可以与绑定到早期clobber的输入共享相同的寄存器（即使其他输入具有相同的值）。"

#: ../../LangRef.rst:3149
msgid "You may only tie an input to an output which has a register constraint, not a memory constraint. Only a single input may be tied to an output."
msgstr "您可能只将输入绑定到具有寄存器约束的输出，而不是内存约束。只有一个输入可以绑定到输出。"

#: ../../LangRef.rst:3152
msgid "There is also an \"interesting\" feature which deserves a bit of explanation: if a register class constraint allocates a register which is too small for the value type operand provided as input, the input value will be split into multiple registers, and all of them passed to the inline asm."
msgstr "还有一个“有趣”的特性值得一点解释：如果一个寄存器类约束分配的寄存器对于作为输入提供的值类型操作数而言太小，则输入值将被分成多个寄存器，并且所有他们传递给内联asm。"

#: ../../LangRef.rst:3157
msgid "However, this feature is often not as useful as you might think."
msgstr "但是，此功能通常没有您想象的那么有用。"

#: ../../LangRef.rst:3159
msgid "Firstly, the registers are *not* guaranteed to be consecutive. So, on those architectures that have instructions which operate on multiple consecutive instructions, this is not an appropriate way to support them. (e.g. the 32-bit SparcV8 has a 64-bit load, which instruction takes a single 32-bit register. The hardware then loads into both the named register, and the next register. This feature of inline asm would not be useful to support that.)"
msgstr "首先，寄存器*不保证是连续的。因此，在具有对多个连续指令进行操作的指令的那些体系结构上，这不是支持它们的适当方式。 （例如，32位SparcV8具有64位加载，该指令需要一个32位寄存器。然后硬件加载到命名寄存器和下一个寄存器。内联asm的这个特性对于支持不起作用那。）"

#: ../../LangRef.rst:3166
msgid "A few of the targets provide a template string modifier allowing explicit access to the second register of a two-register operand (e.g. MIPS ``L``, ``M``, and ``D``). On such an architecture, you can actually access the second allocated register (yet, still, not any subsequent ones). But, in that case, you're still probably better off simply splitting the value into two separate operands, for clarity. (e.g. see the description of the ``A`` constraint on X86, which, despite existing only for use with this feature, is not really a good idea to use)"
msgstr "一些目标提供了一个模板字符串修饰符，允许显式访问双寄存器操作数的第二个寄存器（例如MIPS``L``，``M``和``D``）。在这样的体系结构中，您实际上可以访问第二个已分配的寄存器（但仍然不是后续的寄存器）。但是，在这种情况下，为了清楚起见，您仍然可能只需将值拆分为两个单独的操作数。 （例如，请参阅X86上的``A``约束的描述，尽管现在仅用于此功能，但使用时并不是一个好主意）"

#: ../../LangRef.rst:3176
msgid "Indirect inputs and outputs"
msgstr "间接输入和输出"

#: ../../LangRef.rst:3178
msgid ""
"Indirect output or input constraints can be specified by the \"``*``\" modifier (which goes after the \"``=``\" in case of an output). This indicates that the asm will write to or read from the contents of an *address* provided as an input argument. (Note that in this way, indirect outputs act more like an *input* than an output: just like an input, they consume an argument of the call expression, rather than producing a return value. An indirect output constraint is an \"output\" only in that the asm is expected to write to the contents of the input memory location, "
"instead of just read from it)."
msgstr "间接输出或输入约束可以由\\“````\\”修饰符指定（在输出的情况下，它位于\\```=``\\“之后）。这表示asm将写入或读取作为输入参数提供的*地址*的内容。 （注意，通过这种方式，间接输出更像是*输入*而不是输出：就像输入一样，它们使用调用表达式的参数，而不是产生返回值。间接输出约束是一个输出“只是因为asm应该写入输入内存位置的内容，而不是只读取它。”"

#: ../../LangRef.rst:3187
msgid "This is most typically used for memory constraint, e.g. \"``=*m``\", to pass the address of a variable as a value."
msgstr "这通常用于内存约束，例如\\“``= * m`` \\”，以将变量的地址作为值传递。"

#: ../../LangRef.rst:3190
msgid "It is also possible to use an indirect *register* constraint, but only on output (e.g. \"``=*r``\"). This will cause LLVM to allocate a register for an output value normally, and then, separately emit a store to the address provided as input, after the provided inline asm. (It's not clear what value this functionality provides, compared to writing the store explicitly after the asm statement, and it can only produce worse code, since it bypasses many optimization passes. I would recommend not using it.)"
msgstr "也可以使用间接*寄存器*约束，但仅限于输出（例如\\“``= * r`` \\”）。这将导致LLVM正常地为输出值分配寄存器，然后，在提供的内联asm之后，单独地将存储发送到作为输入提供的地址。 （与在asm语句之后显式写入存储相比，此功能提供的价值尚不清楚，并且它只会产生更糟糕的代码，因为它会绕过许多优化传递。我建议不要使用它。）"

#: ../../LangRef.rst:3200
msgid "Clobber constraints"
msgstr "Clobber约束"

#: ../../LangRef.rst:3202
msgid "A clobber constraint is indicated by a \"``~``\" prefix. A clobber does not consume an input operand, nor generate an output. Clobbers cannot use any of the general constraint code letters -- they may use only explicit register constraints, e.g. \"``~{eax}``\". The one exception is that a clobber string of \"``~{memory}``\" indicates that the assembly writes to arbitrary undeclared memory locations -- not only the memory pointed to by a declared indirect output."
msgstr "clobber约束由\\“``~`` \\”前缀表示。 clobber不使用输入操作数，也不生成输出。 Clobbers不能使用任何一般约束代码字母 - 它们可能只使用显式寄存器约束，例如\\“``〜{eax}``\\”。一个例外是一个反义词字符串\\“`〜{memory}``\\”表示程序集写入任意未声明的内存位置 - 不仅是声明的间接输出所指向的内存。"

#: ../../LangRef.rst:3212
msgid "Constraint Codes"
msgstr "约束代码"

#: ../../LangRef.rst:3213
msgid "After a potential prefix comes constraint code, or codes."
msgstr "潜在的前缀后出现约束代码或代码。"

#: ../../LangRef.rst:3215
msgid "A Constraint Code is either a single letter (e.g. \"``r``\"), a \"``^``\" character followed by two letters (e.g. \"``^wc``\"), or \"``{``\" register-name \"``}``\" (e.g. \"``{eax}``\")."
msgstr "约束代码是一个字母（例如\\“``r`` \\”），一个字符后跟两个字母（例如\\“``^ wc`` \\”），或\\“``{``\\”register-name \\“``}``\\”（例如\\```{eax}``\\“）。"

#: ../../LangRef.rst:3219
msgid "The one and two letter constraint codes are typically chosen to be the same as GCC's constraint codes."
msgstr "通常选择单字母和双字母约束代码与GCC的约束代码相同。"

#: ../../LangRef.rst:3222
msgid "A single constraint may include one or more than constraint code in it, leaving it up to LLVM to choose which one to use. This is included mainly for compatibility with the translation of GCC inline asm coming from clang."
msgstr "单个约束可以包括一个或多个约束代码，将其留给LLVM来选择使用哪个。这主要是为了兼容来自clang的GCC inline asm的翻译。"

#: ../../LangRef.rst:3226
msgid "There are two ways to specify alternatives, and either or both may be used in an inline asm constraint list:"
msgstr "有两种方法可以指定备选方案，并且可以在内联asm约束列表中使用其中一种或两种："

#: ../../LangRef.rst:3229
msgid "Append the codes to each other, making a constraint code set. E.g. \"``im``\" or \"``{eax}m``\". This means \"choose any of the options in the set\". The choice of constraint is made independently for each constraint in the constraint list."
msgstr "将代码相互附加，设置约束代码。例如\\“``im`` \\”或\\“``{eax} m`` \\”。这意味着“选择集合中的任何选项”。约束的选择是针对约束列表中的每个约束独立进行的。"

#: ../../LangRef.rst:3234
msgid "Use \"``|``\" between constraint code sets, creating alternatives. Every constraint in the constraint list must have the same number of alternative sets. With this syntax, the same alternative in *all* of the items in the constraint list will be chosen together."
msgstr "在约束代码集之间使用\\“``|``\\”，创建备选方案。约束列表中的每个约束必须具有相同数量的备用集。使用此语法，将一起选择约束列表中* all *项中的相同替代项。"

#: ../../LangRef.rst:3239
msgid "Putting those together, you might have a two operand constraint string like ``\"rm|r,ri|rm\"``. This indicates that if operand 0 is ``r`` or ``m``, then operand 1 may be one of ``r`` or ``i``. If operand 0 is ``r``, then operand 1 may be one of ``r`` or ``m``. But, operand 0 and 1 cannot both be of type m."
msgstr "把它们放在一起，你可能有一个两个操作数约束字符串，如``\\“rm | r，ri | rm \\”``。这表明如果操作数0是``r``或``m``，那么操作数1可以是``r``或``i``之一。如果操作数0是``r``，则操作数1可以是``r``或``m``之一。但是，操作数0和1不能都是m类型。"

#: ../../LangRef.rst:3244
msgid ""
"However, the use of either of the alternatives features is *NOT* recommended, as LLVM is not able to make an intelligent choice about which one to use. (At the point it currently needs to choose, not enough information is available to do so in a smart way.) Thus, it simply tries to make a choice that's most likely to compile, not one that will be optimal performance. (e.g., given \"``rm``\", it'll always choose to use memory, not registers). And, if given multiple registers, or multiple register classes, it will simply choose the first one. (In fact, it doesn't "
"currently even ensure explicitly specified physical registers are unique, so specifying multiple physical registers as alternatives, like ``{r11}{r12},{r11}{r12}``, will assign r11 to both operands, not at all what was intended.)"
msgstr "但是，建议不要使用任何替代功能，因为LLVM无法明智地选择使用哪一个。 （在目前需要选择的一点上，没有足够的信息以智能的方式这样做。）因此，它只是尝试做出最有可能编译的选择，而不是最佳性能的选择。 （例如，给定“``rm`` \\”，它总是选择使用内存，而不是寄存器）。并且，如果给定多个寄存器或多个寄存器类，它将只选择第一个。 （事实上，它目前甚至不确保明确指定的物理寄存器是唯一的，因此指定多个物理寄存器作为替代，如``{r11} {r12}，{r11} {r12}``，将r11分配给两者操作数，根本不是预期的。）"

#: ../../LangRef.rst:3257
msgid "Supported Constraint Code List"
msgstr "支持的约束代码列表"

#: ../../LangRef.rst:3259
msgid "The constraint codes are, in general, expected to behave the same way they do in GCC. LLVM's support is often implemented on an 'as-needed' basis, to support C inline asm code which was supported by GCC. A mismatch in behavior between LLVM and GCC likely indicates a bug in LLVM."
msgstr "一般来说，约束代码的行为方式与它们在GCC中的行为方式相同。 LLVM的支持通常是在“按需”的基础上实现的，以支持GCC支持的C内联asm代码。 LLVM和GCC之间的行为不匹配可能表明LLVM中存在错误。"

#: ../../LangRef.rst:3264
msgid "Some constraint codes are typically supported by all targets:"
msgstr "所有目标通常都支持一些约束代码："

#: ../../LangRef.rst:3266
msgid "``r``: A register in the target's general purpose register class."
msgstr "``r``：目标通用寄存器类中的寄存器。"

#: ../../LangRef.rst:3267
msgid "``m``: A memory address operand. It is target-specific what addressing modes are supported, typical examples are register, or register + register offset, or register + immediate offset (of some target-specific size)."
msgstr "``m``：内存地址操作数。它是特定于目标的寻址模式，典型的例子是寄存器，寄存器+寄存器偏移，或寄存器+立即偏移（某些特定于目标的大小）。"

#: ../../LangRef.rst:3270
msgid "``i``: An integer constant (of target-specific width). Allows either a simple immediate, or a relocatable value."
msgstr "``i``：一个整数常量（特定于目标的宽度）。允许简单的立即值或可重定位值。"

#: ../../LangRef.rst:3272
msgid "``n``: An integer constant -- *not* including relocatable values."
msgstr "``n``：一个整数常量 -  *不*包括可重定位的值。"

#: ../../LangRef.rst:3273
msgid "``s``: An integer constant, but allowing *only* relocatable values."
msgstr "``s``：一个整数常量，但只允许*可重定位值。"

#: ../../LangRef.rst:3274
msgid "``X``: Allows an operand of any kind, no constraint whatsoever. Typically useful to pass a label for an asm branch or call."
msgstr "``X``：允许任何类型的操作数，无任何约束。通常用于传递asm分支或调用的标签。"

#: ../../LangRef.rst:3280
msgid "``{register-name}``: Requires exactly the named physical register."
msgstr "``{register-name}``：完全需要命名的物理寄存器。"

#: ../../LangRef.rst:3282
msgid "Other constraints are target-specific:"
msgstr "其他约束是针对特定目标的："

#: ../../LangRef.rst:3284 ../../LangRef.rst:3527
msgid "AArch64:"
msgstr ""

#: ../../LangRef.rst:3286
msgid "``z``: An immediate integer 0. Outputs ``WZR`` or ``XZR``, as appropriate."
msgstr "``z``：立即整数0.输出``WZR``或``XZR``，视情况而定。"

#: ../../LangRef.rst:3287
msgid "``I``: An immediate integer valid for an ``ADD`` or ``SUB`` instruction, i.e. 0 to 4095 with optional shift by 12."
msgstr "``I``：对于``ADD``或``SUB``指令有效的立即整数，即0到4095，可选移位12。"

#: ../../LangRef.rst:3289
msgid "``J``: An immediate integer that, when negated, is valid for an ``ADD`` or ``SUB`` instruction, i.e. -1 to -4095 with optional left shift by 12."
msgstr "``J``：一个立即整数，当被否定时，对于``ADD``或``SUB``指令有效，即-1到-4095，可选左移12。"

#: ../../LangRef.rst:3291
msgid "``K``: An immediate integer that is valid for the 'bitmask immediate 32' of a logical instruction like ``AND``, ``EOR``, or ``ORR`` with a 32-bit register."
msgstr "``K``：一个立即整数，对于逻辑指令的'bitmask immediate 32'有效，如``AND``，``EOR``或带有32位寄存器的``ORR``。"

#: ../../LangRef.rst:3293
msgid "``L``: An immediate integer that is valid for the 'bitmask immediate 64' of a logical instruction like ``AND``, ``EOR``, or ``ORR`` with a 64-bit register."
msgstr "``L``：一个立即整数，对于逻辑指令的'bitmask immediate 64'有效，如``AND``，``EOR``或带有64位寄存器的``ORR``。"

#: ../../LangRef.rst:3295
msgid "``M``: An immediate integer for use with the ``MOV`` assembly alias on a 32-bit register. This is a superset of ``K``: in addition to the bitmask immediate, also allows immediate integers which can be loaded with a single ``MOVZ`` or ``MOVL`` instruction."
msgstr "``M``：一个立即整数，用于32位寄存器上的``MOV``汇编别名。这是``K``的超集：除了bitmask immediate之外，还允许直接整数，可以加载单个``MOVZ``或``MOVL``指令。"

#: ../../LangRef.rst:3299
msgid "``N``: An immediate integer for use with the ``MOV`` assembly alias on a 64-bit register. This is a superset of ``L``."
msgstr "``N``：一个立即整数，用于64位寄存器上的``MOV``汇编别名。这是“L``的超集。"

#: ../../LangRef.rst:3301
msgid "``Q``: Memory address operand must be in a single register (no offsets). (However, LLVM currently does this for the ``m`` constraint as well.)"
msgstr "``Q``：存储器地址操作数必须在单个寄存器中（无偏移）。 （但是，LLVM目前也用于``m``约束。）"

#: ../../LangRef.rst:3304
msgid "``r``: A 32 or 64-bit integer register (W* or X*)."
msgstr "``r``：32或64位整数寄存器（W *或X *）。"

#: ../../LangRef.rst:3305
msgid "``w``: A 32, 64, or 128-bit floating-point/SIMD register."
msgstr "``w``：32位，64位或128位浮点/ SIMD寄存器。"

#: ../../LangRef.rst:3306
msgid "``x``: A lower 128-bit floating-point/SIMD register (``V0`` to ``V15``)."
msgstr "``x``：一个较低的128位浮点/ SIMD寄存器（``V0``到``V15``）。"

#: ../../LangRef.rst:3308 ../../LangRef.rst:3536
msgid "AMDGPU:"
msgstr ""

#: ../../LangRef.rst:3310 ../../LangRef.rst:3425
msgid "``r``: A 32 or 64-bit integer register."
msgstr "``r``：32或64位整数寄存器。"

#: ../../LangRef.rst:3311
msgid "``[0-9]v``: The 32-bit VGPR register, number 0-9."
msgstr "``[0-9] v``：32位VGPR寄存器，编号0-9。"

#: ../../LangRef.rst:3312
msgid "``[0-9]s``: The 32-bit SGPR register, number 0-9."
msgstr "``[0-9] s``：32位SGPR寄存器，编号0-9。"

#: ../../LangRef.rst:3315
msgid "All ARM modes:"
msgstr "所有ARM模式："

#: ../../LangRef.rst:3317
msgid "``Q``, ``Um``, ``Un``, ``Uq``, ``Us``, ``Ut``, ``Uv``, ``Uy``: Memory address operand. Treated the same as operand ``m``, at the moment."
msgstr "``Q``，``Um``，``Un``，``Uq``，``Us``，``Ut``，``Uv``，``Uy``：记忆地址操作数。目前处理与操作数“m”相同。"

#: ../../LangRef.rst:3320
msgid "ARM and ARM's Thumb2 mode:"
msgstr "ARM和ARM的Thumb2模式："

#: ../../LangRef.rst:3322
msgid "``j``: An immediate integer between 0 and 65535 (valid for ``MOVW``)"
msgstr "``j``：0到65535之间的立即整数（对于``MOVW``有效）"

#: ../../LangRef.rst:3323
msgid "``I``: An immediate integer valid for a data-processing instruction."
msgstr "``I``：对数据处理指令有效的立即整数。"

#: ../../LangRef.rst:3324
msgid "``J``: An immediate integer between -4095 and 4095."
msgstr "``J``：-4095到4095之间的直接整数。"

#: ../../LangRef.rst:3325
msgid "``K``: An immediate integer whose bitwise inverse is valid for a data-processing instruction. (Can be used with template modifier \"``B``\" to print the inverted value)."
msgstr "``K``：一个立即整数，其按位反转对数据处理指令有效。 （可与模板修饰符\\“``B`` \\”一起使用以打印反转值）。"

#: ../../LangRef.rst:3328
msgid "``L``: An immediate integer whose negation is valid for a data-processing instruction. (Can be used with template modifier \"``n``\" to print the negated value)."
msgstr "``L``：一个立即数，其否定对数据处理指令有效。 （可与模板修饰符\\“``n`` \\”一起使用以打印否定值）。"

#: ../../LangRef.rst:3331
msgid "``M``: A power of two or a integer between 0 and 32."
msgstr "``M``：2的幂或0到32之间的整数。"

#: ../../LangRef.rst:3332
msgid "``N``: Invalid immediate constraint."
msgstr "``N``：无效的立即约束。"

#: ../../LangRef.rst:3333
msgid "``O``: Invalid immediate constraint."
msgstr "``O``：无效的立即约束。"

#: ../../LangRef.rst:3334
msgid "``r``: A general-purpose 32-bit integer register (``r0-r15``)."
msgstr "``r``：通用的32位整数寄存器（``r0-r15``）。"

#: ../../LangRef.rst:3335
msgid "``l``: In Thumb2 mode, low 32-bit GPR registers (``r0-r7``). In ARM mode, same as ``r``."
msgstr "``l``：在Thumb2模式下，低32位GPR寄存器（``r0-r7``）。在ARM模式下，与``r``相同。"

#: ../../LangRef.rst:3337
msgid "``h``: In Thumb2 mode, a high 32-bit GPR register (``r8-r15``). In ARM mode, invalid."
msgstr "``h``：在Thumb2模式下，一个高32位GPR寄存器（``r8-r15``）。在ARM模式下，无效。"

#: ../../LangRef.rst:3339 ../../LangRef.rst:3359
msgid "``w``: A 32, 64, or 128-bit floating-point/SIMD register: ``s0-s31``, ``d0-d31``, or ``q0-q15``."
msgstr "``w``：32位，64位或128位浮点/ SIMD寄存器：``s0-s31``，``d0-d31``或``q0-q15``。"

#: ../../LangRef.rst:3341 ../../LangRef.rst:3361
msgid "``x``: A 32, 64, or 128-bit floating-point/SIMD register: ``s0-s15``, ``d0-d7``, or ``q0-q3``."
msgstr "``x``：32位，64位或128位浮点/ SIMD寄存器：``s0-s15``，``d0-d7``或``q0-q3``。"

#: ../../LangRef.rst:3343 ../../LangRef.rst:3363
msgid "``t``: A floating-point/SIMD register, only supports 32-bit values: ``s0-s31``."
msgstr "``t``：一个浮点/ SIMD寄存器，只支持32位值：``s0-s31``。"

#: ../../LangRef.rst:3346
msgid "ARM's Thumb1 mode:"
msgstr "ARM的Thumb1模式："

#: ../../LangRef.rst:3348
msgid "``I``: An immediate integer between 0 and 255."
msgstr "``I``：0到255之间的直接整数。"

#: ../../LangRef.rst:3349
msgid "``J``: An immediate integer between -255 and -1."
msgstr "``J``：-255和-1之间的直接整数。"

#: ../../LangRef.rst:3350
msgid "``K``: An immediate integer between 0 and 255, with optional left-shift by some amount."
msgstr "``K``：0到255之间的直接整数，可选左移一些。"

#: ../../LangRef.rst:3352
msgid "``L``: An immediate integer between -7 and 7."
msgstr "``L``：-7到7之间的直接整数。"

#: ../../LangRef.rst:3353
msgid "``M``: An immediate integer which is a multiple of 4 between 0 and 1020."
msgstr "``M``：一个立即整数，它是0到1020之间的4的倍数。"

#: ../../LangRef.rst:3354
msgid "``N``: An immediate integer between 0 and 31."
msgstr "``N``：0到31之间的直接整数。"

#: ../../LangRef.rst:3355
msgid "``O``: An immediate integer which is a multiple of 4 between -508 and 508."
msgstr "``O``：一个立即整数，它是-508和508之间的4的倍数。"

#: ../../LangRef.rst:3356
msgid "``r``: A low 32-bit GPR register (``r0-r7``)."
msgstr "``r``：一个低32位GPR寄存器（``r0-r7``）。"

#: ../../LangRef.rst:3357
msgid "``l``: A low 32-bit GPR register (``r0-r7``)."
msgstr "``l``：低32位GPR寄存器（``r0-r7``）。"

#: ../../LangRef.rst:3358
msgid "``h``: A high GPR register (``r0-r7``)."
msgstr "``h``：一个高GPR寄存器（``r0-r7``）。"

#: ../../LangRef.rst:3367 ../../LangRef.rst:3569
msgid "Hexagon:"
msgstr "六边形："

#: ../../LangRef.rst:3369
msgid "``o``, ``v``: A memory address operand, treated the same as constraint ``m``, at the moment."
msgstr "``o``，``v``：一个内存地址操作数，目前处理与约束``m``相同。"

#: ../../LangRef.rst:3371
msgid "``r``: A 32 or 64-bit register."
msgstr "``r``：32或64位寄存器。"

#: ../../LangRef.rst:3373 ../../LangRef.rst:3580
msgid "MSP430:"
msgstr "MSP430："

#: ../../LangRef.rst:3375
msgid "``r``: An 8 or 16-bit register."
msgstr "``r``：8位或16位寄存器。"

#: ../../LangRef.rst:3377 ../../LangRef.rst:3584
msgid "MIPS:"
msgstr "MIPS："

#: ../../LangRef.rst:3379 ../../LangRef.rst:3414
msgid "``I``: An immediate signed 16-bit integer."
msgstr "``I``：立即签名的16位整数。"

#: ../../LangRef.rst:3380
msgid "``J``: An immediate integer zero."
msgstr "``J``：一个立即的整数零。"

#: ../../LangRef.rst:3381 ../../LangRef.rst:3416
msgid "``K``: An immediate unsigned 16-bit integer."
msgstr "``K``：一个立即无符号的16位整数。"

#: ../../LangRef.rst:3382
msgid "``L``: An immediate 32-bit integer, where the lower 16 bits are 0."
msgstr "``L``：立即32位整数，其中低16位为0。"

#: ../../LangRef.rst:3383
msgid "``N``: An immediate integer between -65535 and -1."
msgstr "``N``：-65535和-1之间的直接整数。"

#: ../../LangRef.rst:3384
msgid "``O``: An immediate signed 15-bit integer."
msgstr "``O``：立即签名的15位整数。"

#: ../../LangRef.rst:3385
msgid "``P``: An immediate integer between 1 and 65535."
msgstr "``P``：1到65535之间的直接整数。"

#: ../../LangRef.rst:3386
msgid "``m``: A memory address operand. In MIPS-SE mode, allows a base address register plus 16-bit immediate offset. In MIPS mode, just a base register."
msgstr "``m``：内存地址操作数。在MIPS-SE模式下，允许基址寄存器加上16位立即数偏移。在MIPS模式下，只是一个基址寄存器。"

#: ../../LangRef.rst:3388
msgid "``R``: A memory address operand. In MIPS-SE mode, allows a base address register plus a 9-bit signed offset. In MIPS mode, the same as constraint ``m``."
msgstr "``R``：内存地址操作数。在MIPS-SE模式下，允许基址寄存器加上9位有符号偏移。在MIPS模式下，与约束“m``相同。"

#: ../../LangRef.rst:3391
msgid "``ZC``: A memory address operand, suitable for use in a ``pref``, ``ll``, or ``sc`` instruction on the given subtarget (details vary)."
msgstr "``ZC``：一个内存地址操作数，适用于给定子目标上的``pref``，``l```或``sc``指令（详情各不相同）。"

#: ../../LangRef.rst:3393
msgid "``r``, ``d``,  ``y``: A 32 or 64-bit GPR register."
msgstr "``r``，``d``，``y``：32或64位GPR寄存器。"

#: ../../LangRef.rst:3394
msgid "``f``: A 32 or 64-bit FPU register (``F0-F31``), or a 128-bit MSA register (``W0-W31``). In the case of MSA registers, it is recommended to use the ``w`` argument modifier for compatibility with GCC."
msgstr "``f``：一个32或64位FPU寄存器（``F0-F31``），或一个128位MSA寄存器（``W0-W31``）。对于MSA寄存器，建议使用``w``参数修饰符与GCC兼容。"

#: ../../LangRef.rst:3397
msgid "``c``: A 32-bit or 64-bit GPR register suitable for indirect jump (always ``25``)."
msgstr "``c``：一个32位或64位GPR寄存器，适合间接跳转（总是“25”）。"

#: ../../LangRef.rst:3399
msgid "``l``: The ``lo`` register, 32 or 64-bit."
msgstr "``l``：``lo``寄存器，32或64位。"

#: ../../LangRef.rst:3400
msgid "``x``: Invalid."
msgstr "``x``：无效。"

#: ../../LangRef.rst:3402 ../../LangRef.rst:3609
msgid "NVPTX:"
msgstr ""

#: ../../LangRef.rst:3404
msgid "``b``: A 1-bit integer register."
msgstr "``b``：1位整数寄存器。"

#: ../../LangRef.rst:3405
msgid "``c`` or ``h``: A 16-bit integer register."
msgstr "``c``或``h``：一个16位整数寄存器。"

#: ../../LangRef.rst:3406 ../../LangRef.rst:3447 ../../LangRef.rst:3502
msgid "``r``: A 32-bit integer register."
msgstr "``r``：一个32位整数寄存器。"

#: ../../LangRef.rst:3407
msgid "``l`` or ``N``: A 64-bit integer register."
msgstr "``l``或``N``：一个64位整数寄存器。"

#: ../../LangRef.rst:3408
msgid "``f``: A 32-bit float register."
msgstr "``f``：一个32位浮点寄存器。"

#: ../../LangRef.rst:3409
msgid "``d``: A 64-bit float register."
msgstr "``d``：64位浮点寄存器。"

#: ../../LangRef.rst:3412 ../../LangRef.rst:3613
msgid "PowerPC:"
msgstr ""

#: ../../LangRef.rst:3415
msgid "``J``: An immediate unsigned 16-bit integer, shifted left 16 bits."
msgstr "``J``：一个立即无符号的16位整数，向左移16位。"

#: ../../LangRef.rst:3417
msgid "``L``: An immediate signed 16-bit integer, shifted left 16 bits."
msgstr "``L``：立即签名的16位整数，向左移16位。"

#: ../../LangRef.rst:3418
msgid "``M``: An immediate integer greater than 31."
msgstr "``M``：大于31的立即整数。"

#: ../../LangRef.rst:3419
msgid "``N``: An immediate integer that is an exact power of 2."
msgstr "``N``：一个精确幂为2的立即整数。"

#: ../../LangRef.rst:3420
msgid "``O``: The immediate integer constant 0."
msgstr "``O``：立即整数常量0。"

#: ../../LangRef.rst:3421
msgid "``P``: An immediate integer constant whose negation is a signed 16-bit constant."
msgstr "``P``：一个立即整数常量，其否定是带符号的16位常数。"

#: ../../LangRef.rst:3423
msgid "``es``, ``o``, ``Q``, ``Z``, ``Zy``: A memory address operand, currently treated the same as ``m``."
msgstr "``es``，``o``，``Q``，``Z``，``Zy``：一个内存地址操作数，当前被视为与``m``相同。"

#: ../../LangRef.rst:3426
msgid "``b``: A 32 or 64-bit integer register, excluding ``R0`` (that is: ``R1-R31``)."
msgstr "``b``：32或64位整数寄存器，不包括``R0``（即``R1-R31``）。"

#: ../../LangRef.rst:3428
msgid "``f``: A 32 or 64-bit float register (``F0-F31``), or when QPX is enabled, a 128 or 256-bit QPX register (``Q0-Q31``; aliases the ``F`` registers)."
msgstr "``f``：32或64位浮点寄存器（``F0-F31``），或者当QPX使能时，128或256位QPX寄存器（``Q0-Q31``;别名`` `F``注册）。"

#: ../../LangRef.rst:3430
msgid "``v``: For ``4 x f32`` or ``4 x f64`` types, when QPX is enabled, a 128 or 256-bit QPX register (``Q0-Q31``), otherwise a 128-bit altivec vector register (``V0-V31``)."
msgstr "``v``：对于``4 x f32``或``4 x f64``类型，当QPX使能时，128或256位QPX寄存器（``Q0-Q31``），否则为128 -bit altivec vector寄存器（``V0-V31``）。"

#: ../../LangRef.rst:3437
msgid "``y``: Condition register (``CR0-CR7``)."
msgstr "``y``：条件寄存器（``CR0-CR7``）。"

#: ../../LangRef.rst:3438
msgid "``wc``: An individual CR bit in a CR register."
msgstr "``wc``：CR寄存器中的一个CR位。"

#: ../../LangRef.rst:3439
msgid "``wa``, ``wd``, ``wf``: Any 128-bit VSX vector register, from the full VSX register set (overlapping both the floating-point and vector register files)."
msgstr "``wa``，``wd``，``wf``：任何128位VSX向量寄存器，来自完整的VSX寄存器组（重叠浮点和向量寄存器文件）。"

#: ../../LangRef.rst:3441
msgid "``ws``: A 32 or 64-bit floating point register, from the full VSX register set."
msgstr "``ws``：一个32或64位浮点寄存器，来自完整的VSX寄存器组。"

#: ../../LangRef.rst:3444 ../../LangRef.rst:3631
msgid "Sparc:"
msgstr ""

#: ../../LangRef.rst:3446
msgid "``I``: An immediate 13-bit signed integer."
msgstr "``I``：一个立即的13位有符号整数。"

#: ../../LangRef.rst:3449 ../../LangRef.rst:3635
msgid "SystemZ:"
msgstr ""

#: ../../LangRef.rst:3451
msgid "``I``: An immediate unsigned 8-bit integer."
msgstr "``I``：一个立即无符号的8位整数。"

#: ../../LangRef.rst:3452
msgid "``J``: An immediate unsigned 12-bit integer."
msgstr "``J``：一个直接无符号的12位整数。"

#: ../../LangRef.rst:3453
msgid "``K``: An immediate signed 16-bit integer."
msgstr "``K``：立即签名的16位整数。"

#: ../../LangRef.rst:3454
msgid "``L``: An immediate signed 20-bit integer."
msgstr "``L``：立即签名的20位整数。"

#: ../../LangRef.rst:3455
msgid "``M``: An immediate integer 0x7fffffff."
msgstr "``M``：立即整数0x7fffffff。"

#: ../../LangRef.rst:3456
msgid "``Q``, ``R``, ``S``, ``T``: A memory address operand, treated the same as ``m``, at the moment."
msgstr "``Q``，``R``，``S``，``T``：一个内存地址操作数，目前处理与``m``相同。"

#: ../../LangRef.rst:3458
msgid "``r`` or ``d``: A 32, 64, or 128-bit integer register."
msgstr "``r``或``d``：32位，64位或128位整数寄存器。"

#: ../../LangRef.rst:3459
msgid "``a``: A 32, 64, or 128-bit integer address register (excludes R0, which in an address context evaluates as zero)."
msgstr "``a``：32位，64位或128位整数地址寄存器（不包括R0，在地址上下文中计算为零）。"

#: ../../LangRef.rst:3461
msgid "``h``: A 32-bit value in the high part of a 64bit data register (LLVM-specific)"
msgstr "``h``:64位数据寄存器高位的32位值（特定于LLVM）"

#: ../../LangRef.rst:3463
msgid "``f``: A 32, 64, or 128-bit floating point register."
msgstr "``f``：32位，64位或128位浮点寄存器。"

#: ../../LangRef.rst:3465 ../../LangRef.rst:3640
msgid "X86:"
msgstr ""

#: ../../LangRef.rst:3467
msgid "``I``: An immediate integer between 0 and 31."
msgstr "``I``：0到31之间的直接整数。"

#: ../../LangRef.rst:3468
msgid "``J``: An immediate integer between 0 and 64."
msgstr "``J``：0到64之间的立即整数。"

#: ../../LangRef.rst:3469
msgid "``K``: An immediate signed 8-bit integer."
msgstr "``K``：立即签名的8位整数。"

#: ../../LangRef.rst:3470
msgid "``L``: An immediate integer, 0xff or 0xffff or (in 64-bit mode only) 0xffffffff."
msgstr "``L``：立即整数，0xff或0xffff或（仅在64位模式下）0xffffffff。"

#: ../../LangRef.rst:3472
msgid "``M``: An immediate integer between 0 and 3."
msgstr "``M``：0到3之间的直接整数。"

#: ../../LangRef.rst:3473
msgid "``N``: An immediate unsigned 8-bit integer."
msgstr "``N``：一个立即无符号的8位整数。"

#: ../../LangRef.rst:3474
msgid "``O``: An immediate integer between 0 and 127."
msgstr "``O``：0到127之间的直接整数。"

#: ../../LangRef.rst:3475
msgid "``e``: An immediate 32-bit signed integer."
msgstr "``e``：立即32位有符号整数。"

#: ../../LangRef.rst:3476
msgid "``Z``: An immediate 32-bit unsigned integer."
msgstr "``Z``：立即32位无符号整数。"

#: ../../LangRef.rst:3477
msgid "``o``, ``v``: Treated the same as ``m``, at the moment."
msgstr "``o``，``v``：目前处理与``m``相同。"

#: ../../LangRef.rst:3478
msgid "``q``: An 8, 16, 32, or 64-bit register which can be accessed as an 8-bit ``l`` integer register. On X86-32, this is the ``a``, ``b``, ``c``, and ``d`` registers, and on X86-64, it is all of the integer registers."
msgstr "``q``：8位，16位，32位或64位寄存器，可作为8位“l”整数寄存器访问。在X86-32上，这是``a``，``b``，``c``和``d``寄存器，在X86-64上，它是所有整数寄存器。"

#: ../../LangRef.rst:3481
msgid "``Q``: An 8, 16, 32, or 64-bit register which can be accessed as an 8-bit ``h`` integer register. This is the ``a``, ``b``, ``c``, and ``d`` registers."
msgstr "``Q``：8位，16位，32位或64位寄存器，可作为8位“h”整数寄存器访问。这是``a``，``b``，``c``和``d``寄存器。"

#: ../../LangRef.rst:3483
msgid "``r`` or ``l``: An 8, 16, 32, or 64-bit integer register."
msgstr "``r``或``l``：8,16,32或64位整数寄存器。"

#: ../../LangRef.rst:3484
msgid "``R``: An 8, 16, 32, or 64-bit \"legacy\" integer register -- one which has existed since i386, and can be accessed without the REX prefix."
msgstr "``R``：一个8,16,32或64位的“遗留”整数寄存器 - 一个自i386以来就存在的寄存器，可以在没有REX前缀的情况下访问。"

#: ../../LangRef.rst:3486
msgid "``f``: A 32, 64, or 80-bit '387 FPU stack pseudo-register."
msgstr "``f``：32位，64位或80位'387 FPU堆栈伪寄存器。"

#: ../../LangRef.rst:3487
msgid "``y``: A 64-bit MMX register, if MMX is enabled."
msgstr "``y``：一个64位MMX寄存器，如果启用了MMX。"

#: ../../LangRef.rst:3488
msgid "``x``: If SSE is enabled: a 32 or 64-bit scalar operand, or 128-bit vector operand in a SSE register. If AVX is also enabled, can also be a 256-bit vector operand in an AVX register. If AVX-512 is also enabled, can also be a 512-bit vector operand in an AVX512 register, Otherwise, an error."
msgstr "``x``：如果使能SSE：SSE寄存器中的32或64位标量操作数或128位向量操作数。如果AVX也被使能，也可以是AVX寄存器中的256位向量操作数。如果AVX-512也被使能，也可以是AVX512寄存器中的512位向量操作数，否则出错。"

#: ../../LangRef.rst:3492
msgid "``Y``: The same as ``x``, if *SSE2* is enabled, otherwise an error."
msgstr "``Y``：与``x``相同，如果启用* SSE2 *，否则出错。"

#: ../../LangRef.rst:3493
msgid "``A``: Special case: allocates EAX first, then EDX, for a single operand (in 32-bit mode, a 64-bit integer operand will get split into two registers). It is not recommended to use this constraint, as in 64-bit mode, the 64-bit operand will get allocated only to RAX -- if two 32-bit operands are needed, you're better off splitting it yourself, before passing it to the asm statement."
msgstr "``A``：特殊情况：首先为单个操作数分配EAX，然后分配EDX（在32位模式下，64位整数操作数将分成两个寄存器）。不建议使用此约束，因为在64位模式下，64位操作数将仅分配给RAX  - 如果需要两个32位操作数，最好在传递之前自行拆分它到asm声明。"

#: ../../LangRef.rst:3500 ../../LangRef.rst:3663
msgid "XCore:"
msgstr ""

#: ../../LangRef.rst:3508
msgid "Asm template argument modifiers"
msgstr "Asm模板参数修饰符"

#: ../../LangRef.rst:3510
msgid "In the asm template string, modifiers can be used on the operand reference, like \"``${0:n}``\"."
msgstr "在asm模板字符串中，可以在操作数引用上使用修饰符，例如\\```$ {0：n}``\\“。"

#: ../../LangRef.rst:3513
msgid "The modifiers are, in general, expected to behave the same way they do in GCC. LLVM's support is often implemented on an 'as-needed' basis, to support C inline asm code which was supported by GCC. A mismatch in behavior between LLVM and GCC likely indicates a bug in LLVM."
msgstr "一般来说，修饰符的行为与它们在GCC中的行为方式相同。 LLVM的支持通常是在“按需”的基础上实现的，以支持GCC支持的C内联asm代码。 LLVM和GCC之间的行为不匹配可能表明LLVM中存在错误。"

#: ../../LangRef.rst:3518
msgid "Target-independent:"
msgstr "目标无关的："

#: ../../LangRef.rst:3520
msgid "``c``: Print an immediate integer constant unadorned, without the target-specific immediate punctuation (e.g. no ``$`` prefix)."
msgstr "``c``：打印一个未加修饰的立即整数常量，没有特定于目标的立即标点符号（例如没有``$``前缀）。"

#: ../../LangRef.rst:3522
msgid "``n``: Negate and print immediate integer constant unadorned, without the target-specific immediate punctuation (e.g. no ``$`` prefix)."
msgstr "``n``：否定并打印立即整数常量未加修饰，没有特定于目标的立即标点符号（例如没有``$``前缀）。"

#: ../../LangRef.rst:3524
msgid "``l``: Print as an unadorned label, without the target-specific label punctuation (e.g. no ``$`` prefix)."
msgstr "``l``：作为一个简单的标签打印，没有特定于目标的标签标点符号（例如没有``$``前缀）。"

#: ../../LangRef.rst:3529
msgid "``w``: Print a GPR register with a ``w*`` name instead of ``x*`` name. E.g., instead of ``x30``, print ``w30``."
msgstr "``w``：使用``w *``名称而不是``x *``名称打印GPR寄存器。例如，而不是``x30``，打印``w30``。"

#: ../../LangRef.rst:3531
msgid "``x``: Print a GPR register with a ``x*`` name. (this is the default, anyhow)."
msgstr "``x``：打印一个带有``x *``名称的GPR寄存器。 （无论如何，这是默认值）。"

#: ../../LangRef.rst:3532
msgid "``b``, ``h``, ``s``, ``d``, ``q``: Print a floating-point/SIMD register with a ``b*``, ``h*``, ``s*``, ``d*``, or ``q*`` name, rather than the default of ``v*``."
msgstr "``b``，``h``，``s``，``d``，``q``：用``b *``打印一个浮点/ SIMD寄存器，``h *`，``s *``，``d *``或``q *``名称，而不是默认的``v *``。"

#: ../../LangRef.rst:3538 ../../LangRef.rst:3611 ../../LangRef.rst:3633
msgid "``r``: No effect."
msgstr "``r``：没影响。"

#: ../../LangRef.rst:3540
msgid "ARM:"
msgstr ""

#: ../../LangRef.rst:3542
msgid "``a``: Print an operand as an address (with ``[`` and ``]`` surrounding a register)."
msgstr "``a``：将操作数打印为地址（寄存器周围有````````````。"

#: ../../LangRef.rst:3544
msgid "``P``: No effect."
msgstr "``P``：没效果。"

#: ../../LangRef.rst:3545
msgid "``q``: No effect."
msgstr "``q``：没效果。"

#: ../../LangRef.rst:3546
msgid "``y``: Print a VFP single-precision register as an indexed double (e.g. print as ``d4[1]`` instead of ``s9``)"
msgstr "``y``：将VFP单精度寄存器打印为索引双精度（例如打印为``d4 [1]``而不是``s9``）"

#: ../../LangRef.rst:3548
msgid "``B``: Bitwise invert and print an immediate integer constant without ``#`` prefix."
msgstr "``B``：按位反转并打印一个没有``#``前缀的立即整数常量。"

#: ../../LangRef.rst:3550
msgid "``L``: Print the low 16-bits of an immediate integer constant."
msgstr "``L``：打印一个立即整数常量的低16位。"

#: ../../LangRef.rst:3551
msgid "``M``: Print as a register set suitable for ldm/stm. Also prints *all* register operands subsequent to the specified one (!), so use carefully."
msgstr "``M``：打印为适合ldm / stm的寄存器组。还会在指定的（！）之后打印* all *寄存器操作数，因此请小心使用。"

#: ../../LangRef.rst:3553
msgid "``Q``: Print the low-order register of a register-pair, or the low-order register of a two-register operand."
msgstr "``Q``：打印寄存器对的低位寄存器，或双寄存器操作数的低位寄存器。"

#: ../../LangRef.rst:3555
msgid "``R``: Print the high-order register of a register-pair, or the high-order register of a two-register operand."
msgstr "``R``：打印寄存器对的高位寄存器，或双寄存器操作数的高位寄存器。"

#: ../../LangRef.rst:3557
msgid "``H``: Print the second register of a register-pair. (On a big-endian system, ``H`` is equivalent to ``Q``, and on little-endian system, ``H`` is equivalent to ``R``.)"
msgstr "``H``：打印寄存器对的第二个寄存器。 （在大端系统中，``H``相当于``Q``，而在little-endian系统中，``H``相当于``R``。）"

#: ../../LangRef.rst:3564
msgid "``e``: Print the low doubleword register of a NEON quad register."
msgstr "``e``：打印NEON quad寄存器的低双字寄存器。"

#: ../../LangRef.rst:3565
msgid "``f``: Print the high doubleword register of a NEON quad register."
msgstr "``f``：打印NEON四重寄存器的高双字寄存器。"

#: ../../LangRef.rst:3566
msgid "``m``: Print the base register of a memory operand without the ``[`` and ``]`` adornment."
msgstr "``m``：打印内存操作数的基址寄存器，不带``````和`````装饰。"

#: ../../LangRef.rst:3571 ../../LangRef.rst:3615
msgid "``L``: Print the second register of a two-register operand. Requires that it has been allocated consecutively to the first."
msgstr "``L``：打印双寄存器操作数的第二个寄存器。要求它已连续分配到第一个。"

#: ../../LangRef.rst:3577 ../../LangRef.rst:3621
msgid "``I``: Print the letter 'i' if the operand is an integer constant, otherwise nothing. Used to print 'addi' vs 'add' instructions."
msgstr "``I``：如果操作数是整数常量，则打印字母'i'，否则不打印。用于打印'addi'与'添加'说明。"

#: ../../LangRef.rst:3582 ../../LangRef.rst:3665
msgid "No additional modifiers."
msgstr "没有额外的修饰符。"

#: ../../LangRef.rst:3586
msgid "``X``: Print an immediate integer as hexadecimal"
msgstr "``X``：将十六进制的立即数整数打印出来"

#: ../../LangRef.rst:3587
msgid "``x``: Print the low 16 bits of an immediate integer as hexadecimal."
msgstr "`````：将十六进制的低位16位打印为十六进制。"

#: ../../LangRef.rst:3588
msgid "``d``: Print an immediate integer as decimal."
msgstr "``d``：打印一个十进制的立即数。"

#: ../../LangRef.rst:3589
msgid "``m``: Subtract one and print an immediate integer as decimal."
msgstr "``m``：减去一个并打印一个十进制的立即数。"

#: ../../LangRef.rst:3590
msgid "``z``: Print $0 if an immediate zero, otherwise print normally."
msgstr "``z``：如果立即为零则打印$ 0，否则打印正常。"

#: ../../LangRef.rst:3591
msgid "``L``: Print the low-order register of a two-register operand, or prints the address of the low-order word of a double-word memory operand."
msgstr "``L``：打印双寄存器操作数的低位寄存器，或打印双字存储器操作数的低位字地址。"

#: ../../LangRef.rst:3596
msgid "``M``: Print the high-order register of a two-register operand, or prints the address of the high-order word of a double-word memory operand."
msgstr "``M``：打印双寄存器操作数的高位寄存器，或打印双字存储器操作数的高位字地址。"

#: ../../LangRef.rst:3601
msgid "``D``: Print the second register of a two-register operand, or prints the second word of a double-word memory operand. (On a big-endian system, ``D`` is equivalent to ``L``, and on little-endian system, ``D`` is equivalent to ``M``.)"
msgstr "``D``：打印双寄存器操作数的第二个寄存器，或打印双字存储器操作数的第二个字。 （在大端系统中，``D``相当于``L``，而在little-endian系统中，``D``相当于``M``。）"

#: ../../LangRef.rst:3605
msgid "``w``: No effect. Provided for compatibility with GCC which requires this modifier in order to print MSA registers (``W0-W31``) with the ``f`` constraint."
msgstr "``w``：没效果。提供与GCC的兼容性，需要使用此修饰符以使用``f``约束打印MSA寄存器（``W0-W31``）。"

#: ../../LangRef.rst:3623
msgid "``y``: For a memory operand, prints formatter for a two-register X-form instruction. (Currently always prints ``r0,OPERAND``)."
msgstr "``y``：对于内存操作数，打印格式化程序，用于双寄存器X-form指令。 （目前总是打印``r0，OPERAND``）。"

#: ../../LangRef.rst:3625
msgid "``U``: Prints 'u' if the memory operand is an update form, and nothing otherwise. (NOTE: LLVM does not support update form, so this will currently always print nothing)"
msgstr "``U``：如果内存操作数是更新形式，则打印'u'，否则不打印。 （注意：LLVM不支持更新表单，因此目前始终不打印任何内容）"

#: ../../LangRef.rst:3628
msgid "``X``: Prints 'x' if the memory operand is an indexed form. (NOTE: LLVM does not support indexed form, so this will currently always print nothing)"
msgstr "``X``：如果内存操作数是索引形式，则打印'x'。 （注意：LLVM不支持索引格式，因此目前始终不打印任何内容）"

#: ../../LangRef.rst:3637
msgid "SystemZ implements only ``n``, and does *not* support any of the other target-independent modifiers."
msgstr "SystemZ仅实现``n``，并且*不支持任何其他与目标无关的修饰符。"

#: ../../LangRef.rst:3642
msgid "``c``: Print an unadorned integer or symbol name. (The latter is target-specific behavior for this typically target-independent modifier)."
msgstr "``c``：打印一个未经修饰的整数或符号名称。 （后者是这种通常与目标无关的修饰符的特定于目标的行为）。"

#: ../../LangRef.rst:3644
msgid "``A``: Print a register name with a '``*``' before it."
msgstr "``A``：在它之前打印一个带有'````'的寄存器名称。"

#: ../../LangRef.rst:3645
msgid "``b``: Print an 8-bit register name (e.g. ``al``); do nothing on a memory operand."
msgstr "``b``：打印一个8位的寄存器名称（例如``al``）;对内存操作数不执行任何操作。"

#: ../../LangRef.rst:3647
msgid "``h``: Print the upper 8-bit register name (e.g. ``ah``); do nothing on a memory operand."
msgstr "``h``：打印高8位寄存器名称（例如``ah``）;对内存操作数不执行任何操作。"

#: ../../LangRef.rst:3649
msgid "``w``: Print the 16-bit register name (e.g. ``ax``); do nothing on a memory operand."
msgstr "``w``：打印16位寄存器名称（例如``ax``）;对内存操作数不执行任何操作。"

#: ../../LangRef.rst:3651
msgid "``k``: Print the 32-bit register name (e.g. ``eax``); do nothing on a memory operand."
msgstr "``k``：打印32位寄存器名称（例如``eax``）;对内存操作数不执行任何操作。"

#: ../../LangRef.rst:3653
msgid "``q``: Print the 64-bit register name (e.g. ``rax``), if 64-bit registers are available, otherwise the 32-bit register name; do nothing on a memory operand."
msgstr "``q``：打印64位寄存器名称（例如``rax``），如果64位寄存器可用，否则打印32位寄存器名称;对内存操作数不执行任何操作。"

#: ../../LangRef.rst:3655
msgid "``n``: Negate and print an unadorned integer, or, for operands other than an immediate integer (e.g. a relocatable symbol expression), print a '-' before the operand. (The behavior for relocatable symbol expressions is a target-specific behavior for this typically target-independent modifier)"
msgstr "``n``：否定并打印一个未修饰的整数，或者，对于立即整数以外的操作数（例如可重定位符号表达式），在操作数之前打印' - '。 （可重定位符号表达式的行为是此通常与目标无关的修饰符的特定于目标的行为）"

#: ../../LangRef.rst:3659
msgid "``H``: Print a memory reference with additional offset +8."
msgstr "``H``：打印带有附加偏移量+8的内存引用。"

#: ../../LangRef.rst:3660
msgid "``P``: Print a memory reference or operand for use as the argument of a call instruction. (E.g. omit ``(rip)``, even though it's PC-relative.)"
msgstr "``P``：打印内存引用或操作数，用作调用指令的参数。 （例如省略``（rip）``，即使它是PC相对的。）"

#: ../../LangRef.rst:3669
msgid "Inline Asm Metadata"
msgstr "内联Asm元数据"

#: ../../LangRef.rst:3671
msgid "The call instructions that wrap inline asm nodes may have a \"``!srcloc``\" MDNode attached to it that contains a list of constant integers. If present, the code generator will use the integer as the location cookie value when report errors through the ``LLVMContext`` error reporting mechanisms. This allows a front-end to correlate backend errors that occur with inline asm back to the source code that produced it. For example:"
msgstr "包含内联asm节点的调用指令可能附加了一个包含常量整数列表的```srcloc`` \\“MDNode。如果存在，代码生成器将通过“LLVMContext”错误报告机制报告错误时使用整数作为位置cookie值。这允许前端将内联asm发生的后端错误与产生它的源代码相关联。例如："

#: ../../LangRef.rst:3685
msgid "It is up to the front-end to make sense of the magic numbers it places in the IR. If the MDNode contains multiple constants, the code generator will use the one that corresponds to the line of the asm that the error occurs on."
msgstr "由前端来理解它在IR中的神奇数字。如果MDNode包含多个常量，则代码生成器将使用与发生错误的asm行相对应的那个。"

#: ../../LangRef.rst:3693
msgid "Metadata"
msgstr "元数据"

#: ../../LangRef.rst:3695
msgid "LLVM IR allows metadata to be attached to instructions in the program that can convey extra information about the code to the optimizers and code generator. One example application of metadata is source-level debug information. There are two metadata primitives: strings and nodes."
msgstr "LLVM IR允许将元数据附加到程序中的指令，该指令可以将有关代码的额外信息传递给优化器和代码生成器。元数据的一个示例应用是源级调试信息。有两个元数据原语：字符串和节点。"

#: ../../LangRef.rst:3700
msgid "Metadata does not have a type, and is not a value. If referenced from a ``call`` instruction, it uses the ``metadata`` type."
msgstr "元数据没有类型，也不是值。如果从``call``指令引用，它使用``metadata``类型。"

#: ../../LangRef.rst:3703
msgid "All metadata are identified in syntax by a exclamation point ('``!``')."
msgstr "所有元数据都通过感叹号（'``！``'）在语法中标识。"

#: ../../LangRef.rst:3708
msgid "Metadata Nodes and Metadata Strings"
msgstr "元数据节点和元数据字符串"

#: ../../LangRef.rst:3710
msgid "A metadata string is a string surrounded by double quotes. It can contain any character by escaping non-printable characters with \"``\\xx``\" where \"``xx``\" is the two digit hex code. For example: \"``!\"test\\00\"``\"."
msgstr "元数据字符串是由双引号括起来的字符串。它可以通过转义不可打印的字符来包含任何字符，其中\\“``\\ xx`` \\”其中\\“``xx`` \\”是两位十六进制代码。例如：\\“``！\\”test \\ 00 \\“``\\”。"

#: ../../LangRef.rst:3715
msgid "Metadata nodes are represented with notation similar to structure constants (a comma separated list of elements, surrounded by braces and preceded by an exclamation point). Metadata nodes can have any values as their operand. For example:"
msgstr "元数据节点用类似于结构常量的符号表示（以逗号分隔的元素列表，由大括号括起并以感叹号开头）。元数据节点可以将任何值作为其操作数。例如："

#: ../../LangRef.rst:3724
msgid "Metadata nodes that aren't uniqued use the ``distinct`` keyword. For example:"
msgstr "未使用的元数据节点使用``distinct``关键字。例如："

#: ../../LangRef.rst:3730
msgid "``distinct`` nodes are useful when nodes shouldn't be merged based on their content. They can also occur when transformations cause uniquing collisions when metadata operands change."
msgstr "当不应根据内容合并节点时，``distinct``节点很有用。当元数据操作数发生变化时，当转换导致单一冲突时，它们也会发生。"

#: ../../LangRef.rst:3734
msgid "A :ref:`named metadata <namedmetadatastructure>` is a collection of metadata nodes, which can be looked up in the module symbol table. For example:"
msgstr "答：ref：`named metadata <namedmetadatastructure>`是元数据节点的集合，可以在模块符号表中查找。例如："

#: ../../LangRef.rst:3742
msgid "Metadata can be used as function arguments. Here ``llvm.dbg.value`` function is using two metadata arguments:"
msgstr "元数据可以用作函数参数。这里``llvm.dbg.value``函数使用两个元数据参数："

#: ../../LangRef.rst:3749
msgid "Metadata can be attached to an instruction. Here metadata ``!21`` is attached to the ``add`` instruction using the ``!dbg`` identifier:"
msgstr "元数据可以附加到指令。这里元数据``！21``使用``！dbg``标识符附加到``add``指令："

#: ../../LangRef.rst:3756
msgid "Metadata can also be attached to a function definition. Here metadata ``!22`` is attached to the ``foo`` function using the ``!dbg`` identifier:"
msgstr "元数据也可以附加到函数定义。这里元数据``！22``使用``！dbg``标识符附加到``foo``函数："

#: ../../LangRef.rst:3765
msgid "More information about specific metadata nodes recognized by the optimizers and code generator is found below."
msgstr "有关优化器和代码生成器识别的特定元数据节点的更多信息，请参见下文。"

#: ../../LangRef.rst:3771
msgid "Specialized Metadata Nodes"
msgstr "专业元数据节点"

#: ../../LangRef.rst:3773
msgid "Specialized metadata nodes are custom data structures in metadata (as opposed to generic tuples). Their fields are labelled, and can be specified in any order."
msgstr "专用元数据节点是元数据中的自定义数据结构（与通用元组相对）。它们的字段已标记，可以按任何顺序指定。"

#: ../../LangRef.rst:3777
msgid "These aren't inherently debug info centric, but currently all the specialized metadata nodes are related to debug info."
msgstr "这些本质上不是以调试信息为中心的，但目前所有专用元数据节点都与调试信息相关。"

#: ../../LangRef.rst:3783
msgid "DICompileUnit"
msgstr "DICompileUnit"

#: ../../LangRef.rst:3785
msgid "``DICompileUnit`` nodes represent a compile unit. The ``enums:``, ``retainedTypes:``, ``subprograms:``, ``globals:``, ``imports:`` and ``macros:`` fields are tuples containing the debug info to be emitted along with the compile unit, regardless of code optimizations (some nodes are only emitted if there are references to them from instructions)."
msgstr "``DICompileUnit``节点代表一个编译单元。 ``enums：``，``retainedTypes：``，``subprograms：``，``globals：``，``imports：``和``macros：``字段是包含调试信息的元组无论代码优化如何，都会与编译单元一起发出（只有在从指令引用它们时才会发出一些节点）。"

#: ../../LangRef.rst:3799
msgid "Compile unit descriptors provide the root scope for objects declared in a specific compilation unit. File descriptors are defined using this scope. These descriptors are collected by a named metadata ``!llvm.dbg.cu``. They keep track of subprograms, global variables, type information, and imported entities (declarations and namespaces)."
msgstr "编译单元描述符提供在特定编译单元中声明的对象的根范围。使用此范围定义文件描述符。这些描述符由命名元数据``！llvm.dbg.cu``收集。它们跟踪子程序，全局变量，类型信息和导入的实体（声明和命名空间）。"

#: ../../LangRef.rst:3808
msgid "DIFile"
msgstr "DIFile"

#: ../../LangRef.rst:3810
msgid "``DIFile`` nodes represent files. The ``filename:`` can include slashes."
msgstr "``DIFile``节点代表文件。 ``filename：``可以包含斜杠。"

#: ../../LangRef.rst:3816
msgid "Files are sometimes used in ``scope:`` fields, and are the only valid target for ``file:`` fields."
msgstr "文件有时用在``scope：``字段中，并且是``file：``字段的唯一有效目标。"

#: ../../LangRef.rst:3822
msgid "DIBasicType"
msgstr "DIBasicType"

#: ../../LangRef.rst:3824
msgid "``DIBasicType`` nodes represent primitive types, such as ``int``, ``bool`` and ``float``. ``tag:`` defaults to ``DW_TAG_base_type``."
msgstr "``DIBasicType``节点代表原始类型，例如``int``，``bool``和``float``。 ``tag：``默认为``DW_TAG_base_type``。"

#: ../../LangRef.rst:3833
msgid "The ``encoding:`` describes the details of the type. Usually it's one of the following:"
msgstr "``encoding：``描述了类型的细节。通常它是以下之一："

#: ../../LangRef.rst:3849
msgid "DISubroutineType"
msgstr "DISubroutineType"

#: ../../LangRef.rst:3851
msgid "``DISubroutineType`` nodes represent subroutine types. Their ``types:`` field refers to a tuple; the first operand is the return type, while the rest are the types of the formal arguments in order. If the first operand is ``null``, that represents a function with no return value (such as ``void foo() {}`` in C++)."
msgstr "``DISubroutineType``节点代表子程序类型。他们的``types：``字段指的是一个元组;第一个操作数是返回类型，其余是正则参数的类型。如果第一个操作数是“null”，则表示没有返回值的函数（例如C ++中的``void foo（）{}``。"

#: ../../LangRef.rst:3865
msgid "DIDerivedType"
msgstr "DIDerivedType"

#: ../../LangRef.rst:3867
msgid "``DIDerivedType`` nodes represent types derived from other types, such as qualified types."
msgstr "``DIDerivedType``节点表示从其他类型派生的类型，例如限定类型。"

#: ../../LangRef.rst:3877 ../../LangRef.rst:3927
msgid "The following ``tag:`` values are valid:"
msgstr "以下``tag：``值有效："

#: ../../LangRef.rst:3891
msgid "``DW_TAG_member`` is used to define a member of a :ref:`composite type <DICompositeType>` or :ref:`subprogram <DISubprogram>`. The type of the member is the ``baseType:``. The ``offset:`` is the member's bit offset. ``DW_TAG_formal_parameter`` is used to define a member which is a formal argument of a subprogram."
msgstr "``DW_TAG_member``用于定义一个成员：ref：`composite type <DICompositeType>`或：ref：`subprogram <DISubprogram>`。成员的类型是``baseType：``。 ``offset：``是成员的位偏移量。 ``DW_TAG_formal_parameter``用于定义一个成员，该成员是子程序的形式参数。"

#: ../../LangRef.rst:3897
msgid "``DW_TAG_typedef`` is used to provide a name for the ``baseType:``."
msgstr "``DW_TAG_typedef``用于为``baseType：``提供一个名称。"

#: ../../LangRef.rst:3899
msgid "``DW_TAG_pointer_type``, ``DW_TAG_reference_type``, ``DW_TAG_const_type``, ``DW_TAG_volatile_type`` and ``DW_TAG_restrict_type`` are used to qualify the ``baseType:``."
msgstr "``DW_TAG_pointer_type``，``DW_TAG_reference_type``，``DW_TAG_const_type``，``DW_TAG_volatile_type``和``DW_TAG_restrict_type``用于限定``baseType：``。"

#: ../../LangRef.rst:3903
msgid "Note that the ``void *`` type is expressed as a type derived from NULL."
msgstr "请注意，``void *``类型表示为从NULL派生的类型。"

#: ../../LangRef.rst:3908
msgid "DICompositeType"
msgstr "DICompositeType"

#: ../../LangRef.rst:3910
msgid "``DICompositeType`` nodes represent types composed of other types, like structures and unions. ``elements:`` points to a tuple of the composed types."
msgstr "``DICompositeType``节点表示由其他类型组成的类型，如结构和联合。 ``elements：``指向组合类型的元组。"

#: ../../LangRef.rst:3913
msgid "If the source language supports ODR, the ``identifier:`` field gives the unique identifier used for type merging between modules. When specified, other types can refer to composite types indirectly via a :ref:`metadata string <metadata-string>` that matches their identifier."
msgstr "如果源语言支持ODR，则``identifier：``字段给出用于模块之间类型合并的唯一标识符。指定时，其他类型可以通过以下方式间接引用复合类型：ref：`metadata string <metadata-string>`匹配其标识符。"

#: ../../LangRef.rst:3940
msgid "For ``DW_TAG_array_type``, the ``elements:`` should be :ref:`subrange descriptors <DISubrange>`, each representing the range of subscripts at that level of indexing. The ``DIFlagVector`` flag to ``flags:`` indicates that an array type is a native packed vector."
msgstr "对于``DW_TAG_array_type``，``elements：``应该是：ref：`subrange descriptors <DISubrange>`，每个表示索引级别的下标范围。 ``flags：``的``DIFlagVector``标志表示数组类型是本机打包向量。"

#: ../../LangRef.rst:3945
msgid "For ``DW_TAG_enumeration_type``, the ``elements:`` should be :ref:`enumerator descriptors <DIEnumerator>`, each representing the definition of an enumeration value for the set. All enumeration type descriptors are collected in the ``enums:`` field of the :ref:`compile unit <DICompileUnit>`."
msgstr "对于``DW_TAG_enumeration_type``，``elements：``应该是：ref：`枚举器描述符<DIEnumerator>`，每个表示集合的枚举值的定义。所有枚举类型描述符都收集在：ref：`compile unit <DICompileUnit>`的``enums：``字段中。"

#: ../../LangRef.rst:3950
msgid "For ``DW_TAG_structure_type``, ``DW_TAG_class_type``, and ``DW_TAG_union_type``, the ``elements:`` should be :ref:`derived types <DIDerivedType>` with ``tag: DW_TAG_member`` or ``tag: DW_TAG_inheritance``."
msgstr "对于``DW_TAG_structure_type``，``DW_TAG_class_type``和``DW_TAG_union_type``，``elements：``应该是：ref：`derived types <DIDerivedType>`with``tag：DW_TAG_member``或``标签：DW_TAG_inheritance``。"

#: ../../LangRef.rst:3957
msgid "DISubrange"
msgstr "DISubrange"

#: ../../LangRef.rst:3959
msgid "``DISubrange`` nodes are the elements for ``DW_TAG_array_type`` variants of :ref:`DICompositeType`. ``count: -1`` indicates an empty array."
msgstr "``DISubrange``节点是``DW_TAG_array_type``变体的元素：ref：`DICompositeType`。 ``count：-1``表示一个空数组。"

#: ../../LangRef.rst:3971
msgid "DIEnumerator"
msgstr "DIEnumerator"

#: ../../LangRef.rst:3973
msgid "``DIEnumerator`` nodes are the elements for ``DW_TAG_enumeration_type`` variants of :ref:`DICompositeType`."
msgstr "``DIEnumerator``节点是``DW_TAG_enumeration_type``变体的元素：ref：`DICompositeType`。"

#: ../../LangRef.rst:3983
msgid "DITemplateTypeParameter"
msgstr "DITemplateTypeParameter"

#: ../../LangRef.rst:3985
msgid "``DITemplateTypeParameter`` nodes represent type parameters to generic source language constructs. They are used (optionally) in :ref:`DICompositeType` and :ref:`DISubprogram` ``templateParams:`` fields."
msgstr "``DITemplateTypeParameter``节点表示通用源语言结构的类型参数。它们（可选）用于：ref：`DICompositeType`和：ref：`DISubprogram```templateParams：``fields。"

#: ../../LangRef.rst:3994
msgid "DITemplateValueParameter"
msgstr "DITemplateValueParameter"

#: ../../LangRef.rst:3996
msgid "``DITemplateValueParameter`` nodes represent value parameters to generic source language constructs. ``tag:`` defaults to ``DW_TAG_template_value_parameter``, but if specified can also be set to ``DW_TAG_GNU_template_template_param`` or ``DW_TAG_GNU_template_param_pack``. They are used (optionally) in :ref:`DICompositeType` and :ref:`DISubprogram` ``templateParams:`` fields."
msgstr "``DITemplateValueParameter``节点表示通用源语言结构的值参数。 ``tag：``默认为``DW_TAG_template_value_parameter``，但如果指定也可以设置为``DW_TAG_GNU_template_template_param``或``DW_TAG_GNU_template_param_pack``。它们（可选）用于：ref：`DICompositeType`和：ref：`DISubprogram```templateParams：``fields。"

#: ../../LangRef.rst:4007
msgid "DINamespace"
msgstr "DINamespace"

#: ../../LangRef.rst:4009
msgid "``DINamespace`` nodes represent namespaces in the source language."
msgstr "``DINamespace``节点表示源语言中的命名空间。"

#: ../../LangRef.rst:4016
msgid "DIGlobalVariable"
msgstr "DIGlobalVariable"

#: ../../LangRef.rst:4018
msgid "``DIGlobalVariable`` nodes represent global variables in the source language."
msgstr "``DIGlobalVariable``节点表示源语言中的全局变量。"

#: ../../LangRef.rst:4027
msgid "All global variables should be referenced by the `globals:` field of a :ref:`compile unit <DICompileUnit>`."
msgstr "所有全局变量都应该由：ref：`compile unit <DICompileUnit>`的`globals：`字段引用。"

#: ../../LangRef.rst:4033
msgid "DISubprogram"
msgstr "DISubprogram"

#: ../../LangRef.rst:4035
msgid "``DISubprogram`` nodes represent functions from the source language. A ``DISubprogram`` may be attached to a function definition using ``!dbg`` metadata. The ``variables:`` field points at :ref:`variables <DILocalVariable>` that must be retained, even if their IR counterparts are optimized out of the IR. The ``type:`` field must point at an :ref:`DISubroutineType`."
msgstr "``DISubprogram``节点代表源语言的功能。可以使用``！dbg``元数据将``DISubprogram``附加到函数定义。 ``variables：``字段指向：ref：`variables <DILocalVariable>`必须保留，即使它们的IR对应物在IR之外被优化。 ``type：``字段必须指向：ref：`DISubroutineType`。"

#: ../../LangRef.rst:4059
msgid "DILexicalBlock"
msgstr "DILexicalBlock"

#: ../../LangRef.rst:4061
msgid "``DILexicalBlock`` nodes describe nested blocks within a :ref:`subprogram <DISubprogram>`. The line number and column numbers are used to distinguish two lexical blocks at same depth. They are valid targets for ``scope:`` fields."
msgstr "``DILexicalBlock``节点描述了一个：ref：`subprogram <DISubprogram>`中的嵌套块。行号和列号用于区分相同深度的两个词法块。它们是``scope：``字段的有效目标。"

#: ../../LangRef.rst:4070
msgid "Usually lexical blocks are ``distinct`` to prevent node merging based on operands."
msgstr "通常，词汇块是“不同的”以防止基于操作数的节点合并。"

#: ../../LangRef.rst:4076
msgid "DILexicalBlockFile"
msgstr "DILexicalBlockFile"

#: ../../LangRef.rst:4078
msgid "``DILexicalBlockFile`` nodes are used to discriminate between sections of a :ref:`lexical block <DILexicalBlock>`. The ``file:`` field can be changed to indicate textual inclusion, or the ``discriminator:`` field can be used to discriminate between control flow within a single block in the source language."
msgstr "``DILexicalBlockFile``节点用于区分a：ref：`lexical block <DILexicalBlock>`的各个部分。可以更改``file：``字段以指示文本包含，或者`discriminator：``字段可用于区分源语言中单个块内的控制流。"

#: ../../LangRef.rst:4092
msgid "DILocation"
msgstr "DILocation"

#: ../../LangRef.rst:4094
msgid "``DILocation`` nodes represent source debug locations. The ``scope:`` field is mandatory, and points at an :ref:`DILexicalBlockFile`, an :ref:`DILexicalBlock`, or an :ref:`DISubprogram`."
msgstr "``DILocation``节点代表源调试位置。 ``scope：``字段是必需的，并指向：ref：`DILexicalBlockFile`，a：ref：`DILexicalBlock`，或者：ref：`DISubprogram`。"

#: ../../LangRef.rst:4105
msgid "DILocalVariable"
msgstr "DILocalVariable"

#: ../../LangRef.rst:4107
msgid "``DILocalVariable`` nodes represent local variables in the source language. If the ``arg:`` field is set to non-zero, then this variable is a subprogram parameter, and it will be included in the ``variables:`` field of its :ref:`DISubprogram`."
msgstr "``DilocalVariable``节点表示源语言中的局部变量。如果``arg：``字段设置为非零，那么这个变量是一个子程序参数，它将包含在它的：`ref：`DISubprogram`的``variables：``字段中。"

#: ../../LangRef.rst:4121
msgid "DIExpression"
msgstr "DIExpression"

#: ../../LangRef.rst:4123
msgid "``DIExpression`` nodes represent DWARF expression sequences. They are used in :ref:`debug intrinsics<dbg_intrinsics>` (such as ``llvm.dbg.declare``) to describe how the referenced LLVM variable relates to the source language variable."
msgstr "``DIExpression``节点代表DWARF表达序列。它们用于：ref：`debug intrinsics <dbg_intrinsics>`（例如``llvm.dbg.declare``）来描述引用的LLVM变量如何与源语言变量相关。"

#: ../../LangRef.rst:4128
msgid "The current supported vocabulary is limited:"
msgstr "目前支持的词汇量有限："

#: ../../LangRef.rst:4130
msgid "``DW_OP_deref`` dereferences the working expression."
msgstr "``DW_OP_deref``取消引用工作表达式。"

#: ../../LangRef.rst:4131
msgid "``DW_OP_plus, 93`` adds ``93`` to the working expression."
msgstr "``DW_OP_plus，93``将``93``添加到工作表达式中。"

#: ../../LangRef.rst:4132
msgid "``DW_OP_bit_piece, 16, 8`` specifies the offset and size (``16`` and ``8`` here, respectively) of the variable piece from the working expression."
msgstr "``DW_OP_bit_piece，16,8``指定工作表达式中变量段的偏移量和大小（分别为“16”和“8”）。"

#: ../../LangRef.rst:4143
msgid "DIObjCProperty"
msgstr "DIObjCProperty"

#: ../../LangRef.rst:4145
msgid "``DIObjCProperty`` nodes represent Objective-C property nodes."
msgstr "``DIObjCProperty``节点代表Objective-C属性节点。"

#: ../../LangRef.rst:4153
msgid "DIImportedEntity"
msgstr "DIImportedEntity"

#: ../../LangRef.rst:4155
msgid "``DIImportedEntity`` nodes represent entities (such as modules) imported into a compile unit."
msgstr "``DIImportedEntity``节点表示导入到编译单元中的实体（例如模块）。"

#: ../../LangRef.rst:4164
msgid "DIMacro"
msgstr "DIMacro"

#: ../../LangRef.rst:4166
msgid "``DIMacro`` nodes represent definition or undefinition of a macro identifiers. The ``name:`` field is the macro identifier, followed by macro parameters when definining a function-like macro, and the ``value`` field is the token-string used to expand the macro identifier."
msgstr "``DIMacro``节点表示宏标识符的定义或不定义。 ``name：``字段是宏标识符，在定义类似函数的宏时后跟宏参数，``value``字段是用于扩展宏标识符的标记字符串。"

#: ../../LangRef.rst:4178
msgid "DIMacroFile"
msgstr "DIMacroFile"

#: ../../LangRef.rst:4180
msgid "``DIMacroFile`` nodes represent inclusion of source files. The ``nodes:`` field is a list of ``DIMacro`` and ``DIMacroFile`` nodes that appear in the included source file."
msgstr "``DIMacroFile``节点表示包含源文件。 ``nodes：``字段是包含在源文件中的``DIMacro``和``DIMacroFile``节点的列表。"

#: ../../LangRef.rst:4190
msgid "'``tbaa``' Metadata"
msgstr "'``tbaa``'元数据"

#: ../../LangRef.rst:4192
msgid "In LLVM IR, memory does not have types, so LLVM's own type system is not suitable for doing TBAA. Instead, metadata is added to the IR to describe a type system of a higher level language. This can be used to implement typical C/C++ TBAA, but it can also be used to implement custom alias analysis behavior for other languages."
msgstr "在LLVM IR中，内存没有类型，因此LLVM自己的类型系统不适合执行TBAA。相反，元数据被添加到IR以描述更高级语言的类型系统。这可用于实现典型的C / C ++ TBAA，但它也可用于实现其他语言的自定义别名分析行为。"

#: ../../LangRef.rst:4198
msgid "The current metadata format is very simple. TBAA metadata nodes have up to three fields, e.g.:"
msgstr "当前的元数据格式非常简单。 TBAA元数据节点最多包含三个字段，例如："

#: ../../LangRef.rst:4208
msgid "The first field is an identity field. It can be any value, usually a metadata string, which uniquely identifies the type. The most important name in the tree is the name of the root node. Two trees with different root node names are entirely disjoint, even if they have leaves with common names."
msgstr "第一个字段是标识字段。它可以是唯一标识类型的任何值，通常是元数据字符串。树中最重要的名称是根节点的名称。具有不同根节点名称的两棵树完全不相交，即使它们具有通用名称的叶子。"

#: ../../LangRef.rst:4214
msgid "The second field identifies the type's parent node in the tree, or is null or omitted for a root node. A type is considered to alias all of its descendants and all of its ancestors in the tree. Also, a type is considered to alias all types in other trees, so that bitcode produced from multiple front-ends is handled conservatively."
msgstr "第二个字段标识树中类型的父节点，或者对于根节点为null或省略。类型被认为是树中所有后代及其所有祖先的别名。此外，类型被认为是别名树中所有类型的别名，因此保守地处理从多个前端生成的bitcode。"

#: ../../LangRef.rst:4220
msgid "If the third field is present, it's an integer which if equal to 1 indicates that the type is \"constant\" (meaning ``pointsToConstantMemory`` should return true; see `other useful AliasAnalysis methods <AliasAnalysis.html#OtherItfs>`_)."
msgstr "如果存在第三个字段，则它是一个整数，如果等于1则表示该类型是“常量”（意思是``pointsToConstantMemory``应该返回true;参见`其他有用的AliasAnalysis方法<AliasAnalysis.html＃OtherItfs>` _）。"

#: ../../LangRef.rst:4226
msgid "'``tbaa.struct``' Metadata"
msgstr "'``tbaa.struct``'元数据"

#: ../../LangRef.rst:4228
msgid "The :ref:`llvm.memcpy <int_memcpy>` is often used to implement aggregate assignment operations in C and similar languages, however it is defined to copy a contiguous region of memory, which is more than strictly necessary for aggregate types which contain holes due to padding. Also, it doesn't contain any TBAA information about the fields of the aggregate."
msgstr "：ref：`llvm.memcpy <int_memcpy>`通常用于实现C语言和类似语言的聚合赋值操作，但是它被定义为复制一个连续的内存区域，这对于包含空洞的聚合类型来说是非常必要的由于填充。此外，它不包含有关聚合字段的任何TBAA信息。"

#: ../../LangRef.rst:4235
msgid "``!tbaa.struct`` metadata can describe which memory subregions in a memcpy are padding and what the TBAA tags of the struct are."
msgstr "``！tbaa.struct``元数据可以描述memcpy中哪些内存子区域是填充的，以及结构的TBAA标记是什么。"

#: ../../LangRef.rst:4238
msgid "The current metadata format is very simple. ``!tbaa.struct`` metadata nodes are a list of operands which are in conceptual groups of three. For each group of three, the first operand gives the byte offset of a field in bytes, the second gives its size in bytes, and the third gives its tbaa tag. e.g.:"
msgstr "当前的元数据格式非常简单。 ``！tbaa.struct``元数据节点是三个概念组中的操作数列表。对于每组三个，第一个操作数以字节为单位给出字段的字节偏移量，第二个给出以字节为单位的字节大小，第三个给出其tbaa标记。例如："

#: ../../LangRef.rst:4248
msgid "This describes a struct with two fields. The first is at offset 0 bytes with size 4 bytes, and has tbaa tag !1. The second is at offset 8 bytes and has size 4 bytes and has tbaa tag !2."
msgstr "这描述了一个包含两个字段的结构。第一个是偏移0字节，大小为4个字节，并且有tbaa标记！1。第二个是偏移8个字节，大小为4个字节，并且有tbaa标记！2。"

#: ../../LangRef.rst:4252
msgid "Note that the fields need not be contiguous. In this example, there is a 4 byte gap between the two fields. This gap represents padding which does not carry useful data and need not be preserved."
msgstr "请注意，字段不必是连续的。在此示例中，两个字段之间存在4个字节的间隔。该间隙表示填充，其不携带有用数据并且不需要保留。"

#: ../../LangRef.rst:4257
msgid "'``noalias``' and '``alias.scope``' Metadata"
msgstr "'``noalias``'和'`alias.scope``'元数据"

#: ../../LangRef.rst:4259
msgid ""
"``noalias`` and ``alias.scope`` metadata provide the ability to specify generic noalias memory-access sets. This means that some collection of memory access instructions (loads, stores, memory-accessing calls, etc.) that carry ``noalias`` metadata can specifically be specified not to alias with some other collection of memory access instructions that carry ``alias.scope`` metadata. Each type of metadata specifies a list of scopes where each scope has an id and a domain. When evaluating an aliasing query, if for some domain, the set of scopes with that domain in one "
"instruction's ``alias.scope`` list is a subset of (or equal to) the set of scopes for that domain in another instruction's ``noalias`` list, then the two memory accesses are assumed not to alias."
msgstr "``noalias``和``alias.scope``元数据提供了指定通用noalias内存访问集的功能。这意味着可以特别指定一些带有“noalias”元数据的内存访问指令（加载，存储，内存访问调用等）的集合，而不是使用带有“别名”的其他一些内存访问指令的别名。 .scope``元数据。每种类型的元数据都指定了一个范围列表，其中每个范围都有一个id和一个域。在评估别名查询时，如果对于某个域，在一个指令的“alias.scope”列表中具有该域的范围集是另一个指令中该域的范围集的一部分（或等于）` noalias``列表，然后假设两个内存访问不是别名。"

#: ../../LangRef.rst:4271
msgid "The metadata identifying each domain is itself a list containing one or two entries. The first entry is the name of the domain. Note that if the name is a string then it can be combined across functions and translation units. A self-reference can be used to create globally unique domain names. A descriptive string may optionally be provided as a second list entry."
msgstr "标识每个域的元数据本身是包含一个或两个条目的列表。第一个条目是域的名称。请注意，如果名称是字符串，则可以跨功能和翻译单元进行组合。自引用可用于创建全局唯一的域名。可选地，可以提供描述性字符串作为第二列表条目。"

#: ../../LangRef.rst:4277
msgid "The metadata identifying each scope is also itself a list containing two or three entries. The first entry is the name of the scope. Note that if the name is a string then it can be combined across functions and translation units. A self-reference can be used to create globally unique scope names. A metadata reference to the scope's domain is the second entry. A descriptive string may optionally be provided as a third list entry."
msgstr "标识每个范围的元数据本身也是包含两个或三个条目的列表。第一个条目是范围的名称。请注意，如果名称是字符串，则可以跨功能和翻译单元进行组合。自引用可用于创建全局唯一的范围名称。对作用域的域的元数据引用是第二个条目。可选地，可以提供描述性字符串作为第三列表条目。"

#: ../../LangRef.rst:4284
msgid "For example,"
msgstr "例如，"

#: ../../LangRef.rst:4318
msgid "'``fpmath``' Metadata"
msgstr "'``fpmath``'元数据"

#: ../../LangRef.rst:4320
msgid "``fpmath`` metadata may be attached to any instruction of floating point type. It can be used to express the maximum acceptable error in the result of that instruction, in ULPs, thus potentially allowing the compiler to use a more efficient but less accurate method of computing it. ULP is defined as follows:"
msgstr "``fpmath``元数据可以附加到任何浮点类型的指令。它可用于在ULP中表达该指令结果中的最大可接受误差，因此可能允许编译器使用更有效但不太准确的计算方法。 ULP定义如下："

#: ../../LangRef.rst:4326
msgid "If ``x`` is a real number that lies between two finite consecutive floating-point numbers ``a`` and ``b``, without being equal to one of them, then ``ulp(x) = |b - a|``, otherwise ``ulp(x)`` is the distance between the two non-equal finite floating-point numbers nearest ``x``. Moreover, ``ulp(NaN)`` is ``NaN``."
msgstr "如果``x``是一个位于两个有限连续浮点数`a``和``b``之间的实数，而不等于它们中的一个，则``ulp（x）= | b -  a |``，否则``ulp（x）``是最接近``x``的两个非等重有限浮点数之间的距离。而且，``ulp（NaN）``是``NaN``。"

#: ../../LangRef.rst:4332
msgid "The metadata node shall consist of a single positive floating point number representing the maximum relative error, for example:"
msgstr "元数据节点应由表示最大相对误差的单个正浮点数组成，例如："

#: ../../LangRef.rst:4342
msgid "'``range``' Metadata"
msgstr "'``range``'元数据"

#: ../../LangRef.rst:4344
msgid "``range`` metadata may be attached only to ``load``, ``call`` and ``invoke`` of integer types. It expresses the possible ranges the loaded value or the value returned by the called function at this call site is in. The ranges are represented with a flattened list of integers. The loaded value or the value returned is known to be in the union of the ranges defined by each consecutive pair. Each pair has the following properties:"
msgstr "``range``元数据可能只附加到``load``，``call``和``invoke``整数类型。它表示加载值或此调用站点上被调用函数返回的值所在的可能范围。范围用展平的整数列表表示。已知加载的值或返回的值在每个连续对定义的范围的并集中。每对都具有以下属性："

#: ../../LangRef.rst:4351
msgid "The type must match the type loaded by the instruction."
msgstr "类型必须与指令加载的类型匹配。"

#: ../../LangRef.rst:4352
msgid "The pair ``a,b`` represents the range ``[a,b)``."
msgstr "对``a，b``表示范围``[a，b）``。"

#: ../../LangRef.rst:4353
msgid "Both ``a`` and ``b`` are constants."
msgstr "``a``和``b``都是常数。"

#: ../../LangRef.rst:4354
msgid "The range is allowed to wrap."
msgstr "该范围允许包装。"

#: ../../LangRef.rst:4355
msgid "The range should not represent the full or empty set. That is, ``a!=b``."
msgstr "范围不应代表完整或空集。也就是说，``a！= b``。"

#: ../../LangRef.rst:4358
msgid "In addition, the pairs must be in signed order of the lower bound and they must be non-contiguous."
msgstr "此外，这些对必须是下限的有符号顺序，并且它们必须是非连续的。"

#: ../../LangRef.rst:4377
msgid "'``unpredictable``' Metadata"
msgstr "'``不可预测``'元数据"

#: ../../LangRef.rst:4379
msgid "``unpredictable`` metadata may be attached to any branch or switch instruction. It can be used to express the unpredictability of control flow. Similar to the llvm.expect intrinsic, it may be used to alter optimizations related to compare and branch instructions. The metadata is treated as a boolean value; if it exists, it signals that the branch or switch that it is attached to is completely unpredictable."
msgstr "``unpredictable``元数据可以附加到任何分支或切换指令。它可以用来表示控制流的不可预测性。与llvm.expect内在函数类似，它可用于更改与比较和分支指令相关的优化。元数据被视为布尔值;如果它存在，则表示它所连接的分支或交换机完全不可预测。"

#: ../../LangRef.rst:4387
msgid "'``llvm.loop``'"
msgstr "'``llvm.loop``'"

#: ../../LangRef.rst:4389
msgid "It is sometimes useful to attach information to loop constructs. Currently, loop metadata is implemented as metadata attached to the branch instruction in the loop latch block. This type of metadata refer to a metadata node that is guaranteed to be separate for each loop. The loop identifier metadata is specified with the name ``llvm.loop``."
msgstr "将信息附加到循环结构有时很有用。当前，循环元数据被实现为附加到循环锁存器块中的分支指令的元数据。这种类型的元数据指的是保证为每个循环分开的元数据节点。循环标识符元数据使用名称``llvm.loop``指定。"

#: ../../LangRef.rst:4395
msgid "The loop identifier metadata is implemented using a metadata that refers to itself to avoid merging it with any other identifier metadata, e.g., during module linkage or function inlining. That is, each loop should refer to their own identification metadata even if they reside in separate functions. The following example contains loop identifier metadata for two separate loop constructs:"
msgstr "循环标识符元数据使用引用其自身的元数据来实现，以避免将其与任何其他标识符元数据合并，例如，在模块链接或函数内联期间。也就是说，每个循环应该引用它们自己的标识元数据，即使它们位于不同的函数中。以下示例包含两个单独的循环结构的循环标识符元数据："

#: ../../LangRef.rst:4407
msgid "The loop identifier metadata can be used to specify additional per-loop metadata. Any operands after the first operand can be treated as user-defined metadata. For example the ``llvm.loop.unroll.count`` suggests an unroll factor to the loop unroller:"
msgstr "循环标识符元数据可用于指定附加的每循环元数据。第一个操作数之后的任何操作数都可以视为用户定义的元数据。例如，``llvm.loop.unroll.count``表示循环展开器的展开因子："

#: ../../LangRef.rst:4420
msgid "'``llvm.loop.vectorize``' and '``llvm.loop.interleave``'"
msgstr "'`llvm.loop.vectorize``'和'``llvm.loop.interleave``'"

#: ../../LangRef.rst:4422
msgid ""
"Metadata prefixed with ``llvm.loop.vectorize`` or ``llvm.loop.interleave`` are used to control per-loop vectorization and interleaving parameters such as vectorization width and interleave count. These metadata should be used in conjunction with ``llvm.loop`` loop identification metadata. The ``llvm.loop.vectorize`` and ``llvm.loop.interleave`` metadata are only optimization hints and the optimizer will only interleave and vectorize loops if it believes it is safe to do so. The ``llvm.mem.parallel_loop_access`` metadata which contains information about loop-carried "
"memory dependencies can be helpful in determining the safety of these transformations."
msgstr "前缀为`llvm.loop.vectorize``或``llvm.loop.interleave``的元数据用于控制每循环矢量化和交织参数，例如矢量化宽度和交错计数。这些元数据应与``llvm.loop``循环标识元数据结合使用。 ``llvm.loop.vectorize``和``llvm.loop.interleave``元数据只是优化提示，如果认为安全，优化器只会交错和矢量化循环。包含循环内存依赖关系信息的`llvm.mem.parallel_loop_access``元数据有助于确定这些转换的安全性。"

#: ../../LangRef.rst:4433
msgid "'``llvm.loop.interleave.count``' Metadata"
msgstr "'`llvm.loop.interleave.count``'元数据"

#: ../../LangRef.rst:4435
msgid "This metadata suggests an interleave count to the loop interleaver. The first operand is the string ``llvm.loop.interleave.count`` and the second operand is an integer specifying the interleave count. For example:"
msgstr "该元数据表示对循环交织器的交织计数。第一个操作数是字符串``llvm.loop.interleave.count``，第二个操作数是一个指定交错计数的整数。例如："

#: ../../LangRef.rst:4444
msgid "Note that setting ``llvm.loop.interleave.count`` to 1 disables interleaving multiple iterations of the loop. If ``llvm.loop.interleave.count`` is set to 0 then the interleave count will be determined automatically."
msgstr "请注意，将``llvm.loop.interleave.count``设置为1会禁用交错循环的多次迭代。如果``llvm.loop.interleave.count``设置为0，则将自动确定交错计数。"

#: ../../LangRef.rst:4449
msgid "'``llvm.loop.vectorize.enable``' Metadata"
msgstr "'`llvm.loop.vectorize.enable``'元数据"

#: ../../LangRef.rst:4451
msgid "This metadata selectively enables or disables vectorization for the loop. The first operand is the string ``llvm.loop.vectorize.enable`` and the second operand is a bit. If the bit operand value is 1 vectorization is enabled. A value of 0 disables vectorization:"
msgstr "此元数据有选择地启用或禁用循环的矢量化。第一个操作数是字符串``llvm.loop.vectorize.enable``，第二个操作数是一个位。如果位操作数值为1，则启用向量化。值为0将禁用矢量化："

#: ../../LangRef.rst:4462
msgid "'``llvm.loop.vectorize.width``' Metadata"
msgstr "'`llvm.loop.vectorize.width``'元数据"

#: ../../LangRef.rst:4464
msgid "This metadata sets the target width of the vectorizer. The first operand is the string ``llvm.loop.vectorize.width`` and the second operand is an integer specifying the width. For example:"
msgstr "此元数据设置矢量化程序的目标宽度。第一个操作数是字符串``llvm.loop.vectorize.width``，第二个操作数是指定宽度的整数。例如："

#: ../../LangRef.rst:4472
msgid "Note that setting ``llvm.loop.vectorize.width`` to 1 disables vectorization of the loop. If ``llvm.loop.vectorize.width`` is set to 0 or if the loop does not have this metadata the width will be determined automatically."
msgstr "请注意，将``llvm.loop.vectorize.width``设置为1会禁用循环的矢量化。如果``llvm.loop.vectorize.width``设置为0或者循环没有这个元数据，宽度将自动确定。"

#: ../../LangRef.rst:4478
msgid "'``llvm.loop.unroll``'"
msgstr "'``llvm.loop.unroll``'"

#: ../../LangRef.rst:4480
msgid "Metadata prefixed with ``llvm.loop.unroll`` are loop unrolling optimization hints such as the unroll factor. ``llvm.loop.unroll`` metadata should be used in conjunction with ``llvm.loop`` loop identification metadata. The ``llvm.loop.unroll`` metadata are only optimization hints and the unrolling will only be performed if the optimizer believes it is safe to do so."
msgstr "前缀为``llvm.loop.unroll``的元数据是循环展开优化提示，例如展开因子。 ``llvm.loop.unroll``元数据应与``llvm.loop``循环标识元数据一起使用。 `llvm.loop.unroll``元数据只是优化提示，只有在优化器认为安全的情况下才会执行展开。"

#: ../../LangRef.rst:4488
msgid "'``llvm.loop.unroll.count``' Metadata"
msgstr "'`llvm.loop.unroll.count``'元数据"

#: ../../LangRef.rst:4490
msgid "This metadata suggests an unroll factor to the loop unroller. The first operand is the string ``llvm.loop.unroll.count`` and the second operand is a positive integer specifying the unroll factor. For example:"
msgstr "此元数据表示循环展开器的展开因子。第一个操作数是字符串``llvm.loop.unroll.count``，第二个操作数是指定展开因子的正整数。例如："

#: ../../LangRef.rst:4499
msgid "If the trip count of the loop is less than the unroll count the loop will be partially unrolled."
msgstr "如果循环的行程计数小于展开计数，则循环将部分展开。"

#: ../../LangRef.rst:4503
msgid "'``llvm.loop.unroll.disable``' Metadata"
msgstr "'`llvm.loop.unroll.disable``'元数据"

#: ../../LangRef.rst:4505
msgid "This metadata disables loop unrolling. The metadata has a single operand which is the string ``llvm.loop.unroll.disable``. For example:"
msgstr "此元数据禁用循环展开。元数据有一个操作数，即字符串``llvm.loop.unroll.disable``。例如："

#: ../../LangRef.rst:4513
msgid "'``llvm.loop.unroll.runtime.disable``' Metadata"
msgstr "'`llvm.loop.unroll.runtime.disable``'元数据"

#: ../../LangRef.rst:4515
msgid "This metadata disables runtime loop unrolling. The metadata has a single operand which is the string ``llvm.loop.unroll.runtime.disable``. For example:"
msgstr "此元数据禁用运行时循环展开。元数据有一个操作数，即字符串``llvm.loop.unroll.runtime.disable``。例如："

#: ../../LangRef.rst:4523
msgid "'``llvm.loop.unroll.enable``' Metadata"
msgstr "'`llvm.loop.unroll.enable``'元数据"

#: ../../LangRef.rst:4525
msgid "This metadata suggests that the loop should be fully unrolled if the trip count is known at compile time and partially unrolled if the trip count is not known at compile time. The metadata has a single operand which is the string ``llvm.loop.unroll.enable``.  For example:"
msgstr "此元数据表明，如果在编译时已知行程计数，则应完全展开循环，如果在编译时未知行程计数，则部分展开。元数据有一个操作数，即字符串``llvm.loop.unroll.enable``。例如："

#: ../../LangRef.rst:4535
msgid "'``llvm.loop.unroll.full``' Metadata"
msgstr "'`llvm.loop.unroll.full``'元数据"

#: ../../LangRef.rst:4537
msgid "This metadata suggests that the loop should be unrolled fully. The metadata has a single operand which is the string ``llvm.loop.unroll.full``. For example:"
msgstr "此元数据表明应该完全展开循环。元数据有一个操作数，即字符串``llvm.loop.unroll.full``。例如："

#: ../../LangRef.rst:4546
msgid "'``llvm.mem``'"
msgstr "'``llvm.mem``'"

#: ../../LangRef.rst:4548
msgid "Metadata types used to annotate memory accesses with information helpful for optimizations are prefixed with ``llvm.mem``."
msgstr "用于使用有助于优化的信息来注释内存访问的元数据类型以“llvm.mem”为前缀。"

#: ../../LangRef.rst:4552
msgid "'``llvm.mem.parallel_loop_access``' Metadata"
msgstr "'`llvm.mem.parallel_loop_access``'元数据"

#: ../../LangRef.rst:4554
msgid "The ``llvm.mem.parallel_loop_access`` metadata refers to a loop identifier, or metadata containing a list of loop identifiers for nested loops. The metadata is attached to memory accessing instructions and denotes that no loop carried memory dependence exist between it and other instructions denoted with the same loop identifier."
msgstr "`llvm.mem.parallel_loop_access``元数据是指循环标识符，或包含嵌套循环的循环标识符列表的元数据。元数据附加到存储器访问指令并且表示在它与用相同的循环标识符表示的其他指令之间不存在循环携带的存储器依赖性。"

#: ../../LangRef.rst:4560
msgid "Precisely, given two instructions ``m1`` and ``m2`` that both have the ``llvm.mem.parallel_loop_access`` metadata, with ``L1`` and ``L2`` being the set of loops associated with that metadata, respectively, then there is no loop carried dependence between ``m1`` and ``m2`` for loops in both ``L1`` and ``L2``."
msgstr "确切地说，给出两个指令``m1``和``m2``都有``llvm.mem.parallel_loop_access``元数据，``L1``和``L2``是与之关联的循环集合那个元数据，然后在``L1``和``L2``的循环中，``m1``和``m2``之间没有循环携带的依赖关系。"

#: ../../LangRef.rst:4566
msgid "As a special case, if all memory accessing instructions in a loop have ``llvm.mem.parallel_loop_access`` metadata that refers to that loop, then the loop has no loop carried memory dependences and is considered to be a parallel loop."
msgstr "作为一种特殊情况，如果循环中的所有内存访问指令都具有引用该循环的“llvm.mem.parallel_loop_access”元数据，那么循环没有循环携带的内存依赖性，并且被认为是并行循环。"

#: ../../LangRef.rst:4571
msgid "Note that if not all memory access instructions have such metadata referring to the loop, then the loop is considered not being trivially parallel. Additional memory dependence analysis is required to make that determination. As a fail safe mechanism, this causes loops that were originally parallel to be considered sequential (if optimization passes that are unaware of the parallel semantics insert new memory instructions into the loop body)."
msgstr "注意，如果并非所有存储器访问指令都具有涉及循环的这种元数据，则认为循环不是平凡的并行。进行该确定需要额外的存储器依赖性分析。作为一种故障安全机制，这会导致最初并行的循环被认为是顺序的（如果优化传递不知道并行语义将新的内存指令插入到循环体中）。"

#: ../../LangRef.rst:4578
msgid "Example of a loop that is considered parallel due to its correct use of both ``llvm.loop`` and ``llvm.mem.parallel_loop_access`` metadata types that refer to the same loop identifier metadata."
msgstr "由于正确使用引用相同循环标识符元数据的`llvm.loop``和`llvm.mem.parallel_loop_access``元数据类型而被认为是并行的循环示例。"

#: ../../LangRef.rst:4596
msgid "It is also possible to have nested parallel loops. In that case the memory accesses refer to a list of loop identifier metadata nodes instead of the loop identifier metadata node directly:"
msgstr "也可以有嵌套的并行循环。在这种情况下，内存访问直接引用循环标识符元数据节点的列表而不是循环标识符元数据节点："

#: ../../LangRef.rst:4629
msgid "'``llvm.bitsets``'"
msgstr "'``llvm.bitsets``'"

#: ../../LangRef.rst:4631
msgid "The ``llvm.bitsets`` global metadata is used to implement :doc:`bitsets <BitSets>`."
msgstr "`llvm.bitsets``全局元数据用于实现：doc：`bitsets <BitSets>`。"

#: ../../LangRef.rst:4635
msgid "'``invariant.group``' Metadata"
msgstr "'``invariant.group``'元数据"

#: ../../LangRef.rst:4637
msgid "The ``invariant.group`` metadata may be attached to ``load``/``store`` instructions. The existence of the ``invariant.group`` metadata on the instruction tells the optimizer that every ``load`` and ``store`` to the same pointer operand within the same invariant group can be assumed to load or store the same value (but see the ``llvm.invariant.group.barrier`` intrinsic which affects when two pointers are considered the same)."
msgstr "``invariant.group``元数据可以附加到``load`` /``store``指令。指令上存在``invariant.group``元数据告诉优化器，可以假定每个``load``和``store``到同一个不变组中的同一个指针操作数加载或存储value（但请参阅`llvm.invariant.group.barrier``内在函数，它会影响两个指针被认为是相同的时间）。"

#: ../../LangRef.rst:4679
msgid "Module Flags Metadata"
msgstr "模块标志元数据"

#: ../../LangRef.rst:4681
msgid "Information about the module as a whole is difficult to convey to LLVM's subsystems. The LLVM IR isn't sufficient to transmit this information. The ``llvm.module.flags`` named metadata exists in order to facilitate this. These flags are in the form of key / value pairs --- much like a dictionary --- making it easy for any subsystem who cares about a flag to look it up."
msgstr "有关整个模块的信息很难传达给LLVM的子系统。 LLVM IR不足以传输此信息。存在名为元数据的`llvm.module.flags``以便于实现此目的。这些标志是键/值对的形式 - 很像字典 - 使任何关心标志的子系统都可以轻松查找。"

#: ../../LangRef.rst:4688
msgid "The ``llvm.module.flags`` metadata contains a list of metadata triplets. Each triplet has the following form:"
msgstr "`llvm.module.flags``元数据包含元数据三元组列表。每个三元组具有以下形式："

#: ../../LangRef.rst:4691
msgid "The first element is a *behavior* flag, which specifies the behavior when two (or more) modules are merged together, and it encounters two (or more) metadata with the same ID. The supported behaviors are described below."
msgstr "第一个元素是* behavior *标志，它指定两个（或多个）模块合并在一起时的行为，并且它遇到具有相同ID的两个（或更多）元数据。支持的行为如下所述。"

#: ../../LangRef.rst:4695
msgid "The second element is a metadata string that is a unique ID for the metadata. Each module may only have one flag entry for each unique ID (not including entries with the **Require** behavior)."
msgstr "第二个元素是元数据字符串，它是元数据的唯一ID。每个模块对于每个唯一ID只能有一个标志条目（不包括具有** Require **行为的条目）。"

#: ../../LangRef.rst:4698
msgid "The third element is the value of the flag."
msgstr "第三个元素是标志的值。"

#: ../../LangRef.rst:4700
msgid "When two (or more) modules are merged together, the resulting ``llvm.module.flags`` metadata is the union of the modules' flags. That is, for each unique metadata ID string, there will be exactly one entry in the merged modules ``llvm.module.flags`` metadata table, and the value for that entry will be determined by the merge behavior flag, as described below. The only exception is that entries with the *Require* behavior are always preserved."
msgstr "当两个（或更多）模块合并在一起时，生成的``llvm.module.flags``元数据是模块标志的并集。也就是说，对于每个唯一的元数据ID字符串，合并的模块``llvm.module.flags``元数据表中只有一个条目，该条目的值将由合并行为标志确定，如下所述。唯一的例外是始终保留具有* Require *行为的条目。"

#: ../../LangRef.rst:4707
msgid "The following behaviors are supported:"
msgstr "支持以下行为："

#: ../../LangRef.rst:4713 ../../LangRef.rst:4810 ../../LangRef.rst:4895
msgid "Value"
msgstr "值"

#: ../../LangRef.rst:4714
msgid "Behavior"
msgstr "行为"

#: ../../LangRef.rst:4716 ../../LangRef.rst:6331 ../../LangRef.rst:6333 ../../LangRef.rst:6335 ../../LangRef.rst:6380 ../../LangRef.rst:6382 ../../LangRef.rst:6384 ../../LangRef.rst:6430 ../../LangRef.rst:6432 ../../LangRef.rst:6434
msgid "1"
msgstr ""

#: ../../LangRef.rst:4719
msgid "**Error**"
msgstr "**错误**"

#: ../../LangRef.rst:4718
msgid "Emits an error if two values disagree, otherwise the resulting value is that of the operands."
msgstr "如果两个值不一致，则发出错误，否则结果值是操作数的值。"

#: ../../LangRef.rst:4721
msgid "2"
msgstr ""

#: ../../LangRef.rst:4724
msgid "**Warning**"
msgstr "**警告**"

#: ../../LangRef.rst:4723
msgid "Emits a warning if two values disagree. The result value will be the operand for the flag from the first module being linked."
msgstr "如果两个值不一致，则发出警告。结果值将是链接的第一个模块的标志的操作数。"

#: ../../LangRef.rst:4726
msgid "3"
msgstr ""

#: ../../LangRef.rst:4734
msgid "**Require**"
msgstr "**必要**"

#: ../../LangRef.rst:4728
msgid "Adds a requirement that another module flag be present and have a specified value after linking is performed. The value must be a metadata pair, where the first element of the pair is the ID of the module flag to be restricted, and the second element of the pair is the value the module flag should be restricted to. This behavior can be used to restrict the allowable results (via triggering of an error) of linking IDs with the **Override** behavior."
msgstr "添加一个要求，即在执行链接后存在另一个模块标志并具有指定值。该值必须是元数据对，其中该对的第一个元素是要限制的模块标志的ID，该对的第二个元素是模块标志应限制的值。此行为可用于限制使用**覆盖**行为链接ID的允许结果（通过触发错误）。"

#: ../../LangRef.rst:4736
msgid "4"
msgstr ""

#: ../../LangRef.rst:4740
msgid "**Override**"
msgstr "**覆盖**"

#: ../../LangRef.rst:4738
msgid "Uses the specified value, regardless of the behavior or value of the other module. If both modules specify **Override**, but the values differ, an error will be emitted."
msgstr "无论其他模块的行为或值如何，都使用指定的值。如果两个模块都指定**覆盖**，但值不同，则会发出错误。"

#: ../../LangRef.rst:4742
msgid "5"
msgstr ""

#: ../../LangRef.rst:4744
msgid "**Append**"
msgstr "**附加**"

#: ../../LangRef.rst:4744
msgid "Appends the two values, which are required to be metadata nodes."
msgstr "附加两个值，这些值是元数据节点所必需的。"

#: ../../LangRef.rst:4746
msgid "6"
msgstr ""

#: ../../LangRef.rst:4749
msgid "**AppendUnique**"
msgstr ""

#: ../../LangRef.rst:4748
msgid "Appends the two values, which are required to be metadata nodes. However, duplicate entries in the second list are dropped during the append operation."
msgstr "附加两个值，这些值是元数据节点所必需的。但是，在追加操作期间会删除第二个列表中的重复条目。"

#: ../../LangRef.rst:4752
msgid "It is an error for a particular unique flag ID to have multiple behaviors, except in the case of **Require** (which adds restrictions on another metadata value) or **Override**."
msgstr "特定的唯一标志ID有多个行为是错误的，除了** Require **（增加了对另一个元数据值的限制）或** Override **的情况除外。"

#: ../../LangRef.rst:4756
msgid "An example of module flags:"
msgstr "模块标志的示例："

#: ../../LangRef.rst:4770
msgid "Metadata ``!0`` has the ID ``!\"foo\"`` and the value '1'. The behavior if two or more ``!\"foo\"`` flags are seen is to emit an error if their values are not equal."
msgstr "元数据``！0``的ID为``！\\“foo \\”``和值'1'。如果看到两个或更多``！\\“foo \\”`标志的行为是在它们的值不相等时发出错误。"

#: ../../LangRef.rst:4774
msgid "Metadata ``!1`` has the ID ``!\"bar\"`` and the value '37'. The behavior if two or more ``!\"bar\"`` flags are seen is to use the value '37'."
msgstr "元数据``！1``的ID为``！\\“bar \\”``和值'37'。如果看到两个或更多``！\\“bar \\”`标志的行为是使用值'37'。"

#: ../../LangRef.rst:4778
msgid "Metadata ``!2`` has the ID ``!\"qux\"`` and the value '42'. The behavior if two or more ``!\"qux\"`` flags are seen is to emit a warning if their values are not equal."
msgstr "元数据``！2``的ID为``！\\“qux \\”``，值为'42'。如果看到两个或更多``！\\“qux \\”`标志的行为是在它们的值不相等时发出警告。"

#: ../../LangRef.rst:4782
msgid "Metadata ``!3`` has the ID ``!\"qux\"`` and the value:"
msgstr "元数据``！3``的ID为``！\\“qux \\”``和值："

#: ../../LangRef.rst:4788
msgid "The behavior is to emit an error if the ``llvm.module.flags`` does not contain a flag with the ID ``!\"foo\"`` that has the value '1' after linking is performed."
msgstr "如果``llvm.module.flags``不包含ID为``！\\“foo \\```且在执行链接后值为'1'的标志，则行为是发出错误。"

#: ../../LangRef.rst:4793
msgid "Objective-C Garbage Collection Module Flags Metadata"
msgstr "Objective-C垃圾收集模块标志元数据"

#: ../../LangRef.rst:4795
msgid "On the Mach-O platform, Objective-C stores metadata about garbage collection in a special section called \"image info\". The metadata consists of a version number and a bitmask specifying what types of garbage collection are supported (if any) by the file. If two or more modules are linked together their garbage collection metadata needs to be merged rather than appended together."
msgstr "在Mach-O平台上，Objective-C在一个名为“image info”的特殊部分中存储有关垃圾收集的元数据。元数据由版本号和位掩码组成，指定文件支持哪些类型的垃圾收集（如果有）。如果两个或多个模块链接在一起，则需要合并垃圾收集元数据而不是将其附加在一起。"

#: ../../LangRef.rst:4802
msgid "The Objective-C garbage collection module flags metadata consists of the following key-value pairs:"
msgstr "Objective-C垃圾收集模块标记元数据包含以下键值对："

#: ../../LangRef.rst:4809 ../../LangRef.rst:4894
msgid "Key"
msgstr "键"

#: ../../LangRef.rst:4812
msgid "``Objective-C Version``"
msgstr ""

#: ../../LangRef.rst:4813
msgid "**[Required]** --- The Objective-C ABI version. Valid values are 1 and 2."
msgstr "** [必需] ** --- Objective-C ABI版本。有效值为1和2。"

#: ../../LangRef.rst:4815
msgid "``Objective-C Image Info Version``"
msgstr "``Objective-C图像信息版本``"

#: ../../LangRef.rst:4816
msgid "**[Required]** --- The version of the image info section. Currently always 0."
msgstr "** [必需] ** ---图像信息部分的版本。目前始终为0。"

#: ../../LangRef.rst:4819
msgid "``Objective-C Image Info Section``"
msgstr "``Objective-C图像信息部分``"

#: ../../LangRef.rst:4820
msgid "**[Required]** --- The section to place the metadata. Valid values are ``\"__OBJC, __image_info, regular\"`` for Objective-C ABI version 1, and ``\"__DATA,__objc_imageinfo, regular, no_dead_strip\"`` for Objective-C ABI version 2."
msgstr "** [必需] ** ---放置元数据的部分。对于Objective-C ABI版本1，有效值为``\\ _“__ OBJC，__ image_info，regular \\”``，对于Objective-C ABI版本2，有效值为``\\ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _"

#: ../../LangRef.rst:4825
msgid "``Objective-C Garbage Collection``"
msgstr "``Objective-C垃圾收集``"

#: ../../LangRef.rst:4826
msgid "**[Required]** --- Specifies whether garbage collection is supported or not. Valid values are 0, for no garbage collection, and 2, for garbage collection supported."
msgstr "** [必需] ** ---指定是否支持垃圾回收。对于无垃圾收集，有效值为0;对于支持的垃圾收集，有效值为2。"

#: ../../LangRef.rst:4830
msgid "``Objective-C GC Only``"
msgstr "``Objective-C GC Only``"

#: ../../LangRef.rst:4831
msgid "**[Optional]** --- Specifies that only garbage collection is supported. If present, its value must be 6. This flag requires that the ``Objective-C Garbage Collection`` flag have the value 2."
msgstr "** [可选] ** ---指定仅支持垃圾回收。如果存在，则其值必须为6.此标志要求``Objective-C Garbage Collection``标志的值为2。"

#: ../../LangRef.rst:4835
msgid "Some important flag interactions:"
msgstr "一些重要的旗帜互动："

#: ../../LangRef.rst:4837
msgid "If a module with ``Objective-C Garbage Collection`` set to 0 is merged with a module with ``Objective-C Garbage Collection`` set to 2, then the resulting module has the ``Objective-C Garbage Collection`` flag set to 0."
msgstr "如果将“Objective-C Garbage Collection`”设置为0的模块与“Objective-C Garbage Collection”设置为2的模块合并，则生成的模块具有“Objective-C Garbage Collection”。标志设置为0。"

#: ../../LangRef.rst:4841
msgid "A module with ``Objective-C Garbage Collection`` set to 0 cannot be merged with a module with ``Objective-C GC Only`` set to 6."
msgstr "将“Objective-C Garbage Collection”设置为0的模块不能与“Objective-C GC Only”设置为6的模块合并。"

#: ../../LangRef.rst:4845
msgid "Automatic Linker Flags Module Flags Metadata"
msgstr "自动链接器标志模块标志元数据"

#: ../../LangRef.rst:4847
msgid "Some targets support embedding flags to the linker inside individual object files. Typically this is used in conjunction with language extensions which allow source files to explicitly declare the libraries they depend on, and have these automatically be transmitted to the linker via object files."
msgstr "某些目标支持在各个目标文件中嵌入标记到链接器。通常，这与语言扩展结合使用，语言扩展允许源文件显式声明它们所依赖的库，并通过目标文件自动将它们传输到链接器。"

#: ../../LangRef.rst:4852
msgid "These flags are encoded in the IR using metadata in the module flags section, using the ``Linker Options`` key. The merge behavior for this flag is required to be ``AppendUnique``, and the value for the key is expected to be a metadata node which should be a list of other metadata nodes, each of which should be a list of metadata strings defining linker options."
msgstr "使用“链接器选项”键，使用模块标志部分中的元数据在IR中对这些标志进行编码。该标志的合并行为必须是“AppendUnique”，并且该键的值应该是元数据节点，该元数据节点应该是其他元数据节点的列表，每个元数据节点应该是定义的元数据字符串列表链接器选项。"

#: ../../LangRef.rst:4858
msgid "For example, the following metadata section specifies two separate sets of linker options, presumably to link against ``libz`` and the ``Cocoa`` framework::"
msgstr "例如，以下元数据部分指定了两组独立的链接器选项，可能是为了链接``libz``和``Cocoa``框架::"

#: ../../LangRef.rst:4868
msgid "The metadata encoding as lists of lists of options, as opposed to a collapsed list of options, is chosen so that the IR encoding can use multiple option strings to specify e.g., a single library, while still having that specifier be preserved as an atomic element that can be recognized by a target specific assembly writer or object file emitter."
msgstr "选择元数据编码作为选项列表的列表，而不是折叠的选项列表，以便IR编码可以使用多个选项字符串来指定例如单个库，同时仍然将该说明符保留为原子元素可以由目标特定的程序集编写器或目标文件发射器识别。"

#: ../../LangRef.rst:4874
msgid "Each individual option is required to be either a valid option for the target's linker, or an option that is reserved by the target specific assembly writer or object file emitter. No other aspect of these options is defined by the IR."
msgstr "每个单独的选项都必须是目标链接器的有效选项，或者是目标特定的汇编编写器或目标文件发射器保留的选项。 IR没有定义这些选项的其他方面。"

#: ../../LangRef.rst:4879
msgid "C type width Module Flags Metadata"
msgstr "C类型宽度模块标志元数据"

#: ../../LangRef.rst:4881
msgid "The ARM backend emits a section into each generated object file describing the options that it was compiled with (in a compiler-independent way) to prevent linking incompatible objects, and to allow automatic library selection. Some of these options are not visible at the IR level, namely wchar_t width and enum width."
msgstr "ARM后端在每个生成的目标文件中发出一个部分，描述它所编译的选项（以独立于编译器的方式），以防止链接不兼容的对象，并允许自动选择库。其中一些选项在IR级别不可见，即wchar_t width和enum width。"

#: ../../LangRef.rst:4887
msgid "To pass this information to the backend, these options are encoded in module flags metadata, using the following key-value pairs:"
msgstr "要将此信息传递给后端，请使用以下键值对在模块标志元数据中对这些选项进行编码："

#: ../../LangRef.rst:4897
msgid "short_wchar"
msgstr ""

#: ../../LangRef.rst:4898
msgid "0 --- sizeof(wchar_t) == 4"
msgstr ""

#: ../../LangRef.rst:4899
msgid "1 --- sizeof(wchar_t) == 2"
msgstr ""

#: ../../LangRef.rst:4901
msgid "short_enum"
msgstr ""

#: ../../LangRef.rst:4902
msgid "0 --- Enums are at least as large as an ``int``."
msgstr "0 ---枚举至少和``int``一样大。"

#: ../../LangRef.rst:4903
msgid "1 --- Enums are stored in the smallest integer type which can represent all of its values."
msgstr "1 ---枚举存储在最小的整数类型中，可以表示其所有值。"

#: ../../LangRef.rst:4906
msgid "For example, the following metadata section specifies that the module was compiled with a ``wchar_t`` width of 4 bytes, and the underlying type of an enum is the smallest type which can represent all of its values::"
msgstr "例如，以下元数据部分指定模块使用“wchar_t”宽度为4个字节进行编译，枚举的基础类型是可以表示其所有值的最小类型::"

#: ../../LangRef.rst:4917
msgid "Intrinsic Global Variables"
msgstr "内在全局变量"

#: ../../LangRef.rst:4919
msgid "LLVM has a number of \"magic\" global variables that contain data that affect code generation or other IR semantics. These are documented here. All globals of this sort should have a section specified as \"``llvm.metadata``\". This section and all globals that start with \"``llvm.``\" are reserved for use by LLVM."
msgstr "LLVM有许多“魔术”全局变量，其中包含影响代码生成或其他IR语义的数据。这些都记录在这里。所有这类全局变量都应该有一个指定为“llvm.metadata`` \\”的部分。本节以及以“llvm .` \\”开头的所有全局变量都保留供LLVM使用。"

#: ../../LangRef.rst:4928
msgid "The '``llvm.used``' Global Variable"
msgstr "'`llvm.used``'全局变量"

#: ../../LangRef.rst:4930
msgid "The ``@llvm.used`` global is an array which has :ref:`appending linkage <linkage_appending>`. This array contains a list of pointers to named global variables, functions and aliases which may optionally have a pointer cast formed of bitcast or getelementptr. For example, a legal use of it is:"
msgstr "``@llvm.used`` global是一个数组，其中包含：ref：`appending linkage <linkage_appending>`。此数组包含指向命名全局变量，函数和别名的指针列表，这些指针可以选择性地具有由bitcast或getelementptr构成的指针。例如，合法使用它是："

#: ../../LangRef.rst:4946
msgid "If a symbol appears in the ``@llvm.used`` list, then the compiler, assembler, and linker are required to treat the symbol as if there is a reference to the symbol that it cannot see (which is why they have to be named). For example, if a variable has internal linkage and no references other than that from the ``@llvm.used`` list, it cannot be deleted. This is commonly used to represent references from inline asms and other things the compiler cannot \"see\", and corresponds to \"``attribute((used))``\" in GNU C."
msgstr "如果符号出现在``@llvm.used``列表中，那么编译器，汇编器和链接器都需要将符号视为对它无法看到的符号的引用（这就是为什么它们必须被命名）。例如，如果变量具有内部链接且没有来自“@ llvm.used`”列表的引用，则不能删除它。这通常用于表示内联asms的引用和编译器不能“看到”的其他内容，并且对应于GNU C中的`````（（used））``\\`。"

#: ../../LangRef.rst:4954
msgid "On some targets, the code generator must emit a directive to the assembler or object file to prevent the assembler and linker from molesting the symbol."
msgstr "在某些目标上，代码生成器必须向汇编器或目标文件发出指令，以防止汇编器和链接器篡改符号。"

#: ../../LangRef.rst:4961
msgid "The '``llvm.compiler.used``' Global Variable"
msgstr "'`llvm.compiler.used``'全局变量"

#: ../../LangRef.rst:4963
msgid "The ``@llvm.compiler.used`` directive is the same as the ``@llvm.used`` directive, except that it only prevents the compiler from touching the symbol. On targets that support it, this allows an intelligent linker to optimize references to the symbol without being impeded as it would be by ``@llvm.used``."
msgstr "``@llvm.compiler.used``指令与``@llvm.used``指令相同，只是它只能阻止编译器触及符号。在支持它的目标上，这允许智能链接器优化对符号的引用，而不会像`@llvm.used``那样受到阻碍。"

#: ../../LangRef.rst:4969
msgid "This is a rare construct that should only be used in rare circumstances, and should not be exposed to source languages."
msgstr "这是一种罕见的构造，只应在极少数情况下使用，不应暴露给源语言。"

#: ../../LangRef.rst:4975
msgid "The '``llvm.global_ctors``' Global Variable"
msgstr "'`llvm.global_ctors``'全局变量"

#: ../../LangRef.rst:4982
msgid "The ``@llvm.global_ctors`` array contains a list of constructor functions, priorities, and an optional associated global or function. The functions referenced by this array will be called in ascending order of priority (i.e. lowest first) when the module is loaded. The order of functions with the same priority is not defined."
msgstr "``@llvm.global_ctors``数组包含构造函数，优先级和可选的关联全局或函数的列表。当加载模块时，将以优先级的升序（即最低的第一个）调用此数组引用的函数。没有定义具有相同优先级的功能的顺序。"

#: ../../LangRef.rst:4988
msgid "If the third field is present, non-null, and points to a global variable or function, the initializer function will only run if the associated data from the current module is not discarded."
msgstr "如果第三个字段存在，非空，并指向全局变量或函数，则只有在不丢弃来自当前模块的关联数据时，才会运行初始化函数。"

#: ../../LangRef.rst:4995
msgid "The '``llvm.global_dtors``' Global Variable"
msgstr "'llvm.global_dtors``'全局变量"

#: ../../LangRef.rst:5002
msgid "The ``@llvm.global_dtors`` array contains a list of destructor functions, priorities, and an optional associated global or function. The functions referenced by this array will be called in descending order of priority (i.e. highest first) when the module is unloaded. The order of functions with the same priority is not defined."
msgstr "``@llvm.global_dtors``数组包含析构函数列表，优先级以及可选的关联全局或函数。卸载模块时，将按优先级降序（即最高优先级）调用此数组引用的函数。没有定义具有相同优先级的功能的顺序。"

#: ../../LangRef.rst:5008
msgid "If the third field is present, non-null, and points to a global variable or function, the destructor function will only run if the associated data from the current module is not discarded."
msgstr "如果第三个字段存在，非空，并指向全局变量或函数，则析构函数仅在未丢弃当前模块的关联数据时运行。"

#: ../../LangRef.rst:5013
msgid "Instruction Reference"
msgstr "指令参考"

#: ../../LangRef.rst:5015
msgid "The LLVM instruction set consists of several different classifications of instructions: :ref:`terminator instructions <terminators>`, :ref:`binary instructions <binaryops>`, :ref:`bitwise binary instructions <bitwiseops>`, :ref:`memory instructions <memoryops>`, and :ref:`other instructions <otherops>`."
msgstr "LLVM指令集由几个不同的指令分类组成：ref：`terminator instructions <terminators>`，ref：`binary instructions <binaryops>`，ref：`bitwise binary instructions <bitwiseops>`，：ref：`内存指令<memoryops>`，和：ref：`其他指令<otherops>`。"

#: ../../LangRef.rst:5024
msgid "Terminator Instructions"
msgstr "终结者指示"

#: ../../LangRef.rst:5026
msgid "As mentioned :ref:`previously <functionstructure>`, every basic block in a program ends with a \"Terminator\" instruction, which indicates which block should be executed after the current block is finished. These terminator instructions typically yield a '``void``' value: they produce control flow, not values (the one exception being the ':ref:`invoke <i_invoke>`' instruction)."
msgstr "如上所述：ref：`previous <functions structure>`，程序中的每个基本块都以一个\\“Terminator \\”指令结束，该指令指示在当前块完成后应该执行哪个块。这些终结符指令通常会产生一个'``void``'值：它们产生控制流，而不是值（一个例外是'：ref：`invoke <i_invoke>`'指令）。"

#: ../../LangRef.rst:5033
msgid "The terminator instructions are: ':ref:`ret <i_ret>`', ':ref:`br <i_br>`', ':ref:`switch <i_switch>`', ':ref:`indirectbr <i_indirectbr>`', ':ref:`invoke <i_invoke>`', ':ref:`resume <i_resume>`', ':ref:`catchswitch <i_catchswitch>`', ':ref:`catchret <i_catchret>`', ':ref:`cleanupret <i_cleanupret>`', and ':ref:`unreachable <i_unreachable>`'."
msgstr "终止符指令是：'：ref：`ret <i_ret>`'，'：ref：`br <i_br>`'，'：ref：`switch <i_switch>`'，'：ref：`indirectbr <i_indirectbr> `'，'：ref：`invoke <i_invoke>`'，'：ref：`resume <i_resume>`'，'：ref：`catchswitch <i_catchswitch>`'，'：ref：`catchret <i_catchret>`' ，'：ref：`cleanupret <i_cleanupret>`'和'：ref：`unreachable <i_unreachable>`'。"

#: ../../LangRef.rst:5044
msgid "'``ret``' Instruction"
msgstr "'``ret``'指令"

#: ../../LangRef.rst:5047 ../../LangRef.rst:5104 ../../LangRef.rst:5153 ../../LangRef.rst:5215 ../../LangRef.rst:5266 ../../LangRef.rst:5361 ../../LangRef.rst:5400 ../../LangRef.rst:5456 ../../LangRef.rst:5504 ../../LangRef.rst:5555 ../../LangRef.rst:5593 ../../LangRef.rst:5644 ../../LangRef.rst:5681 ../../LangRef.rst:5736 ../../LangRef.rst:5777 ../../LangRef.rst:5832 ../../LangRef.rst:5869 ../../LangRef.rst:5913 ../../LangRef.rst:5961 ../../LangRef.rst:5998 ../../LangRef.rst:6040 ../../LangRef.rst:6097 ../../LangRef.rst:6146 ../../LangRef.rst:6201 ../../LangRef.rst:6251
#: ../../LangRef.rst:6302 ../../LangRef.rst:6351 ../../LangRef.rst:6400 ../../LangRef.rst:6463 ../../LangRef.rst:6503 ../../LangRef.rst:6545 ../../LangRef.rst:6606 ../../LangRef.rst:6652 ../../LangRef.rst:6707 ../../LangRef.rst:6765 ../../LangRef.rst:6891 ../../LangRef.rst:6972 ../../LangRef.rst:7028 ../../LangRef.rst:7114 ../../LangRef.rst:7187 ../../LangRef.rst:7394 ../../LangRef.rst:7436 ../../LangRef.rst:7476 ../../LangRef.rst:7517 ../../LangRef.rst:7558 ../../LangRef.rst:7598 ../../LangRef.rst:7640 ../../LangRef.rst:7682 ../../LangRef.rst:7723 ../../LangRef.rst:7766
#: ../../LangRef.rst:7812 ../../LangRef.rst:7857 ../../LangRef.rst:7909 ../../LangRef.rst:7962 ../../LangRef.rst:8053 ../../LangRef.rst:8168 ../../LangRef.rst:8222 ../../LangRef.rst:8269 ../../LangRef.rst:8404 ../../LangRef.rst:8455 ../../LangRef.rst:8539 ../../LangRef.rst:8607 ../../LangRef.rst:8772 ../../LangRef.rst:8804 ../../LangRef.rst:8837 ../../LangRef.rst:8896 ../../LangRef.rst:8931 ../../LangRef.rst:8967 ../../LangRef.rst:9007 ../../LangRef.rst:9045 ../../LangRef.rst:9082 ../../LangRef.rst:9135 ../../LangRef.rst:9179 ../../LangRef.rst:9211 ../../LangRef.rst:9237
#: ../../LangRef.rst:9277 ../../LangRef.rst:9314 ../../LangRef.rst:9347 ../../LangRef.rst:9378 ../../LangRef.rst:9411 ../../LangRef.rst:9455 ../../LangRef.rst:9514 ../../LangRef.rst:9567 ../../LangRef.rst:9622 ../../LangRef.rst:9673 ../../LangRef.rst:9713 ../../LangRef.rst:9751 ../../LangRef.rst:9787 ../../LangRef.rst:9823 ../../LangRef.rst:9860 ../../LangRef.rst:9895 ../../LangRef.rst:9930 ../../LangRef.rst:9965 ../../LangRef.rst:10000 ../../LangRef.rst:10035 ../../LangRef.rst:10071 ../../LangRef.rst:10107 ../../LangRef.rst:10149 ../../LangRef.rst:10190
#: ../../LangRef.rst:10226 ../../LangRef.rst:10261 ../../LangRef.rst:10296 ../../LangRef.rst:10332 ../../LangRef.rst:10369 ../../LangRef.rst:10405 ../../LangRef.rst:10447 ../../LangRef.rst:10475 ../../LangRef.rst:10510 ../../LangRef.rst:10548 ../../LangRef.rst:10595 ../../LangRef.rst:10649 ../../LangRef.rst:10699 ../../LangRef.rst:10748 ../../LangRef.rst:10798 ../../LangRef.rst:10848 ../../LangRef.rst:10898 ../../LangRef.rst:10951 ../../LangRef.rst:11020 ../../LangRef.rst:11087 ../../LangRef.rst:11127 ../../LangRef.rst:11215 ../../LangRef.rst:11261
#: ../../LangRef.rst:11302 ../../LangRef.rst:11347 ../../LangRef.rst:11397 ../../LangRef.rst:11451 ../../LangRef.rst:11509 ../../LangRef.rst:11542 ../../LangRef.rst:11573 ../../LangRef.rst:11603 ../../LangRef.rst:11632 ../../LangRef.rst:11668 ../../LangRef.rst:11698 ../../LangRef.rst:11738 ../../LangRef.rst:11776 ../../LangRef.rst:11803 ../../LangRef.rst:11830 ../../LangRef.rst:11866 ../../LangRef.rst:11904 ../../LangRef.rst:11942 ../../LangRef.rst:11977 ../../LangRef.rst:12019 ../../LangRef.rst:12042
msgid "Syntax:"
msgstr "句法："

#: ../../LangRef.rst:5055 ../../LangRef.rst:5112 ../../LangRef.rst:5160 ../../LangRef.rst:5222 ../../LangRef.rst:5274 ../../LangRef.rst:5368 ../../LangRef.rst:5408 ../../LangRef.rst:5463 ../../LangRef.rst:5512 ../../LangRef.rst:5562 ../../LangRef.rst:5603 ../../LangRef.rst:5651 ../../LangRef.rst:5691 ../../LangRef.rst:5743 ../../LangRef.rst:5787 ../../LangRef.rst:5839 ../../LangRef.rst:5877 ../../LangRef.rst:5921 ../../LangRef.rst:5968 ../../LangRef.rst:6005 ../../LangRef.rst:6047 ../../LangRef.rst:6104 ../../LangRef.rst:6156 ../../LangRef.rst:6209 ../../LangRef.rst:6259
#: ../../LangRef.rst:6309 ../../LangRef.rst:6358 ../../LangRef.rst:6407 ../../LangRef.rst:6470 ../../LangRef.rst:6510 ../../LangRef.rst:6552 ../../LangRef.rst:6613 ../../LangRef.rst:6659 ../../LangRef.rst:6714 ../../LangRef.rst:6776 ../../LangRef.rst:6899 ../../LangRef.rst:6979 ../../LangRef.rst:7035 ../../LangRef.rst:7121 ../../LangRef.rst:7196 ../../LangRef.rst:7401 ../../LangRef.rst:7443 ../../LangRef.rst:7483 ../../LangRef.rst:7524 ../../LangRef.rst:7565 ../../LangRef.rst:7605 ../../LangRef.rst:7647 ../../LangRef.rst:7689 ../../LangRef.rst:7730 ../../LangRef.rst:7773
#: ../../LangRef.rst:7819 ../../LangRef.rst:7864 ../../LangRef.rst:7916 ../../LangRef.rst:7969 ../../LangRef.rst:8060 ../../LangRef.rst:8175 ../../LangRef.rst:8231 ../../LangRef.rst:8277 ../../LangRef.rst:8411 ../../LangRef.rst:8466 ../../LangRef.rst:8546 ../../LangRef.rst:8614 ../../LangRef.rst:8779 ../../LangRef.rst:8811 ../../LangRef.rst:8844 ../../LangRef.rst:8903 ../../LangRef.rst:8938 ../../LangRef.rst:8974 ../../LangRef.rst:9014 ../../LangRef.rst:9052 ../../LangRef.rst:9090 ../../LangRef.rst:9146 ../../LangRef.rst:9186 ../../LangRef.rst:9218 ../../LangRef.rst:9284
#: ../../LangRef.rst:9321 ../../LangRef.rst:9354 ../../LangRef.rst:9385 ../../LangRef.rst:9419 ../../LangRef.rst:9464 ../../LangRef.rst:9528 ../../LangRef.rst:9581 ../../LangRef.rst:9636 ../../LangRef.rst:9688 ../../LangRef.rst:9728 ../../LangRef.rst:9766 ../../LangRef.rst:9802 ../../LangRef.rst:9838 ../../LangRef.rst:9875 ../../LangRef.rst:9910 ../../LangRef.rst:9945 ../../LangRef.rst:9980 ../../LangRef.rst:10015 ../../LangRef.rst:10050 ../../LangRef.rst:10086 ../../LangRef.rst:10122 ../../LangRef.rst:10164 ../../LangRef.rst:10205 ../../LangRef.rst:10241
#: ../../LangRef.rst:10276 ../../LangRef.rst:10311 ../../LangRef.rst:10347 ../../LangRef.rst:10384 ../../LangRef.rst:10420 ../../LangRef.rst:10459 ../../LangRef.rst:10487 ../../LangRef.rst:10526 ../../LangRef.rst:10564 ../../LangRef.rst:10611 ../../LangRef.rst:10661 ../../LangRef.rst:10711 ../../LangRef.rst:10760 ../../LangRef.rst:10810 ../../LangRef.rst:10860 ../../LangRef.rst:10910 ../../LangRef.rst:10959 ../../LangRef.rst:11028 ../../LangRef.rst:11095 ../../LangRef.rst:11135 ../../LangRef.rst:11222 ../../LangRef.rst:11268 ../../LangRef.rst:11315
#: ../../LangRef.rst:11360 ../../LangRef.rst:11407 ../../LangRef.rst:11461 ../../LangRef.rst:11516 ../../LangRef.rst:11549 ../../LangRef.rst:11580 ../../LangRef.rst:11610 ../../LangRef.rst:11639 ../../LangRef.rst:11675 ../../LangRef.rst:11714 ../../LangRef.rst:11752 ../../LangRef.rst:11783 ../../LangRef.rst:11810 ../../LangRef.rst:11837 ../../LangRef.rst:11873 ../../LangRef.rst:11912 ../../LangRef.rst:11954 ../../LangRef.rst:11984 ../../LangRef.rst:12033 ../../LangRef.rst:12049
msgid "Overview:"
msgstr "概述："

#: ../../LangRef.rst:5057
msgid "The '``ret``' instruction is used to return control flow (and optionally a value) from a function back to the caller."
msgstr "'``ret``'指令用于将控制流（以及可选的值）从函数返回给调用者。"

#: ../../LangRef.rst:5060
msgid "There are two forms of the '``ret``' instruction: one that returns a value and then causes control flow, and one that just causes control flow to occur."
msgstr "'``ret``'指令有两种形式：一种是返回一个值然后引起控制流，一种只是导致控制流发生。"

#: ../../LangRef.rst:5065 ../../LangRef.rst:5120 ../../LangRef.rst:5168 ../../LangRef.rst:5230 ../../LangRef.rst:5296 ../../LangRef.rst:5374 ../../LangRef.rst:5415 ../../LangRef.rst:5470 ../../LangRef.rst:5519 ../../LangRef.rst:5608 ../../LangRef.rst:5656 ../../LangRef.rst:5699 ../../LangRef.rst:5751 ../../LangRef.rst:5792 ../../LangRef.rst:5844 ../../LangRef.rst:5882 ../../LangRef.rst:5926 ../../LangRef.rst:5973 ../../LangRef.rst:6011 ../../LangRef.rst:6055 ../../LangRef.rst:6110 ../../LangRef.rst:6162 ../../LangRef.rst:6215 ../../LangRef.rst:6266 ../../LangRef.rst:6315
#: ../../LangRef.rst:6364 ../../LangRef.rst:6414 ../../LangRef.rst:6476 ../../LangRef.rst:6516 ../../LangRef.rst:6559 ../../LangRef.rst:6619 ../../LangRef.rst:6665 ../../LangRef.rst:6722 ../../LangRef.rst:6781 ../../LangRef.rst:6904 ../../LangRef.rst:6985 ../../LangRef.rst:7042 ../../LangRef.rst:7126 ../../LangRef.rst:7204 ../../LangRef.rst:7406 ../../LangRef.rst:7448 ../../LangRef.rst:7488 ../../LangRef.rst:7529 ../../LangRef.rst:7571 ../../LangRef.rst:7611 ../../LangRef.rst:7653 ../../LangRef.rst:7695 ../../LangRef.rst:7736 ../../LangRef.rst:7779 ../../LangRef.rst:7825
#: ../../LangRef.rst:7870 ../../LangRef.rst:7922 ../../LangRef.rst:7976 ../../LangRef.rst:8073 ../../LangRef.rst:8181 ../../LangRef.rst:8237 ../../LangRef.rst:8282 ../../LangRef.rst:8418 ../../LangRef.rst:8476 ../../LangRef.rst:8554 ../../LangRef.rst:8630 ../../LangRef.rst:8785 ../../LangRef.rst:8817 ../../LangRef.rst:8850 ../../LangRef.rst:8909 ../../LangRef.rst:8945 ../../LangRef.rst:8981 ../../LangRef.rst:9021 ../../LangRef.rst:9058 ../../LangRef.rst:9098 ../../LangRef.rst:9292 ../../LangRef.rst:9333 ../../LangRef.rst:9427 ../../LangRef.rst:9472 ../../LangRef.rst:9538
#: ../../LangRef.rst:9593 ../../LangRef.rst:9646 ../../LangRef.rst:9698 ../../LangRef.rst:9736 ../../LangRef.rst:9771 ../../LangRef.rst:9807 ../../LangRef.rst:9844 ../../LangRef.rst:9880 ../../LangRef.rst:9915 ../../LangRef.rst:9950 ../../LangRef.rst:9985 ../../LangRef.rst:10020 ../../LangRef.rst:10056 ../../LangRef.rst:10092 ../../LangRef.rst:10129 ../../LangRef.rst:10171 ../../LangRef.rst:10211 ../../LangRef.rst:10246 ../../LangRef.rst:10281 ../../LangRef.rst:10317 ../../LangRef.rst:10354 ../../LangRef.rst:10390 ../../LangRef.rst:10426 ../../LangRef.rst:10532
#: ../../LangRef.rst:10570 ../../LangRef.rst:10617 ../../LangRef.rst:10668 ../../LangRef.rst:10718 ../../LangRef.rst:10767 ../../LangRef.rst:10817 ../../LangRef.rst:10867 ../../LangRef.rst:10917 ../../LangRef.rst:11037 ../../LangRef.rst:11101 ../../LangRef.rst:11142 ../../LangRef.rst:11228 ../../LangRef.rst:11274 ../../LangRef.rst:11321 ../../LangRef.rst:11365 ../../LangRef.rst:11413 ../../LangRef.rst:11466 ../../LangRef.rst:11522 ../../LangRef.rst:11555 ../../LangRef.rst:11586 ../../LangRef.rst:11616 ../../LangRef.rst:11647 ../../LangRef.rst:11680
#: ../../LangRef.rst:11719 ../../LangRef.rst:11757 ../../LangRef.rst:11788 ../../LangRef.rst:11815 ../../LangRef.rst:11844 ../../LangRef.rst:11880 ../../LangRef.rst:11922 ../../LangRef.rst:11960 ../../LangRef.rst:11991 ../../LangRef.rst:12027 ../../LangRef.rst:12056
msgid "Arguments:"
msgstr "参数："

#: ../../LangRef.rst:5067
msgid "The '``ret``' instruction optionally accepts a single argument, the return value. The type of the return value must be a ':ref:`first class <t_firstclass>`' type."
msgstr "'``ret``'指令可选地接受单个参数，即返回值。返回值的类型必须是'：ref：`first class <t_firstclass>`'类型。"

#: ../../LangRef.rst:5071
msgid "A function is not :ref:`well formed <wellformed>` if it it has a non-void return type and contains a '``ret``' instruction with no return value or a return value with a type that does not match its type, or if it has a void return type and contains a '``ret``' instruction with a return value."
msgstr "函数不是：ref：`well formed <wellformed>`如果它有一个非void返回类型并包含一个没有返回值的'``ret``'指令或一个类型不匹配的返回值它的类型，或者它是否具有void返回类型并包含带有返回值的'``ret``'指令。"

#: ../../LangRef.rst:5078 ../../LangRef.rst:5127 ../../LangRef.rst:5176 ../../LangRef.rst:5241 ../../LangRef.rst:5328 ../../LangRef.rst:5381 ../../LangRef.rst:5430 ../../LangRef.rst:5478 ../../LangRef.rst:5534 ../../LangRef.rst:5570 ../../LangRef.rst:5615 ../../LangRef.rst:5663 ../../LangRef.rst:5706 ../../LangRef.rst:5758 ../../LangRef.rst:5799 ../../LangRef.rst:5851 ../../LangRef.rst:5889 ../../LangRef.rst:5933 ../../LangRef.rst:5980 ../../LangRef.rst:6018 ../../LangRef.rst:6062 ../../LangRef.rst:6117 ../../LangRef.rst:6169 ../../LangRef.rst:6222 ../../LangRef.rst:6273
#: ../../LangRef.rst:6322 ../../LangRef.rst:6371 ../../LangRef.rst:6421 ../../LangRef.rst:6484 ../../LangRef.rst:6525 ../../LangRef.rst:6571 ../../LangRef.rst:6634 ../../LangRef.rst:6676 ../../LangRef.rst:6737 ../../LangRef.rst:6866 ../../LangRef.rst:6946 ../../LangRef.rst:6992 ../../LangRef.rst:7070 ../../LangRef.rst:7153 ../../LangRef.rst:7261 ../../LangRef.rst:7415 ../../LangRef.rst:7456 ../../LangRef.rst:7496 ../../LangRef.rst:7537 ../../LangRef.rst:7578 ../../LangRef.rst:7620 ../../LangRef.rst:7662 ../../LangRef.rst:7704 ../../LangRef.rst:7745 ../../LangRef.rst:7787
#: ../../LangRef.rst:7832 ../../LangRef.rst:7882 ../../LangRef.rst:7929 ../../LangRef.rst:7998 ../../LangRef.rst:8104 ../../LangRef.rst:8200 ../../LangRef.rst:8244 ../../LangRef.rst:8366 ../../LangRef.rst:8426 ../../LangRef.rst:8490 ../../LangRef.rst:8571 ../../LangRef.rst:8636 ../../LangRef.rst:8790 ../../LangRef.rst:8822 ../../LangRef.rst:8856 ../../LangRef.rst:8917 ../../LangRef.rst:8953 ../../LangRef.rst:8989 ../../LangRef.rst:9029 ../../LangRef.rst:9066 ../../LangRef.rst:9118 ../../LangRef.rst:9154 ../../LangRef.rst:9195 ../../LangRef.rst:9227 ../../LangRef.rst:9256
#: ../../LangRef.rst:9303 ../../LangRef.rst:9338 ../../LangRef.rst:9364 ../../LangRef.rst:9393 ../../LangRef.rst:9443 ../../LangRef.rst:9492 ../../LangRef.rst:9555 ../../LangRef.rst:9610 ../../LangRef.rst:9662 ../../LangRef.rst:9704 ../../LangRef.rst:9742 ../../LangRef.rst:9777 ../../LangRef.rst:9813 ../../LangRef.rst:9850 ../../LangRef.rst:9886 ../../LangRef.rst:9921 ../../LangRef.rst:9956 ../../LangRef.rst:9991 ../../LangRef.rst:10026 ../../LangRef.rst:10062 ../../LangRef.rst:10098 ../../LangRef.rst:10135 ../../LangRef.rst:10177 ../../LangRef.rst:10217
#: ../../LangRef.rst:10252 ../../LangRef.rst:10287 ../../LangRef.rst:10323 ../../LangRef.rst:10360 ../../LangRef.rst:10396 ../../LangRef.rst:10432 ../../LangRef.rst:10466 ../../LangRef.rst:10495 ../../LangRef.rst:10539 ../../LangRef.rst:10583 ../../LangRef.rst:10630 ../../LangRef.rst:10677 ../../LangRef.rst:10727 ../../LangRef.rst:10776 ../../LangRef.rst:10826 ../../LangRef.rst:10876 ../../LangRef.rst:10926 ../../LangRef.rst:11043 ../../LangRef.rst:11107 ../../LangRef.rst:11148 ../../LangRef.rst:11240 ../../LangRef.rst:11281 ../../LangRef.rst:11327
#: ../../LangRef.rst:11371 ../../LangRef.rst:11419 ../../LangRef.rst:11472 ../../LangRef.rst:11529 ../../LangRef.rst:11562 ../../LangRef.rst:11593 ../../LangRef.rst:11624 ../../LangRef.rst:11653 ../../LangRef.rst:11687 ../../LangRef.rst:11727 ../../LangRef.rst:11765 ../../LangRef.rst:11793 ../../LangRef.rst:11820 ../../LangRef.rst:11852 ../../LangRef.rst:11886 ../../LangRef.rst:11931 ../../LangRef.rst:11967 ../../LangRef.rst:11996 ../../LangRef.rst:12061
msgid "Semantics:"
msgstr "语义："

#: ../../LangRef.rst:5080
msgid "When the '``ret``' instruction is executed, control flow returns back to the calling function's context. If the caller is a \":ref:`call <i_call>`\" instruction, execution continues at the instruction after the call. If the caller was an \":ref:`invoke <i_invoke>`\" instruction, execution continues at the beginning of the \"normal\" destination block. If the instruction returns a value, that value shall set the call or invoke instruction's return value."
msgstr "当执行'``ret``'指令时，控制流程返回到调用函数的上下文。如果调用者是一个\\“：ref：`call <i_call>`\\”指令，则在调用后的指令处继续执行。如果调用者是一个\\“：ref：`invoke <i_invoke>`\\”指令，则执行在\\“normal \\”目标块的开头继续。如果指令返回一个值，该值应设置调用或调用指令的返回值。"

#: ../../LangRef.rst:5090 ../../LangRef.rst:5135 ../../LangRef.rst:5193 ../../LangRef.rst:5254 ../../LangRef.rst:5346 ../../LangRef.rst:5388 ../../LangRef.rst:5441 ../../LangRef.rst:5492 ../../LangRef.rst:5542 ../../LangRef.rst:5632 ../../LangRef.rst:5671 ../../LangRef.rst:5723 ../../LangRef.rst:5766 ../../LangRef.rst:5820 ../../LangRef.rst:5859 ../../LangRef.rst:5903 ../../LangRef.rst:5949 ../../LangRef.rst:5988 ../../LangRef.rst:6030 ../../LangRef.rst:6085 ../../LangRef.rst:6125 ../../LangRef.rst:6187 ../../LangRef.rst:6236 ../../LangRef.rst:6287 ../../LangRef.rst:6339
#: ../../LangRef.rst:6388 ../../LangRef.rst:6438 ../../LangRef.rst:6491 ../../LangRef.rst:6533 ../../LangRef.rst:6581 ../../LangRef.rst:6640 ../../LangRef.rst:6683 ../../LangRef.rst:6750 ../../LangRef.rst:6958 ../../LangRef.rst:7015 ../../LangRef.rst:7089 ../../LangRef.rst:7175 ../../LangRef.rst:7314 ../../LangRef.rst:7423 ../../LangRef.rst:7464 ../../LangRef.rst:7505 ../../LangRef.rst:7547 ../../LangRef.rst:7587 ../../LangRef.rst:7628 ../../LangRef.rst:7670 ../../LangRef.rst:7712 ../../LangRef.rst:7753 ../../LangRef.rst:7798 ../../LangRef.rst:7842 ../../LangRef.rst:7894
#: ../../LangRef.rst:7940 ../../LangRef.rst:8033 ../../LangRef.rst:8150 ../../LangRef.rst:8207 ../../LangRef.rst:8257 ../../LangRef.rst:8375 ../../LangRef.rst:8441 ../../LangRef.rst:8518 ../../LangRef.rst:8591 ../../LangRef.rst:8661
msgid "Example:"
msgstr "例："

#: ../../LangRef.rst:5101
msgid "'``br``' Instruction"
msgstr "'`br``'指令"

#: ../../LangRef.rst:5114
msgid "The '``br``' instruction is used to cause control flow to transfer to a different basic block in the current function. There are two forms of this instruction, corresponding to a conditional branch and an unconditional branch."
msgstr "'`br``'指令用于使控制流转移到当前函数中的不同基本块。该指令有两种形式，对应于条件分支和无条件分支。"

#: ../../LangRef.rst:5122
msgid "The conditional branch form of the '``br``' instruction takes a single '``i1``' value and two '``label``' values. The unconditional form of the '``br``' instruction takes a single '``label``' value as a target."
msgstr "'`br``'指令的条件分支形式采用单个'``i1``'值和两个'``label``'值。无条件形式的'`br``'指令将单个'``label``'值作为目标。"

#: ../../LangRef.rst:5129
msgid "Upon execution of a conditional '``br``' instruction, the '``i1``' argument is evaluated. If the value is ``true``, control flows to the '``iftrue``' ``label`` argument. If \"cond\" is ``false``, control flows to the '``iffalse``' ``label`` argument."
msgstr "执行条件'`br``'指令后，将评估'``i1``'参数。如果值为“true”，则控制流向'``iftrue``'`````参数。如果\\“cond \\”是``false``，则控制流向'``iffalse``'``label``参数。"

#: ../../LangRef.rst:5150
msgid "'``switch``' Instruction"
msgstr "'``switch``'指令"

#: ../../LangRef.rst:5162
msgid "The '``switch``' instruction is used to transfer control flow to one of several different places. It is a generalization of the '``br``' instruction, allowing a branch to occur to one of many possible destinations."
msgstr "'``switch``'指令用于将控制流转移到几个不同的地方之一。它是'`br``'指令的推广，允许分支出现在许多可能的目的地之一。"

#: ../../LangRef.rst:5170
msgid "The '``switch``' instruction uses three parameters: an integer comparison value '``value``', a default '``label``' destination, and an array of pairs of comparison value constants and '``label``'s. The table is not allowed to contain duplicate constant entries."
msgstr "'``switch``'指令使用三个参数：一个整数比较值'``value``'，一个默认的'``label``'目的地，以及一对比较值常量和'``标签的数组``的。该表不允许包含重复的常量条目。"

#: ../../LangRef.rst:5178
msgid "The ``switch`` instruction specifies a table of values and destinations. When the '``switch``' instruction is executed, this table is searched for the given value. If the value is found, control flow is transferred to the corresponding destination; otherwise, control flow is transferred to the default destination."
msgstr "``switch``指令指定值和目标的表。当执行'``switch``'指令时，将在该表中搜索给定值。如果找到该值，则控制流被转移到相应的目的地;否则，控制流程将转移到默认目的地。"

#: ../../LangRef.rst:5185 ../../LangRef.rst:5249
msgid "Implementation:"
msgstr "执行："

#: ../../LangRef.rst:5187
msgid "Depending on properties of the target machine and the particular ``switch`` instruction, this instruction may be code generated in different ways. For example, it could be generated as a series of chained conditional branches or with a lookup table."
msgstr "根据目标机器的属性和特定的``switch``指令，该指令可以是以不同方式生成的代码。例如，它可以生成为一系列链式条件分支或查找表。"

#: ../../LangRef.rst:5212
msgid "'``indirectbr``' Instruction"
msgstr "'`indirectbr``'指令"

#: ../../LangRef.rst:5224
msgid "The '``indirectbr``' instruction implements an indirect branch to a label within the current function, whose address is specified by \"``address``\". Address must be derived from a :ref:`blockaddress <blockaddress>` constant."
msgstr "'`indirectbr``'指令实现了对当前函数中标签的间接分支，其地址由\\```address`` \\“指定。地址必须来自：ref：`blockaddress <blockaddress>`常量。"

#: ../../LangRef.rst:5232
msgid "The '``address``' argument is the address of the label to jump to. The rest of the arguments indicate the full set of possible destinations that the address may point to. Blocks are allowed to occur multiple times in the destination list, though this isn't particularly useful."
msgstr "'``address``'参数是要跳转到的标签的地址。其余参数表示地址可能指向的完整可能目的地集。允许块在目标列表中多次出现，但这不是特别有用。"

#: ../../LangRef.rst:5237
msgid "This destination list is required so that dataflow analysis has an accurate understanding of the CFG."
msgstr "此目标列表是必需的，以便数据流分析能够准确了解CFG。"

#: ../../LangRef.rst:5243
msgid "Control transfers to the block specified in the address argument. All possible destination blocks must be listed in the label list, otherwise this instruction has undefined behavior. This implies that jumps to labels defined in other functions have undefined behavior as well."
msgstr "控制转移到address参数中指定的块。必须在标签列表中列出所有可能的目标块，否则此指令具有未定义的行为。这意味着跳转到其他函数中定义的标签也具有未定义的行为。"

#: ../../LangRef.rst:5251
msgid "This is typically implemented with a jump through a register."
msgstr "这通常通过跳过寄存器来实现。"

#: ../../LangRef.rst:5263
msgid "'``invoke``' Instruction"
msgstr "'``invoke``'指令"

#: ../../LangRef.rst:5276
msgid "The '``invoke``' instruction causes control to transfer to a specified function, with the possibility of control flow transfer to either the '``normal``' label or the '``exception``' label. If the callee function returns with the \"``ret``\" instruction, control flow will return to the \"normal\" label. If the callee (or any indirect callees) returns via the \":ref:`resume <i_resume>`\" instruction or other exception handling mechanism, control is interrupted and continued at the dynamically nearest \"exception\" label."
msgstr "'``invoke``'指令使控制转移到指定的函数，控制流可能转移到'``normal``'标签或'``exception``'标签。如果被调用函数返回带有“``ret`` \\”指令，则控制流将返回到“normal”标签。如果被调用者（或任何间接被调用者）通过\\“：ref：`resume <i_resume>`\\”指令或其他异常处理机制返回，则控制被中断并在动态最近的“异常”标签处继续。"

#: ../../LangRef.rst:5285
msgid "The '``exception``' label is a `landing pad <ExceptionHandling.html#overview>`_ for the exception. As such, '``exception``' label is required to have the \":ref:`landingpad <i_landingpad>`\" instruction, which contains the information about the behavior of the program after unwinding happens, as its first non-PHI instruction. The restrictions on the \"``landingpad``\" instruction's tightly couples it to the \"``invoke``\" instruction, so that the important information contained within the \"``landingpad``\" instruction can't be lost through normal code motion."
msgstr "'``exception``'标签是异常的登陆垫<ExceptionHandling.html＃overview>`_。因此，'``exception``'标签需要有\\“：ref：`landingpad <i_landingpad>`\\”指令，其中包含有关展开后程序行为的信息，因为它是第一个非PHI指令。对````landingpad`` \\“指令的限制将它与'```invoke`` \\”指令紧密结合在一起，以便在````landingpad`` \\“指令中包含的重要信息可以'通过正常的代码运动丢失。"

#: ../../LangRef.rst:5298 ../../LangRef.rst:8284
msgid "This instruction requires several arguments:"
msgstr "该指令需要几个参数："

#: ../../LangRef.rst:5300
msgid "The optional \"cconv\" marker indicates which :ref:`calling convention <callingconv>` the call should use. If none is specified, the call defaults to using C calling conventions."
msgstr "可选的\\“cconv \\”标记指示调用应该使用的：ref：`calling convention <callingconv>`。如果未指定，则调用默认使用C调用约定。"

#: ../../LangRef.rst:5303 ../../LangRef.rst:8340
msgid "The optional :ref:`Parameter Attributes <paramattrs>` list for return values. Only '``zeroext``', '``signext``', and '``inreg``' attributes are valid here."
msgstr "可选：ref：`参数属性<paramattrs>`返回值的列表。只有'``zeroext``'，'``signext``'和'``inreg``'属性在这里有效。"

#: ../../LangRef.rst:5306
msgid "'``ptr to function ty``': shall be the signature of the pointer to function value being invoked. In most cases, this is a direct function invocation, but indirect ``invoke``'s are just as possible, branching off an arbitrary pointer to function value."
msgstr "'``ptr to function ty``'：应该是调用函数值的指针的签名。在大多数情况下，这是一个直接的函数调用，但间接的``invoke``是尽可能的，从函数值的任意指针分支。"

#: ../../LangRef.rst:5310
msgid "'``function ptr val``': An LLVM value containing a pointer to a function to be invoked."
msgstr "'``function ptr val``'：一个LLVM值，包含一个指向要调用的函数的指针。"

#: ../../LangRef.rst:5312 ../../LangRef.rst:8355
msgid "'``function args``': argument list whose types match the function signature argument types and parameter attributes. All arguments must be of :ref:`first class <t_firstclass>` type. If the function signature indicates the function accepts a variable number of arguments, the extra arguments can be specified."
msgstr "'``function args``'：参数列表，其类型与函数签名参数类型和参数属性匹配。所有参数必须是：ref：`first class <t_firstclass>`type。如果函数签名指示函数接受可变数量的参数，则可以指定额外参数。"

#: ../../LangRef.rst:5317
msgid "'``normal label``': the label reached when the called function executes a '``ret``' instruction."
msgstr "'``normal label``'：被调用函数执行'``ret``'指令时到达的标签。"

#: ../../LangRef.rst:5319
msgid "'``exception label``': the label reached when a callee returns via the :ref:`resume <i_resume>` instruction or other exception handling mechanism."
msgstr "'``exception label``'：当被调用者通过：ref：`resume <i_resume>`指令或其他异常处理机制返回时到达的标签。"

#: ../../LangRef.rst:5322 ../../LangRef.rst:8360
msgid "The optional :ref:`function attributes <fnattrs>` list. Only '``noreturn``', '``nounwind``', '``readonly``' and '``readnone``' attributes are valid here."
msgstr "可选：ref：`function attributes <fnattrs>`list。只有'``noreturn``'，'``nounwind``'，```readonly``'和'``readnone``'属性在这里有效。"

#: ../../LangRef.rst:5325 ../../LangRef.rst:8363
msgid "The optional :ref:`operand bundles <opbundles>` list."
msgstr "可选：ref：`operand bundle <opbundles>`list。"

#: ../../LangRef.rst:5330
msgid "This instruction is designed to operate as a standard '``call``' instruction in most regards. The primary difference is that it establishes an association with a label, which is used by the runtime library to unwind the stack."
msgstr "在大多数情况下，该指令旨在作为标准的“``call``'指令运行。主要区别在于它与标签建立关联，运行时库使用该标签来展开堆栈。"

#: ../../LangRef.rst:5335
msgid "This instruction is used in languages with destructors to ensure that proper cleanup is performed in the case of either a ``longjmp`` or a thrown exception. Additionally, this is important for implementation of '``catch``' clauses in high-level languages that support them."
msgstr "该指令用于具有析构函数的语言，以确保在“longjmp”或抛出异常的情况下执行正确的清理。此外，这对于在支持它们的高级语言中实现“`catch``'子句非常重要。"

#: ../../LangRef.rst:5340
msgid "For the purposes of the SSA form, the definition of the value returned by the '``invoke``' instruction is deemed to occur on the edge from the current block to the \"normal\" label. If the callee unwinds then no return value is available."
msgstr "出于SSA形式的目的，'``invoke``'指令返回的值的定义被认为发生在从当前块到\\“normal \\”标签的边缘。如果被调用者展开，则没有可用的返回值。"

#: ../../LangRef.rst:5358
msgid "'``resume``' Instruction"
msgstr "'``resume``'指令"

#: ../../LangRef.rst:5370
msgid "The '``resume``' instruction is a terminator instruction that has no successors."
msgstr "'``resume``'指令是没有后继的终结符指令。"

#: ../../LangRef.rst:5376
msgid "The '``resume``' instruction requires one argument, which must have the same type as the result of any '``landingpad``' instruction in the same function."
msgstr "'``resume``'指令需要一个参数，该参数必须与同一函数中任何'``landingpad``'指令的结果相同。"

#: ../../LangRef.rst:5383
msgid "The '``resume``' instruction resumes propagation of an existing (in-flight) exception whose unwinding was interrupted with a :ref:`landingpad <i_landingpad>` instruction."
msgstr "'``resume``'指令恢复传播现有（飞行中）异常，其异常被：ref：`landingpad <i_landingpad>`指令中断。"

#: ../../LangRef.rst:5397
msgid "'``catchswitch``' Instruction"
msgstr "'``catchswitch``'指令"

#: ../../LangRef.rst:5410
msgid "The '``catchswitch``' instruction is used by `LLVM's exception handling system <ExceptionHandling.html#overview>`_ to describe the set of possible catch handlers that may be executed by the :ref:`EH personality routine <personalityfn>`."
msgstr "```catchswitch``'指令由`LLVM的异常处理系统<ExceptionHandling.html＃overview>`_用于描述可能由以下内容执行的可能的catch处理程序集：ref：`EH个性例程<personalityfn> `。"

#: ../../LangRef.rst:5417
msgid "The ``parent`` argument is the token of the funclet that contains the ``catchswitch`` instruction. If the ``catchswitch`` is not inside a funclet, this operand may be the token ``none``."
msgstr "``parent``参数是包含``catchswitch``指令的funclet的标记。如果``catchswitch``不在funclet中，那么这个操作数可能是令牌``none``。"

#: ../../LangRef.rst:5421
msgid "The ``default`` argument is the label of another basic block beginning with either a ``cleanuppad`` or ``catchswitch`` instruction.  This unwind destination must be a legal target with respect to the ``parent`` links, as described in the `exception handling documentation\\ <ExceptionHandling.html#wineh-constraints>`_."
msgstr "``default``参数是另一个以``cleanuppad``或``catchswitch``指令开头的基本块的标签。这个展开目的地必须是关于``parent``链接的合法目标，如`异常处理文档\\ <ExceptionHandling.html＃wineh-constraints>`_中所述。"

#: ../../LangRef.rst:5426
msgid "The ``handlers`` are a nonempty list of successor blocks that each begin with a :ref:`catchpad <i_catchpad>` instruction."
msgstr "``handlers``是一个非空的后继块列表，每个后续块都以：ref：`catchpad <i_catchpad>`指令开头。"

#: ../../LangRef.rst:5432
msgid "Executing this instruction transfers control to one of the successors in ``handlers``, if appropriate, or continues to unwind via the unwind label if present."
msgstr "如果适用，执行此指令将控制转移到“处理程序”中的一个后继程序，或者如果存在则通过展开标签继续展开。"

#: ../../LangRef.rst:5436
msgid "The ``catchswitch`` is both a terminator and a \"pad\" instruction, meaning that it must be both the first non-phi instruction and last instruction in the basic block. Therefore, it must be the only non-phi instruction in the block."
msgstr "``catchswitch``既是终结符又是\\“pad \\”指令，这意味着它必须是基本块中的第一个非phi指令和最后一个指令。因此，它必须是块中唯一的非phi指令。"

#: ../../LangRef.rst:5453
msgid "'``catchret``' Instruction"
msgstr "'``catchret``'指示"

#: ../../LangRef.rst:5465
msgid "The '``catchret``' instruction is a terminator instruction that has a single successor."
msgstr "'``catchret``'指令是一个具有单个后继的终结指令。"

#: ../../LangRef.rst:5472
msgid "The first argument to a '``catchret``' indicates which ``catchpad`` it exits.  It must be a :ref:`catchpad <i_catchpad>`. The second argument to a '``catchret``' specifies where control will transfer to next."
msgstr "'``catchret``'的第一个参数表示它退出的``catchpad``。它必须是：ref：`catchpad <i_catchpad>`。 '``catchret``'的第二个参数指定控件将转移到下一个的位置。"

#: ../../LangRef.rst:5480
msgid "The '``catchret``' instruction ends an existing (in-flight) exception whose unwinding was interrupted with a :ref:`catchpad <i_catchpad>` instruction.  The :ref:`personality function <personalityfn>` gets a chance to execute arbitrary code to, for example, destroy the active exception.  Control then transfers to ``normal``."
msgstr "'``catchret``'指令结束了一个现有的（飞行中）异常，其异常被一个：ref：`catchpad <i_catchpad>'指令中断。 ：ref：`个性函数<personalityfn>`有机会执行任意代码，例如，销毁活动异常。然后控制转移到“正常”。"

#: ../../LangRef.rst:5486
msgid "The ``token`` argument must be a token produced by a ``catchpad`` instruction. If the specified ``catchpad`` is not the most-recently-entered not-yet-exited funclet pad (as described in the `EH documentation\\ <ExceptionHandling.html#wineh-constraints>`_), the ``catchret``'s behavior is undefined."
msgstr "``token``参数必须是``catchpad``指令产生的标记。如果指定的``catchpad``不是最近进入的尚未退出的funclet pad（如'EH文档\\ <ExceptionHandling.html＃wineh-constraints>`_中所述），则``catchret ``的行为未定义。"

#: ../../LangRef.rst:5501
msgid "'``cleanupret``' Instruction"
msgstr "'``cleanupret``'指令"

#: ../../LangRef.rst:5514
msgid "The '``cleanupret``' instruction is a terminator instruction that has an optional successor."
msgstr "'``cleanupret``'指令是一个终止指令，它有一个可选的后继指令。"

#: ../../LangRef.rst:5521
msgid "The '``cleanupret``' instruction requires one argument, which indicates which ``cleanuppad`` it exits, and must be a :ref:`cleanuppad <i_cleanuppad>`. If the specified ``cleanuppad`` is not the most-recently-entered not-yet-exited funclet pad (as described in the `EH documentation\\ <ExceptionHandling.html#wineh-constraints>`_), the ``cleanupret``'s behavior is undefined."
msgstr "'``cleanupret``'指令需要一个参数，它指示它退出哪个``cleanuppad``，并且必须是：ref：`cleanuppad <i_cleanuppad>`。如果指定的``cleanuppad``不是最近进入的尚未退出的funclet pad（如'EH documentation \\ <ExceptionHandling.html＃wineh-constraints>`_中所述），那么``cleanupret ``的行为未定义。"

#: ../../LangRef.rst:5527
msgid "The '``cleanupret``' instruction also has an optional successor, ``continue``, which must be the label of another basic block beginning with either a ``cleanuppad`` or ``catchswitch`` instruction.  This unwind destination must be a legal target with respect to the ``parent`` links, as described in the `exception handling documentation\\ <ExceptionHandling.html#wineh-constraints>`_."
msgstr "'``cleanupret``'指令还有一个可选的后继，``continue``，它必须是另一个以``cleanuppad``或``catchswitch``指令开头的基本块的标签。这个展开目的地必须是关于``parent``链接的合法目标，如`异常处理文档\\ <ExceptionHandling.html＃wineh-constraints>`_中所述。"

#: ../../LangRef.rst:5536
msgid "The '``cleanupret``' instruction indicates to the :ref:`personality function <personalityfn>` that one :ref:`cleanuppad <i_cleanuppad>` it transferred control to has ended. It transfers control to ``continue`` or unwinds out of the function."
msgstr "'``cleanupret``'指令指示：ref：`个性函数<personalityfn>`一个：ref：`cleanuppad <i_cleanuppad>`它将控制转移到已经结束。它将控制转移到``continue``或从函数中展开。"

#: ../../LangRef.rst:5552
msgid "'``unreachable``' Instruction"
msgstr "'``无法达到'`'指令"

#: ../../LangRef.rst:5564
msgid "The '``unreachable``' instruction has no defined semantics. This instruction is used to inform the optimizer that a particular portion of the code is not reachable. This can be used to indicate that the code after a no-return function cannot be reached, and other facts."
msgstr "'``unreachable``'指令没有定义的语义。该指令用于通知优化器代码的特定部分是不可访问的。这可以用来表示无法达到无返回功能后的代码和其他事实。"

#: ../../LangRef.rst:5572
msgid "The '``unreachable``' instruction has no defined semantics."
msgstr "'``unreachable``'指令没有定义的语义。"

#: ../../LangRef.rst:5577
msgid "Binary Operations"
msgstr "二元操作"

#: ../../LangRef.rst:5579
msgid "Binary operators are used to do most of the computation in a program. They require two operands of the same type, execute an operation on them, and produce a single value. The operands might represent multiple data, as is the case with the :ref:`vector <t_vector>` data type. The result value has the same type as its operands."
msgstr "二进制运算符用于执行程序中的大部分计算。它们需要两个相同类型的操作数，对它们执行操作，并生成单个值。操作数可能代表多个数据，例如：ref：`vector <t_vector>`数据类型。结果值与其操作数具有相同的类型。"

#: ../../LangRef.rst:5585
msgid "There are several different binary operators:"
msgstr "有几种不同的二元运算符："

#: ../../LangRef.rst:5590
msgid "'``add``' Instruction"
msgstr "'``add``'指令"

#: ../../LangRef.rst:5605
msgid "The '``add``' instruction returns the sum of its two operands."
msgstr "'``add``'指令返回其两个操作数的总和。"

#: ../../LangRef.rst:5610
msgid "The two arguments to the '``add``' instruction must be :ref:`integer <t_integer>` or :ref:`vector <t_vector>` of integer values. Both arguments must have identical types."
msgstr "'``add``'指令的两个参数必须是：ref：`integer <t_integer>`或：ref：`vector <t_vector>`的整数值。两个参数必须具有相同的类型。"

#: ../../LangRef.rst:5617
msgid "The value produced is the integer sum of the two operands."
msgstr "生成的值是两个操作数的整数和。"

#: ../../LangRef.rst:5619
msgid "If the sum has unsigned overflow, the result returned is the mathematical result modulo 2\\ :sup:`n`\\ , where n is the bit width of the result."
msgstr "如果总和有无符号溢出，则返回的结果是模2 \\：sup：`n` \\的数学结果，其中n是结果的位宽。"

#: ../../LangRef.rst:5623 ../../LangRef.rst:5714
msgid "Because LLVM integers use a two's complement representation, this instruction is appropriate for both signed and unsigned integers."
msgstr "由于LLVM整数使用二进制补码表示，因此该指令适用于有符号和无符号整数。"

#: ../../LangRef.rst:5626
msgid "``nuw`` and ``nsw`` stand for \"No Unsigned Wrap\" and \"No Signed Wrap\", respectively. If the ``nuw`` and/or ``nsw`` keywords are present, the result value of the ``add`` is a :ref:`poison value <poisonvalues>` if unsigned and/or signed overflow, respectively, occurs."
msgstr "``nuw``和``nsw``分别代表\\“No Unsigned Wrap \\”和\\“No Signed Wrap \\”。如果存在``nuw``和/或``nsw``关键字，则``add``的结果值分别为：ref：`poison value <poisonvalues>`如果是无符号和/或有符号溢出，发生。"

#: ../../LangRef.rst:5641
msgid "'``fadd``' Instruction"
msgstr "'``fadd``'指令"

#: ../../LangRef.rst:5653
msgid "The '``fadd``' instruction returns the sum of its two operands."
msgstr "'``fadd``'指令返回其两个操作数的总和。"

#: ../../LangRef.rst:5658
msgid "The two arguments to the '``fadd``' instruction must be :ref:`floating point <t_floating>` or :ref:`vector <t_vector>` of floating point values. Both arguments must have identical types."
msgstr "'`fadd``'指令的两个参数必须是：ref：`浮点<t_floating>`或：ref：`vector <t_vector>`浮点值。两个参数必须具有相同的类型。"

#: ../../LangRef.rst:5665
msgid "The value produced is the floating point sum of the two operands. This instruction can also take any number of :ref:`fast-math flags <fastmath>`, which are optimization hints to enable otherwise unsafe floating point optimizations:"
msgstr "产生的值是两个操作数的浮点和。该指令也可以使用以下任意数量的：ref：`fast-math flags <fastmath>`，它们是优化提示，用于启用其他不安全的浮点优化："

#: ../../LangRef.rst:5678
msgid "'``sub``' Instruction"
msgstr "'``sub``'指令"

#: ../../LangRef.rst:5693
msgid "The '``sub``' instruction returns the difference of its two operands."
msgstr "'``sub``'指令返回其两个操作数的差异。"

#: ../../LangRef.rst:5695
msgid "Note that the '``sub``' instruction is used to represent the '``neg``' instruction present in most other intermediate representations."
msgstr "注意，'``sub``'指令用于表示大多数其他中间表示中存在的'``neg``'指令。"

#: ../../LangRef.rst:5701
msgid "The two arguments to the '``sub``' instruction must be :ref:`integer <t_integer>` or :ref:`vector <t_vector>` of integer values. Both arguments must have identical types."
msgstr "'``sub``'指令的两个参数必须是：ref：`integer <t_integer>`或：ref：`vector <t_vector>`的整数值。两个参数必须具有相同的类型。"

#: ../../LangRef.rst:5708
msgid "The value produced is the integer difference of the two operands."
msgstr "产生的值是两个操作数的整数差。"

#: ../../LangRef.rst:5710
msgid "If the difference has unsigned overflow, the result returned is the mathematical result modulo 2\\ :sup:`n`\\ , where n is the bit width of the result."
msgstr "如果差值有无符号溢出，则返回的结果是模2 \\：sup：`n` \\的数学结果，其中n是结果的位宽。"

#: ../../LangRef.rst:5717
msgid "``nuw`` and ``nsw`` stand for \"No Unsigned Wrap\" and \"No Signed Wrap\", respectively. If the ``nuw`` and/or ``nsw`` keywords are present, the result value of the ``sub`` is a :ref:`poison value <poisonvalues>` if unsigned and/or signed overflow, respectively, occurs."
msgstr "``nuw``和``nsw``分别代表\\“No Unsigned Wrap \\”和\\“No Signed Wrap \\”。如果存在``nuw``和/或``nsw``关键字，则``sub``的结果值分别是：ref：`poison value <poisonvalues>`如果是无符号和/或有符号溢出，发生。"

#: ../../LangRef.rst:5733
msgid "'``fsub``' Instruction"
msgstr "'``fsub``'指令"

#: ../../LangRef.rst:5745
msgid "The '``fsub``' instruction returns the difference of its two operands."
msgstr "'``fsub``'指令返回两个操作数的差异。"

#: ../../LangRef.rst:5747
msgid "Note that the '``fsub``' instruction is used to represent the '``fneg``' instruction present in most other intermediate representations."
msgstr "注意，'``fsub``'指令用于表示大多数其他中间表示中存在的'``fneg``'指令。"

#: ../../LangRef.rst:5753
msgid "The two arguments to the '``fsub``' instruction must be :ref:`floating point <t_floating>` or :ref:`vector <t_vector>` of floating point values. Both arguments must have identical types."
msgstr "'``fsub``'指令的两个参数必须是：ref：`浮点<t_floating>`或：ref：`vector <t_vector>`浮点值。两个参数必须具有相同的类型。"

#: ../../LangRef.rst:5760
msgid "The value produced is the floating point difference of the two operands. This instruction can also take any number of :ref:`fast-math flags <fastmath>`, which are optimization hints to enable otherwise unsafe floating point optimizations:"
msgstr "产生的值是两个操作数的浮点差。该指令也可以使用以下任意数量的：ref：`fast-math flags <fastmath>`，它们是优化提示，用于启用其他不安全的浮点优化："

#: ../../LangRef.rst:5774
msgid "'``mul``' Instruction"
msgstr "'``mul``'指示"

#: ../../LangRef.rst:5789
msgid "The '``mul``' instruction returns the product of its two operands."
msgstr "'``mul``'指令返回其两个操作数的乘积。"

#: ../../LangRef.rst:5794
msgid "The two arguments to the '``mul``' instruction must be :ref:`integer <t_integer>` or :ref:`vector <t_vector>` of integer values. Both arguments must have identical types."
msgstr "'`mul``'指令的两个参数必须是：ref：`integer <t_integer>`或：ref：`vector <t_vector>`的整数值。两个参数必须具有相同的类型。"

#: ../../LangRef.rst:5801
msgid "The value produced is the integer product of the two operands."
msgstr "产生的值是两个操作数的整数乘积。"

#: ../../LangRef.rst:5803
msgid "If the result of the multiplication has unsigned overflow, the result returned is the mathematical result modulo 2\\ :sup:`n`\\ , where n is the bit width of the result."
msgstr "如果乘法的结果具有无符号溢出，则返回的结果是数学结果模2 \\：sup：`n` \\，其中n是结果的位宽。"

#: ../../LangRef.rst:5807
msgid "Because LLVM integers use a two's complement representation, and the result is the same width as the operands, this instruction returns the correct result for both signed and unsigned integers. If a full product (e.g. ``i32`` * ``i32`` -> ``i64``) is needed, the operands should be sign-extended or zero-extended as appropriate to the width of the full product."
msgstr "因为LLVM整数使用二进制补码表示，并且结果与操作数的宽度相同，所以此指令返回有符号和无符号整数的正确结果。如果需要完整的产品（例如``i32`` *``i32``  - >``i64``），操作数应根据整个产品的宽度进行符号扩展或零扩展。"

#: ../../LangRef.rst:5814
msgid "``nuw`` and ``nsw`` stand for \"No Unsigned Wrap\" and \"No Signed Wrap\", respectively. If the ``nuw`` and/or ``nsw`` keywords are present, the result value of the ``mul`` is a :ref:`poison value <poisonvalues>` if unsigned and/or signed overflow, respectively, occurs."
msgstr "``nuw``和``nsw``分别代表\\“No Unsigned Wrap \\”和\\“No Signed Wrap \\”。如果存在``nuw``和/或``nsw``关键字，那么``mul``的结果值分别为：ref：`poison value <poisonvalues>`如果是无符号和/或有符号溢出，发生。"

#: ../../LangRef.rst:5829
msgid "'``fmul``' Instruction"
msgstr "'``fmul``'指令"

#: ../../LangRef.rst:5841
msgid "The '``fmul``' instruction returns the product of its two operands."
msgstr "'``fmul``'指令返回其两个操作数的乘积。"

#: ../../LangRef.rst:5846
msgid "The two arguments to the '``fmul``' instruction must be :ref:`floating point <t_floating>` or :ref:`vector <t_vector>` of floating point values. Both arguments must have identical types."
msgstr "'``fmul``'指令的两个参数必须是：ref：`浮点<t_floating>`或：ref：`vector <t_vector>`浮点值。两个参数必须具有相同的类型。"

#: ../../LangRef.rst:5853
msgid "The value produced is the floating point product of the two operands. This instruction can also take any number of :ref:`fast-math flags <fastmath>`, which are optimization hints to enable otherwise unsafe floating point optimizations:"
msgstr "产生的值是两个操作数的浮点乘积。该指令也可以使用以下任意数量的：ref：`fast-math flags <fastmath>`，它们是优化提示，用于启用其他不安全的浮点优化："

#: ../../LangRef.rst:5866
msgid "'``udiv``' Instruction"
msgstr "'``udiv``'指令"

#: ../../LangRef.rst:5879
msgid "The '``udiv``' instruction returns the quotient of its two operands."
msgstr "'``udiv``'指令返回其两个操作数的商。"

#: ../../LangRef.rst:5884
msgid "The two arguments to the '``udiv``' instruction must be :ref:`integer <t_integer>` or :ref:`vector <t_vector>` of integer values. Both arguments must have identical types."
msgstr "'``udiv``'指令的两个参数必须是：ref：`integer <t_integer>`或：ref：`vector <t_vector>`的整数值。两个参数必须具有相同的类型。"

#: ../../LangRef.rst:5891
msgid "The value produced is the unsigned integer quotient of the two operands."
msgstr "产生的值是两个操作数的无符号整数商。"

#: ../../LangRef.rst:5893
msgid "Note that unsigned integer division and signed integer division are distinct operations; for signed integer division, use '``sdiv``'."
msgstr "注意，无符号整数除法和有符号整数除法是不同的操作;对于有符号整数除法，请使用'``sdiv``'。"

#: ../../LangRef.rst:5896
msgid "Division by zero leads to undefined behavior."
msgstr "除以零会导致未定义的行为。"

#: ../../LangRef.rst:5898
#, python-format
msgid "If the ``exact`` keyword is present, the result value of the ``udiv`` is a :ref:`poison value <poisonvalues>` if %op1 is not a multiple of %op2 (as such, \"((a udiv exact b) mul b) == a\")."
msgstr "如果存在``exact``关键字，则``udiv``的结果值为：ref：`poison value <poisonvalues>`如果%o p1不是%o p2的倍数（因此，\\ “（（完全确切的b）mul b）== a \\”）。"

#: ../../LangRef.rst:5910
msgid "'``sdiv``' Instruction"
msgstr "'`sdiv``'指令"

#: ../../LangRef.rst:5923
msgid "The '``sdiv``' instruction returns the quotient of its two operands."
msgstr "'``sdiv``'指令返回其两个操作数的商。"

#: ../../LangRef.rst:5928
msgid "The two arguments to the '``sdiv``' instruction must be :ref:`integer <t_integer>` or :ref:`vector <t_vector>` of integer values. Both arguments must have identical types."
msgstr "'`sdiv``'指令的两个参数必须是：ref：`integer <t_integer>`或：ref：`vector <t_vector>`的整数值。两个参数必须具有相同的类型。"

#: ../../LangRef.rst:5935
msgid "The value produced is the signed integer quotient of the two operands rounded towards zero."
msgstr "产生的值是两个操作数的符号整数商，舍入为零。"

#: ../../LangRef.rst:5938
msgid "Note that signed integer division and unsigned integer division are distinct operations; for unsigned integer division, use '``udiv``'."
msgstr "注意，有符号整数除法和无符号整数除法是不同的操作;对于无符号整数除法，请使用'``udiv``'。"

#: ../../LangRef.rst:5941
msgid "Division by zero leads to undefined behavior. Overflow also leads to undefined behavior; this is a rare case, but can occur, for example, by doing a 32-bit division of -2147483648 by -1."
msgstr "除以零会导致未定义的行为。溢出也会导致不确定的行为;这是一种罕见的情况，但可能会发生，例如，通过-1进行-2147483648的32位除法。"

#: ../../LangRef.rst:5945
msgid "If the ``exact`` keyword is present, the result value of the ``sdiv`` is a :ref:`poison value <poisonvalues>` if the result would be rounded."
msgstr "如果存在``exact``关键字，则``sdiv``的结果值为：ref：`poison value <poisonvalues>`如果结果将被舍入。"

#: ../../LangRef.rst:5958
msgid "'``fdiv``' Instruction"
msgstr "'``fdiv``'指令"

#: ../../LangRef.rst:5970
msgid "The '``fdiv``' instruction returns the quotient of its two operands."
msgstr "'``fdiv``'指令返回其两个操作数的商。"

#: ../../LangRef.rst:5975
msgid "The two arguments to the '``fdiv``' instruction must be :ref:`floating point <t_floating>` or :ref:`vector <t_vector>` of floating point values. Both arguments must have identical types."
msgstr "'```fdiv``'指令的两个参数必须是：ref：浮点值的浮点数<t_floating>`或：ref：`vector <t_vector>`。两个参数必须具有相同的类型。"

#: ../../LangRef.rst:5982
msgid "The value produced is the floating point quotient of the two operands. This instruction can also take any number of :ref:`fast-math flags <fastmath>`, which are optimization hints to enable otherwise unsafe floating point optimizations:"
msgstr "产生的值是两个操作数的浮点商。该指令也可以使用以下任意数量的：ref：`fast-math flags <fastmath>`，它们是优化提示，用于启用其他不安全的浮点优化："

#: ../../LangRef.rst:5995
msgid "'``urem``' Instruction"
msgstr "'''urem``'指示"

#: ../../LangRef.rst:6007
msgid "The '``urem``' instruction returns the remainder from the unsigned division of its two arguments."
msgstr "'`'urem``'指令返回其两个参数的无符号除法的余数。"

#: ../../LangRef.rst:6013
msgid "The two arguments to the '``urem``' instruction must be :ref:`integer <t_integer>` or :ref:`vector <t_vector>` of integer values. Both arguments must have identical types."
msgstr "'`'urem``'指令的两个参数必须是：ref：`integer <t_integer>`或：ref：`vector <t_vector>`的整数值。两个参数必须具有相同的类型。"

#: ../../LangRef.rst:6020
msgid "This instruction returns the unsigned integer *remainder* of a division. This instruction always performs an unsigned division to get the remainder."
msgstr "该指令返回除法的无符号整数*余数*。该指令总是执行无符号除法以获得余数。"

#: ../../LangRef.rst:6024
msgid "Note that unsigned integer remainder and signed integer remainder are distinct operations; for signed integer remainder, use '``srem``'."
msgstr "注意，无符号整数余数和有符号整数余数是不同的操作;对于有符号整数余数，请使用'``srem``'。"

#: ../../LangRef.rst:6027
msgid "Taking the remainder of a division by zero leads to undefined behavior."
msgstr "将除数的余数除以零会导致未定义的行为。"

#: ../../LangRef.rst:6037
msgid "'``srem``' Instruction"
msgstr "''srem``'指示"

#: ../../LangRef.rst:6049
msgid "The '``srem``' instruction returns the remainder from the signed division of its two operands. This instruction can also take :ref:`vector <t_vector>` versions of the values in which case the elements must be integers."
msgstr "'`srem``'指令返回其两个操作数的有符号除法的余数。该指令还可以采用：ref：`vector <t_vector>`这些值的版本，在这种情况下，元素必须是整数。"

#: ../../LangRef.rst:6057
msgid "The two arguments to the '``srem``' instruction must be :ref:`integer <t_integer>` or :ref:`vector <t_vector>` of integer values. Both arguments must have identical types."
msgstr "'`srem``'指令的两个参数必须是：ref：`integer <t_integer>`或：ref：`vector <t_vector>`的整数值。两个参数必须具有相同的类型。"

#: ../../LangRef.rst:6064
msgid "This instruction returns the *remainder* of a division (where the result is either zero or has the same sign as the dividend, ``op1``), not the *modulo* operator (where the result is either zero or has the same sign as the divisor, ``op2``) of a value. For more information about the difference, see `The Math Forum <http://mathforum.org/dr.math/problems/anne.4.28.99.html>`_. For a table of how this is implemented in various languages, please see `Wikipedia: modulo operation <http://en.wikipedia.org/wiki/Modulo_operation>`_."
msgstr "该指令返回除法的*余数*（其中结果为零或与被除数相同的符号，``op1``），而不是* modulo *运算符（其中结果为零或具有相同的结果）签署一个值的除数，``op2``）。有关差异的更多信息，请参阅“数学论坛”<http://mathforum.org/dr.math/problems/anne.4.28.99.html>`_。有关如何以各种语言实现此功能的表格，请参阅“Wikipedia：modulo operation <http://en.wikipedia.org/wiki/Modulo_operation>`_。"

#: ../../LangRef.rst:6074
msgid "Note that signed integer remainder and unsigned integer remainder are distinct operations; for unsigned integer remainder, use '``urem``'."
msgstr "注意，有符号整数余数和无符号整数余数是不同的操作;对于无符号整数余数，请使用'``urem``'。"

#: ../../LangRef.rst:6077
msgid "Taking the remainder of a division by zero leads to undefined behavior. Overflow also leads to undefined behavior; this is a rare case, but can occur, for example, by taking the remainder of a 32-bit division of -2147483648 by -1. (The remainder doesn't actually overflow, but this rule lets srem be implemented using instructions that return both the result of the division and the remainder.)"
msgstr "将除数的余数除以零会导致未定义的行为。溢出也会导致不确定的行为;这是一种罕见的情况，但可能会发生，例如，将32位除法的余数-2147483648除以-1。 （其余部分实际上并没有溢出，但是这条规则允许使用返回除法结果和余数的指令来实现srem。）"

#: ../../LangRef.rst:6094
msgid "'``frem``' Instruction"
msgstr "'``frem``'指令"

#: ../../LangRef.rst:6106
msgid "The '``frem``' instruction returns the remainder from the division of its two operands."
msgstr "'``frem``'指令从两个操作数的除法中返回余数。"

#: ../../LangRef.rst:6112
msgid "The two arguments to the '``frem``' instruction must be :ref:`floating point <t_floating>` or :ref:`vector <t_vector>` of floating point values. Both arguments must have identical types."
msgstr "'``frem``'指令的两个参数必须是：ref：`浮点<t_floating>`或：ref：`vector <t_vector>`浮点值。两个参数必须具有相同的类型。"

#: ../../LangRef.rst:6119
msgid "This instruction returns the *remainder* of a division. The remainder has the same sign as the dividend. This instruction can also take any number of :ref:`fast-math flags <fastmath>`, which are optimization hints to enable otherwise unsafe floating point optimizations:"
msgstr "该指令返回除法的*余数*。其余部分与股息具有相同的符号。该指令也可以使用以下任意数量的：ref：`fast-math flags <fastmath>`，它们是优化提示，用于启用其他不安全的浮点优化："

#: ../../LangRef.rst:6134
msgid "Bitwise Binary Operations"
msgstr "按位二进制运算"

#: ../../LangRef.rst:6136
msgid "Bitwise binary operators are used to do various forms of bit-twiddling in a program. They are generally very efficient instructions and can commonly be strength reduced from other instructions. They require two operands of the same type, execute an operation on them, and produce a single value. The resulting value is the same type as its operands."
msgstr "按位二进制运算符用于在程序中进行各种形式的bit-twiddling。它们通常是非常有效的指令，通常可以从其他指令中减少强度。它们需要两个相同类型的操作数，对它们执行操作，并生成单个值。结果值与其操作数的类型相同。"

#: ../../LangRef.rst:6143
msgid "'``shl``' Instruction"
msgstr "'``shl``'指令"

#: ../../LangRef.rst:6158
msgid "The '``shl``' instruction returns the first operand shifted to the left a specified number of bits."
msgstr "'``shl``'指令返回第一个操作数，向左移动指定的位数。"

#: ../../LangRef.rst:6164
msgid "Both arguments to the '``shl``' instruction must be the same :ref:`integer <t_integer>` or :ref:`vector <t_vector>` of integer type. '``op2``' is treated as an unsigned value."
msgstr "'``shl``'指令的两个参数必须相同：ref：`integer <t_integer>`或：ref：`vector <t_vector>`整数类型。 '``op2``'被视为无符号值。"

#: ../../LangRef.rst:6171
msgid "The value produced is ``op1`` \\* 2\\ :sup:`op2` mod 2\\ :sup:`n`, where ``n`` is the width of the result. If ``op2`` is (statically or dynamically) equal to or larger than the number of bits in ``op1``, the result is undefined. If the arguments are vectors, each vector element of ``op1`` is shifted by the corresponding shift amount in ``op2``."
msgstr "产生的值是``op1`` \\ * 2 \\：sup：`op2` mod 2 \\：sup：`n`，其中``n``是结果的宽度。如果``op2``（静态或动态）等于或大于``op1``中的位数，则结果是未定义的。如果参数是向量，则“op1”的每个向量元素在“op2”中移位相应的移位量。"

#: ../../LangRef.rst:6178
#, python-format
msgid "If the ``nuw`` keyword is present, then the shift produces a :ref:`poison value <poisonvalues>` if it shifts out any non-zero bits. If the ``nsw`` keyword is present, then the shift produces a :ref:`poison value <poisonvalues>` if it shifts out any bits that disagree with the resultant sign bit. As such, NUW/NSW have the same semantics as they would if the shift were expressed as a mul instruction with the same nsw/nuw bits in (mul %op1, (shl 1, %op2))."
msgstr "如果存在``nuw``关键字，那么如果移出任何非零位，则移位产生：ref：`poison value <poisonvalues>`。如果存在``nsw``关键字，那么移位产生一个：ref：`poison value <poisonvalues>`如果它移出任何不同意结果符号位的位。因此，NUW / NSW具有与将移位表示为具有相同nsw / nuw位的mul指令时相同的语义（mul %o p1，（shl 1， %o p2））。"

#: ../../LangRef.rst:6198
msgid "'``lshr``' Instruction"
msgstr "'``lshr``'指令"

#: ../../LangRef.rst:6211
msgid "The '``lshr``' instruction (logical shift right) returns the first operand shifted to the right a specified number of bits with zero fill."
msgstr "'`lshr``'指令（逻辑右移）返回第一个操作数，向右移动指定的位数，填充为零。"

#: ../../LangRef.rst:6217
msgid "Both arguments to the '``lshr``' instruction must be the same :ref:`integer <t_integer>` or :ref:`vector <t_vector>` of integer type. '``op2``' is treated as an unsigned value."
msgstr "'`lshr``'指令的两个参数必须相同：ref：`integer <t_integer>`或：ref：`vector <t_vector>`整数类型。 '``op2``'被视为无符号值。"

#: ../../LangRef.rst:6224
msgid "This instruction always performs a logical shift right operation. The most significant bits of the result will be filled with zero bits after the shift. If ``op2`` is (statically or dynamically) equal to or larger than the number of bits in ``op1``, the result is undefined. If the arguments are vectors, each vector element of ``op1`` is shifted by the corresponding shift amount in ``op2``."
msgstr "该指令始终执行逻辑右移操作。移位后，结果的最高有效位将填充零位。如果``op2``（静态或动态）等于或大于``op1``中的位数，则结果是未定义的。如果参数是向量，则“op1”的每个向量元素在“op2”中移位相应的移位量。"

#: ../../LangRef.rst:6231
msgid "If the ``exact`` keyword is present, the result value of the ``lshr`` is a :ref:`poison value <poisonvalues>` if any of the bits shifted out are non-zero."
msgstr "如果存在``exact``关键字，那么``lshr``的结果值是：ref：`poison value <poisonvalues>`如果移出的任何位都是非零的。"

#: ../../LangRef.rst:6248
msgid "'``ashr``' Instruction"
msgstr "'``ashr``'指令"

#: ../../LangRef.rst:6261
msgid "The '``ashr``' instruction (arithmetic shift right) returns the first operand shifted to the right a specified number of bits with sign extension."
msgstr "'`ashr``'指令（算术右移）返回第一个操作数，右移一个指定位数的符号扩展名。"

#: ../../LangRef.rst:6268
msgid "Both arguments to the '``ashr``' instruction must be the same :ref:`integer <t_integer>` or :ref:`vector <t_vector>` of integer type. '``op2``' is treated as an unsigned value."
msgstr "'`ashr``'指令的两个参数必须相同：ref：`integer <t_integer>`或：ref：`vector <t_vector>`整数类型。 '``op2``'被视为无符号值。"

#: ../../LangRef.rst:6275
msgid "This instruction always performs an arithmetic shift right operation, The most significant bits of the result will be filled with the sign bit of ``op1``. If ``op2`` is (statically or dynamically) equal to or larger than the number of bits in ``op1``, the result is undefined. If the arguments are vectors, each vector element of ``op1`` is shifted by the corresponding shift amount in ``op2``."
msgstr "该指令总是执行算术右移操作，结果的最高有效位将用“op1`”的符号位填充。如果``op2``（静态或动态）等于或大于``op1``中的位数，则结果是未定义的。如果参数是向量，则“op1”的每个向量元素在“op2”中移位相应的移位量。"

#: ../../LangRef.rst:6282
msgid "If the ``exact`` keyword is present, the result value of the ``ashr`` is a :ref:`poison value <poisonvalues>` if any of the bits shifted out are non-zero."
msgstr "如果存在``exact``关键字，那么``ashr``的结果值是：ref：`poison value <poisonvalues>`如果任何移出的位都是非零的。"

#: ../../LangRef.rst:6299
msgid "'``and``' Instruction"
msgstr "'``和``'指令"

#: ../../LangRef.rst:6311
msgid "The '``and``' instruction returns the bitwise logical and of its two operands."
msgstr "'``和``'指令返回按位逻辑及其两个操作数。"

#: ../../LangRef.rst:6317
msgid "The two arguments to the '``and``' instruction must be :ref:`integer <t_integer>` or :ref:`vector <t_vector>` of integer values. Both arguments must have identical types."
msgstr "'``和``'指令的两个参数必须是：ref：`integer <t_integer>`或：ref：`vector <t_vector>`的整数值。两个参数必须具有相同的类型。"

#: ../../LangRef.rst:6324
msgid "The truth table used for the '``and``' instruction is:"
msgstr "用于'``和``'指令的真值表是："

#: ../../LangRef.rst:6327 ../../LangRef.rst:6376 ../../LangRef.rst:6426
msgid "In0"
msgstr "IN0"

#: ../../LangRef.rst:6327 ../../LangRef.rst:6376 ../../LangRef.rst:6426
msgid "In1"
msgstr "IN1"

#: ../../LangRef.rst:6327 ../../LangRef.rst:6376 ../../LangRef.rst:6426
msgid "Out"
msgstr "退房"

#: ../../LangRef.rst:6329 ../../LangRef.rst:6331 ../../LangRef.rst:6333 ../../LangRef.rst:6378 ../../LangRef.rst:6380 ../../LangRef.rst:6382 ../../LangRef.rst:6428 ../../LangRef.rst:6430 ../../LangRef.rst:6432 ../../LangRef.rst:6434
msgid "0"
msgstr "0"

#: ../../LangRef.rst:6348
msgid "'``or``' Instruction"
msgstr "'``or``' 指令"

#: ../../LangRef.rst:6360
msgid "The '``or``' instruction returns the bitwise logical inclusive or of its two operands."
msgstr "'``or``' 指令返回按位逻辑包含或其两个操作数。"

#: ../../LangRef.rst:6366
msgid "The two arguments to the '``or``' instruction must be :ref:`integer <t_integer>` or :ref:`vector <t_vector>` of integer values. Both arguments must have identical types."
msgstr "'``或``''指令的两个参数必须是：ref：`integer <t_integer>`或：ref：`vector <t_vector>`的整数值。两个参数必须具有相同的类型。"

#: ../../LangRef.rst:6373
msgid "The truth table used for the '``or``' instruction is:"
msgstr "用于'``或``'指令的真值表是："

#: ../../LangRef.rst:6397
msgid "'``xor``' Instruction"
msgstr "'```xor``'指令"

#: ../../LangRef.rst:6409
msgid "The '``xor``' instruction returns the bitwise logical exclusive or of its two operands. The ``xor`` is used to implement the \"one's complement\" operation, which is the \"~\" operator in C."
msgstr "'``xor``'指令返回按位逻辑异或其两个操作数。 ``xor``用于实现\\“one's complement \\”操作，这是C中的\\“〜\\”运算符。"

#: ../../LangRef.rst:6416
msgid "The two arguments to the '``xor``' instruction must be :ref:`integer <t_integer>` or :ref:`vector <t_vector>` of integer values. Both arguments must have identical types."
msgstr "'``xor``'指令的两个参数必须是：ref：`integer <t_integer>`或：ref：`vector <t_vector>`的整数值。两个参数必须具有相同的类型。"

#: ../../LangRef.rst:6423
msgid "The truth table used for the '``xor``' instruction is:"
msgstr "用于'``xor``'指令的真值表是："

#: ../../LangRef.rst:6448
msgid "Vector Operations"
msgstr "矢量运算"

#: ../../LangRef.rst:6450
msgid "LLVM supports several instructions to represent vector operations in a target-independent manner. These instructions cover the element-access and vector-specific operations needed to process vectors effectively. While LLVM does directly support these vector operations, many sophisticated algorithms will want to use target-specific intrinsics to take full advantage of a specific target."
msgstr "LLVM支持几种以与目标无关的方式表示向量操作的指令。这些指令涵盖了有效处理向量所需的元素访问和向量特定操作。虽然LLVM直接支持这些向量操作，但许多复杂的算法都希望使用特定于目标的内在函数来充分利用特定目标。"

#: ../../LangRef.rst:6460
msgid "'``extractelement``' Instruction"
msgstr "'``extractelement``'指令"

#: ../../LangRef.rst:6472
msgid "The '``extractelement``' instruction extracts a single scalar element from a vector at a specified index."
msgstr "'``extractelement``'指令从指定索引处的向量中提取单个标量元素。"

#: ../../LangRef.rst:6478
msgid "The first operand of an '``extractelement``' instruction is a value of :ref:`vector <t_vector>` type. The second operand is an index indicating the position from which to extract the element. The index may be a variable of any integer type."
msgstr "'``extractelement``'指令的第一个操作数是一个值：ref：`vector <t_vector>`type。第二个操作数是指示从中提取元素的位置的索引。索引可以是任何整数类型的变量。"

#: ../../LangRef.rst:6486
msgid "The result is a scalar of the same type as the element type of ``val``. Its value is the value at position ``idx`` of ``val``. If ``idx`` exceeds the length of ``val``, the results are undefined."
msgstr "结果是与``val``的元素类型相同类型的标量。它的值是``val``的位置``idx``的值。如果``idx``超过``val``的长度，结果是不确定的。"

#: ../../LangRef.rst:6500
msgid "'``insertelement``' Instruction"
msgstr "'``insertelement``'指令"

#: ../../LangRef.rst:6512
msgid "The '``insertelement``' instruction inserts a scalar element into a vector at a specified index."
msgstr "'``insertelement``'指令将标量元素插入到指定索引处的向量中。"

#: ../../LangRef.rst:6518
msgid "The first operand of an '``insertelement``' instruction is a value of :ref:`vector <t_vector>` type. The second operand is a scalar value whose type must equal the element type of the first operand. The third operand is an index indicating the position at which to insert the value. The index may be a variable of any integer type."
msgstr "'``insertelement``'指令的第一个操作数是一个值：ref：`vector <t_vector>`type。第二个操作数是标量值，其类型必须等于第一个操作数的元素类型。第三个操作数是指示插入值的位置的索引。索引可以是任何整数类型的变量。"

#: ../../LangRef.rst:6527
msgid "The result is a vector of the same type as ``val``. Its element values are those of ``val`` except at position ``idx``, where it gets the value ``elt``. If ``idx`` exceeds the length of ``val``, the results are undefined."
msgstr "结果是一个与``val``相同类型的向量。它的元素值是``val``的值，除了位置``idx``，它获取值``elt``。如果``idx``超过``val``的长度，结果是不确定的。"

#: ../../LangRef.rst:6542
msgid "'``shufflevector``' Instruction"
msgstr "'``shufflevector``'指令"

#: ../../LangRef.rst:6554
msgid "The '``shufflevector``' instruction constructs a permutation of elements from two input vectors, returning a vector with the same element type as the input and length that is the same as the shuffle mask."
msgstr "'``shufflevector``'指令从两个输入向量构造元素的排列，返回一个与输入相同的元素类型的向量和与shuffle mask相同的长度。"

#: ../../LangRef.rst:6561
msgid "The first two operands of a '``shufflevector``' instruction are vectors with the same type. The third argument is a shuffle mask whose element type is always 'i32'. The result of the instruction is a vector whose length is the same as the shuffle mask and whose element type is the same as the element type of the first two operands."
msgstr "'`shufflevector``'指令的前两个操作数是具有相同类型的向量。第三个参数是一个shuffle mask，其元素类型始终为'i32'。该指令的结果是一个向量，其长度与shuffle掩码相同，其元素类型与前两个操作数的元素类型相同。"

#: ../../LangRef.rst:6567
msgid "The shuffle mask operand is required to be a constant vector with either constant integer or undef values."
msgstr "shuffle掩码操作数必须是具有常量整数或undef值的常量向量。"

#: ../../LangRef.rst:6573
msgid "The elements of the two input vectors are numbered from left to right across both of the vectors. The shuffle mask operand specifies, for each element of the result vector, which element of the two input vectors the result element gets. The element selector may be undef (meaning \"don't care\") and the second operand may be undef if performing a shuffle from only one vector."
msgstr "两个输入矢量的元素在两个矢量上从左到右编号。对于结果向量的每个元素，shuffle mask操作数指定结果元素获得的两个输入向量中的哪个元素。元素选择器可以是undef（意思是“不关心”），并且如果仅从一个向量执行shuffle，则第二操作数可以是undef。"

#: ../../LangRef.rst:6595
msgid "Aggregate Operations"
msgstr "聚合操作"

#: ../../LangRef.rst:6597
msgid "LLVM supports several instructions for working with :ref:`aggregate <t_aggregate>` values."
msgstr "LLVM支持以下几个使用指令：ref：`aggregate <t_aggregate>`值。"

#: ../../LangRef.rst:6603
msgid "'``extractvalue``' Instruction"
msgstr "'``extractvalue``'指令"

#: ../../LangRef.rst:6615
msgid "The '``extractvalue``' instruction extracts the value of a member field from an :ref:`aggregate <t_aggregate>` value."
msgstr "'`extractvalue``'指令从：ref：`aggregate <t_aggregate>`值中提取成员字段的值。"

#: ../../LangRef.rst:6621
msgid "The first operand of an '``extractvalue``' instruction is a value of :ref:`struct <t_struct>` or :ref:`array <t_array>` type. The other operands are constant indices to specify which value to extract in a similar manner as indices in a '``getelementptr``' instruction."
msgstr "'`extractvalue``'指令的第一个操作数是一个值：ref：`struct <t_struct>`或：ref：`array <t_array>`type。其他操作数是常量索引，用于指定以与“getelementptr``”指令中的索引类似的方式提取哪个值。"

#: ../../LangRef.rst:6626
msgid "The major differences to ``getelementptr`` indexing are:"
msgstr "与``getelementptr``索引的主要区别是："

#: ../../LangRef.rst:6628
msgid "Since the value being indexed is not a pointer, the first index is omitted and assumed to be zero."
msgstr "由于被索引的值不是指针，因此省略第一个索引并假设为零。"

#: ../../LangRef.rst:6630
msgid "At least one index must be specified."
msgstr "必须至少指定一个索引。"

#: ../../LangRef.rst:6631
msgid "Not only struct indices but also array indices must be in bounds."
msgstr "不仅结构索引而且数组索引必须在边界内。"

#: ../../LangRef.rst:6636
msgid "The result is the value at the position in the aggregate specified by the index operands."
msgstr "结果是索引操作数指定的聚合位置的值。"

#: ../../LangRef.rst:6649
msgid "'``insertvalue``' Instruction"
msgstr "'``insertvalue``'指令"

#: ../../LangRef.rst:6661
msgid "The '``insertvalue``' instruction inserts a value into a member field in an :ref:`aggregate <t_aggregate>` value."
msgstr "'``insertvalue``'指令在一个成员字段中插入一个值：ref：`aggregate <t_aggregate>`值。"

#: ../../LangRef.rst:6667
msgid "The first operand of an '``insertvalue``' instruction is a value of :ref:`struct <t_struct>` or :ref:`array <t_array>` type. The second operand is a first-class value to insert. The following operands are constant indices indicating the position at which to insert the value in a similar manner as indices in a '``extractvalue``' instruction. The value to insert must have the same type as the value identified by the indices."
msgstr "'``insertvalue``'指令的第一个操作数是一个值：ref：`struct <t_struct>`或：ref：`array <t_array>`type。第二个操作数是要插入的第一类值。以下操作数是常量索引，表示以与“extractvalue``”指令中的索引类似的方式插入值的位置。要插入的值必须与索引标识的值具有相同的类型。"

#: ../../LangRef.rst:6678
msgid "The result is an aggregate of the same type as ``val``. Its value is that of ``val`` except that the value at the position specified by the indices is that of ``elt``."
msgstr "结果是与``val``相同类型的聚合。它的值是``val``的值，除了索引指定的位置的值是``elt``的值。"

#: ../../LangRef.rst:6694
msgid "Memory Access and Addressing Operations"
msgstr "内存访问和寻址操作"

#: ../../LangRef.rst:6696
msgid "A key design point of an SSA-based representation is how it represents memory. In LLVM, no memory locations are in SSA form, which makes things very simple. This section describes how to read, write, and allocate memory in LLVM."
msgstr "基于SSA的表示的关键设计点是它如何表示内存。在LLVM中，没有内存位置采用SSA格式，这使得事情变得非常简单。本节介绍如何在LLVM中读取，写入和分配内存。"

#: ../../LangRef.rst:6704
msgid "'``alloca``' Instruction"
msgstr "'``alloca``'指令"

#: ../../LangRef.rst:6716
msgid "The '``alloca``' instruction allocates memory on the stack frame of the currently executing function, to be automatically released when this function returns to its caller. The object is always allocated in the generic address space (address space zero)."
msgstr "'``alloca``'指令在当前正在执行的函数的堆栈帧上分配内存，当该函数返回其调用者时自动释放。始终在通用地址空间（地址空间为零）中分配对象。"

#: ../../LangRef.rst:6724
msgid ""
"The '``alloca``' instruction allocates ``sizeof(<type>)*NumElements`` bytes of memory on the runtime stack, returning a pointer of the appropriate type to the program. If \"NumElements\" is specified, it is the number of elements allocated, otherwise \"NumElements\" is defaulted to be one. If a constant alignment is specified, the value result of the allocation is guaranteed to be aligned to at least that boundary. The alignment may not be greater than ``1 << 29``. If not specified, or if zero, the target can choose to align the allocation on any convenient boundary "
"compatible with the type."
msgstr "'``alloca``'指令在运行时堆栈上分配``sizeof（<type>）* NumElements``字节的内存，向程序返回适当类型的指针。如果指定了“NumElements”，则它是分配的元素数，否则\\“NumElements \\”默认为1。如果指定了常量对齐，则保证分配的值结果至少与该边界对齐。对齐可能不会大于“1 << 29``。如果未指定，或者如果为零，则目标可以选择在与该类型兼容的任何方便边界上对齐分配。"

#: ../../LangRef.rst:6734
msgid "'``type``' may be any sized type."
msgstr "'``type``'可以是任何大小的类型。"

#: ../../LangRef.rst:6739
msgid ""
"Memory is allocated; a pointer is returned. The operation is undefined if there is insufficient stack space for the allocation. '``alloca``'d memory is automatically released when the function returns. The '``alloca``' instruction is commonly used to represent automatic variables that must have an address available. When the function returns (either with the ``ret`` or ``resume`` instructions), the memory is reclaimed. Allocating zero bytes is legal, but the result is undefined. The order in which memory is allocated (ie., which way the stack grows) is not specified."
msgstr "内存已分配;返回一个指针。如果分配的堆栈空间不足，则操作未定义。当函数返回时，```alloca``'d内存会自动释放。 '`alloca``'指令通常用于表示必须具有可用地址的自动变量。当函数返回时（使用``ret``或``resume``指令），内存被回收。分配零字节是合法的，但结果是未定义的。未指定分配内存的顺序（即，堆栈增长的方式）。"

#: ../../LangRef.rst:6762
msgid "'``load``' Instruction"
msgstr "'``load``'指令"

#: ../../LangRef.rst:6778
msgid "The '``load``' instruction is used to read from memory."
msgstr "'``load``'指令用于从内存中读取。"

#: ../../LangRef.rst:6783
msgid "The argument to the ``load`` instruction specifies the memory address from which to load. The type specified must be a :ref:`first class <t_firstclass>` type. If the ``load`` is marked as ``volatile``, then the optimizer is not allowed to modify the number or order of execution of this ``load`` with other :ref:`volatile operations <volatile>`."
msgstr "``load``指令的参数指定要加载的内存地址。指定的类型必须是：ref：`first class <t_firstclass>`type。如果``load``被标记为``volatile``，那么优化器不允许用其他命令修改这个``load``的执行次数或顺序：ref：`volatile operations <volatile>`。"

#: ../../LangRef.rst:6790
msgid ""
"If the ``load`` is marked as ``atomic``, it takes an extra :ref:`ordering <ordering>` and optional ``singlethread`` argument. The ``release`` and ``acq_rel`` orderings are not valid on ``load`` instructions. Atomic loads produce :ref:`defined <memmodel>` results when they may see multiple atomic stores. The type of the pointee must be an integer, pointer, or floating-point type whose bit width is a power of two greater than or equal to eight and less than or equal to a target-specific size limit.  ``align`` must be explicitly specified on atomic loads, and the load "
"has undefined behavior if the alignment is not set to a value which is at least the size in bytes of the pointee. ``!nontemporal`` does not have any defined semantics for atomic loads."
msgstr "如果``load``被标记为``atomic``，则需要额外的：ref：`ordering <ordering>`和可选的``singlethread``参数。 ``release``和``acq_rel``排序在``load``指令上无效。原子加载产生：ref：`defined <memmodel>`当他们看到多个原子商店时会产生结果。指针对象的类型必须是整数，指针或浮点类型，其位宽是2的幂，大于或等于8且小于或等于特定于目标的大小限制。必须在原子载荷上显式指定``align``，如果对齐没有设置为至少是指针对象的字节大小的值，则加载具有未定义的行为。 ``！nontemporal``对原子载荷没有任何定义的语义。"

#: ../../LangRef.rst:6801 ../../LangRef.rst:6925
msgid "The optional constant ``align`` argument specifies the alignment of the operation (that is, the alignment of the memory address). A value of 0 or an omitted ``align`` argument means that the operation has the ABI alignment for the target. It is the responsibility of the code emitter to ensure that the alignment information is correct. Overestimating the alignment results in undefined behavior. Underestimating the alignment may produce less efficient code. An alignment of 1 is always safe. The maximum possible alignment is ``1 << 29``."
msgstr "可选的常量``align``参数指定操作的对齐方式（即内存地址的对齐方式）。值为0或省略的``align``参数表示该操作具有目标的ABI对齐方式。代码发射器负责确保对齐信息正确。过高估计对齐会导致未定义的行为。低估对齐可能会产生效率较低的代码。 1的对齐总是安全的。最大可能的对齐是“1 << 29``。"

#: ../../LangRef.rst:6810 ../../LangRef.rst:6934
msgid "The optional ``!nontemporal`` metadata must reference a single metadata name ``<index>`` corresponding to a metadata node with one ``i32`` entry of value 1. The existence of the ``!nontemporal`` metadata on the instruction tells the optimizer and code generator that this load is not expected to be reused in the cache. The code generator may select special instructions to save cache bandwidth, such as the ``MOVNT`` instruction on x86."
msgstr "可选的``！nontemporal``元数据必须引用与元数据节点对应的单个元数据名称``<index>``，其中一个``i32``条目值为1.存在``！nontemporal``元数据在指令上告诉优化器和代码生成器，预计不会在缓存中重用此负载。代码生成器可以选择特殊指令来保存缓存带宽，例如x86上的“MOVNT”指令。"

#: ../../LangRef.rst:6818
msgid "The optional ``!invariant.load`` metadata must reference a single metadata name ``<index>`` corresponding to a metadata node with no entries. The existence of the ``!invariant.load`` metadata on the instruction tells the optimizer and code generator that the address operand to this load points to memory which can be assumed unchanged. Being invariant does not imply that a location is dereferenceable, but it does imply that once the location is known dereferenceable its value is henceforth unchanging."
msgstr "可选的``！invariant.load``元数据必须引用与没有条目的元数据节点对应的单个元数据名称``<index>``。指令上存在``！invariant.load``元数据告诉优化器和代码生成器该负载的地址操作数指向可以假设不变的内存。不变性并不意味着某个位置是可解除引用的，但它确实意味着一旦知道该位置可解除引用，其价值就会变得不变。"

#: ../../LangRef.rst:6828
msgid "The optional ``!invariant.group`` metadata must reference a single metadata name"
msgstr "可选的``！invariant.group``元数据必须引用单个元数据名称"

#: ../../LangRef.rst:6828
msgid "``<index>`` corresponding to a metadata node. See ``invariant.group`` metadata."
msgstr "``<index>``对应于元数据节点。请参阅``invariant.group``元数据。"

#: ../../LangRef.rst:6830
msgid "The optional ``!nonnull`` metadata must reference a single metadata name ``<index>`` corresponding to a metadata node with no entries. The existence of the ``!nonnull`` metadata on the instruction tells the optimizer that the value loaded is known to never be null. This is analogous to the ``nonnull`` attribute on parameters and return values. This metadata can only be applied to loads of a pointer type."
msgstr "可选的``！nonnull``元数据必须引用与没有条目的元数据节点相对应的单个元数据名称``<index>``。指令上存在``！nonnull``元数据告诉优化器已知加载的值永远不会为空。这类似于参数和返回值的``nonnull``属性。此元数据只能应用于指针类型的加载。"

#: ../../LangRef.rst:6838
msgid "The optional ``!dereferenceable`` metadata must reference a single metadata name ``<deref_bytes_node>`` corresponding to a metadata node with one ``i64`` entry. The existence of the ``!dereferenceable`` metadata on the instruction tells the optimizer that the value loaded is known to be dereferenceable. The number of bytes known to be dereferenceable is specified by the integer value in the metadata node. This is analogous to the ''dereferenceable'' attribute on parameters and return values. This metadata can only be applied to loads of a pointer type."
msgstr "可选的``！dereferenceable``元数据必须引用与具有一个``i64``条目的元数据节点相对应的单个元数据名称``<deref_bytes_node>``。指令上存在``！dereferenceable``元数据告诉优化器已知加载的值是可解除引用的。已知可解除引用的字节数由元数据节点中的整数值指定。这类似于参数和返回值的''dereferenceable''属性。此元数据只能应用于指针类型的加载。"

#: ../../LangRef.rst:6847
msgid ""
"The optional ``!dereferenceable_or_null`` metadata must reference a single metadata name ``<deref_bytes_node>`` corresponding to a metadata node with one ``i64`` entry. The existence of the ``!dereferenceable_or_null`` metadata on the instruction tells the optimizer that the value loaded is known to be either dereferenceable or null. The number of bytes known to be dereferenceable is specified by the integer value in the metadata node. This is analogous to the ''dereferenceable_or_null'' attribute on parameters and return values. This metadata can only be applied to "
"loads of a pointer type."
msgstr "可选的``！dereferenceable_or_null``元数据必须引用与具有一个``i64``条目的元数据节点相对应的单个元数据名称``<deref_bytes_node>``。指令上存在``！dereferenceable_or_null``元数据告诉优化器已知加载的值可解除引用或为空。已知可解除引用的字节数由元数据节点中的整数值指定。这类似于参数和返回值的''dereferenceable_or_null''属性。此元数据只能应用于指针类型的加载。"

#: ../../LangRef.rst:6857
msgid "The optional ``!align`` metadata must reference a single metadata name ``<align_node>`` corresponding to a metadata node with one ``i64`` entry. The existence of the ``!align`` metadata on the instruction tells the optimizer that the value loaded is known to be aligned to a boundary specified by the integer value in the metadata node. The alignment must be a power of 2. This is analogous to the ''align'' attribute on parameters and return values. This metadata can only be applied to loads of a pointer type."
msgstr "可选的``！align``元数据必须引用与元数据节点对应的单个元数据名称``<align_node>``和一个``i64``条目。指令上存在``！align``元数据告诉优化器已知加载的值与元数据节点中的整数值指定的边界对齐。对齐必须是2的幂。这类似于参数和返回值的''align''属性。此元数据只能应用于指针类型的加载。"

#: ../../LangRef.rst:6868
msgid "The location of memory pointed to is loaded. If the value being loaded is of scalar type then the number of bytes read does not exceed the minimum number of bytes needed to hold all bits of the type. For example, loading an ``i24`` reads at most three bytes. When loading a value of a type like ``i20`` with a size that is not an integral number of bytes, the result is undefined if the value was not originally written using a store of the same type."
msgstr "指向的内存位置已加载。如果加载的值是标量类型，那么读取的字节数不会超过保存该类型所有位所需的最小字节数。例如，加载``i24``最多读取三个字节。当加载类型为“i20”的类型的值，其大小不是整数字节时，如果该值最初不是使用相同类型的存储写入的，则结果是未定义的。"

#: ../../LangRef.rst:6888
msgid "'``store``' Instruction"
msgstr "'``store``'指令"

#: ../../LangRef.rst:6901
msgid "The '``store``' instruction is used to write to memory."
msgstr "'`store``'指令用于写入内存。"

#: ../../LangRef.rst:6906
msgid "There are two arguments to the ``store`` instruction: a value to store and an address at which to store it. The type of the ``<pointer>`` operand must be a pointer to the :ref:`first class <t_firstclass>` type of the ``<value>`` operand. If the ``store`` is marked as ``volatile``, then the optimizer is not allowed to modify the number or order of execution of this ``store`` with other :ref:`volatile operations <volatile>`."
msgstr "``store``指令有两个参数：要存储的值和存储它的地址。 ``<pointer>``操作数的类型必须是指向``<value>``操作数的`ref：`first class <t_firstclass>`类型的指针。如果``store``被标记为``volatile``，那么优化器不允许用其他命令修改这个``store``的执行次数或顺序：ref：`volatile operations <volatile>`。"

#: ../../LangRef.rst:6914
msgid ""
"If the ``store`` is marked as ``atomic``, it takes an extra :ref:`ordering <ordering>` and optional ``singlethread`` argument. The ``acquire`` and ``acq_rel`` orderings aren't valid on ``store`` instructions. Atomic loads produce :ref:`defined <memmodel>` results when they may see multiple atomic stores. The type of the pointee must be an integer, pointer, or floating-point type whose bit width is a power of two greater than or equal to eight and less than or equal to a target-specific size limit.  ``align`` must be explicitly specified on atomic stores, and the store "
"has undefined behavior if the alignment is not set to a value which is at least the size in bytes of the pointee. ``!nontemporal`` does not have any defined semantics for atomic stores."
msgstr "如果``store``被标记为``atomic``，则需要额外的：ref：`ordering <ordering>`和可选的``singlethread``参数。 ``acquire``和``acq_rel``排序在``store``指令上无效。原子加载产生：ref：`defined <memmodel>`当他们看到多个原子商店时会产生结果。指针对象的类型必须是整数，指针或浮点类型，其位宽是2的幂，大于或等于8且小于或等于特定于目标的大小限制。必须在原子存储上显式指定``align``，并且如果对齐未设置为至少是指针对象的字节大小的值，则存储具有未定义的行为。 ``！nontemporal``对原子商店没有任何定义的语义。"

#: ../../LangRef.rst:6942
msgid "The optional ``!invariant.group`` metadata must reference a single metadata name ``<index>``. See ``invariant.group`` metadata."
msgstr "可选的``！invariant.group``元数据必须引用单个元数据名称``<index>``。请参阅``invariant.group``元数据。"

#: ../../LangRef.rst:6948
msgid "The contents of memory are updated to contain ``<value>`` at the location specified by the ``<pointer>`` operand. If ``<value>`` is of scalar type then the number of bytes written does not exceed the minimum number of bytes needed to hold all bits of the type. For example, storing an ``i24`` writes at most three bytes. When writing a value of a type like ``i20`` with a size that is not an integral number of bytes, it is unspecified what happens to the extra bits that do not belong to the type, but they will typically be overwritten."
msgstr "内存的内容更新为在``<pointer>``操作数指定的位置包含``<value>``。如果``<value>``是标量类型，那么写入的字节数不会超过保存该类型所有位所需的最小字节数。例如，存储“i24”最多写入三个字节。当写一个像``i20``这样的类型的值，其大小不是整数个字节时，未指定不属于该类型的额外位会发生什么，但它们通常会被覆盖。"

#: ../../LangRef.rst:6969
msgid "'``fence``' Instruction"
msgstr "'``fence``'指令"

#: ../../LangRef.rst:6981
msgid "The '``fence``' instruction is used to introduce happens-before edges between operations."
msgstr "'``fence``'指令用于引入操作之前发生的边缘。"

#: ../../LangRef.rst:6987
msgid "'``fence``' instructions take an :ref:`ordering <ordering>` argument which defines what *synchronizes-with* edges they add. They can only be given ``acquire``, ``release``, ``acq_rel``, and ``seq_cst`` orderings."
msgstr "'``fence``'指令采用：ref：`ordering <ordering>`参数，用于定义与它们添加*同步的* *。它们只能被赋予``acquire``，``release``，``acq_rel``和``seq_cst``排序。"

#: ../../LangRef.rst:6994
msgid ""
"A fence A which has (at least) ``release`` ordering semantics *synchronizes with* a fence B with (at least) ``acquire`` ordering semantics if and only if there exist atomic operations X and Y, both operating on some atomic object M, such that A is sequenced before X, X modifies M (either directly or through some side effect of a sequence headed by X), Y is sequenced before B, and Y observes M. This provides a *happens-before* dependency between A and B. Rather than an explicit ``fence``, one (but not both) of the atomic operations X or Y might provide a ``release`` or "
"``acquire`` (resp.) ordering constraint and still *synchronize-with* the explicit ``fence`` and establish the *happens-before* edge."
msgstr "具有（至少）``release``排序语义*的围栏A与*围栏B同步（至少）``acquire``排序语义当且仅当存在原子操作X和Y时，两者都在运行一些原子对象M，使得A在X之前被排序，X被修改为M（直接或通过以X为首的序列的一些副作用），Y在B之前被排序，并且Y观察M.这提供了*发生在之前* A和B之间的依赖关系。而不是一个明确的``fence``，原子操作X或Y中的一个（但不是两个）可能提供一个``release``或``acquire``（resp。）排序约束并且仍然*与明确的``fence``同步 - 并建立* happen-before * edge。"

#: ../../LangRef.rst:7006
msgid "A ``fence`` which has ``seq_cst`` ordering, in addition to having both ``acquire`` and ``release`` semantics specified above, participates in the global program order of other ``seq_cst`` operations and/or fences."
msgstr "具有``seq_cst``排序的``fence``除了具有上面指定的``acquire``和``release``语义之外，还参与其他``seq_cst``操作的全局程序顺序和/或围栏。"

#: ../../LangRef.rst:7010
msgid "The optional \":ref:`singlethread <singlethread>`\" argument specifies that the fence only synchronizes with other fences in the same thread. (This is useful for interacting with signal handlers.)"
msgstr "可选的\\“：ref：`singlethread <singlethread>`\\”参数指定fence仅与同一线程中的其他fence同步。 （这对于与信号处理程序交互很有用。）"

#: ../../LangRef.rst:7025
msgid "'``cmpxchg``' Instruction"
msgstr "'``cmpxchg``'指令"

#: ../../LangRef.rst:7037
msgid "The '``cmpxchg``' instruction is used to atomically modify memory. It loads a value in memory and compares it to a given value. If they are equal, it tries to store a new value into the memory."
msgstr "'`cmpxchg``'指令用于原子地修改内存。它在内存中加载一个值并将其与给定值进行比较。如果它们相等，它会尝试将新值存储到内存中。"

#: ../../LangRef.rst:7044
msgid ""
"There are three arguments to the '``cmpxchg``' instruction: an address to operate on, a value to compare to the value currently be at that address, and a new value to place at that address if the compared values are equal. The type of '<cmp>' must be an integer type whose bit width is a power of two greater than or equal to eight and less than or equal to a target-specific size limit. '<cmp>' and '<new>' must have the same type, and the type of '<pointer>' must be a pointer to that type. If the ``cmpxchg`` is marked as ``volatile``, then the optimizer is not allowed "
"to modify the number or order of execution of this ``cmpxchg`` with other :ref:`volatile operations <volatile>`."
msgstr "'`cmpxchg``'指令有三个参数：一个要操作的地址，一个与当前该地址值相比较的值，以及一个新值，如果比较值相等则放在该地址。 “<cmp>”的类型必须是整数类型，其位宽是2的幂，大于或等于8且小于或等于特定于目标的大小限制。 '<cmp>'和'<new>'必须具有相同的类型，'<pointer>'的类型必须是指向该类型的指针。如果``cmpxchg``被标记为``volatile``，那么优化器不允许用其他命令修改这个``cmpxchg``的执行次数或顺序：ref：`volatile operations <volatile>`。"

#: ../../LangRef.rst:7055
msgid "The success and failure :ref:`ordering <ordering>` arguments specify how this ``cmpxchg`` synchronizes with other atomic operations. Both ordering parameters must be at least ``monotonic``, the ordering constraint on failure must be no stronger than that on success, and the failure ordering cannot be either ``release`` or ``acq_rel``."
msgstr "成功与失败：ref：`ordering <ordering>`参数指定这个``cmpxchg``如何与其他原子操作同步。两个排序参数必须至少是“单调的”，失败的排序约束必须不强于成功，并且失败排序不能是“释放”或“acq_rel”。"

#: ../../LangRef.rst:7061
msgid "The optional \"``singlethread``\" argument declares that the ``cmpxchg`` is only atomic with respect to code (usually signal handlers) running in the same thread as the ``cmpxchg``. Otherwise the cmpxchg is atomic with respect to all other code in the system."
msgstr "可选的````singlethread`` \\“参数声明``cmpxchg``对于在与``cmpxchg``相同的线程中运行的代码（通常是信号处理程序）来说只是原子的。否则，cmpxchg相对于系统中的所有其他代码都是原子的。"

#: ../../LangRef.rst:7066
msgid "The pointer passed into cmpxchg must have alignment greater than or equal to the size in memory of the operand."
msgstr "传递给cmpxchg的指针必须具有大于或等于操作数内存大小的对齐方式。"

#: ../../LangRef.rst:7072
msgid "The contents of memory at the location specified by the '``<pointer>``' operand is read and compared to '``<cmp>``'; if the read value is the equal, the '``<new>``' is written. The original value at the location is returned, together with a flag indicating success (true) or failure (false)."
msgstr "读取'``<pointer>``'操作数指定位置的内存内容，并与'``<cmp>``'进行比较;如果读取值相等，则写入“`<new>``'。返回该位置的原始值以及指示成功（true）或失败（false）的标志。"

#: ../../LangRef.rst:7077
msgid "If the cmpxchg operation is marked as ``weak`` then a spurious failure is permitted: the operation may not write ``<new>`` even if the comparison matched."
msgstr "如果cmpxchg操作被标记为“弱”，则允许虚假失败：即使比较匹配，操作也可能不会写入``<new>``。"

#: ../../LangRef.rst:7081
msgid "If the cmpxchg operation is strong (the default), the i1 value is 1 if and only if the value loaded equals ``cmp``."
msgstr "如果cmpxchg操作很强（默认值），当且仅当加载的值等于``cmp``时，i1值为1。"

#: ../../LangRef.rst:7084
msgid "A successful ``cmpxchg`` is a read-modify-write instruction for the purpose of identifying release sequences. A failed ``cmpxchg`` is equivalent to an atomic load with an ordering parameter determined the second ordering parameter."
msgstr "成功的``cmpxchg``是一个读 - 修改 - 写指令，用于识别释放序列。失败的``cmpxchg``等同于原子加载，其中排序参数确定了第二个排序参数。"

#: ../../LangRef.rst:7111
msgid "'``atomicrmw``' Instruction"
msgstr "'``atomicrmw``'指令"

#: ../../LangRef.rst:7123
msgid "The '``atomicrmw``' instruction is used to atomically modify memory."
msgstr "'``atomicrmw``'指令用于原子地修改内存。"

#: ../../LangRef.rst:7128
msgid "There are three arguments to the '``atomicrmw``' instruction: an operation to apply, an address whose value to modify, an argument to the operation. The operation must be one of the following keywords:"
msgstr "'`atomicrmw``'指令有三个参数：要应用的操作，要修改其值的地址，操作的参数。该操作必须是以下关键字之一："

#: ../../LangRef.rst:7132
msgid "xchg"
msgstr ""

#: ../../LangRef.rst:7133
msgid "add"
msgstr ""

#: ../../LangRef.rst:7134
msgid "sub"
msgstr ""

#: ../../LangRef.rst:7135
msgid "and"
msgstr ""

#: ../../LangRef.rst:7136
msgid "nand"
msgstr ""

#: ../../LangRef.rst:7137
msgid "or"
msgstr ""

#: ../../LangRef.rst:7138
msgid "xor"
msgstr ""

#: ../../LangRef.rst:7139
msgid "max"
msgstr ""

#: ../../LangRef.rst:7140
msgid "min"
msgstr ""

#: ../../LangRef.rst:7141
msgid "umax"
msgstr ""

#: ../../LangRef.rst:7142
msgid "umin"
msgstr ""

#: ../../LangRef.rst:7144
msgid "The type of '<value>' must be an integer type whose bit width is a power of two greater than or equal to eight and less than or equal to a target-specific size limit. The type of the '``<pointer>``' operand must be a pointer to that type. If the ``atomicrmw`` is marked as ``volatile``, then the optimizer is not allowed to modify the number or order of execution of this ``atomicrmw`` with other :ref:`volatile operations <volatile>`."
msgstr "'<value>'的类型必须是整数类型，其位宽是2的幂，大于或等于8且小于或等于目标特定的大小限制。 '``<pointer>``'操作数的类型必须是指向该类型的指针。如果``atomicrmw``被标记为``volatile``，那么优化器不允许用其他命令修改这个``atomicrmw``的执行次数或命令：ref：`volatile operations <volatile>`。"

#: ../../LangRef.rst:7155
msgid "The contents of memory at the location specified by the '``<pointer>``' operand are atomically read, modified, and written back. The original value at the location is returned. The modification is specified by the operation argument:"
msgstr "由'``<pointer>``'操作数指定的位置的内存内容被原子读取，修改和写回。返回该位置的原始值。修改由operation参数指定："

#: ../../LangRef.rst:7160
msgid "xchg: ``*ptr = val``"
msgstr ""

#: ../../LangRef.rst:7161
msgid "add: ``*ptr = *ptr + val``"
msgstr ""

#: ../../LangRef.rst:7162
msgid "sub: ``*ptr = *ptr - val``"
msgstr ""

#: ../../LangRef.rst:7163
msgid "and: ``*ptr = *ptr & val``"
msgstr ""

#: ../../LangRef.rst:7164
msgid "nand: ``*ptr = ~(*ptr & val)``"
msgstr ""

#: ../../LangRef.rst:7165
msgid "or: ``*ptr = *ptr | val``"
msgstr ""

#: ../../LangRef.rst:7166
msgid "xor: ``*ptr = *ptr ^ val``"
msgstr ""

#: ../../LangRef.rst:7167
msgid "max: ``*ptr = *ptr > val ? *ptr : val`` (using a signed comparison)"
msgstr ""

#: ../../LangRef.rst:7168
msgid "min: ``*ptr = *ptr < val ? *ptr : val`` (using a signed comparison)"
msgstr ""

#: ../../LangRef.rst:7169
msgid "umax: ``*ptr = *ptr > val ? *ptr : val`` (using an unsigned comparison)"
msgstr ""

#: ../../LangRef.rst:7171
msgid "umin: ``*ptr = *ptr < val ? *ptr : val`` (using an unsigned comparison)"
msgstr ""

#: ../../LangRef.rst:7184
msgid "'``getelementptr``' Instruction"
msgstr "'``getelementptr``'指令"

#: ../../LangRef.rst:7198
msgid "The '``getelementptr``' instruction is used to get the address of a subelement of an :ref:`aggregate <t_aggregate>` data structure. It performs address calculation only and does not access memory. The instruction can also be used to calculate a vector of such addresses."
msgstr "'``getelementptr``'指令用于获取：ref：`aggregate <t_aggregate>`数据结构的子元素的地址。它仅执行地址计算，不访问内存。该指令还可用于计算这些地址的向量。"

#: ../../LangRef.rst:7206
msgid ""
"The first argument is always a type used as the basis for the calculations. The second argument is always a pointer or a vector of pointers, and is the base address to start from. The remaining arguments are indices that indicate which of the elements of the aggregate object are indexed. The interpretation of each index is dependent on the type being indexed into. The first index always indexes the pointer value given as the first argument, the second index indexes a value of the type pointed to (not necessarily the value directly pointed to, since the first index can "
"be non-zero), etc. The first type indexed into must be a pointer value, subsequent types can be arrays, vectors, and structs. Note that subsequent types being indexed into can never be pointers, since that would require loading the pointer before continuing calculation."
msgstr "第一个参数始终是用作计算基础的类型。第二个参数始终是指针或指针向量，并且是从中开始的基址。其余参数是指示聚合对象的哪些元素被索引的索引。每个索引的解释取决于索引的类型。第一个索引始终索引作为第一个参数给出的指针值，第二个索引索引指向的类型的值（不一定是直接指向的值，因为第一个索引可以是非零），等等。第一个类型indexed into必须是指针值，后续类型可以是数组，向量和结构。请注意，索引的后续类型永远不能成为指针，因为这需要在继续计算之前加载指针。"

#: ../../LangRef.rst:7219
msgid "The type of each index argument depends on the type it is indexing into. When indexing into a (optionally packed) structure, only ``i32`` integer **constants** are allowed (when using a vector of indices they must all be the **same** ``i32`` integer constant). When indexing into an array, pointer or vector, integers of any width are allowed, and they are not required to be constant. These integers are treated as signed values where relevant."
msgstr "每个索引参数的类型取决于它索引的类型。索引到（可选地打包）结构时，只允许``i32``整数**常量**（当使用索引向量时，它们必须都是**相同的**``i32``整数常量）。索引到数组，指针或向量时，允许任何宽度的整数，并且它们不需要是常量。这些整数在相关时被视为有符号值。"

#: ../../LangRef.rst:7227
msgid "For example, let's consider a C code fragment and how it gets compiled to LLVM:"
msgstr "例如，让我们考虑一个C代码片段以及如何将其编译为LLVM："

#: ../../LangRef.rst:7247
msgid "The LLVM code generated by Clang is:"
msgstr "Clang生成的LLVM代码是："

#: ../../LangRef.rst:7263
#, python-format
msgid ""
"In the example above, the first index is indexing into the '``%struct.ST*``' type, which is a pointer, yielding a '``%struct.ST``' = '``{ i32, double, %struct.RT }``' type, a structure. The second index indexes into the third element of the structure, yielding a '``%struct.RT``' = '``{ i8 , [10 x [20 x i32]], i8 }``' type, another structure. The third index indexes into the second element of the structure, yielding a '``[10 x [20 x i32]]``' type, an array. The two dimensions of the array are subscripted into, yielding an '``i32``' type. The '``getelementptr``' "
"instruction returns a pointer to this element, thus computing a value of '``i32*``' type."
msgstr "在上面的例子中，第一个索引索引到'`` %s truct.ST *``'类型，这是一个指针，产生一个'`` %s truct.ST``'='``{i32 ，double， %s truct.RT}``'type，一个结构。第二个索引索引到结构的第三个元素，产生一个'` %s truct.RT``'='``{i8，[10 x [20 x i32]]，i8}``'type，另一个结构体。第三个索引索引到结构的第二个元素，产生一个'``[10 x [20 x i32]]``'类型，一个数组。数组的两个维度是下标，产生一个'``i32``'类型。 '``getelementptr``'指令返回一个指向这个元素的指针，从而计算出'``i32 *``'类型的值。"

#: ../../LangRef.rst:7274
msgid "Note that it is perfectly legal to index partially through a structure, returning a pointer to an inner element. Because of this, the LLVM code for the given testcase is equivalent to:"
msgstr "请注意，通过结构部分索引，返回指向内部元素的指针是完全合法的。因此，给定测试用例的LLVM代码等效于："

#: ../../LangRef.rst:7289
msgid ""
"If the ``inbounds`` keyword is present, the result value of the ``getelementptr`` is a :ref:`poison value <poisonvalues>` if the base pointer is not an *in bounds* address of an allocated object, or if any of the addresses that would be formed by successive addition of the offsets implied by the indices to the base address with infinitely precise signed arithmetic are not an *in bounds* address of that allocated object. The *in bounds* addresses for an allocated object are all the addresses that point into the object, plus the address one byte past the end. In cases "
"where the base is a vector of pointers the ``inbounds`` keyword applies to each of the computations element-wise."
msgstr "如果存在``inbounds``关键字，那么``getelementptr``的结果值是：ref：`poison value <poisonvalues>`如果基指针不是分配对象的bounds *地址中的*，或者，如果通过将索引隐含的偏移量连续添加到具有无限精确的带符号算术的基址而形成的任何地址不是该分配对象的边界*地址中的*。分配对象的* in bounds *地址是指向对象的所有地址，加上超过末尾一个字节的地址。在基数是指针向量的情况下，``inbounds``关键字适用于每个计算元素。"

#: ../../LangRef.rst:7300
msgid "If the ``inbounds`` keyword is not present, the offsets are added to the base address with silently-wrapping two's complement arithmetic. If the offsets have a different width from the pointer, they are sign-extended or truncated to the width of the pointer. The result value of the ``getelementptr`` may be outside the object pointed to by the base pointer. The result value may not necessarily be used to access memory though, even if it happens to point into allocated storage. See the :ref:`Pointer Aliasing Rules <pointeraliasing>` section for more information."
msgstr "如果不存在``inbounds``关键字，则通过静默包装二进制补码算法将偏移量添加到基址。如果偏移量与指针的宽度不同，则将它们符号扩展或截断为指针的宽度。 ``getelementptr``的结果值可能在基指针指向的对象之外。但是，结果值可能不一定用于访问内存，即使它恰好指向已分配的存储。有关详细信息，请参阅：ref：`指针别名规则<pointeraliasing>`部分。"

#: ../../LangRef.rst:7310
msgid "The getelementptr instruction is often confusing. For some more insight into how it works, see :doc:`the getelementptr FAQ <GetElementPtr>`."
msgstr "getelementptr指令经常令人困惑。有关其工作原理的更多信息，请参阅：doc：`getelementptr FAQ <GetElementPtr>`。"

#: ../../LangRef.rst:7328
msgid "Vector of pointers:"
msgstr "指针矢量："

#: ../../LangRef.rst:7330
msgid "The ``getelementptr`` returns a vector of pointers, instead of a single address, when one or more of its arguments is a vector. In such cases, all vector arguments should have the same number of elements, and every scalar argument will be effectively broadcast into a vector during address calculation."
msgstr "当一个或多个参数是向量时，``getelementptr``返回一个指针向量，而不是单个地址。在这种情况下，所有向量参数应具有相同数量的元素，并且在地址计算期间，每个标量参数将有效地广播到向量中。"

#: ../../LangRef.rst:7351
msgid "The two following instructions are equivalent:"
msgstr "以下两条说明是等效的："

#: ../../LangRef.rst:7364
msgid "Let's look at the C code, where the vector version of ``getelementptr`` makes sense:"
msgstr "让我们看看C代码，其中``getelementptr``的矢量版本是有意义的："

#: ../../LangRef.rst:7384
msgid "Conversion Operations"
msgstr "转换操作"

#: ../../LangRef.rst:7386
msgid "The instructions in this category are the conversion instructions (casting) which all take a single operand and a type. They perform various bit conversions on the operand."
msgstr "此类别中的指令是转换指令（转换），它们都采用单个操作数和类型。它们在操作数上执行各种位转换。"

#: ../../LangRef.rst:7391
msgid "'``trunc .. to``' Instruction"
msgstr "'``trunc .. to``'指令"

#: ../../LangRef.rst:7403
msgid "The '``trunc``' instruction truncates its operand to the type ``ty2``."
msgstr "'``trunc``'指令将其操作数截断为类型``ty2``。"

#: ../../LangRef.rst:7408
msgid "The '``trunc``' instruction takes a value to trunc, and a type to trunc it to. Both types must be of :ref:`integer <t_integer>` types, or vectors of the same number of integers. The bit size of the ``value`` must be larger than the bit size of the destination type, ``ty2``. Equal sized types are not allowed."
msgstr "'``trunc``'指令将一个值设为trunc，将一个类型设为trunc。两种类型必须是：ref：`integer <t_integer>`类型，或相同数量的整数的向量。 ``value``的位大小必须大于目标类型的位大小``ty2``。不允许使用相同大小的类型。"

#: ../../LangRef.rst:7417
msgid "The '``trunc``' instruction truncates the high order bits in ``value`` and converts the remaining bits to ``ty2``. Since the source size must be larger than the destination size, ``trunc`` cannot be a *no-op cast*. It will always truncate bits."
msgstr "'``trunc``'指令截断``value``中的高位，并将剩余的位转换为``ty2``。由于源大小必须大于目标大小，因此``trunc``不能是* no-op cast *。它总是会截断位。"

#: ../../LangRef.rst:7433
msgid "'``zext .. to``' Instruction"
msgstr "'``zext .. to``'指令"

#: ../../LangRef.rst:7445
msgid "The '``zext``' instruction zero extends its operand to type ``ty2``."
msgstr "'``zext``'指令将其操作数扩展为类型``ty2``。"

#: ../../LangRef.rst:7450
msgid "The '``zext``' instruction takes a value to cast, and a type to cast it to. Both types must be of :ref:`integer <t_integer>` types, or vectors of the same number of integers. The bit size of the ``value`` must be smaller than the bit size of the destination type, ``ty2``."
msgstr "'``zext``'指令接受一个值进行强制转换，以及一个将其强制转换为的类型。两种类型必须是：ref：`integer <t_integer>`类型，或相同数量的整数的向量。 ``value``的位大小必须小于目标类型的位大小``ty2``。"

#: ../../LangRef.rst:7458
msgid "The ``zext`` fills the high order bits of the ``value`` with zero bits until it reaches the size of the destination type, ``ty2``."
msgstr "``zext``用零位填充``value``的高位，直到达到目标类型的大小``ty2``。"

#: ../../LangRef.rst:7461
msgid "When zero extending from i1, the result will always be either 0 or 1."
msgstr "当零从i1延伸时，结果将始终为0或1。"

#: ../../LangRef.rst:7473
msgid "'``sext .. to``' Instruction"
msgstr "'``sext .. to``'指令"

#: ../../LangRef.rst:7485
msgid "The '``sext``' sign extends ``value`` to the type ``ty2``."
msgstr "'`sext``'符号将``value``扩展为``ty2``类型。"

#: ../../LangRef.rst:7490
msgid "The '``sext``' instruction takes a value to cast, and a type to cast it to. Both types must be of :ref:`integer <t_integer>` types, or vectors of the same number of integers. The bit size of the ``value`` must be smaller than the bit size of the destination type, ``ty2``."
msgstr "'``sext``'指令接受一个值进行强制转换，以及一个将其强制转换为的类型。两种类型必须是：ref：`integer <t_integer>`类型，或相同数量的整数的向量。 ``value``的位大小必须小于目标类型的位大小``ty2``。"

#: ../../LangRef.rst:7498
msgid "The '``sext``' instruction performs a sign extension by copying the sign bit (highest order bit) of the ``value`` until it reaches the bit size of the type ``ty2``."
msgstr "'``sext``'指令通过复制``value``的符号位（最高位）来执行符号扩展，直到达到类型``ty2``的位大小。"

#: ../../LangRef.rst:7502
msgid "When sign extending from i1, the extension always results in -1 or 0."
msgstr "当符号从i1延伸时，扩展名总是导致-1或0。"

#: ../../LangRef.rst:7514
msgid "'``fptrunc .. to``' Instruction"
msgstr "'``fptrunc .. to``'指令"

#: ../../LangRef.rst:7526
msgid "The '``fptrunc``' instruction truncates ``value`` to type ``ty2``."
msgstr "'``fptrunc``'指令截断``value``以输入``ty2``。"

#: ../../LangRef.rst:7531
msgid "The '``fptrunc``' instruction takes a :ref:`floating point <t_floating>` value to cast and a :ref:`floating point <t_floating>` type to cast it to. The size of ``value`` must be larger than the size of ``ty2``. This implies that ``fptrunc`` cannot be used to make a *no-op cast*."
msgstr "'``fptrunc``'指令使用：ref：`浮点<t_floating>`值进行强制转换，使用：ref：`浮点<t_floating>`类型将其强制转换为。 ``value``的大小必须大于``ty2``的大小。这意味着``fptrunc``不能用于制作* no-op cast *。"

#: ../../LangRef.rst:7539
msgid "The '``fptrunc``' instruction casts a ``value`` from a larger :ref:`floating point <t_floating>` type to a smaller :ref:`floating point <t_floating>` type. If the value cannot fit (i.e. overflows) within the destination type, ``ty2``, then the results are undefined. If the cast produces an inexact result, how rounding is performed (e.g. truncation, also known as round to zero) is undefined."
msgstr "'``fptrunc``'指令将一个``value``从一个更大的：ref：`浮点<t_floating>`类型转换为一个更小的：ref：`浮点<t_floating>`类型。如果值不能适合（即溢出）目标类型，``ty2``，那么结果是不确定的。如果强制转换产生不精确的结果，则执行舍入的方式（例如，截断，也称为舍入为零）未定义。"

#: ../../LangRef.rst:7555
msgid "'``fpext .. to``' Instruction"
msgstr "'``fpext ... to``'指令"

#: ../../LangRef.rst:7567
msgid "The '``fpext``' extends a floating point ``value`` to a larger floating point value."
msgstr "'``fpext``'将浮点``value``扩展为更大的浮点值。"

#: ../../LangRef.rst:7573
msgid "The '``fpext``' instruction takes a :ref:`floating point <t_floating>` ``value`` to cast, and a :ref:`floating point <t_floating>` type to cast it to. The source type must be smaller than the destination type."
msgstr "'``fpext``'指令采用：ref：`浮点<t_floating>``````来强制转换，a：ref：`浮点<t_floating>`类型转换为。源类型必须小于目标类型。"

#: ../../LangRef.rst:7580
msgid "The '``fpext``' instruction extends the ``value`` from a smaller :ref:`floating point <t_floating>` type to a larger :ref:`floating point <t_floating>` type. The ``fpext`` cannot be used to make a *no-op cast* because it always changes bits. Use ``bitcast`` to make a *no-op cast* for a floating point cast."
msgstr "'``fpext``'指令将``value``从较小的：ref：`浮点<t_floating>`类型扩展为更大的：ref：`浮点<t_floating>`类型。 ``fpext``不能用于制作* no-op cast *因为它总是改变位。使用``bitcast``为浮点演员制作* no-op cast *。"

#: ../../LangRef.rst:7595
msgid "'``fptoui .. to``' Instruction"
msgstr "'``fptoui .. to``'指令"

#: ../../LangRef.rst:7607
msgid "The '``fptoui``' converts a floating point ``value`` to its unsigned integer equivalent of type ``ty2``."
msgstr "'``fptoui``'将浮点数``value``转换为等效于``ty2``的无符号整数。"

#: ../../LangRef.rst:7613
msgid "The '``fptoui``' instruction takes a value to cast, which must be a scalar or vector :ref:`floating point <t_floating>` value, and a type to cast it to ``ty2``, which must be an :ref:`integer <t_integer>` type. If ``ty`` is a vector floating point type, ``ty2`` must be a vector integer type with the same number of elements as ``ty``"
msgstr "'``fptoui``'指令需要一个值来强制转换，它必须是一个标量或向量：ref：`浮点<t_floating>`值，以及一个将它强制转换为``ty2``的类型，必须是an：ref：`integer <t_integer>`类型。如果``ty``是向量浮点类型，``ty2``必须是一个向量整数类型，其元素数量与``ty``相同"

#: ../../LangRef.rst:7622
msgid "The '``fptoui``' instruction converts its :ref:`floating point <t_floating>` operand into the nearest (rounding towards zero) unsigned integer value. If the value cannot fit in ``ty2``, the results are undefined."
msgstr "'``fptoui``'指令将其：ref：`浮点<t_floating>`操作数转换为最接近的（向零舍入）无符号整数值。如果该值不适合“ty2”，则结果未定义。"

#: ../../LangRef.rst:7637
msgid "'``fptosi .. to``' Instruction"
msgstr "'``fptosi .. to``'指令"

#: ../../LangRef.rst:7649
msgid "The '``fptosi``' instruction converts :ref:`floating point <t_floating>` ``value`` to type ``ty2``."
msgstr "'``fptosi``'指令将：ref：`浮点<t_floating>```value``转换为``ty2``。"

#: ../../LangRef.rst:7655
msgid "The '``fptosi``' instruction takes a value to cast, which must be a scalar or vector :ref:`floating point <t_floating>` value, and a type to cast it to ``ty2``, which must be an :ref:`integer <t_integer>` type. If ``ty`` is a vector floating point type, ``ty2`` must be a vector integer type with the same number of elements as ``ty``"
msgstr "'``fptosi``'指令需要一个值来强制转换，它必须是一个标量或向量：ref：`浮点<t_floating>`值，以及一个将它强制转换为``ty2``的类型，必须是an：ref：`integer <t_integer>`类型。如果``ty``是向量浮点类型，``ty2``必须是一个向量整数类型，其元素数量与``ty``相同"

#: ../../LangRef.rst:7664
msgid "The '``fptosi``' instruction converts its :ref:`floating point <t_floating>` operand into the nearest (rounding towards zero) signed integer value. If the value cannot fit in ``ty2``, the results are undefined."
msgstr "'``fptosi``'指令将其：ref：`浮点<t_floating>`操作数转换为最接近的（舍入为零）有符号整数值。如果该值不适合“ty2”，则结果未定义。"

#: ../../LangRef.rst:7679
msgid "'``uitofp .. to``' Instruction"
msgstr "'``uitofp .. to``'指令"

#: ../../LangRef.rst:7691
msgid "The '``uitofp``' instruction regards ``value`` as an unsigned integer and converts that value to the ``ty2`` type."
msgstr "'``uitofp``'指令将``value``视为无符号整数，并将该值转换为``ty2``类型。"

#: ../../LangRef.rst:7697
msgid "The '``uitofp``' instruction takes a value to cast, which must be a scalar or vector :ref:`integer <t_integer>` value, and a type to cast it to ``ty2``, which must be an :ref:`floating point <t_floating>` type. If ``ty`` is a vector integer type, ``ty2`` must be a vector floating point type with the same number of elements as ``ty``"
msgstr "'``uitofp``'指令接受一个值来强制转换，它必须是一个标量或向量：ref：`integer <t_integer>`值，以及一个将它强制转换为``ty2``的类型，它必须是：ref：`浮点<t_floating>`类型。如果``ty``是一个向量整数类型，``ty2``必须是一个向量浮点类型，其元素数量与``ty``相同"

#: ../../LangRef.rst:7706
msgid "The '``uitofp``' instruction interprets its operand as an unsigned integer quantity and converts it to the corresponding floating point value. If the value cannot fit in the floating point value, the results are undefined."
msgstr "'``uitofp``'指令将其操作数解释为无符号整数并将其转换为相应的浮点值。如果该值不适合浮点值，则结果未定义。"

#: ../../LangRef.rst:7720
msgid "'``sitofp .. to``' Instruction"
msgstr "'``sitofp .. to``'指令"

#: ../../LangRef.rst:7732
msgid "The '``sitofp``' instruction regards ``value`` as a signed integer and converts that value to the ``ty2`` type."
msgstr "'``sitofp``'指令将``value``视为有符号整数，并将该值转换为``ty2``类型。"

#: ../../LangRef.rst:7738
msgid "The '``sitofp``' instruction takes a value to cast, which must be a scalar or vector :ref:`integer <t_integer>` value, and a type to cast it to ``ty2``, which must be an :ref:`floating point <t_floating>` type. If ``ty`` is a vector integer type, ``ty2`` must be a vector floating point type with the same number of elements as ``ty``"
msgstr "'``sitofp``'指令接受一个值来强制转换，它必须是一个标量或向量：ref：`integer <t_integer>`值，以及一个将它强制转换为``ty2``的类型，它必须是：ref：`浮点<t_floating>`类型。如果``ty``是一个向量整数类型，``ty2``必须是一个向量浮点类型，其元素数量与``ty``相同"

#: ../../LangRef.rst:7747
msgid "The '``sitofp``' instruction interprets its operand as a signed integer quantity and converts it to the corresponding floating point value. If the value cannot fit in the floating point value, the results are undefined."
msgstr "'`sitofp``'指令将其操作数解释为有符号整数并将其转换为相应的浮点值。如果该值不适合浮点值，则结果未定义。"

#: ../../LangRef.rst:7763
msgid "'``ptrtoint .. to``' Instruction"
msgstr "'``ptrtoint .. to``'指示"

#: ../../LangRef.rst:7775
msgid "The '``ptrtoint``' instruction converts the pointer or a vector of pointers ``value`` to the integer (or vector of integers) type ``ty2``."
msgstr "'``ptrtoint``'指令将指针或指针``value``的向量转换为整数（或整数向量）类型``ty2``。"

#: ../../LangRef.rst:7781
msgid "The '``ptrtoint``' instruction takes a ``value`` to cast, which must be a value of type :ref:`pointer <t_pointer>` or a vector of pointers, and a type to cast it to ``ty2``, which must be an :ref:`integer <t_integer>` or a vector of integers type."
msgstr "'``ptrtoint``'指令需要一个``value``来强制转换，它必须是一个类型的值：ref：`pointer <t_pointer>`或一个指针向量，以及一个将它强制转换为``的类型。 ty2``，必须是：ref：`integer <t_integer>`或整数类型的向量。"

#: ../../LangRef.rst:7789
msgid "The '``ptrtoint``' instruction converts ``value`` to integer type ``ty2`` by interpreting the pointer value as an integer and either truncating or zero extending that value to the size of the integer type. If ``value`` is smaller than ``ty2`` then a zero extension is done. If ``value`` is larger than ``ty2`` then a truncation is done. If they are the same size, then nothing is done (*no-op cast*) other than a type change."
msgstr "'``ptrtoint``'指令通过将指针值解释为整数并将该值截断或零扩展为整数类型的大小，将``value``转换为整数类型``ty2``。如果``value``小于``ty2``则完成零扩展。如果``value``大于``ty2``那么就完成了截断。如果它们的大小相同，那么除了类型更改之外什么都不做（* no-op cast *）。"

#: ../../LangRef.rst:7809
msgid "'``inttoptr .. to``' Instruction"
msgstr "'``inttoptr .. to``'指令"

#: ../../LangRef.rst:7821
msgid "The '``inttoptr``' instruction converts an integer ``value`` to a pointer type, ``ty2``."
msgstr "'``inttoptr``'指令将整数``value``转换为指针类型``ty2``。"

#: ../../LangRef.rst:7827
msgid "The '``inttoptr``' instruction takes an :ref:`integer <t_integer>` value to cast, and a type to cast it to, which must be a :ref:`pointer <t_pointer>` type."
msgstr "'``inttoptr``'指令采用：ref：`integer <t_integer>`要强制转换的值，以及要将其强制转换为的类型，它必须是：ref：`pointer <t_pointer>`type。"

#: ../../LangRef.rst:7834
msgid "The '``inttoptr``' instruction converts ``value`` to type ``ty2`` by applying either a zero extension or a truncation depending on the size of the integer ``value``. If ``value`` is larger than the size of a pointer then a truncation is done. If ``value`` is smaller than the size of a pointer then a zero extension is done. If they are the same size, nothing is done (*no-op cast*)."
msgstr "'``inttoptr``'指令通过应用零扩展或截断来将``value``转换为类型``ty2``，具体取决于整数``value``的大小。如果``value``大于指针的大小，则完成截断。如果``value``小于指针的大小，则完成零扩展。如果它们的大小相同，则不执行任何操作（* no-op cast *）。"

#: ../../LangRef.rst:7854
msgid "'``bitcast .. to``' Instruction"
msgstr "'``bitcast ... to``'指令"

#: ../../LangRef.rst:7866
msgid "The '``bitcast``' instruction converts ``value`` to type ``ty2`` without changing any bits."
msgstr "'``bitcast``'指令将``value``转换为``ty2``，而不改变任何位。"

#: ../../LangRef.rst:7872
msgid "The '``bitcast``' instruction takes a value to cast, which must be a non-aggregate first class value, and a type to cast it to, which must also be a non-aggregate :ref:`first class <t_firstclass>` type. The bit sizes of ``value`` and the destination type, ``ty2``, must be identical. If the source type is a pointer, the destination type must also be a pointer of the same size. This instruction supports bitwise conversion of vectors to integers and to vectors of other types (as long as they have the same size)."
msgstr "'``bitcast``'指令接受一个值来强制转换，它必须是非聚合的第一类值，以及一个将它强制转换为的类型，它也必须是非聚合的：ref：`first class <t_firstclass >`类型。 ``value``的位大小和目标类型``ty2``必须相同。如果源类型是指针，则目标类型也必须是相同大小的指针。该指令支持向量逐位转换为整数和其他类型的向量（只要它们具有相同的大小）。"

#: ../../LangRef.rst:7884
msgid "The '``bitcast``' instruction converts ``value`` to type ``ty2``. It is always a *no-op cast* because no bits change with this conversion. The conversion is done as if the ``value`` had been stored to memory and read back as type ``ty2``. Pointer (or vector of pointers) types may only be converted to other pointer (or vector of pointers) types with the same address space through this instruction. To convert pointers to other types, use the :ref:`inttoptr <i_inttoptr>` or :ref:`ptrtoint <i_ptrtoint>` instructions first."
msgstr "'``bitcast``'指令将``value``转换为``ty2``。它始终是* no-op cast *，因为此转换不会改变位。转换完成就好像``value``已经存储到内存中并回读为类型``ty2``。指针（或指针矢量）类型只能通过该指令转换为具有相同地址空间的其他指针（或指针矢量）类型。要将指针转换为其他类型，请首先使用：ref：`inttoptr <i_inttoptr>`或：ref：`ptrtoint <i_ptrtoint>`指令。"

#: ../../LangRef.rst:7906
msgid "'``addrspacecast .. to``' Instruction"
msgstr "'``addrspacecast .. to``'指令"

#: ../../LangRef.rst:7918
msgid "The '``addrspacecast``' instruction converts ``ptrval`` from ``pty`` in address space ``n`` to type ``pty2`` in address space ``m``."
msgstr "'``addrspacecast``'指令将``ptrval``从地址空间``n``中的``pty``转换为地址空间``m``中的``pty2``。"

#: ../../LangRef.rst:7924
msgid "The '``addrspacecast``' instruction takes a pointer or vector of pointer value to cast and a pointer type to cast it to, which must have a different address space."
msgstr "'``addrspacecast``'指令接受指针值的指针或向量以及将其强制转换为的指针类型，它必须具有不同的地址空间。"

#: ../../LangRef.rst:7931
msgid "The '``addrspacecast``' instruction converts the pointer value ``ptrval`` to type ``pty2``. It can be a *no-op cast* or a complex value modification, depending on the target and the address space pair. Pointer conversions within the same address space must be performed with the ``bitcast`` instruction. Note that if the address space conversion is legal then both result and operand refer to the same memory location."
msgstr "'``addrspacecast``'指令将指针值``ptrval``转换为``pty2``。它可以是* no-op cast *或复杂的值修改，具体取决于目标和地址空间对。必须使用``bitcast``指令执行同一地址空间内的指针转换。请注意，如果地址空间转换是合法的，则结果和操作数都指向相同的内存位置。"

#: ../../LangRef.rst:7951
msgid "Other Operations"
msgstr "其他行动"

#: ../../LangRef.rst:7953
msgid "The instructions in this category are the \"miscellaneous\" instructions, which defy better classification."
msgstr "此类别中的说明是“杂项”说明，无法更好地进行分类。"

#: ../../LangRef.rst:7959
msgid "'``icmp``' Instruction"
msgstr "'```icmp``'指令"

#: ../../LangRef.rst:7971
msgid "The '``icmp``' instruction returns a boolean value or a vector of boolean values based on comparison of its two integer, integer vector, pointer, or pointer vector operands."
msgstr "'``icmp``'指令根据其两个整数，整数向量，指针或指针向量操作数的比较返回布尔值或布尔值向量。"

#: ../../LangRef.rst:7978
msgid "The '``icmp``' instruction takes three operands. The first operand is the condition code indicating the kind of comparison to perform. It is not a value, just a keyword. The possible condition code are:"
msgstr "'``icmp``'指令需要三个操作数。第一个操作数是指示要执行的比较类型的条件代码。它不是一个值，只是一个关键字。可能的条件代码是："

#: ../../LangRef.rst:7982
msgid "``eq``: equal"
msgstr "``eq``：相等"

#: ../../LangRef.rst:7983
msgid "``ne``: not equal"
msgstr "``ne``：不相等"

#: ../../LangRef.rst:7984
msgid "``ugt``: unsigned greater than"
msgstr "``ugt``：无符号大于"

#: ../../LangRef.rst:7985
msgid "``uge``: unsigned greater or equal"
msgstr "``uge``：无符号大于或等于"

#: ../../LangRef.rst:7986
msgid "``ult``: unsigned less than"
msgstr "``ult``：无符号小于"

#: ../../LangRef.rst:7987
msgid "``ule``: unsigned less or equal"
msgstr "``ule``：unsigned less或equal"

#: ../../LangRef.rst:7988
msgid "``sgt``: signed greater than"
msgstr "``sgt``：签名大于"

#: ../../LangRef.rst:7989
msgid "``sge``: signed greater or equal"
msgstr "``sge``：签名更大或更平等"

#: ../../LangRef.rst:7990
msgid "``slt``: signed less than"
msgstr "``slt``：签名不到"

#: ../../LangRef.rst:7991
msgid "``sle``: signed less or equal"
msgstr "``sle``：签名更少或相等"

#: ../../LangRef.rst:7993
msgid "The remaining two arguments must be :ref:`integer <t_integer>` or :ref:`pointer <t_pointer>` or integer :ref:`vector <t_vector>` typed. They must also be identical types."
msgstr "剩下的两个参数必须是：ref：`integer <t_integer>`或：ref：`pointer <t_pointer>`或integer：ref：`vector <t_vector>`typed。它们也必须是相同的类型。"

#: ../../LangRef.rst:8000
msgid "The '``icmp``' compares ``op1`` and ``op2`` according to the condition code given as ``cond``. The comparison performed always yields either an :ref:`i1 <t_integer>` or vector of ``i1`` result, as follows:"
msgstr "'``icmp``'根据作为``cond``给出的条件代码比较``op1``和``op2``。执行的比较总是产生：ref：`i1 <t_integer>`或``i1``结果的向量，如下所示："

#: ../../LangRef.rst:8004
msgid "``eq``: yields ``true`` if the operands are equal, ``false`` otherwise. No sign interpretation is necessary or performed."
msgstr "``eq``：如果操作数相等则产生``true``，否则产生``false``。不需要或执行任何标志解释。"

#: ../../LangRef.rst:8006
msgid "``ne``: yields ``true`` if the operands are unequal, ``false`` otherwise. No sign interpretation is necessary or performed."
msgstr "``ne``：如果操作数不相等则产生``true``，否则产生``false``。不需要或执行任何标志解释。"

#: ../../LangRef.rst:8008
msgid "``ugt``: interprets the operands as unsigned values and yields ``true`` if ``op1`` is greater than ``op2``."
msgstr "``ugt``：将操作数解释为无符号值，如果``op1``大于``op2``，则产生``true``。"

#: ../../LangRef.rst:8010
msgid "``uge``: interprets the operands as unsigned values and yields ``true`` if ``op1`` is greater than or equal to ``op2``."
msgstr "``uge``：将操作数解释为无符号值，如果``op1``大于或等于``op2``，则产生``true``。"

#: ../../LangRef.rst:8012
msgid "``ult``: interprets the operands as unsigned values and yields ``true`` if ``op1`` is less than ``op2``."
msgstr "``ult``：将操作数解释为无符号值，如果``op1``小于``op2``，则产生``true``。"

#: ../../LangRef.rst:8014
msgid "``ule``: interprets the operands as unsigned values and yields ``true`` if ``op1`` is less than or equal to ``op2``."
msgstr "``ule``：将操作数解释为无符号值，如果``op1``小于或等于``op2``，则产生``true``。"

#: ../../LangRef.rst:8016
msgid "``sgt``: interprets the operands as signed values and yields ``true`` if ``op1`` is greater than ``op2``."
msgstr "``sgt``：将操作数解释为带符号的值，如果``op1``大于``op2``，则产生``true``。"

#: ../../LangRef.rst:8018
msgid "``sge``: interprets the operands as signed values and yields ``true`` if ``op1`` is greater than or equal to ``op2``."
msgstr "``sge``：将操作数解释为有符号值，如果``op1``大于或等于``op2``，则产生``true``。"

#: ../../LangRef.rst:8020
msgid "``slt``: interprets the operands as signed values and yields ``true`` if ``op1`` is less than ``op2``."
msgstr "``slt``：将操作数解释为带符号的值，如果``op1``小于``op2``，则产生``true``。"

#: ../../LangRef.rst:8022
msgid "``sle``: interprets the operands as signed values and yields ``true`` if ``op1`` is less than or equal to ``op2``."
msgstr "``sle``：将操作数解释为有符号值，如果``op1``小于或等于``op2``，则产生``true``。"

#: ../../LangRef.rst:8025
msgid "If the operands are :ref:`pointer <t_pointer>` typed, the pointer values are compared as if they were integers."
msgstr "如果操作数是：ref：`pointer <t_pointer>`typed，则将指针值进行比较，就好像它们是整数一样。"

#: ../../LangRef.rst:8028
msgid "If the operands are integer vectors, then they are compared element by element. The result is an ``i1`` vector with the same number of elements as the values being compared. Otherwise, the result is an ``i1``."
msgstr "如果操作数是整数向量，则逐个元素地对它们进行比较。结果是一个``i1``向量，其元素数量与被比较的值相同。否则，结果是“i1”。"

#: ../../LangRef.rst:8044
msgid "Note that the code generator does not yet support vector types with the ``icmp`` instruction."
msgstr "请注意，代码生成器还不支持带有``icmp``指令的向量类型。"

#: ../../LangRef.rst:8050
msgid "'``fcmp``' Instruction"
msgstr "'``fcmp``'指令"

#: ../../LangRef.rst:8062
msgid "The '``fcmp``' instruction returns a boolean value or vector of boolean values based on comparison of its operands."
msgstr "'```fcmp``'指令根据其操作数的比较返回布尔值或布尔值向量。"

#: ../../LangRef.rst:8065
msgid "If the operands are floating point scalars, then the result type is a boolean (:ref:`i1 <t_integer>`)."
msgstr "如果操作数是浮点标量，那么结果类型是布尔值（：ref：`i1 <t_integer>`）。"

#: ../../LangRef.rst:8068
msgid "If the operands are floating point vectors, then the result type is a vector of boolean with the same number of elements as the operands being compared."
msgstr "如果操作数是浮点向量，则结果类型是布尔值的向量，其元素数量与要比较的操作数相同。"

#: ../../LangRef.rst:8075
msgid "The '``fcmp``' instruction takes three operands. The first operand is the condition code indicating the kind of comparison to perform. It is not a value, just a keyword. The possible condition code are:"
msgstr "'```fcmp``'指令需要三个操作数。第一个操作数是指示要执行的比较类型的条件代码。它不是一个值，只是一个关键字。可能的条件代码是："

#: ../../LangRef.rst:8079
msgid "``false``: no comparison, always returns false"
msgstr "``false``：没有比较，总是返回false"

#: ../../LangRef.rst:8080
msgid "``oeq``: ordered and equal"
msgstr "``oeq``：有序和平等"

#: ../../LangRef.rst:8081
msgid "``ogt``: ordered and greater than"
msgstr "``ogt``：有序且大于"

#: ../../LangRef.rst:8082
msgid "``oge``: ordered and greater than or equal"
msgstr "``oge``：有序且大于或等于"

#: ../../LangRef.rst:8083
msgid "``olt``: ordered and less than"
msgstr "``olt``：有序且少于"

#: ../../LangRef.rst:8084
msgid "``ole``: ordered and less than or equal"
msgstr "``ole``：有序且小于或等于"

#: ../../LangRef.rst:8085
msgid "``one``: ordered and not equal"
msgstr "``one``：有序且不相等"

#: ../../LangRef.rst:8086
msgid "``ord``: ordered (no nans)"
msgstr "``ord``：有序（没有nans）"

#: ../../LangRef.rst:8087
msgid "``ueq``: unordered or equal"
msgstr "``ueq``：无序或平等"

#: ../../LangRef.rst:8088
msgid "``ugt``: unordered or greater than"
msgstr "``ugt``：无序或大于"

#: ../../LangRef.rst:8089
msgid "``uge``: unordered or greater than or equal"
msgstr "``uge``：无序或大于或等于"

#: ../../LangRef.rst:8090
msgid "``ult``: unordered or less than"
msgstr "``ult``：无序或低于"

#: ../../LangRef.rst:8091
msgid "``ule``: unordered or less than or equal"
msgstr "``ule``：无序或小于或等于"

#: ../../LangRef.rst:8092
msgid "``une``: unordered or not equal"
msgstr "``une``：无序或不平等"

#: ../../LangRef.rst:8093
msgid "``uno``: unordered (either nans)"
msgstr "``uno``：无序（无论是nans）"

#: ../../LangRef.rst:8094
msgid "``true``: no comparison, always returns true"
msgstr "``true``：没有比较，总是返回true"

#: ../../LangRef.rst:8096
msgid "*Ordered* means that neither operand is a QNAN while *unordered* means that either operand may be a QNAN."
msgstr "* Ordered *表示两个操作数都不是QNAN，而* unordered *表示任一操作数都可以是QNAN。"

#: ../../LangRef.rst:8099
msgid "Each of ``val1`` and ``val2`` arguments must be either a :ref:`floating point <t_floating>` type or a :ref:`vector <t_vector>` of floating point type. They must have identical types."
msgstr "每个``val1``和``val2``参数必须是：ref：`浮点<t_floating>`类型或a：ref：`vector <t_vector>`浮点类型。它们必须具有相同的类型。"

#: ../../LangRef.rst:8106
msgid "The '``fcmp``' instruction compares ``op1`` and ``op2`` according to the condition code given as ``cond``. If the operands are vectors, then the vectors are compared element by element. Each comparison performed always yields an :ref:`i1 <t_integer>` result, as follows:"
msgstr "'```fcmp``'指令根据作为``cond``给出的条件代码比较``op1``和``op2``。如果操作数是向量，则逐个元素地比较向量。执行的每个比较总是产生：ref：`i1 <t_integer>`结果，如下所示："

#: ../../LangRef.rst:8111
msgid "``false``: always yields ``false``, regardless of operands."
msgstr "``false``：无论操作数如何，总是产生``false``。"

#: ../../LangRef.rst:8112
msgid "``oeq``: yields ``true`` if both operands are not a QNAN and ``op1`` is equal to ``op2``."
msgstr "``oeq``：如果两个操作数都不是QNAN并且``op1``等于``op2``，则产生``true``。"

#: ../../LangRef.rst:8114
msgid "``ogt``: yields ``true`` if both operands are not a QNAN and ``op1`` is greater than ``op2``."
msgstr "``ogt``：如果两个操作数都不是QNAN而且``op1``大于``op2``，则产生``true``。"

#: ../../LangRef.rst:8116
msgid "``oge``: yields ``true`` if both operands are not a QNAN and ``op1`` is greater than or equal to ``op2``."
msgstr "``oge``：如果两个操作数都不是QNAN并且``op1``大于或等于``op2``，则产生``true``。"

#: ../../LangRef.rst:8118
msgid "``olt``: yields ``true`` if both operands are not a QNAN and ``op1`` is less than ``op2``."
msgstr "``olt``：如果两个操作数都不是QNAN而且``op1``小于``op2``，则产生``true``。"

#: ../../LangRef.rst:8120
msgid "``ole``: yields ``true`` if both operands are not a QNAN and ``op1`` is less than or equal to ``op2``."
msgstr "``ole``：如果两个操作数都不是QNAN并且``op1``小于或等于``op2``，则产生``true``。"

#: ../../LangRef.rst:8122
msgid "``one``: yields ``true`` if both operands are not a QNAN and ``op1`` is not equal to ``op2``."
msgstr "``one``：如果两个操作数都不是QNAN并且``op1``不等于``op2``，则产生``true``。"

#: ../../LangRef.rst:8124
msgid "``ord``: yields ``true`` if both operands are not a QNAN."
msgstr "``ord``：如果两个操作数都不是QNAN，则产生``true``。"

#: ../../LangRef.rst:8125
msgid "``ueq``: yields ``true`` if either operand is a QNAN or ``op1`` is equal to ``op2``."
msgstr "``ueq``：如果操作数是QNAN或者``op1``等于``op2``，则产生``true``。"

#: ../../LangRef.rst:8127
msgid "``ugt``: yields ``true`` if either operand is a QNAN or ``op1`` is greater than ``op2``."
msgstr "``ugt``：如果操作数是QNAN或者``op1``大于``op2``，则产生``true``。"

#: ../../LangRef.rst:8129
msgid "``uge``: yields ``true`` if either operand is a QNAN or ``op1`` is greater than or equal to ``op2``."
msgstr "``uge``：如果操作数是QNAN或者``op1``大于或等于``op2``，则产生``true``。"

#: ../../LangRef.rst:8131
msgid "``ult``: yields ``true`` if either operand is a QNAN or ``op1`` is less than ``op2``."
msgstr "``ult``：如果操作数是QNAN或者``op1``小于``op2``，则产生``true``。"

#: ../../LangRef.rst:8133
msgid "``ule``: yields ``true`` if either operand is a QNAN or ``op1`` is less than or equal to ``op2``."
msgstr "``ule``：如果操作数是QNAN或者``op1``小于或等于``op2``，则产生``true``。"

#: ../../LangRef.rst:8135
msgid "``une``: yields ``true`` if either operand is a QNAN or ``op1`` is not equal to ``op2``."
msgstr "``une``：如果操作数是QNAN或者``op1``不等于``op2``，则产生``true``。"

#: ../../LangRef.rst:8137
msgid "``uno``: yields ``true`` if either operand is a QNAN."
msgstr "``uno``：如果任一操作数是QNAN，则产生``true``。"

#: ../../LangRef.rst:8138
msgid "``true``: always yields ``true``, regardless of operands."
msgstr "``true``：无论操作数如何，总是产生``true``。"

#: ../../LangRef.rst:8140
msgid "The ``fcmp`` instruction can also optionally take any number of :ref:`fast-math flags <fastmath>`, which are optimization hints to enable otherwise unsafe floating point optimizations."
msgstr "``fcmp``指令也可以选择使用任意数量的：ref：`fast-math flags <fastmath>`，它们是优化提示，用于启用其他不安全的浮点优化。"

#: ../../LangRef.rst:8144
msgid "Any set of fast-math flags are legal on an ``fcmp`` instruction, but the only flags that have any effect on its semantics are those that allow assumptions to be made about the values of input arguments; namely ``nnan``, ``ninf``, and ``nsz``. See :ref:`fastmath` for more information."
msgstr "任何一组快速数学标志在``fcmp``指令上都是合法的，但是对它的语义有任何影响的唯一标志是那些允许对输入参数的值进行假设的标志;即``nnan``，``ninf``和``nsz``。有关更多信息，请参阅：ref：`fastmath`。"

#: ../../LangRef.rst:8159
msgid "Note that the code generator does not yet support vector types with the ``fcmp`` instruction."
msgstr "请注意，代码生成器尚不支持带有``fcmp``指令的向量类型。"

#: ../../LangRef.rst:8165
msgid "'``phi``' Instruction"
msgstr "'``phi``'指令"

#: ../../LangRef.rst:8177
msgid "The '``phi``' instruction is used to implement the φ node in the SSA graph representing the function."
msgstr "'``phi``'指令用于实现表示函数的SSA图中的φ节点。"

#: ../../LangRef.rst:8183
msgid "The type of the incoming values is specified with the first type field. After this, the '``phi``' instruction takes a list of pairs as arguments, with one pair for each predecessor basic block of the current block. Only values of :ref:`first class <t_firstclass>` type may be used as the value arguments to the PHI node. Only labels may be used as the label arguments."
msgstr "使用第一个类型字段指定传入值的类型。在此之后，'``phi``'指令将对列表作为参数，其中一对用于当前块的每个前任基本块。只有：ref：`first class <t_firstclass>`类型的值可以用作PHI节点的值参数。只有标签可以用作标签参数。"

#: ../../LangRef.rst:8190
msgid "There must be no non-phi instructions between the start of a basic block and the PHI instructions: i.e. PHI instructions must be first in a basic block."
msgstr "在基本块的开始和PHI指令之间必须没有非phi指令：即PHI指令必须在基本块中是第一个。"

#: ../../LangRef.rst:8194
msgid "For the purposes of the SSA form, the use of each incoming value is deemed to occur on the edge from the corresponding predecessor block to the current block (but after any definition of an '``invoke``' instruction's return value on the same edge)."
msgstr "出于SSA形式的目的，每个传入值的使用被认为发生在从相应的前任块到当前块的边缘上（但是在'``invoke``'指令的返回值的任何定义之后）边缘）。"

#: ../../LangRef.rst:8202
msgid "At runtime, the '``phi``' instruction logically takes on the value specified by the pair corresponding to the predecessor basic block that executed just prior to the current block."
msgstr "在运行时，'``phi``'指令逻辑上采用对应于当前块之前执行的前任基本块的对指定的值。"

#: ../../LangRef.rst:8219
msgid "'``select``' Instruction"
msgstr "'``select``'指令"

#: ../../LangRef.rst:8233
msgid "The '``select``' instruction is used to choose one value based on a condition, without IR-level branching."
msgstr "'``select``'指令用于根据条件选择一个值，没有IR级分支。"

#: ../../LangRef.rst:8239
msgid "The '``select``' instruction requires an 'i1' value or a vector of 'i1' values indicating the condition, and two values of the same :ref:`first class <t_firstclass>` type."
msgstr "'``select``'指令需要'i1'值或表示条件的'i1'值的向量，以及相同的两个值：ref：`first class <t_firstclass>`type。"

#: ../../LangRef.rst:8246
msgid "If the condition is an i1 and it evaluates to 1, the instruction returns the first value argument; otherwise, it returns the second value argument."
msgstr "如果条件是i1并且计算结果为1，则指令返回第一个值参数;否则，它返回第二个值参数。"

#: ../../LangRef.rst:8250
msgid "If the condition is a vector of i1, then the value arguments must be vectors of the same size, and the selection is done element by element."
msgstr "如果条件是i1的向量，则value参数必须是相同大小的向量，并且选择是逐个元素完成的。"

#: ../../LangRef.rst:8253
msgid "If the condition is an i1 and the value arguments are vectors of the same size, then an entire vector is selected."
msgstr "如果条件是i1并且值参数是相同大小的向量，则选择整个向量。"

#: ../../LangRef.rst:8266
msgid "'``call``' Instruction"
msgstr "'``call``'指令"

#: ../../LangRef.rst:8279
msgid "The '``call``' instruction represents a simple function call."
msgstr "'``call``'指令代表一个简单的函数调用。"

#: ../../LangRef.rst:8286
msgid "The optional ``tail`` and ``musttail`` markers indicate that the optimizers should perform tail call optimization. The ``tail`` marker is a hint that `can be ignored <CodeGenerator.html#sibcallopt>`_. The ``musttail`` marker means that the call must be tail call optimized in order for the program to be correct. The ``musttail`` marker provides these guarantees:"
msgstr "可选的``tail``和``musttail``标记表示优化器应该执行尾调用优化。 ``tail``标记是一个提示，可以忽略<CodeGenerator.html＃sibcallopt>`_。 ``musttail``标记意味着调用必须是尾调用优化，以使程序正确。 ``musttail``标记提供以下保证："

#: ../../LangRef.rst:8292
msgid "The call will not cause unbounded stack growth if it is part of a recursive cycle in the call graph."
msgstr "如果调用是调用图中递归循环的一部分，则调用不会导致无限堆栈增长。"

#: ../../LangRef.rst:8294
msgid "Arguments with the :ref:`inalloca <attr_inalloca>` attribute are forwarded in place."
msgstr "使用：ref：`inalloca <attr_inalloca>`属性的参数将被转发到位。"

#: ../../LangRef.rst:8297
msgid "Both markers imply that the callee does not access allocas or varargs from the caller. Calls marked ``musttail`` must obey the following additional rules:"
msgstr "两个标记都暗示被调用者不会从调用者访问allocas或varargs。标记为“musttail”的呼叫必须遵守以下附加规则："

#: ../../LangRef.rst:8301
msgid "The call must immediately precede a :ref:`ret <i_ret>` instruction, or a pointer bitcast followed by a ret instruction."
msgstr "调用必须紧跟在：ref：`ret <i_ret>`指令之前，或指针bitcast之后是ret指令。"

#: ../../LangRef.rst:8303
msgid "The ret instruction must return the (possibly bitcasted) value produced by the call or void."
msgstr "ret指令必须返回由call或void产生的（可能是bitcasted）值。"

#: ../../LangRef.rst:8305
msgid "The caller and callee prototypes must match. Pointer types of parameters or return types may differ in pointee type, but not in address space."
msgstr "调用者和被调用者原型必须匹配。指针类型的参数或返回类型可能在指针类型中有所不同，但在地址空间中可能不同。"

#: ../../LangRef.rst:8308
msgid "The calling conventions of the caller and callee must match."
msgstr "调用者和被调用者的调用约定必须匹配。"

#: ../../LangRef.rst:8309
msgid "All ABI-impacting function attributes, such as sret, byval, inreg, returned, and inalloca, must match."
msgstr "所有影响ABI的函数属性，例如sret，byval，inreg，return和inalloca，必须匹配。"

#: ../../LangRef.rst:8311
msgid "The callee must be varargs iff the caller is varargs. Bitcasting a non-varargs function to the appropriate varargs type is legal so long as the non-varargs prefixes obey the other rules."
msgstr "如果调用者是varargs，则被调用者必须是varargs。只要非varargs前缀遵循其他规则，将非varargs函数绑定到适当的varargs类型是合法的。"

#: ../../LangRef.rst:8315
msgid "Tail call optimization for calls marked ``tail`` is guaranteed to occur if the following conditions are met:"
msgstr "如果满足以下条件，则保证发生标记为``tail``的呼叫的尾调用优化："

#: ../../LangRef.rst:8318
msgid "Caller and callee both have the calling convention ``fastcc``."
msgstr "调用者和被调用者都有调用约定``fastcc``。"

#: ../../LangRef.rst:8319
msgid "The call is in tail position (ret immediately follows call and ret uses value of call or is void)."
msgstr "呼叫处于尾部位置（紧跟呼叫后ret，ret使用呼叫值或无效）。"

#: ../../LangRef.rst:8321
msgid "Option ``-tailcallopt`` is enabled, or ``llvm::GuaranteedTailCallOpt`` is ``true``."
msgstr "选项``-tailcallopt``已启用，或``llvm :: GuaranteedTailCallOpt``为``true``。"

#: ../../LangRef.rst:8323
msgid "`Platform-specific constraints are met. <CodeGenerator.html#tailcallopt>`_"
msgstr "`满足平台特定的约束。 <CodeGenerator.html＃tailcallopt>`_"

#: ../../LangRef.rst:8326
msgid "The optional ``notail`` marker indicates that the optimizers should not add ``tail`` or ``musttail`` markers to the call. It is used to prevent tail call optimization from being performed on the call."
msgstr "可选的``notail``标记表示优化器不应该在调用中添加``tail``或``musttail``标记。它用于防止对呼叫执行尾调用优化。"

#: ../../LangRef.rst:8330
msgid "The optional ``fast-math flags`` marker indicates that the call has one or more :ref:`fast-math flags <fastmath>`, which are optimization hints to enable otherwise unsafe floating-point optimizations. Fast-math flags are only valid for calls that return a floating-point scalar or vector type."
msgstr "可选的``fast-math flags``标记表示调用有一个或多个：ref：`fast-math flags <fastmath>`，它们是优化提示，用于启用其他不安全的浮点优化。快速数学标志仅对返回浮点标量或向量类型的调用有效。"

#: ../../LangRef.rst:8335
msgid "The optional \"cconv\" marker indicates which :ref:`calling convention <callingconv>` the call should use. If none is specified, the call defaults to using C calling conventions. The calling convention of the call must match the calling convention of the target function, or else the behavior is undefined."
msgstr "可选的\\“cconv \\”标记指示调用应该使用的：ref：`calling convention <callingconv>`。如果未指定，则调用默认使用C调用约定。调用的调用约定必须与目标函数的调用约定匹配，否则行为是未定义的。"

#: ../../LangRef.rst:8343
msgid "'``ty``': the type of the call instruction itself which is also the type of the return value. Functions that return no value are marked ``void``."
msgstr "'``ty``'：调用指令本身的类型，它也是返回值的类型。不返回任何值的函数标记为``void``。"

#: ../../LangRef.rst:8346
msgid "'``fnty``': shall be the signature of the pointer to function value being invoked. The argument types must match the types implied by this signature. This type can be omitted if the function is not varargs and if the function type does not return a pointer to a function."
msgstr "'``fnty``'：应该是调用函数值的指针的签名。参数类型必须与此签名隐含的类型匹配。如果函数不是varargs并且函数类型没有返回指向函数的指针，则可以省略此类型。"

#: ../../LangRef.rst:8351
msgid "'``fnptrval``': An LLVM value containing a pointer to a function to be invoked. In most cases, this is a direct function invocation, but indirect ``call``'s are just as possible, calling an arbitrary pointer to function value."
msgstr "'``fnptrval``'：一个LLVM值，包含一个指向要调用的函数的指针。在大多数情况下，这是一个直接的函数调用，但间接的``call``是尽可能的，调用一个指向函数值的任意指针。"

#: ../../LangRef.rst:8368
msgid "The '``call``' instruction is used to cause control flow to transfer to a specified function, with its incoming arguments bound to the specified values. Upon a '``ret``' instruction in the called function, control flow continues with the instruction after the function call, and the return value of the function is bound to the result argument."
msgstr "'``call``'指令用于使控制流转移到指定的函数，其传入的参数绑定到指定的值。在被调用函数中的'``ret``'指令后，控制流继续执行函数调用后的指令，并将函数的返回值绑定到result参数。"

#: ../../LangRef.rst:8392
msgid "llvm treats calls to some functions with names and arguments that match the standard C99 library as being the C99 library functions, and may perform optimizations or generate code for them under that assumption. This is something we'd like to change in the future to provide better support for freestanding environments and non-C-based languages."
msgstr "llvm将具有与标准C99库匹配的名称和参数的某些函数的调用视为C99库函数，并且可以在该假设下执行优化或为它们生成代码。这是我们将来要改变的，以便为独立环境和非基于C的语言提供更好的支持。"

#: ../../LangRef.rst:8401
msgid "'``va_arg``' Instruction"
msgstr "'``va_arg``'指令"

#: ../../LangRef.rst:8413
msgid "The '``va_arg``' instruction is used to access arguments passed through the \"variable argument\" area of a function call. It is used to implement the ``va_arg`` macro in C."
msgstr "'``va_arg``'指令用于访问通过函数调用的\\“variable argument \\”区域传递的参数。它用于在C中实现``va_arg``宏。"

#: ../../LangRef.rst:8420
msgid "This instruction takes a ``va_list*`` value and the type of the argument. It returns a value of the specified argument type and increments the ``va_list`` to point to the next argument. The actual type of ``va_list`` is target specific."
msgstr "该指令采用``va_list *``值和参数的类型。它返回指定参数类型的值，并递增“va_list”以指向下一个参数。 “va_list”的实际类型是特定于目标的。"

#: ../../LangRef.rst:8428
msgid "The '``va_arg``' instruction loads an argument of the specified type from the specified ``va_list`` and causes the ``va_list`` to point to the next argument. For more information, see the variable argument handling :ref:`Intrinsic Functions <int_varargs>`."
msgstr "'``va_arg``'指令从指定的``va_list``加载指定类型的参数，并使``va_list``指向下一个参数。有关更多信息，请参阅变量参数处理：ref：`Intrinsic Functions <int_varargs>`。"

#: ../../LangRef.rst:8433
msgid "It is legal for this instruction to be called in a function which does not take a variable number of arguments, for example, the ``vfprintf`` function."
msgstr "在不接受可变数量参数的函数中调用此指令是合法的，例如，``vfprintf``函数。"

#: ../../LangRef.rst:8437
msgid "``va_arg`` is an LLVM instruction instead of an :ref:`intrinsic function <intrinsics>` because it takes a type as an argument."
msgstr "``va_arg``是一个LLVM指令而不是：ref：`内部函数<intrinsics>`因为它将一个类型作为参数。"

#: ../../LangRef.rst:8443
msgid "See the :ref:`variable argument processing <int_varargs>` section."
msgstr "请参阅：ref：`变量参数处理<int_varargs>`部分。"

#: ../../LangRef.rst:8445
msgid "Note that the code generator does not yet fully support va\\_arg on many targets. Also, it does not currently support va\\_arg with aggregate types on any target."
msgstr "请注意，代码生成器尚未完全支持许多目标上的va \\ _ arg。此外，它目前不支持任何目标上具有聚合类型的va \\ _ arg。"

#: ../../LangRef.rst:8452
msgid "'``landingpad``' Instruction"
msgstr "'``landingpad``'指令"

#: ../../LangRef.rst:8468
msgid "The '``landingpad``' instruction is used by `LLVM's exception handling system <ExceptionHandling.html#overview>`_ to specify that a basic block is a landing pad --- one where the exception lands, and corresponds to the code found in the ``catch`` portion of a ``try``/``catch`` sequence. It defines values supplied by the :ref:`personality function <personalityfn>` upon re-entry to the function. The ``resultval`` has the type ``resultty``."
msgstr "```landingpad``'指令被'LLVM的异常处理系统<ExceptionHandling.html＃overview>`_用来指定一个基本块是一个着陆点---异常落地的一个，对应代码发现在``try`` /``catch``序列的``catch``部分。它定义了在重新进入函数时由：ref：`personality function <personalityfn>`提供的值。 ``resultval``的类型为``resultty``。"

#: ../../LangRef.rst:8478
msgid "The optional ``cleanup`` flag indicates that the landing pad block is a cleanup."
msgstr "可选的``cleanup``标志表示着陆垫块是清理。"

#: ../../LangRef.rst:8481
msgid "A ``clause`` begins with the clause type --- ``catch`` or ``filter`` --- and contains the global variable representing the \"type\" that may be caught or filtered respectively. Unlike the ``catch`` clause, the ``filter`` clause takes an array constant as its argument. Use \"``[0 x i8**] undef``\" for a filter which cannot throw. The '``landingpad``' instruction must contain *at least* one ``clause`` or the ``cleanup`` flag."
msgstr "``clause``以子句类型---``catch``或``filter`` ---开头，并包含表示可以分别捕获或过滤的\\“type \\”的全局变量。与``catch``子句不同，``filter``子句将数组常量作为参数。使用\\“```[0 x i8 **] undef`` \\”对于不能抛出的过滤器。 '``landingpad``'指令必须包含*至少* one``子句``或``cleanup``标志。"

#: ../../LangRef.rst:8492
msgid "The '``landingpad``' instruction defines the values which are set by the :ref:`personality function <personalityfn>` upon re-entry to the function, and therefore the \"result type\" of the ``landingpad`` instruction. As with calling conventions, how the personality function results are represented in LLVM IR is target specific."
msgstr "'``landingpad``'指令定义了在重新进入函数时由：ref：`个性函数<personalityfn>`设置的值，因此定义了``landingpad`的“结果类型”。 `指示。与调用约定一样，LLVM IR中表示的个性函数结果如何是特定于目标的。"

#: ../../LangRef.rst:8498
msgid "The clauses are applied in order from top to bottom. If two ``landingpad`` instructions are merged together through inlining, the clauses from the calling function are appended to the list of clauses. When the call stack is being unwound due to an exception being thrown, the exception is compared against each ``clause`` in turn. If it doesn't match any of the clauses, and the ``cleanup`` flag is not set, then unwinding continues further up the call stack."
msgstr "这些条款从上到下依次应用。如果两个``landingpad``指令通过内联合并在一起，则来自调用函数的子句将附加到子句列表中。当由于抛出异常而展开调用堆栈时，异常将依次与每个“子句”进行比较。如果它与任何子句都不匹配，并且未设置``cleanup``标志，那么展开将继续向上调用堆栈。"

#: ../../LangRef.rst:8506
msgid "The ``landingpad`` instruction has several restrictions:"
msgstr "``landingpad``指令有几个限制："

#: ../../LangRef.rst:8508
msgid "A landing pad block is a basic block which is the unwind destination of an '``invoke``' instruction."
msgstr "着陆块块是一个基本块，它是'`invoke``'指令的展开目标。"

#: ../../LangRef.rst:8510
msgid "A landing pad block must have a '``landingpad``' instruction as its first non-PHI instruction."
msgstr "一个着陆垫块必须有一个'``landingpad``'指令作为它的第一个非PHI指令。"

#: ../../LangRef.rst:8512
msgid "There can be only one '``landingpad``' instruction within the landing pad block."
msgstr "在着陆垫块中只能有一个'``landingpad``'指令。"

#: ../../LangRef.rst:8514
msgid "A basic block that is not a landing pad block may not include a '``landingpad``' instruction."
msgstr "不是着陆垫块的基本块可能不包括'``landingpad``'指令。"

#: ../../LangRef.rst:8536
msgid "'``catchpad``' Instruction"
msgstr "'``catchpad``'指令"

#: ../../LangRef.rst:8548
msgid "The '``catchpad``' instruction is used by `LLVM's exception handling system <ExceptionHandling.html#overview>`_ to specify that a basic block begins a catch handler --- one where a personality routine attempts to transfer control to catch an exception."
msgstr "```catchpad``'指令被'LLVM的异常处理系统<ExceptionHandling.html＃overview>`_用来指定一个基本块开始一个catch处理程序---一个个性例程试图将控制转移到catch一个例外。"

#: ../../LangRef.rst:8556
msgid "The ``catchswitch`` operand must always be a token produced by a :ref:`catchswitch <i_catchswitch>` instruction in a predecessor block. This ensures that each ``catchpad`` has exactly one predecessor block, and it always terminates in a ``catchswitch``."
msgstr "``catchswitch``操作数必须始终是由前导块中的：ref：`catchswitch <i_catchswitch>'指令生成的标记。这确保了每个``catchpad``只有一个前导块，它总是以``catchswitch``结束。"

#: ../../LangRef.rst:8561
msgid "The ``args`` correspond to whatever information the personality routine requires to know if this is an appropriate handler for the exception. Control will transfer to the ``catchpad`` if this is the first appropriate handler for the exception."
msgstr "``args``对应于个性例程需要知道的任何信息，如果这是异常的适当处理程序。如果这是异常的第一个合适的处理程序，控件将转移到``catchpad``。"

#: ../../LangRef.rst:8566
msgid "The ``resultval`` has the type :ref:`token <t_token>` and is used to match the ``catchpad`` to corresponding :ref:`catchrets <i_catchret>` and other nested EH pads."
msgstr "``resultval``的类型为：ref：`token <t_token>`，用于匹配``catchpad``到对应的：ref：`catchrets <i_catchret>`和其他嵌套的EH pad。"

#: ../../LangRef.rst:8573
msgid "When the call stack is being unwound due to an exception being thrown, the exception is compared against the ``args``. If it doesn't match, control will not reach the ``catchpad`` instruction.  The representation of ``args`` is entirely target and personality function-specific."
msgstr "当由于抛出异常而展开调用堆栈时，异常将与``args``进行比较。如果不匹配，控件将不会到达``catchpad``指令。 “args”的表示完全是目标和个性功能特定的。"

#: ../../LangRef.rst:8578
msgid "Like the :ref:`landingpad <i_landingpad>` instruction, the ``catchpad`` instruction must be the first non-phi of its parent basic block."
msgstr "像：ref：`landingpad <i_landingpad>`指令一样，``catchpad``指令必须是其父基本块的第一个非phi。"

#: ../../LangRef.rst:8581
msgid "The meaning of the tokens produced and consumed by ``catchpad`` and other \"pad\" instructions is described in the `Windows exception handling documentation\\ <ExceptionHandling.html#wineh>`_."
msgstr "由``catchpad``和其他“pad”指令生成和使用的标记的含义在`Windows异常处理文档\\ <ExceptionHandling.html＃wineh>`_中描述。"

#: ../../LangRef.rst:8585
msgid "When a ``catchpad`` has been \"entered\" but not yet \"exited\" (as described in the `EH documentation\\ <ExceptionHandling.html#wineh-constraints>`_), it is undefined behavior to execute a :ref:`call <i_call>` or :ref:`invoke <i_invoke>` that does not carry an appropriate :ref:`\"funclet\" bundle <ob_funclet>`."
msgstr "当一个``catchpad``已被“输入”但尚未“退出”时（如'EH文档\\ <ExceptionHandling.html＃wineh-constraints>`_中所述），它是未定义的行为执行a：ref：`call <i_call>`或：ref：`invoke <i_invoke>`没有合适的：ref：`\\“funclet \\”bundle <ob_funclet>`。"

#: ../../LangRef.rst:8604
msgid "'``cleanuppad``' Instruction"
msgstr "'``cleanuppad``'指令"

#: ../../LangRef.rst:8616
msgid ""
"The '``cleanuppad``' instruction is used by `LLVM's exception handling system <ExceptionHandling.html#overview>`_ to specify that a basic block is a cleanup block --- one where a personality routine attempts to transfer control to run cleanup actions. The ``args`` correspond to whatever additional information the :ref:`personality function <personalityfn>` requires to execute the cleanup. The ``resultval`` has the type :ref:`token <t_token>` and is used to match the ``cleanuppad`` to corresponding :ref:`cleanuprets <i_cleanupret>`. The ``parent`` argument is the token "
"of the funclet that contains the ``cleanuppad`` instruction. If the ``cleanuppad`` is not inside a funclet, this operand may be the token ``none``."
msgstr "'``cleanuppad``'指令由`LLVM的异常处理系统<ExceptionHandling.html＃overview>`_用来指定一个基本块是一个清理块---一个个性例程试图将控制转移到运行的块清理行动。 ``args``对应于以下任何附加信息：ref：`personality function <personalityfn>`需要执行清理。 ``resultval``的类型为：ref：`token <t_token>`，用于将``cleanuppad``与相应的匹配：ref：`cleanuprets <i_cleanupret>`。 ``parent``参数是包含``cleanuppad``指令的funclet的标记。如果``cleanuppad``不在funclet中，那么这个操作数可能是令牌``none``。"

#: ../../LangRef.rst:8632
msgid "The instruction takes a list of arbitrary values which are interpreted by the :ref:`personality function <personalityfn>`."
msgstr "该指令采用由以下内容解释的任意值列表：ref：`personality function <personalityfn>`。"

#: ../../LangRef.rst:8638
msgid "When the call stack is being unwound due to an exception being thrown, the :ref:`personality function <personalityfn>` transfers control to the ``cleanuppad`` with the aid of the personality-specific arguments. As with calling conventions, how the personality function results are represented in LLVM IR is target specific."
msgstr "当由于抛出异常而解开调用堆栈时，：ref：`personality function <personalityfn>`借助特定于个性的参数将控制转移到``cleanuppad``。与调用约定一样，LLVM IR中表示的个性函数结果如何是特定于目标的。"

#: ../../LangRef.rst:8644
msgid "The ``cleanuppad`` instruction has several restrictions:"
msgstr "``cleanuppad``指令有几个限制："

#: ../../LangRef.rst:8646
msgid "A cleanup block is a basic block which is the unwind destination of an exceptional instruction."
msgstr "清理块是一个基本块，它是异常指令的展开目标。"

#: ../../LangRef.rst:8648
msgid "A cleanup block must have a '``cleanuppad``' instruction as its first non-PHI instruction."
msgstr "清理块必须有一个'``cleanuppad``'指令作为其第一个非PHI指令。"

#: ../../LangRef.rst:8650
msgid "There can be only one '``cleanuppad``' instruction within the cleanup block."
msgstr "清理块中只能有一个'``cleanuppad``'指令。"

#: ../../LangRef.rst:8652
msgid "A basic block that is not a cleanup block may not include a '``cleanuppad``' instruction."
msgstr "不是清理块的基本块可能不包含'``cleanuppad``'指令。"

#: ../../LangRef.rst:8655
msgid "When a ``cleanuppad`` has been \"entered\" but not yet \"exited\" (as described in the `EH documentation\\ <ExceptionHandling.html#wineh-constraints>`_), it is undefined behavior to execute a :ref:`call <i_call>` or :ref:`invoke <i_invoke>` that does not carry an appropriate :ref:`\"funclet\" bundle <ob_funclet>`."
msgstr "当``cleanuppad``已被“输入”但尚未“退出”时（如'EH文档\\ <ExceptionHandling.html＃wineh-constraints>`_中所述），它是未定义的行为执行a：ref：`call <i_call>`或：ref：`invoke <i_invoke>`没有合适的：ref：`\\“funclet \\”bundle <ob_funclet>`。"

#: ../../LangRef.rst:8670
msgid "Intrinsic Functions"
msgstr "内在函数"

#: ../../LangRef.rst:8672
msgid "LLVM supports the notion of an \"intrinsic function\". These functions have well known names and semantics and are required to follow certain restrictions. Overall, these intrinsics represent an extension mechanism for the LLVM language that does not require changing all of the transformations in LLVM when adding to the language (or the bitcode reader/writer, the parser, etc...)."
msgstr "LLVM支持“内在函数”的概念。这些函数具有众所周知的名称和语义，并且必须遵循某些限制。总的来说，这些内在函数代表了LLVM语言的扩展机制，它不需要在添加到语言（或bitcode读取器/写入器，解析器等等）时更改LLVM中的所有转换。"

#: ../../LangRef.rst:8679
msgid "Intrinsic function names must all start with an \"``llvm.``\" prefix. This prefix is reserved in LLVM for intrinsic names; thus, function names may not begin with this prefix. Intrinsic functions must always be external functions: you cannot define the body of intrinsic functions. Intrinsic functions may only be used in call or invoke instructions: it is illegal to take the address of an intrinsic function. Additionally, because intrinsic functions are part of the LLVM language, it is required if any are added that they be documented here."
msgstr "内在函数名必须以一个“llvm .` \\”前缀开头。 LLVM中为内在名称保留此前缀;因此，函数名称不能以此前缀开头。内在函数必须始终是外部函数：您不能定义内部函数的主体。内部函数只能用于调用或调用指令：获取内部函数的地址是非法的。此外，由于内部函数是LLVM语言的一部分，因此如果添加任何内容函数，则需要在此处进行记录。"

#: ../../LangRef.rst:8688
msgid ""
"Some intrinsic functions can be overloaded, i.e., the intrinsic represents a family of functions that perform the same operation but on different data types. Because LLVM can represent over 8 million different integer types, overloading is used commonly to allow an intrinsic function to operate on any integer type. One or more of the argument types or the result type can be overloaded to accept any integer type. Argument types may also be defined as exactly matching a previous argument's type or the result type. This allows an intrinsic function which accepts multiple "
"arguments, but needs all of them to be of the same type, to only be overloaded with respect to a single argument or the result."
msgstr "一些内部函数可以重载，即内在函数表示执行相同操作但在不同数据类型上的一系列函数。因为LLVM可以表示超过800万种不同的整数类型，所以通常使用重载来允许内部函数对任何整数类型进行操作。可以重载一个或多个参数类型或结果类型以接受任何整数类型。参数类型也可以定义为与先前参数的类型或结果类型完全匹配。这允许一个内部函数接受多个参数，但需要它们都是相同的类型，只能相对于单个参数或结果重载。"

#: ../../LangRef.rst:8700
msgid ""
"Overloaded intrinsics will have the names of its overloaded argument types encoded into its function name, each preceded by a period. Only those types which are overloaded result in a name suffix. Arguments whose type is matched against another type do not. For example, the ``llvm.ctpop`` function can take an integer of any width and returns an integer of exactly the same integer width. This leads to a family of functions such as ``i8 @llvm.ctpop.i8(i8 %val)`` and ``i29 @llvm.ctpop.i29(i29 %val)``. Only one type, the return type, is overloaded, and only one type "
"suffix is required. Because the argument's type is matched against the return type, it does not require its own name suffix."
msgstr "重载的内在函数将其重载的参数类型的名称编码到其函数名称中，每个名称前面都有一个句点。只有那些重载的类型才会生成名称后缀。类型与另一种类型匹配的参数不会。例如，``llvm.ctpop``函数可以取任何宽度的整数，并返回一个完全相同的整数宽度的整数。这导致了一系列函数，例如``i8 @ llvm.ctpop.i8（i8％val）``和``i29 @ llvm.ctpop.i29（i29％val）``。只有一种类型（返回类型）被重载，并且只需要一个类型后缀。因为参数的类型与返回类型匹配，所以它不需要自己的名称后缀。"

#: ../../LangRef.rst:8712
msgid "To learn how to add an intrinsic function, please see the `Extending LLVM Guide <ExtendingLLVM.html>`_."
msgstr "要了解如何添加内部函数，请参阅“扩展LLVM指南<ExtendingLLVM.html>`_。"

#: ../../LangRef.rst:8718
msgid "Variable Argument Handling Intrinsics"
msgstr "变量参数处理内在函数"

#: ../../LangRef.rst:8720
msgid "Variable argument support is defined in LLVM with the :ref:`va_arg <i_va_arg>` instruction and these three intrinsic functions. These functions are related to the similarly named macros defined in the ``<stdarg.h>`` header file."
msgstr "LLVM中使用：ref：`va_arg <i_va_arg>`指令和这三个内部函数定义变量参数支持。这些函数与``<stdarg.h>``头文件中定义的类似命名的宏有关。"

#: ../../LangRef.rst:8725
msgid "All of these functions operate on arguments that use a target-specific value type \"``va_list``\". The LLVM assembly language reference manual does not define what this type is, so all transformations should be prepared to handle these functions regardless of the type used."
msgstr "所有这些函数都在使用特定于目标的值类型“va_list`` \\”的参数上运行。 LLVM汇编语言参考手册未定义此类型的内容，因此无论使用何种类型，都应准备好所有转换以处理这些函数。"

#: ../../LangRef.rst:8730
msgid "This example shows how the :ref:`va_arg <i_va_arg>` instruction and the variable argument handling intrinsic functions are used."
msgstr "此示例显示如何使用：ref：`va_arg <i_va_arg>`指令和处理内部函数的变量参数。"

#: ../../LangRef.rst:8769
msgid "'``llvm.va_start``' Intrinsic"
msgstr "'`llvm.va_start``'内在"

#: ../../LangRef.rst:8781
msgid "The '``llvm.va_start``' intrinsic initializes ``*<arglist>`` for subsequent use by ``va_arg``."
msgstr "'`llvm.va_start``'内在函数初始化``* <arglist>``供`va_arg``后续使用。"

#: ../../LangRef.rst:8787
msgid "The argument is a pointer to a ``va_list`` element to initialize."
msgstr "参数是一个指向要初始化的``va_list``元素的指针。"

#: ../../LangRef.rst:8792
msgid "The '``llvm.va_start``' intrinsic works just like the ``va_start`` macro available in C. In a target-dependent way, it initializes the ``va_list`` element to which the argument points, so that the next call to ``va_arg`` will produce the first variable argument passed to the function. Unlike the C ``va_start`` macro, this intrinsic does not need to know the last argument of the function as the compiler can figure that out."
msgstr "'llvm.va_start``'内在函数就像C中可用的``va_start``宏一样。以目标依赖的方式，它初始化参数指向的``va_list``元素，这样下一次调用``va_arg``将产生传递给函数的第一个变量参数。与C``va_start``宏不同，这个内在函数不需要知道函数的最后一个参数，因为编译器可以解决这个问题。"

#: ../../LangRef.rst:8801
msgid "'``llvm.va_end``' Intrinsic"
msgstr "'`llvm.va_end``'内在"

#: ../../LangRef.rst:8813
msgid "The '``llvm.va_end``' intrinsic destroys ``*<arglist>``, which has been initialized previously with ``llvm.va_start`` or ``llvm.va_copy``."
msgstr "'llvm.va_end``'内在破坏了``* <arglist>``，它先前已经用``llvm.va_start``或``llvm.va_copy``初始化了。"

#: ../../LangRef.rst:8819
msgid "The argument is a pointer to a ``va_list`` to destroy."
msgstr "参数是指向要销毁的``va_list``的指针。"

#: ../../LangRef.rst:8824
msgid "The '``llvm.va_end``' intrinsic works just like the ``va_end`` macro available in C. In a target-dependent way, it destroys the ``va_list`` element to which the argument points. Calls to :ref:`llvm.va_start <int_va_start>` and :ref:`llvm.va_copy <int_va_copy>` must be matched exactly with calls to ``llvm.va_end``."
msgstr "'llvm.va_end``'内在函数就像C中可用的``va_end``宏一样。它依赖于目标，它会破坏参数所指向的``va_list``元素。调用：ref：`llvm.va_start <int_va_start>`和：ref：`llvm.va_copy <int_va_copy>`必须与对`llvm.va_end``的调用完全匹配。"

#: ../../LangRef.rst:8834
msgid "'``llvm.va_copy``' Intrinsic"
msgstr "'``llvm.va_copy``'内在"

#: ../../LangRef.rst:8846
msgid "The '``llvm.va_copy``' intrinsic copies the current argument position from the source argument list to the destination argument list."
msgstr "'`llvm.va_copy``'内在函数将当前参数位置从源参数列表复制到目标参数列表。"

#: ../../LangRef.rst:8852
msgid "The first argument is a pointer to a ``va_list`` element to initialize. The second argument is a pointer to a ``va_list`` element to copy from."
msgstr "第一个参数是一个指向要初始化的``va_list``元素的指针。第二个参数是指向要复制的``va_list``元素的指针。"

#: ../../LangRef.rst:8858
msgid "The '``llvm.va_copy``' intrinsic works just like the ``va_copy`` macro available in C. In a target-dependent way, it copies the source ``va_list`` element into the destination ``va_list`` element. This intrinsic is necessary because the `` llvm.va_start`` intrinsic may be arbitrarily complex and require, for example, memory allocation."
msgstr "'llvm.va_copy``'内在函数就像C中可用的``va_copy``宏一样。它以依赖于目标的方式将源``va_list``元素复制到目标``va_list``中。元件。这个内在函数是必要的，因为``llvm.va_start``内在函数可能是任意复杂的，并且需要例如内存分配。"

#: ../../LangRef.rst:8865
msgid "Accurate Garbage Collection Intrinsics"
msgstr "准确的垃圾收集内在"

#: ../../LangRef.rst:8867
msgid "LLVM's support for `Accurate Garbage Collection <GarbageCollection.html>`_ (GC) requires the frontend to generate code containing appropriate intrinsic calls and select an appropriate GC strategy which knows how to lower these intrinsics in a manner which is appropriate for the target collector."
msgstr "LLVM支持“精确垃圾收集<GarbageCollection.html”`_（GC）要求前端生成包含适当内部调用的代码，并选择适当的GC策略，该策略知道如何以适合目标收集器的方式降低这些内在函数。"

#: ../../LangRef.rst:8872
msgid "These intrinsics allow identification of :ref:`GC roots on the stack <int_gcroot>`, as well as garbage collector implementations that require :ref:`read <int_gcread>` and :ref:`write <int_gcwrite>` barriers. Frontends for type-safe garbage collected languages should generate these intrinsics to make use of the LLVM garbage collectors. For more details, see `Garbage Collection with LLVM <GarbageCollection.html>`_."
msgstr "这些内在函数允许识别：ref：`GC根目录在堆栈<int_gcroot>`，以及垃圾收集器实现，它们需要：ref：`read <int_gcread>`和：ref：`write <int_gcwrite>`barrier。类型安全垃圾收集语言的前端应生成这些内在函数以利用LLVM垃圾收集器。有关更多详细信息，请参阅“使用LLVM的垃圾收集<GarbageCollection.html>`_。"

#: ../../LangRef.rst:8880
msgid "Experimental Statepoint Intrinsics"
msgstr "实验状态内在函数"

#: ../../LangRef.rst:8882
msgid "LLVM provides an second experimental set of intrinsics for describing garbage collection safepoints in compiled code. These intrinsics are an alternative to the ``llvm.gcroot`` intrinsics, but are compatible with the ones for :ref:`read <int_gcread>` and :ref:`write <int_gcwrite>` barriers. The differences in approach are covered in the `Garbage Collection with LLVM <GarbageCollection.html>`_ documentation. The intrinsics themselves are described in :doc:`Statepoints`."
msgstr "LLVM提供了第二组实体内在函数，用于描述编译代码中的垃圾收集安全点。这些内在函数是``llvm.gcroot``内在函数的替代品，但它与以下内容兼容：ref：`read <int_gcread>`和：ref：`write <int_gcwrite>`barrier。 “垃圾收集与LLVM <GarbageCollection.html>”_文档中介绍了方法的不同之处。内在函数本身描述于：doc：`Statepoints`。"

#: ../../LangRef.rst:8893
msgid "'``llvm.gcroot``' Intrinsic"
msgstr "'`llvm.gcroot``'内在"

#: ../../LangRef.rst:8905
msgid "The '``llvm.gcroot``' intrinsic declares the existence of a GC root to the code generator, and allows some metadata to be associated with it."
msgstr "'`llvm.gcroot``'内在声明了代码生成器中存在GC根，并允许一些元数据与它相关联。"

#: ../../LangRef.rst:8911
msgid "The first argument specifies the address of a stack object that contains the root pointer. The second pointer (which must be either a constant or a global value address) contains the meta-data to be associated with the root."
msgstr "第一个参数指定包含根指针的堆栈对象的地址。第二个指针（必须是常量或全局值地址）包含与根关联的元数据。"

#: ../../LangRef.rst:8919
msgid "At runtime, a call to this intrinsic stores a null pointer into the \"ptrloc\" location. At compile-time, the code generator generates information to allow the runtime to find the pointer at GC safe points. The '``llvm.gcroot``' intrinsic may only be used in a function which :ref:`specifies a GC algorithm <gc>`."
msgstr "在运行时，对此内在函数的调用将空指针存储到\\“ptrloc \\”位置。在编译时，代码生成器生成信息以允许运行时在GC安全点处查找指针。 'llvm.gcroot``'内在函数只能用于以下函数：ref：`指定GC算法<gc>`。"

#: ../../LangRef.rst:8928
msgid "'``llvm.gcread``' Intrinsic"
msgstr "'``llvm.gcread``'内在"

#: ../../LangRef.rst:8940
msgid "The '``llvm.gcread``' intrinsic identifies reads of references from heap locations, allowing garbage collector implementations that require read barriers."
msgstr "'`llvm.gcread``'内在标识从堆位置读取引用，允许垃圾收集器实现需要读取障碍。"

#: ../../LangRef.rst:8947
msgid "The second argument is the address to read from, which should be an address allocated from the garbage collector. The first object is a pointer to the start of the referenced object, if needed by the language runtime (otherwise null)."
msgstr "第二个参数是要读取的地址，该地址应该是从垃圾收集器分配的地址。如果语言运行库需要，则第一个对象是指向引用对象的开头的指针（否则为null）。"

#: ../../LangRef.rst:8955
msgid "The '``llvm.gcread``' intrinsic has the same semantics as a load instruction, but may be replaced with substantially more complex code by the garbage collector runtime, as needed. The '``llvm.gcread``' intrinsic may only be used in a function which :ref:`specifies a GC algorithm <gc>`."
msgstr "'llvm.gcread``'内在函数与加载指令具有相同的语义，但可以根据需要由垃圾收集器运行时替换为更复杂的代码。 'llvm.gcread``'内在函数只能用于以下函数：ref：`指定GC算法<gc>`。"

#: ../../LangRef.rst:8964
msgid "'``llvm.gcwrite``' Intrinsic"
msgstr "'`llvm.gcwrite``'内在"

#: ../../LangRef.rst:8976
msgid "The '``llvm.gcwrite``' intrinsic identifies writes of references to heap locations, allowing garbage collector implementations that require write barriers (such as generational or reference counting collectors)."
msgstr "'`llvm.gcwrite``'内在函数标识对堆位置的引用的写入，允许需要写入障碍的垃圾收集器实现（例如代数或引用计数收集器）。"

#: ../../LangRef.rst:8983
msgid "The first argument is the reference to store, the second is the start of the object to store it to, and the third is the address of the field of Obj to store to. If the runtime does not require a pointer to the object, Obj may be null."
msgstr "第一个参数是对store的引用，第二个参数是存储它的对象的开始，第三个参数是要存储的Obj字段的地址。如果运行时不需要指向对象的指针，则Obj可以为null。"

#: ../../LangRef.rst:8991
msgid "The '``llvm.gcwrite``' intrinsic has the same semantics as a store instruction, but may be replaced with substantially more complex code by the garbage collector runtime, as needed. The '``llvm.gcwrite``' intrinsic may only be used in a function which :ref:`specifies a GC algorithm <gc>`."
msgstr "'llvm.gcwrite``'内在函数与存储指令具有相同的语义，但可以根据需要由垃圾收集器运行时替换为实质上更复杂的代码。 '`llvm.gcwrite``'内在函数只能用于以下函数：ref：`指定GC算法<gc>`。"

#: ../../LangRef.rst:8998
msgid "Code Generator Intrinsics"
msgstr "代码生成器内在函数"

#: ../../LangRef.rst:9000
msgid "These intrinsics are provided by LLVM to expose special features that may only be implemented with code generator support."
msgstr "这些内在函数由LLVM提供，用于公开可能仅通过代码生成器支持实现的特殊功能。"

#: ../../LangRef.rst:9004
msgid "'``llvm.returnaddress``' Intrinsic"
msgstr "''llvm.returnaddress``'内在"

#: ../../LangRef.rst:9016
msgid "The '``llvm.returnaddress``' intrinsic attempts to compute a target-specific value indicating the return address of the current function or one of its callers."
msgstr "'llvm.returnaddress``'内在尝试计算特定于目标的值，指示当前函数或其中一个调用者的返回地址。"

#: ../../LangRef.rst:9023
msgid "The argument to this intrinsic indicates which function to return the address for. Zero indicates the calling function, one indicates its caller, etc. The argument is **required** to be a constant integer value."
msgstr "此内在函数的参数指示返回地址的函数。零表示调用函数，一个表示调用函数，等等。参数** ** **为常量整数值。"

#: ../../LangRef.rst:9031
msgid "The '``llvm.returnaddress``' intrinsic either returns a pointer indicating the return address of the specified call frame, or zero if it cannot be identified. The value returned by this intrinsic is likely to be incorrect or 0 for arguments other than zero, so it should only be used for debugging purposes."
msgstr "'llvm.returnaddress``'内在函数返回指示指定调用帧的返回地址的指针，如果无法识别，则返回零。对于非零参数，此内在函数返回的值可能不正确或为0，因此它应仅用于调试目的。"

#: ../../LangRef.rst:9037 ../../LangRef.rst:9074
msgid "Note that calling this intrinsic does not prevent function inlining or other aggressive transformations, so the value returned may not be that of the obvious source-language caller."
msgstr "请注意，调用此内在函数不会阻止函数内联或其他积极转换，因此返回的值可能不是明显的源语言调用者的值。"

#: ../../LangRef.rst:9042
msgid "'``llvm.frameaddress``' Intrinsic"
msgstr "'`llvm.frameaddress``'内在"

#: ../../LangRef.rst:9054
msgid "The '``llvm.frameaddress``' intrinsic attempts to return the target-specific frame pointer value for the specified stack frame."
msgstr "'llvm.frameaddress``'内在尝试返回指定堆栈帧的特定于目标的帧指针值。"

#: ../../LangRef.rst:9060
msgid "The argument to this intrinsic indicates which function to return the frame pointer for. Zero indicates the calling function, one indicates its caller, etc. The argument is **required** to be a constant integer value."
msgstr "此内在函数的参数指示返回帧指针的函数。零表示调用函数，一个表示调用函数，等等。参数** ** **为常量整数值。"

#: ../../LangRef.rst:9068
msgid "The '``llvm.frameaddress``' intrinsic either returns a pointer indicating the frame address of the specified call frame, or zero if it cannot be identified. The value returned by this intrinsic is likely to be incorrect or 0 for arguments other than zero, so it should only be used for debugging purposes."
msgstr "'llvm.frameaddress``'内在函数返回指示指定调用帧的帧地址的指针，如果无法识别，则返回零。对于非零参数，此内在函数返回的值可能不正确或为0，因此它应仅用于调试目的。"

#: ../../LangRef.rst:9079
msgid "'``llvm.localescape``' and '``llvm.localrecover``' Intrinsics"
msgstr "'`llvm.localescape``'和'``llvm.localrecover``'Intrinsics"

#: ../../LangRef.rst:9092
msgid "The '``llvm.localescape``' intrinsic escapes offsets of a collection of static allocas, and the '``llvm.localrecover``' intrinsic applies those offsets to a live frame pointer to recover the address of the allocation. The offset is computed during frame layout of the caller of ``llvm.localescape``."
msgstr "'llvm.localescape``'内在转义了静态分配集合的偏移量，'`llvm.localrecover``'内在函数将这些偏移应用于实时帧指针以恢复分配的地址。在“llvm.localescape”的调用者的帧布局期间计算偏移量。"

#: ../../LangRef.rst:9100
msgid "All arguments to '``llvm.localescape``' must be pointers to static allocas or casts of static allocas. Each function can only call '``llvm.localescape``' once, and it can only do so from the entry block."
msgstr "“llvm.localescape``”的所有参数都必须是指向静态allocas的静态allocas或强制分配的指针。每个函数只能调用一次“llvm.localescape``”，它只能从入口块中调用。"

#: ../../LangRef.rst:9104
msgid "The ``func`` argument to '``llvm.localrecover``' must be a constant bitcasted pointer to a function defined in the current module. The code generator cannot determine the frame allocation offset of functions defined in other modules."
msgstr "'`llvm.localrecover``'的``func``参数必须是指向当前模块中定义的函数的常量bitcasted指针。代码生成器无法确定其他模块中定义的函数的帧分配偏移量。"

#: ../../LangRef.rst:9109
msgid "The ``fp`` argument to '``llvm.localrecover``' must be a frame pointer of a call frame that is currently live. The return value of '``llvm.localaddress``' is one way to produce such a value, but various runtimes also expose a suitable pointer in platform-specific ways."
msgstr "'`llvm.localrecover``'的``fp``参数必须是当前有效的调用帧的帧指针。 'llvm.localaddress``'的返回值是产生这样一个值的一种方法，但是各种运行时也以特定于平台的方式暴露了一个合适的指针。"

#: ../../LangRef.rst:9114
msgid "The ``idx`` argument to '``llvm.localrecover``' indicates which alloca passed to '``llvm.localescape``' to recover. It is zero-indexed."
msgstr "'`llvm.localrecover``'的``idx``参数表示哪个alloca传递给'``llvm.localescape``'来恢复。它是零索引的。"

#: ../../LangRef.rst:9120
msgid "These intrinsics allow a group of functions to share access to a set of local stack allocations of a one parent function. The parent function may call the '``llvm.localescape``' intrinsic once from the function entry block, and the child functions can use '``llvm.localrecover``' to access the escaped allocas. The '``llvm.localescape``' intrinsic blocks inlining, as inlining changes where the escaped allocas are allocated, which would break attempts to use '``llvm.localrecover``'."
msgstr "这些内在函数允许一组函数共享对一个父函数的一组本地堆栈分配的访问。父函数可以从函数入口块调用一次'`llvm.localescape``'内在函数，子函数可以使用'`llvm.localrecover``来访问转义的allocas。 'llvm.localescape``'内在块内联，因为内联更改了分配转义分配的位置，这会破坏使用'`llvm.localrecover``'的尝试。"

#: ../../LangRef.rst:9132
msgid "'``llvm.read_register``' and '``llvm.write_register``' Intrinsics"
msgstr "'``llvm.read_register``'和'``llvm.write_register``'Intrinsics"

#: ../../LangRef.rst:9148
msgid "The '``llvm.read_register``' and '``llvm.write_register``' intrinsics provides access to the named register. The register must be valid on the architecture being compiled to. The type needs to be compatible with the register being read."
msgstr "'llvm.read_register``'和'`llvm.write_register``'内在函数提供对命名寄存器的访问。该寄存器必须在要编译的体系结构上有效。该类型需要与正在读取的寄存器兼容。"

#: ../../LangRef.rst:9156
msgid "The '``llvm.read_register``' intrinsic returns the current value of the register, where possible. The '``llvm.write_register``' intrinsic sets the current value of the register, where possible."
msgstr "在可能的情况下，'`llvm.read_register``'内在函数返回寄存器的当前值。 'llvm.write_register``'内在函数尽可能设置寄存器的当前值。"

#: ../../LangRef.rst:9160
msgid "This is useful to implement named register global variables that need to always be mapped to a specific register, as is common practice on bare-metal programs including OS kernels."
msgstr "这对于实现需要始终映射到特定寄存器的命名寄存器全局变量很有用，这是包括OS内核在内的裸机程序的常见做法。"

#: ../../LangRef.rst:9164
msgid "The compiler doesn't check for register availability or use of the used register in surrounding code, including inline assembly. Because of that, allocatable registers are not supported."
msgstr "编译器不检查寄存器可用性或在周围代码中使用已使用的寄存器，包括内联汇编。因此，不支持可分配寄存器。"

#: ../../LangRef.rst:9168
msgid "Warning: So far it only works with the stack pointer on selected architectures (ARM, AArch64, PowerPC and x86_64). Significant amount of work is needed to support other registers and even more so, allocatable registers."
msgstr "警告：到目前为止，它仅适用于所选体系结构（ARM，AArch64，PowerPC和x86_64）上的堆栈指针。需要大量的工作来支持其他寄存器，甚至更多的可分配寄存器。"

#: ../../LangRef.rst:9176
msgid "'``llvm.stacksave``' Intrinsic"
msgstr "'``llvm.stacksave``'内在"

#: ../../LangRef.rst:9188
msgid "The '``llvm.stacksave``' intrinsic is used to remember the current state of the function stack, for use with :ref:`llvm.stackrestore <int_stackrestore>`. This is useful for implementing language features like scoped automatic variable sized arrays in C99."
msgstr "'llvm.stacksave``'内在函数用于记住函数堆栈的当前状态，用于：ref：`llvm.stackrestore <int_stackrestore>`。这对于实现C99中的作用域自动变量大小数组等语言功能非常有用。"

#: ../../LangRef.rst:9197
msgid "This intrinsic returns a opaque pointer value that can be passed to :ref:`llvm.stackrestore <int_stackrestore>`. When an ``llvm.stackrestore`` intrinsic is executed with a value saved from ``llvm.stacksave``, it effectively restores the state of the stack to the state it was in when the ``llvm.stacksave`` intrinsic executed. In practice, this pops any :ref:`alloca <i_alloca>` blocks from the stack that were allocated after the ``llvm.stacksave`` was executed."
msgstr "此内在函数返回一个不透明的指针值，可以传递给：ref：`llvm.stackrestore <int_stackrestore>`。当使用从`llvm.stacksave``保存的值执行``llvm.stackrestore``内在函数时，它有效地将堆栈状态恢复到执行``llvm.stacksave``内在时的状态。 。在实践中，这会弹出任何：ref：`alloca <i_alloca>`在执行`llvm.stacksave``之后分配的堆栈。"

#: ../../LangRef.rst:9208
msgid "'``llvm.stackrestore``' Intrinsic"
msgstr "'`llvm.stackrestore``'内在"

#: ../../LangRef.rst:9220
msgid "The '``llvm.stackrestore``' intrinsic is used to restore the state of the function stack to the state it was in when the corresponding :ref:`llvm.stacksave <int_stacksave>` intrinsic executed. This is useful for implementing language features like scoped automatic variable sized arrays in C99."
msgstr "'`llvm.stackrestore``'内在函数用于将函数堆栈的状态恢复到相应的：ref：`llvm.stacksave <int_stacksave>`内在执行时的状态。这对于实现C99中的作用域自动变量大小数组等语言功能非常有用。"

#: ../../LangRef.rst:9229
msgid "See the description for :ref:`llvm.stacksave <int_stacksave>`."
msgstr "请参阅以下说明：ref：`llvm.stacksave <int_stacksave>`。"

#: ../../LangRef.rst:9234
msgid "'``llvm.get.dynamic.area.offset``' Intrinsic"
msgstr "'``llvm.get.dynamic.area.offset``'内在"

#: ../../LangRef.rst:9258
msgid "These intrinsics return a non-negative integer value that can be used to get the address of the most recent dynamic alloca, allocated by :ref:`alloca <i_alloca>` on the caller's stack. In particular, for targets where stack grows downwards, adding this offset to the native stack pointer would get the address of the most recent dynamic alloca. For targets where stack grows upwards, the situation is a bit more complicated, because substracting this value from stack pointer would get the address one past the end of the most recent dynamic alloca."
msgstr "这些内在函数返回一个非负整数值，可用于获取最新动态alloca的地址，由调用者堆栈上的：ref：`alloca <i_alloca>`分配。特别是，对于堆栈向下增长的目标，将此偏移量添加到本机堆栈指针将获得最新动态alloca的地址。对于堆栈向上增长的目标，情况稍微复杂一些，因为从堆栈指针中减去此值会使地址超过最近动态alloca的结尾。"

#: ../../LangRef.rst:9266
msgid "Although for most targets `llvm.get.dynamic.area.offset <int_get_dynamic_area_offset>` returns just a zero, for others, such as PowerPC and PowerPC64, it returns a compile-time-known constant value."
msgstr "虽然对于大多数目标来说，`llvm.get.dynamic.area.offset <int_get_dynamic_area_offset>`只返回零，对于其他目标，例如PowerPC和PowerPC64，它返回一个编译时已知的常量值。"

#: ../../LangRef.rst:9270
msgid "The return value type of :ref:`llvm.get.dynamic.area.offset <int_get_dynamic_area_offset>` must match the target's generic address space's (address space 0) pointer type."
msgstr "返回值类型：ref：`llvm.get.dynamic.area.offset <int_get_dynamic_area_offset>`必须与目标的通用地址空间（地址空间0）指针类型匹配。"

#: ../../LangRef.rst:9274
msgid "'``llvm.prefetch``' Intrinsic"
msgstr "'``llvm.prefetch``'内在"

#: ../../LangRef.rst:9286
msgid "The '``llvm.prefetch``' intrinsic is a hint to the code generator to insert a prefetch instruction if supported; otherwise, it is a noop. Prefetches have no effect on the behavior of the program but can change its performance characteristics."
msgstr "'`llvm.prefetch``'内在函数提示代码生成器在支持时插入预取指令;否则，它是一个noop。预取对程序的行为没有影响，但可以改变其性能特征。"

#: ../../LangRef.rst:9294
msgid "``address`` is the address to be prefetched, ``rw`` is the specifier determining if the fetch should be for a read (0) or write (1), and ``locality`` is a temporal locality specifier ranging from (0) - no locality, to (3) - extremely local keep in cache. The ``cache type`` specifies whether the prefetch is performed on the data (1) or instruction (0) cache. The ``rw``, ``locality`` and ``cache type`` arguments must be constant integers."
msgstr "``address``是要预取的地址，``rw``是确定取指令应该是read（0）还是write（1）的说明符，``locality``是时间位置指示符范围从（0） - 没有位置，到（3） - 极端本地保持在缓存中。 ``cache type``指定是对数据（1）还是指令（0）高速缓存执行预取。 ``rw``，``locality``和``cache type``参数必须是常量整数。"

#: ../../LangRef.rst:9305
msgid "This intrinsic does not modify the behavior of the program. In particular, prefetches cannot trap and do not produce a value. On targets that support this intrinsic, the prefetch can provide hints to the processor cache for better performance."
msgstr "此内在函数不会修改程序的行为。特别是，预取不能捕获并且不会产生值。在支持此内在函数的目标上，预取可以为处理器缓存提供提示以获得更好的性能。"

#: ../../LangRef.rst:9311
msgid "'``llvm.pcmarker``' Intrinsic"
msgstr "'`llvm.pcmarker``'内在"

#: ../../LangRef.rst:9323
msgid "The '``llvm.pcmarker``' intrinsic is a method to export a Program Counter (PC) in a region of code to simulators and other tools. The method is target specific, but it is expected that the marker will use exported symbols to transmit the PC of the marker. The marker makes no guarantees that it will remain with any specific instruction after optimizations. It is possible that the presence of a marker will inhibit optimizations. The intended use is to be inserted after optimizations to allow correlations of simulation runs."
msgstr "'`llvm.pcmarker``'内在函数是一种将代码区域中的程序计数器（PC）导出到模拟器和其他工具的方法。该方法是针对特定目标的，但是预期标记将使用导出的符号来传输标记的PC。标记不保证在优化后它将保留在任何特定指令中。标记的存在可能会抑制优化。在优化之后插入预期用途以允许模拟运行的相关性。"

#: ../../LangRef.rst:9335
msgid "``id`` is a numerical id identifying the marker."
msgstr "``id``是识别标记的数字id。"

#: ../../LangRef.rst:9340
msgid "This intrinsic does not modify the behavior of the program. Backends that do not support this intrinsic may ignore it."
msgstr "此内在函数不会修改程序的行为。不支持此内在的后端可能会忽略它。"

#: ../../LangRef.rst:9344
msgid "'``llvm.readcyclecounter``' Intrinsic"
msgstr "'``llvm.readcyclecounter``'内在"

#: ../../LangRef.rst:9356
msgid "The '``llvm.readcyclecounter``' intrinsic provides access to the cycle counter register (or similar low latency, high accuracy clocks) on those targets that support it. On X86, it should map to RDTSC. On Alpha, it should map to RPCC. As the backing counters overflow quickly (on the order of 9 seconds on alpha), this should only be used for small timings."
msgstr "'llvm.readcyclecounter``'内在提供对支持它的那些目标的循环计数器寄存器（或类似的低延迟，高精度时钟）的访问。在X86上，它应该映射到RDTSC。在Alpha上，它应该映射到RPCC。由于后备计数器快速溢出（在alpha上大约9秒），这应该只用于小时间。"

#: ../../LangRef.rst:9366
msgid "When directly supported, reading the cycle counter should not modify any memory. Implementations are allowed to either return a application specific value or a system wide value. On backends without support, this is lowered to a constant 0."
msgstr "直接支持时，读取循环计数器不应修改任何内存。允许实现返回特定于应用程序的值或系统范围的值。在没有支持的后端，这被降低到常数0。"

#: ../../LangRef.rst:9371
msgid "Note that runtime support may be conditional on the privilege-level code is running at and the host platform."
msgstr "请注意，运行时支持可能取决于正在运行的权限级代码和主机平台。"

#: ../../LangRef.rst:9375
msgid "'``llvm.clear_cache``' Intrinsic"
msgstr "'`llvm.clear_cache``'内在"

#: ../../LangRef.rst:9387
msgid "The '``llvm.clear_cache``' intrinsic ensures visibility of modifications in the specified range to the execution unit of the processor. On targets with non-unified instruction and data cache, the implementation flushes the instruction cache."
msgstr "'llvm.clear_cache``'内在函数确保指定范围内的修改可见到处理器的执行单元。在具有非统一指令和数据高速缓存的目标上，实现刷新指令高速缓存。"

#: ../../LangRef.rst:9395
msgid "On platforms with coherent instruction and data caches (e.g. x86), this intrinsic is a nop. On platforms with non-coherent instruction and data cache (e.g. ARM, MIPS), the intrinsic is lowered either to appropriate instructions or a system call, if cache flushing requires special privileges."
msgstr "在具有连贯指令和数据缓存（例如x86）的平台上，此内在函数是一个nop。在具有非一致性指令和数据高速缓存（例如ARM，MIPS）的平台上，如果高速缓存刷新需要特殊权限，则将内在函数降低到适当的指令或系统调用。"

#: ../../LangRef.rst:9401
msgid "The default behavior is to emit a call to ``__clear_cache`` from the run time library."
msgstr "默认行为是从运行时库中发出对``__clear_cache``的调用。"

#: ../../LangRef.rst:9404
msgid "This instrinsic does *not* empty the instruction pipeline. Modifications of the current function are outside the scope of the intrinsic."
msgstr "这种内在性不会*清空指令管道。当前函数的修改超出了内在函数的范围。"

#: ../../LangRef.rst:9408
msgid "'``llvm.instrprof_increment``' Intrinsic"
msgstr "'``llvm.instrprof_increment``'内在"

#: ../../LangRef.rst:9421
msgid "The '``llvm.instrprof_increment``' intrinsic can be emitted by a frontend for use with instrumentation based profiling. These will be lowered by the ``-instrprof`` pass to generate execution counts of a program at runtime."
msgstr "前端可以发出'`llvm.instrprof_increment``'内在函数，以便与基于检测的分析一起使用。这些将被``-instrprof``传递降低，以在运行时生成程序的执行计数。"

#: ../../LangRef.rst:9429
msgid "The first argument is a pointer to a global variable containing the name of the entity being instrumented. This should generally be the (mangled) function name for a set of counters."
msgstr "第一个参数是指向包含要检测的实体名称的全局变量的指针。这通常应该是一组计数器的（损坏的）函数名称。"

#: ../../LangRef.rst:9433
msgid "The second argument is a hash value that can be used by the consumer of the profile data to detect changes to the instrumented source, and the third is the number of counters associated with ``name``. It is an error if ``hash`` or ``num-counters`` differ between two instances of ``instrprof_increment`` that refer to the same name."
msgstr "第二个参数是一个哈希值，配置文件数据的使用者可以使用该哈希值来检测已检测源的更改，第三个参数是与``name``相关联的计数器的数量。如果``hash``或``num-counters``在两个引用相同名称的``instrprof_increment``实例之间不同，则会出错。"

#: ../../LangRef.rst:9439
msgid "The last argument refers to which of the counters for ``name`` should be incremented. It should be a value between 0 and ``num-counters``."
msgstr "最后一个参数指的是``name``的哪个计数器应该递增。它应该是介于0和“num-counters”之间的值。"

#: ../../LangRef.rst:9445
msgid "This intrinsic represents an increment of a profiling counter. It will cause the ``-instrprof`` pass to generate the appropriate data structures and the code to increment the appropriate value, in a format that can be written out by a compiler runtime and consumed via the ``llvm-profdata`` tool."
msgstr "此内在函数表示概要分析计数器的增量。它将导致``-instrprof``传递生成适当的数据结构和代码以增加适当的值，格式可由编译器运行时写出并通过``llvm-profdata``工具消耗。"

#: ../../LangRef.rst:9452
msgid "'``llvm.instrprof_value_profile``' Intrinsic"
msgstr "'`llvm.instrprof_value_profile``'内在"

#: ../../LangRef.rst:9466
msgid "The '``llvm.instrprof_value_profile``' intrinsic can be emitted by a frontend for use with instrumentation based profiling. This will be lowered by the ``-instrprof`` pass to find out the target values, instrumented expressions take in a program at runtime."
msgstr "前端可以发出'`llvm.instrprof_value_profile``'内在函数，以便与基于检测的分析一起使用。这将通过``-instrprof``传递来降低，以找出目标值，检测表达式在运行时接受程序。"

#: ../../LangRef.rst:9474
msgid "The first argument is a pointer to a global variable containing the name of the entity being instrumented. ``name`` should generally be the (mangled) function name for a set of counters."
msgstr "第一个参数是指向包含要检测的实体名称的全局变量的指针。 ``name``通常应该是一组计数器的（损坏的）函数名。"

#: ../../LangRef.rst:9478
msgid "The second argument is a hash value that can be used by the consumer of the profile data to detect changes to the instrumented source. It is an error if ``hash`` differs between two instances of ``llvm.instrprof_*`` that refer to the same name."
msgstr "第二个参数是一个哈希值，配置文件数据的使用者可以使用该哈希值来检测已检测源的更改。如果``llvm.instrprof_ *``的两个实例之间的``hash``不同，则引用相同的名称是错误的。"

#: ../../LangRef.rst:9483
msgid "The third argument is the value of the expression being profiled. The profiled expression's value should be representable as an unsigned 64-bit value. The fourth argument represents the kind of value profiling that is being done. The supported value profiling kinds are enumerated through the ``InstrProfValueKind`` type declared in the ``<include/llvm/ProfileData/InstrProf.h>`` header file. The last argument is the index of the instrumented expression within ``name``. It should be >= 0."
msgstr "第三个参数是被分析的表达式的值。 profiled表达式的值应该可以表示为无符号的64位值。第四个参数表示正在进行的值分析。支持的值分析类型通过``<include / llvm / ProfileData / InstrProf.h>``头文件中声明的``InstrProfValueKind``类型进行枚举。最后一个参数是``name``中的检测表达式的索引。它应该> = 0。"

#: ../../LangRef.rst:9494
msgid "This intrinsic represents the point where a call to a runtime routine should be inserted for value profiling of target expressions. ``-instrprof`` pass will generate the appropriate data structures and replace the ``llvm.instrprof_value_profile`` intrinsic with the call to the profile runtime library with proper arguments."
msgstr "此内在函数表示应插入对运行时例程的调用以进行目标表达式的值分析。 ``-instrprof`` pass将生成适当的数据结构，并用适当的参数调用配置文件运行时库来替换``llvm.instrprof_value_profile``内在函数。"

#: ../../LangRef.rst:9501
msgid "Standard C Library Intrinsics"
msgstr "标准C库内在函数"

#: ../../LangRef.rst:9503
msgid "LLVM provides intrinsics for a few important standard C library functions. These intrinsics allow source-language front-ends to pass information about the alignment of the pointer arguments to the code generator, providing opportunity for more efficient code generation."
msgstr "LLVM为一些重要的标准C库函数提供内在函数。这些内在函数允许源语言前端将有关指针参数对齐的信息传递给代码生成器，从而为更高效的代码生成提供了机会。"

#: ../../LangRef.rst:9511
msgid "'``llvm.memcpy``' Intrinsic"
msgstr "'``llvm.memcpy``'内在"

#: ../../LangRef.rst:9516
msgid "This is an overloaded intrinsic. You can use ``llvm.memcpy`` on any integer bit width and for different address spaces. Not all targets support all bit widths however."
msgstr "这是一个过载的内在。您可以对任何整数位宽和不同的地址空间使用``llvm.memcpy``。但并非所有目标都支持所有位宽。"

#: ../../LangRef.rst:9530
msgid "The '``llvm.memcpy.*``' intrinsics copy a block of memory from the source location to the destination location."
msgstr "'llvm.memcpy。*``'内在函数将一块内存从源位置复制到目标位置。"

#: ../../LangRef.rst:9533
msgid "Note that, unlike the standard libc function, the ``llvm.memcpy.*`` intrinsics do not return a value, takes extra alignment/isvolatile arguments and the pointers can be in specified address spaces."
msgstr "请注意，与标准的libc函数不同，``llvm.memcpy。*``intrinsics不返回值，需要额外的alignment / isvolatile参数，指针可以在指定的地址空间中。"

#: ../../LangRef.rst:9540 ../../LangRef.rst:9595
msgid "The first argument is a pointer to the destination, the second is a pointer to the source. The third argument is an integer argument specifying the number of bytes to copy, the fourth argument is the alignment of the source and destination locations, and the fifth is a boolean indicating a volatile access."
msgstr "第一个参数是指向目标的指针，第二个参数是指向源的指针。第三个参数是一个整数参数，指定要复制的字节数，第四个参数是源和目标位置的对齐，第五个参数是指示易失性访问的布尔值。"

#: ../../LangRef.rst:9546
msgid "If the call to this intrinsic has an alignment value that is not 0 or 1, then the caller guarantees that both the source and destination pointers are aligned to that boundary."
msgstr "如果对此内在函数的调用具有非0或1的对齐值，则调用者保证源指针和目标指针都与该边界对齐。"

#: ../../LangRef.rst:9550
msgid "If the ``isvolatile`` parameter is ``true``, the ``llvm.memcpy`` call is a :ref:`volatile operation <volatile>`. The detailed access behavior is not very cleanly specified and it is unwise to depend on it."
msgstr "如果``isvolatile``参数是``true``，``llvm.memcpy``调用是：ref：`volatile operation <volatile>`。详细的访问行为没有非常清晰地指定，依赖它是不明智的。"

#: ../../LangRef.rst:9557
msgid "The '``llvm.memcpy.*``' intrinsics copy a block of memory from the source location to the destination location, which are not allowed to overlap. It copies \"len\" bytes of memory over. If the argument is known to be aligned to some boundary, this can be specified as the fourth argument, otherwise it should be set to 0 or 1 (both meaning no alignment)."
msgstr "'llvm.memcpy。*``'内在函数将一块内存从源位置复制到目标位置，不允许重叠。它复制了“len”字节的内存。如果已知参数与某个边界对齐，则可以将其指定为第四个参数，否则应将其设置为0或1（均表示不对齐）。"

#: ../../LangRef.rst:9564
msgid "'``llvm.memmove``' Intrinsic"
msgstr "'`llvm.memmove``'内在"

#: ../../LangRef.rst:9569
msgid "This is an overloaded intrinsic. You can use llvm.memmove on any integer bit width and for different address space. Not all targets support all bit widths however."
msgstr "这是一个过载的内在。您可以在任何整数位宽和不同的地址空间上使用llvm.memmove。但并非所有目标都支持所有位宽。"

#: ../../LangRef.rst:9583
msgid "The '``llvm.memmove.*``' intrinsics move a block of memory from the source location to the destination location. It is similar to the '``llvm.memcpy``' intrinsic but allows the two memory locations to overlap."
msgstr "'llvm.memmove。*``'内在函数将一块内存从源位置移动到目标位置。它类似于'`llvm.memcpy``'内在函数但允许两个内存位置重叠。"

#: ../../LangRef.rst:9588
msgid "Note that, unlike the standard libc function, the ``llvm.memmove.*`` intrinsics do not return a value, takes extra alignment/isvolatile arguments and the pointers can be in specified address spaces."
msgstr "请注意，与标准的libc函数不同，``llvm.memmove。*``intrinsics不返回值，需要额外的alignment / isvolatile参数，指针可以在指定的地址空间中。"

#: ../../LangRef.rst:9601
msgid "If the call to this intrinsic has an alignment value that is not 0 or 1, then the caller guarantees that the source and destination pointers are aligned to that boundary."
msgstr "如果对此内在函数的调用具有非0或1的对齐值，则调用方可确保源指针和目标指针与该边界对齐。"

#: ../../LangRef.rst:9605
msgid "If the ``isvolatile`` parameter is ``true``, the ``llvm.memmove`` call is a :ref:`volatile operation <volatile>`. The detailed access behavior is not very cleanly specified and it is unwise to depend on it."
msgstr "如果``isvolatile``参数是``true``，``llvm.memmove``调用是：ref：`volatile operation <volatile>`。详细的访问行为没有非常清晰地指定，依赖它是不明智的。"

#: ../../LangRef.rst:9612
msgid "The '``llvm.memmove.*``' intrinsics copy a block of memory from the source location to the destination location, which may overlap. It copies \"len\" bytes of memory over. If the argument is known to be aligned to some boundary, this can be specified as the fourth argument, otherwise it should be set to 0 or 1 (both meaning no alignment)."
msgstr "'llvm.memmove。*``'内在函数将一块内存从源位置复制到目标位置，这可能会重叠。它复制了“len”字节的内存。如果已知参数与某个边界对齐，则可以将其指定为第四个参数，否则应将其设置为0或1（均表示不对齐）。"

#: ../../LangRef.rst:9619
msgid "'``llvm.memset.*``' Intrinsics"
msgstr "'``llvm.memset。*``'内在学"

#: ../../LangRef.rst:9624
msgid "This is an overloaded intrinsic. You can use llvm.memset on any integer bit width and for different address spaces. However, not all targets support all bit widths."
msgstr "这是一个过载的内在。您可以对任何整数位宽和不同的地址空间使用llvm.memset。但是，并非所有目标都支持所有位宽。"

#: ../../LangRef.rst:9638
msgid "The '``llvm.memset.*``' intrinsics fill a block of memory with a particular byte value."
msgstr "'llvm.memset。*``'内在函数用特定的字节值填充内存块。"

#: ../../LangRef.rst:9641
msgid "Note that, unlike the standard libc function, the ``llvm.memset`` intrinsic does not return a value and takes extra alignment/volatile arguments. Also, the destination can be in an arbitrary address space."
msgstr "请注意，与标准libc函数不同，``llvm.memset``内在函数不返回值并采用额外的alignment / volatile参数。此外，目的地可以在任意地址空间中。"

#: ../../LangRef.rst:9648
msgid "The first argument is a pointer to the destination to fill, the second is the byte value with which to fill it, the third argument is an integer argument specifying the number of bytes to fill, and the fourth argument is the known alignment of the destination location."
msgstr "第一个参数是指向要填充的目标的指针，第二个参数是用于填充它的字节值，第三个参数是指定要填充的字节数的整数参数，第四个参数是目标的已知对齐方式地点。"

#: ../../LangRef.rst:9653
msgid "If the call to this intrinsic has an alignment value that is not 0 or 1, then the caller guarantees that the destination pointer is aligned to that boundary."
msgstr "如果对此内在函数的调用具有不为0或1的对齐值，则调用方保证目标指针与该边界对齐。"

#: ../../LangRef.rst:9657
msgid "If the ``isvolatile`` parameter is ``true``, the ``llvm.memset`` call is a :ref:`volatile operation <volatile>`. The detailed access behavior is not very cleanly specified and it is unwise to depend on it."
msgstr "如果``isvolatile``参数是``true``，``llvm.memset``调用是：ref：`volatile operation <volatile>`。详细的访问行为没有非常清晰地指定，依赖它是不明智的。"

#: ../../LangRef.rst:9664
msgid "The '``llvm.memset.*``' intrinsics fill \"len\" bytes of memory starting at the destination location. If the argument is known to be aligned to some boundary, this can be specified as the fourth argument, otherwise it should be set to 0 or 1 (both meaning no alignment)."
msgstr "'llvm.memset。*``'内在函数从目标位置开始填充\\“len \\”内存字节。如果已知参数与某个边界对齐，则可以将其指定为第四个参数，否则应将其设置为0或1（均表示不对齐）。"

#: ../../LangRef.rst:9670
msgid "'``llvm.sqrt.*``' Intrinsic"
msgstr "'``llvm.sqrt。*``'内在"

#: ../../LangRef.rst:9675
msgid "This is an overloaded intrinsic. You can use ``llvm.sqrt`` on any floating point or vector of floating point type. Not all targets support all types however."
msgstr "这是一个过载的内在。您可以在任何浮点或浮点类型的向量上使用``llvm.sqrt``。但并非所有目标都支持所有类型。"

#: ../../LangRef.rst:9690
msgid "The '``llvm.sqrt``' intrinsics return the sqrt of the specified operand, returning the same value as the libm '``sqrt``' functions would. Unlike ``sqrt`` in libm, however, ``llvm.sqrt`` has undefined behavior for negative numbers other than -0.0 (which allows for better optimization, because there is no need to worry about errno being set). ``llvm.sqrt(-0.0)`` is defined to return -0.0 like IEEE sqrt."
msgstr "'`llvm.sqrt``'内在函数返回指定操作数的sqrt，返回与libm'``sqrt``'函数相同的值。然而，与libm中的``sqrt``不同，``llvm.sqrt``对于除-0.0之外的负数具有未定义的行为（这允许更好的优化，因为不需要担心设置errno）。 ``llvm.sqrt（-0.0）``被定义为像IEEE sqrt一样返回-0.0。"

#: ../../LangRef.rst:9700 ../../LangRef.rst:9773 ../../LangRef.rst:9809 ../../LangRef.rst:9882 ../../LangRef.rst:9917 ../../LangRef.rst:9952 ../../LangRef.rst:9987 ../../LangRef.rst:10022 ../../LangRef.rst:10058 ../../LangRef.rst:10094 ../../LangRef.rst:10248 ../../LangRef.rst:10283 ../../LangRef.rst:10319 ../../LangRef.rst:10356 ../../LangRef.rst:10392 ../../LangRef.rst:10428
msgid "The argument and return value are floating point numbers of the same type."
msgstr "参数和返回值是相同类型的浮点数。"

#: ../../LangRef.rst:9706
msgid "This function returns the sqrt of the specified operand if it is a nonnegative floating point number."
msgstr "如果指定的操作数是非负浮点数，则此函数返回该sqrt。"

#: ../../LangRef.rst:9710
msgid "'``llvm.powi.*``' Intrinsic"
msgstr "'`llvm.powi。*``'内在"

#: ../../LangRef.rst:9715
msgid "This is an overloaded intrinsic. You can use ``llvm.powi`` on any floating point or vector of floating point type. Not all targets support all types however."
msgstr "这是一个过载的内在。您可以在任何浮点或浮点类型的向量上使用``llvm.powi``。但并非所有目标都支持所有类型。"

#: ../../LangRef.rst:9730
msgid "The '``llvm.powi.*``' intrinsics return the first operand raised to the specified (positive or negative) power. The order of evaluation of multiplications is not defined. When a vector of floating point type is used, the second argument remains a scalar integer value."
msgstr "'llvm.powi。*``'内在函数将第一个操作数返回到指定的（正或负）幂。没有定义乘法的评估顺序。当使用浮点类型的向量时，第二个参数仍然是标量整数值。"

#: ../../LangRef.rst:9738
msgid "The second argument is an integer power, and the first is a value to raise to that power."
msgstr "第二个参数是整数幂，第一个是提升到该幂的值。"

#: ../../LangRef.rst:9744
msgid "This function returns the first value raised to the second power with an unspecified sequence of rounding operations."
msgstr "此函数返回通过未指定的舍入操作序列提升到第二个幂的第一个值。"

#: ../../LangRef.rst:9748
msgid "'``llvm.sin.*``' Intrinsic"
msgstr "'``llvm.sin。*``'内在"

#: ../../LangRef.rst:9753
msgid "This is an overloaded intrinsic. You can use ``llvm.sin`` on any floating point or vector of floating point type. Not all targets support all types however."
msgstr "这是一个过载的内在。您可以在任何浮点或浮点类型的向量上使用``llvm.sin``。但并非所有目标都支持所有类型。"

#: ../../LangRef.rst:9768
msgid "The '``llvm.sin.*``' intrinsics return the sine of the operand."
msgstr "'llvm.sin。*``'内在函数返回操作数的正弦值。"

#: ../../LangRef.rst:9779
msgid "This function returns the sine of the specified operand, returning the same values as the libm ``sin`` functions would, and handles error conditions in the same way."
msgstr "此函数返回指定操作数的正弦值，返回与libm``sin```函数相同的值，并以相同方式处理错误条件。"

#: ../../LangRef.rst:9784
msgid "'``llvm.cos.*``' Intrinsic"
msgstr "'``llvm.cos。*``'内在"

#: ../../LangRef.rst:9789
msgid "This is an overloaded intrinsic. You can use ``llvm.cos`` on any floating point or vector of floating point type. Not all targets support all types however."
msgstr "这是一个过载的内在。您可以在任何浮点或浮点类型的向量上使用``llvm.cos``。但并非所有目标都支持所有类型。"

#: ../../LangRef.rst:9804
msgid "The '``llvm.cos.*``' intrinsics return the cosine of the operand."
msgstr "'llvm.cos。*``'内在函数返回操作数的余弦。"

#: ../../LangRef.rst:9815
msgid "This function returns the cosine of the specified operand, returning the same values as the libm ``cos`` functions would, and handles error conditions in the same way."
msgstr "此函数返回指定操作数的余弦值，返回与libm“cos``函数相同的值，并以相同的方式处理错误条件。"

#: ../../LangRef.rst:9820
msgid "'``llvm.pow.*``' Intrinsic"
msgstr "'`llvm.pow。*``'内在"

#: ../../LangRef.rst:9825
msgid "This is an overloaded intrinsic. You can use ``llvm.pow`` on any floating point or vector of floating point type. Not all targets support all types however."
msgstr "这是一个过载的内在。你可以在任何浮点或浮点类型的向量上使用``llvm.pow``。但并非所有目标都支持所有类型。"

#: ../../LangRef.rst:9840
msgid "The '``llvm.pow.*``' intrinsics return the first operand raised to the specified (positive or negative) power."
msgstr "'llvm.pow。*``'内在函数将第一个操作数返回到指定的（正或负）幂。"

#: ../../LangRef.rst:9846
msgid "The second argument is a floating point power, and the first is a value to raise to that power."
msgstr "第二个参数是浮点幂，第一个是提升到该幂的值。"

#: ../../LangRef.rst:9852
msgid "This function returns the first value raised to the second power, returning the same values as the libm ``pow`` functions would, and handles error conditions in the same way."
msgstr "此函数返回第一个提升到第二个幂的值，返回与libm``pow``函数相同的值，并以相同的方式处理错误条件。"

#: ../../LangRef.rst:9857
msgid "'``llvm.exp.*``' Intrinsic"
msgstr "'``llvm.exp。*``'内在"

#: ../../LangRef.rst:9862
msgid "This is an overloaded intrinsic. You can use ``llvm.exp`` on any floating point or vector of floating point type. Not all targets support all types however."
msgstr "这是一个过载的内在。您可以在任何浮点或浮点类型的向量上使用``llvm.exp``。但并非所有目标都支持所有类型。"

#: ../../LangRef.rst:9877
msgid "The '``llvm.exp.*``' intrinsics perform the exp function."
msgstr "'`llvm.exp。*``'内在函数执行exp函数。"

#: ../../LangRef.rst:9888
msgid "This function returns the same values as the libm ``exp`` functions would, and handles error conditions in the same way."
msgstr "该函数返回与libm``exp``函数相同的值，并以相同的方式处理错误条件。"

#: ../../LangRef.rst:9892
msgid "'``llvm.exp2.*``' Intrinsic"
msgstr "'``llvm.exp2。*``'内在"

#: ../../LangRef.rst:9897
msgid "This is an overloaded intrinsic. You can use ``llvm.exp2`` on any floating point or vector of floating point type. Not all targets support all types however."
msgstr "这是一个过载的内在。你可以在任何浮点或浮点类型的向量上使用``llvm.exp2``。但并非所有目标都支持所有类型。"

#: ../../LangRef.rst:9912
msgid "The '``llvm.exp2.*``' intrinsics perform the exp2 function."
msgstr "'llvm.exp2。*``'内在函数执行exp2函数。"

#: ../../LangRef.rst:9923
msgid "This function returns the same values as the libm ``exp2`` functions would, and handles error conditions in the same way."
msgstr "该函数返回与libm``exp2``函数相同的值，并以相同的方式处理错误条件。"

#: ../../LangRef.rst:9927
msgid "'``llvm.log.*``' Intrinsic"
msgstr "'``llvm.log。*``'内在"

#: ../../LangRef.rst:9932
msgid "This is an overloaded intrinsic. You can use ``llvm.log`` on any floating point or vector of floating point type. Not all targets support all types however."
msgstr "这是一个过载的内在。您可以在任何浮点或浮点类型的向量上使用``llvm.log``。但并非所有目标都支持所有类型。"

#: ../../LangRef.rst:9947
msgid "The '``llvm.log.*``' intrinsics perform the log function."
msgstr "'`llvm.log。*``'内在函数执行日志功能。"

#: ../../LangRef.rst:9958
msgid "This function returns the same values as the libm ``log`` functions would, and handles error conditions in the same way."
msgstr "此函数返回与libm``log``函数相同的值，并以相同的方式处理错误条件。"

#: ../../LangRef.rst:9962
msgid "'``llvm.log10.*``' Intrinsic"
msgstr "'`llvm.log10。*``'内在"

#: ../../LangRef.rst:9967
msgid "This is an overloaded intrinsic. You can use ``llvm.log10`` on any floating point or vector of floating point type. Not all targets support all types however."
msgstr "这是一个过载的内在。您可以在任何浮点或浮点类型的向量上使用``llvm.log10``。但并非所有目标都支持所有类型。"

#: ../../LangRef.rst:9982
msgid "The '``llvm.log10.*``' intrinsics perform the log10 function."
msgstr "'`llvm.log10。*``'内在函数执行log10函数。"

#: ../../LangRef.rst:9993
msgid "This function returns the same values as the libm ``log10`` functions would, and handles error conditions in the same way."
msgstr "该函数返回与libm``log10``函数相同的值，并以相同的方式处理错误条件。"

#: ../../LangRef.rst:9997
msgid "'``llvm.log2.*``' Intrinsic"
msgstr "'``llvm.log2。*``'内在"

#: ../../LangRef.rst:10002
msgid "This is an overloaded intrinsic. You can use ``llvm.log2`` on any floating point or vector of floating point type. Not all targets support all types however."
msgstr "这是一个过载的内在。您可以在任何浮点或浮点类型的向量上使用``llvm.log2``。但并非所有目标都支持所有类型。"

#: ../../LangRef.rst:10017
msgid "The '``llvm.log2.*``' intrinsics perform the log2 function."
msgstr "'`llvm.log2。*``'内在函数执行log2函数。"

#: ../../LangRef.rst:10028
msgid "This function returns the same values as the libm ``log2`` functions would, and handles error conditions in the same way."
msgstr "该函数返回与libm``log2``函数相同的值，并以相同的方式处理错误条件。"

#: ../../LangRef.rst:10032
msgid "'``llvm.fma.*``' Intrinsic"
msgstr "'``llvm.fma。*``'内在"

#: ../../LangRef.rst:10037
msgid "This is an overloaded intrinsic. You can use ``llvm.fma`` on any floating point or vector of floating point type. Not all targets support all types however."
msgstr "这是一个过载的内在。您可以在任何浮点或浮点类型的向量上使用``llvm.fma``。但并非所有目标都支持所有类型。"

#: ../../LangRef.rst:10052
msgid "The '``llvm.fma.*``' intrinsics perform the fused multiply-add operation."
msgstr "'`llvm.fma。*``'内在函数执行融合乘法 - 加法运算。"

#: ../../LangRef.rst:10064
msgid "This function returns the same values as the libm ``fma`` functions would, and does not set errno."
msgstr "此函数返回与libm``fma``函数相同的值，并且不设置errno。"

#: ../../LangRef.rst:10068
msgid "'``llvm.fabs.*``' Intrinsic"
msgstr "'``llvm.fabs。*``'内在"

#: ../../LangRef.rst:10073
msgid "This is an overloaded intrinsic. You can use ``llvm.fabs`` on any floating point or vector of floating point type. Not all targets support all types however."
msgstr "这是一个过载的内在。你可以在任何浮点或浮点类型的向量上使用``llvm.fabs``。但并非所有目标都支持所有类型。"

#: ../../LangRef.rst:10088
msgid "The '``llvm.fabs.*``' intrinsics return the absolute value of the operand."
msgstr "'llvm.fabs。*``'内在函数返回操作数的绝对值。"

#: ../../LangRef.rst:10100
msgid "This function returns the same values as the libm ``fabs`` functions would, and handles error conditions in the same way."
msgstr "该函数返回与libm``fabs``函数相同的值，并以相同的方式处理错误条件。"

#: ../../LangRef.rst:10104
msgid "'``llvm.minnum.*``' Intrinsic"
msgstr "'`llvm.minnum。*``'内在"

#: ../../LangRef.rst:10109
msgid "This is an overloaded intrinsic. You can use ``llvm.minnum`` on any floating point or vector of floating point type. Not all targets support all types however."
msgstr "这是一个过载的内在。您可以在任何浮点或浮点类型的向量上使用``llvm.minnum``。但并非所有目标都支持所有类型。"

#: ../../LangRef.rst:10124
msgid "The '``llvm.minnum.*``' intrinsics return the minimum of the two arguments."
msgstr "'llvm.minnum。*``'内在函数返回两个参数中的最小值。"

#: ../../LangRef.rst:10131 ../../LangRef.rst:10173 ../../LangRef.rst:10213
msgid "The arguments and return value are floating point numbers of the same type."
msgstr "参数和返回值是相同类型的浮点数。"

#: ../../LangRef.rst:10137
msgid "Follows the IEEE-754 semantics for minNum, which also match for libm's fmin."
msgstr "遵循minNum的IEEE-754语义，它也匹配libm的fmin。"

#: ../../LangRef.rst:10140
msgid "If either operand is a NaN, returns the other non-NaN operand. Returns NaN only if both operands are NaN. If the operands compare equal, returns a value that compares equal to both operands. This means that fmin(+/-0.0, +/-0.0) could return either -0.0 or 0.0."
msgstr "如果任一操作数是NaN，则返回另一个非NaN操作数。仅当两个操作数都是NaN时才返回NaN。如果操作数比较相等，则返回一个比较两个操作数的值。这意味着fmin（+/- 0.0，+ /  -  0.0）可以返回-0.0或0.0。"

#: ../../LangRef.rst:10146
msgid "'``llvm.maxnum.*``' Intrinsic"
msgstr "'`llvm.maxnum。*``'内在"

#: ../../LangRef.rst:10151
msgid "This is an overloaded intrinsic. You can use ``llvm.maxnum`` on any floating point or vector of floating point type. Not all targets support all types however."
msgstr "这是一个过载的内在。您可以在任何浮点或浮点类型的向量上使用``llvm.maxnum``。但并非所有目标都支持所有类型。"

#: ../../LangRef.rst:10166
msgid "The '``llvm.maxnum.*``' intrinsics return the maximum of the two arguments."
msgstr "'llvm.maxnum。*``'内在函数返回两个参数的最大值。"

#: ../../LangRef.rst:10178
msgid "Follows the IEEE-754 semantics for maxNum, which also match for libm's fmax."
msgstr "遵循maxNum的IEEE-754语义，它也匹配libm的fmax。"

#: ../../LangRef.rst:10181
msgid "If either operand is a NaN, returns the other non-NaN operand. Returns NaN only if both operands are NaN. If the operands compare equal, returns a value that compares equal to both operands. This means that fmax(+/-0.0, +/-0.0) could return either -0.0 or 0.0."
msgstr "如果任一操作数是NaN，则返回另一个非NaN操作数。仅当两个操作数都是NaN时才返回NaN。如果操作数比较相等，则返回一个比较两个操作数的值。这意味着fmax（+/- 0.0，+ /  -  0.0）可以返回-0.0或0.0。"

#: ../../LangRef.rst:10187
msgid "'``llvm.copysign.*``' Intrinsic"
msgstr "'``llvm.copysign。*``'内在"

#: ../../LangRef.rst:10192
msgid "This is an overloaded intrinsic. You can use ``llvm.copysign`` on any floating point or vector of floating point type. Not all targets support all types however."
msgstr "这是一个过载的内在。您可以在任何浮点或浮点类型的向量上使用``llvm.copysign``。但并非所有目标都支持所有类型。"

#: ../../LangRef.rst:10207
msgid "The '``llvm.copysign.*``' intrinsics return a value with the magnitude of the first operand and the sign of the second operand."
msgstr "'llvm.copysign。*``'内在函数返回一个值，其值为第一个操作数的大小和第二个操作数的符号。"

#: ../../LangRef.rst:10219
msgid "This function returns the same values as the libm ``copysign`` functions would, and handles error conditions in the same way."
msgstr "该函数返回与libm``copysign``函数相同的值，并以相同的方式处理错误条件。"

#: ../../LangRef.rst:10223
msgid "'``llvm.floor.*``' Intrinsic"
msgstr "'``llvm.floor。*``'内在"

#: ../../LangRef.rst:10228
msgid "This is an overloaded intrinsic. You can use ``llvm.floor`` on any floating point or vector of floating point type. Not all targets support all types however."
msgstr "这是一个过载的内在。你可以在任何浮点或浮点类型的向量上使用``llvm.floor``。但并非所有目标都支持所有类型。"

#: ../../LangRef.rst:10243
msgid "The '``llvm.floor.*``' intrinsics return the floor of the operand."
msgstr "'llvm.floor。*``'内在函数返回操作数的底限。"

#: ../../LangRef.rst:10254
msgid "This function returns the same values as the libm ``floor`` functions would, and handles error conditions in the same way."
msgstr "此函数返回与libm`` floor``函数相同的值，并以相同的方式处理错误条件。"

#: ../../LangRef.rst:10258
msgid "'``llvm.ceil.*``' Intrinsic"
msgstr "'``llvm.ceil。*``'内在"

#: ../../LangRef.rst:10263
msgid "This is an overloaded intrinsic. You can use ``llvm.ceil`` on any floating point or vector of floating point type. Not all targets support all types however."
msgstr "这是一个过载的内在。你可以在任何浮点或浮点类型的向量上使用``llvm.ceil``。但并非所有目标都支持所有类型。"

#: ../../LangRef.rst:10278
msgid "The '``llvm.ceil.*``' intrinsics return the ceiling of the operand."
msgstr "'llvm.ceil。*``'内在函数返回操作数的上限。"

#: ../../LangRef.rst:10289
msgid "This function returns the same values as the libm ``ceil`` functions would, and handles error conditions in the same way."
msgstr "该函数返回与libm``ceil``函数相同的值，并以相同的方式处理错误条件。"

#: ../../LangRef.rst:10293
msgid "'``llvm.trunc.*``' Intrinsic"
msgstr "'``llvm.trunc。*``'内在"

#: ../../LangRef.rst:10298
msgid "This is an overloaded intrinsic. You can use ``llvm.trunc`` on any floating point or vector of floating point type. Not all targets support all types however."
msgstr "这是一个过载的内在。你可以在任何浮点或浮点类型的向量上使用``llvm.trunc``。但并非所有目标都支持所有类型。"

#: ../../LangRef.rst:10313
msgid "The '``llvm.trunc.*``' intrinsics returns the operand rounded to the nearest integer not larger in magnitude than the operand."
msgstr "'llvm.trunc。*``'内在函数将操作数返回到最接近的整数，该整数的大小不大于操作数。"

#: ../../LangRef.rst:10325
msgid "This function returns the same values as the libm ``trunc`` functions would, and handles error conditions in the same way."
msgstr "此函数返回与libm``tob``函数相同的值，并以相同的方式处理错误条件。"

#: ../../LangRef.rst:10329
msgid "'``llvm.rint.*``' Intrinsic"
msgstr "'`llvm.rint。*``'内在"

#: ../../LangRef.rst:10334
msgid "This is an overloaded intrinsic. You can use ``llvm.rint`` on any floating point or vector of floating point type. Not all targets support all types however."
msgstr "这是一个过载的内在。您可以在任何浮点或浮点类型的向量上使用``llvm.rint``。但并非所有目标都支持所有类型。"

#: ../../LangRef.rst:10349
msgid "The '``llvm.rint.*``' intrinsics returns the operand rounded to the nearest integer. It may raise an inexact floating-point exception if the operand isn't an integer."
msgstr "'`llvm.rint。*``'intrinsics将操作数四舍五入到最接近的整数。如果操作数不是整数，则可能引发不精确的浮点异常。"

#: ../../LangRef.rst:10362
msgid "This function returns the same values as the libm ``rint`` functions would, and handles error conditions in the same way."
msgstr "该函数返回与libm``rint``函数相同的值，并以相同的方式处理错误条件。"

#: ../../LangRef.rst:10366
msgid "'``llvm.nearbyint.*``' Intrinsic"
msgstr "'``llvm.nearbyint。*``'内在"

#: ../../LangRef.rst:10371
msgid "This is an overloaded intrinsic. You can use ``llvm.nearbyint`` on any floating point or vector of floating point type. Not all targets support all types however."
msgstr "这是一个过载的内在。您可以在任何浮点或浮点类型的向量上使用``llvm.nearbyint``。但并非所有目标都支持所有类型。"

#: ../../LangRef.rst:10386
msgid "The '``llvm.nearbyint.*``' intrinsics returns the operand rounded to the nearest integer."
msgstr "'`llvm.nearbyint。*``'内在函数返回舍入到最接近整数的操作数。"

#: ../../LangRef.rst:10398
msgid "This function returns the same values as the libm ``nearbyint`` functions would, and handles error conditions in the same way."
msgstr "此函数返回与libm``snieldint``函数相同的值，并以相同的方式处理错误条件。"

#: ../../LangRef.rst:10402
msgid "'``llvm.round.*``' Intrinsic"
msgstr "'`llvm.round。*``'内在"

#: ../../LangRef.rst:10407
msgid "This is an overloaded intrinsic. You can use ``llvm.round`` on any floating point or vector of floating point type. Not all targets support all types however."
msgstr "这是一个过载的内在。你可以在任何浮点或浮点类型的向量上使用``llvm.round``。但并非所有目标都支持所有类型。"

#: ../../LangRef.rst:10422
msgid "The '``llvm.round.*``' intrinsics returns the operand rounded to the nearest integer."
msgstr "'llvm.round。*``'内在函数返回舍入到最接近整数的操作数。"

#: ../../LangRef.rst:10434
msgid "This function returns the same values as the libm ``round`` functions would, and handles error conditions in the same way."
msgstr "此函数返回与libm``round``函数相同的值，并以相同的方式处理错误条件。"

#: ../../LangRef.rst:10438
msgid "Bit Manipulation Intrinsics"
msgstr "位操纵内在函数"

#: ../../LangRef.rst:10440
msgid "LLVM provides intrinsics for a few important bit manipulation operations. These allow efficient code generation for some algorithms."
msgstr "LLVM为一些重要的位操作操作提供内在函数。这些允许为某些算法生成有效的代码。"

#: ../../LangRef.rst:10444
msgid "'``llvm.bitreverse.*``' Intrinsics"
msgstr "'`llvm.bitreverse。*``'内在学"

#: ../../LangRef.rst:10449
msgid "This is an overloaded intrinsic function. You can use bitreverse on any integer type."
msgstr "这是一个重载的内在函数。您可以对任何整数类型使用bitreverse。"

#: ../../LangRef.rst:10461
msgid "The '``llvm.bitreverse``' family of intrinsics is used to reverse the bitpattern of an integer value; for example ``0b1234567`` becomes ``0b7654321``."
msgstr "'llvm.bitreverse``'内在函数族用于反转整数值的位模式;例如``0b1234567``变为``0b7654321``。"

#: ../../LangRef.rst:10468
msgid "The ``llvm.bitreverse.iN`` intrinsic returns an i16 value that has bit ``M`` in the input moved to bit ``N-M`` in the output."
msgstr "``llvm.bitreverse.iN``内在函数返回一个i16值，该值在输入中的位“M`”移动到输出中的位“NM”。"

#: ../../LangRef.rst:10472
msgid "'``llvm.bswap.*``' Intrinsics"
msgstr "'``llvm.bswap。*``'内在学"

#: ../../LangRef.rst:10477
msgid "This is an overloaded intrinsic function. You can use bswap on any integer type that is an even number of bytes (i.e. BitWidth % 16 == 0)."
msgstr "这是一个重载的内在函数。您可以对任何偶数字节的整数类型使用bswap（即BitWidth％16 == 0）。"

#: ../../LangRef.rst:10489
msgid "The '``llvm.bswap``' family of intrinsics is used to byte swap integer values with an even number of bytes (positive multiple of 16 bits). These are useful for performing operations on data that is not in the target's native byte order."
msgstr "'llvm.bswap``'内在函数族用于字节交换具有偶数字节的整数值（16位的正数）。这些对于对不在目标的本机字节顺序中的数据执行操作非常有用。"

#: ../../LangRef.rst:10497
msgid "The ``llvm.bswap.i16`` intrinsic returns an i16 value that has the high and low byte of the input i16 swapped. Similarly, the ``llvm.bswap.i32`` intrinsic returns an i32 value that has the four bytes of the input i32 swapped, so that if the input bytes are numbered 0, 1, 2, 3 then the returned i32 will have its bytes in 3, 2, 1, 0 order. The ``llvm.bswap.i48``, ``llvm.bswap.i64`` and other intrinsics extend this concept to additional even-byte lengths (6 bytes, 8 bytes and more, respectively)."
msgstr "``llvm.bswap.i16``内在函数返回一个i16值，该值具有交换输入i16的高字节和低字节。类似地，``llvm.bswap.i32``内在函数返回一个i32值，该值具有交换的输入i32的四个字节，因此如果输入字节编号为0,1,2,3，则返回的i32将具有其字节数为3,2,1,0。 ``llvm.bswap.i48``，``llvm.bswap.i64``和其他内在函数将这个概念扩展到额外的偶数字节长度（分别为6个字节，8个字节或更多）。"

#: ../../LangRef.rst:10507
msgid "'``llvm.ctpop.*``' Intrinsic"
msgstr "'``llvm.ctpop。*``'内在"

#: ../../LangRef.rst:10512
msgid "This is an overloaded intrinsic. You can use llvm.ctpop on any integer bit width, or on any vector with integer elements. Not all targets support all bit widths or vector types, however."
msgstr "这是一个过载的内在。您可以对任何整数位宽或任何带整数元素的向量使用llvm.ctpop。但是，并非所有目标都支持所有位宽或矢量类型。"

#: ../../LangRef.rst:10528
msgid "The '``llvm.ctpop``' family of intrinsics counts the number of bits set in a value."
msgstr "'llvm.ctpop``'内在函数族计算一个值中设置的位数。"

#: ../../LangRef.rst:10534
msgid "The only argument is the value to be counted. The argument may be of any integer type, or a vector with integer elements. The return type must match the argument type."
msgstr "唯一的参数是要计算的值。参数可以是任何整数类型，也可以是具有整数元素的向量。返回类型必须与参数类型匹配。"

#: ../../LangRef.rst:10541
msgid "The '``llvm.ctpop``' intrinsic counts the 1's in a variable, or within each element of a vector."
msgstr "'llvm.ctpop``'内在函数计算变量中的1或者向量的每个元素内的1。"

#: ../../LangRef.rst:10545
msgid "'``llvm.ctlz.*``' Intrinsic"
msgstr "'``llvm.ctlz。*``'内在"

#: ../../LangRef.rst:10550
msgid "This is an overloaded intrinsic. You can use ``llvm.ctlz`` on any integer bit width, or any vector whose elements are integers. Not all targets support all bit widths or vector types, however."
msgstr "这是一个过载的内在。您可以在任何整数位宽度上使用``llvm.ctlz``，或任何元素为整数的向量。但是，并非所有目标都支持所有位宽或矢量类型。"

#: ../../LangRef.rst:10566
msgid "The '``llvm.ctlz``' family of intrinsic functions counts the number of leading zeros in a variable."
msgstr "'llvm.ctlz``'内部函数族计算变量中前导零的数量。"

#: ../../LangRef.rst:10572 ../../LangRef.rst:10619
msgid "The first argument is the value to be counted. This argument may be of any integer type, or a vector with integer element type. The return type must match the first argument type."
msgstr "第一个参数是要计算的值。此参数可以是任何整数类型，也可以是具有整数元素类型的向量。返回类型必须与第一个参数类型匹配。"

#: ../../LangRef.rst:10576 ../../LangRef.rst:10623
msgid "The second argument must be a constant and is a flag to indicate whether the intrinsic should ensure that a zero as the first argument produces a defined result. Historically some architectures did not provide a defined result for zero values as efficiently, and many algorithms are now predicated on avoiding zero-value inputs."
msgstr "第二个参数必须是常量，并且是一个标志，用于指示内在函数是否应确保零作为第一个参数产生定义的结果。从历史上看，一些架构并没有为零值提供有效的定义结果，现在许多算法都是基于避免零值输入。"

#: ../../LangRef.rst:10585
msgid "The '``llvm.ctlz``' intrinsic counts the leading (most significant) zeros in a variable, or within each element of the vector. If ``src == 0`` then the result is the size in bits of the type of ``src`` if ``is_zero_undef == 0`` and ``undef`` otherwise. For example, ``llvm.ctlz(i32 2) = 30``."
msgstr "'llvm.ctlz``'内在计算变量中的前导（最重要）零，或者向量的每个元素内的零。如果``src == 0``那么结果是``src``类型的位大小，如果``is_zero_undef == 0``，否则``undef``。例如，``llvm.ctlz（i32 2）= 30``。"

#: ../../LangRef.rst:10592
msgid "'``llvm.cttz.*``' Intrinsic"
msgstr "'``llvm.cttz。*``'内在"

#: ../../LangRef.rst:10597
msgid "This is an overloaded intrinsic. You can use ``llvm.cttz`` on any integer bit width, or any vector of integer elements. Not all targets support all bit widths or vector types, however."
msgstr "这是一个过载的内在。您可以在任何整数位宽度或任何整数元素向量上使用``llvm.cttz``。但是，并非所有目标都支持所有位宽或矢量类型。"

#: ../../LangRef.rst:10613
msgid "The '``llvm.cttz``' family of intrinsic functions counts the number of trailing zeros."
msgstr "'llvm.cttz``'内部函数族计算尾随零的数量。"

#: ../../LangRef.rst:10632
msgid "The '``llvm.cttz``' intrinsic counts the trailing (least significant) zeros in a variable, or within each element of a vector. If ``src == 0`` then the result is the size in bits of the type of ``src`` if ``is_zero_undef == 0`` and ``undef`` otherwise. For example, ``llvm.cttz(2) = 1``."
msgstr "'llvm.cttz``'内在函数计算变量或向量的每个元素内的尾随（最不重要）零。如果``src == 0``那么结果是``src``类型的位大小，如果``is_zero_undef == 0``，否则``undef``。例如，``llvm.cttz（2）= 1``。"

#: ../../LangRef.rst:10641
msgid "Arithmetic with Overflow Intrinsics"
msgstr "具有溢出内在函数的算术"

#: ../../LangRef.rst:10643
msgid "LLVM provides intrinsics for some arithmetic with overflow operations."
msgstr "LLVM为具有溢出操作的某些算法提供内在函数。"

#: ../../LangRef.rst:10646
msgid "'``llvm.sadd.with.overflow.*``' Intrinsics"
msgstr "'``llvm.sadd.with.overflow。*``'内在函数"

#: ../../LangRef.rst:10651
msgid "This is an overloaded intrinsic. You can use ``llvm.sadd.with.overflow`` on any integer bit width."
msgstr "这是一个过载的内在。您可以在任何整数位宽度上使用``llvm.sadd.with.overflow``。"

#: ../../LangRef.rst:10663
msgid "The '``llvm.sadd.with.overflow``' family of intrinsic functions perform a signed addition of the two arguments, and indicate whether an overflow occurred during the signed summation."
msgstr "'llvm.sadd.with.overflow``系列内部函数执行两个参数的有符号加法，并指示在符号求和期间是否发生溢出。"

#: ../../LangRef.rst:10670
msgid "The arguments (%a and %b) and the first element of the result structure may be of integer types of any bit width, but they must have the same bit width. The second element of the result structure must be of type ``i1``. ``%a`` and ``%b`` are the two values that will undergo signed addition."
msgstr "参数（ %a和%b ）和结果结构的第一个元素可以是任何位宽的整数类型，但它们必须具有相同的位宽。结果结构的第二个元素必须是``i1``类型。 `` %a a``和`` %b b``是将进行符号加法的两个值。"

#: ../../LangRef.rst:10679
msgid "The '``llvm.sadd.with.overflow``' family of intrinsic functions perform a signed addition of the two variables. They return a structure --- the first element of which is the signed summation, and the second element of which is a bit specifying if the signed summation resulted in an overflow."
msgstr "'llvm.sadd.with.overflow``'系列内部函数执行两个变量的带符号加法。它们返回一个结构---其中第一个元素是有符号求和，其中第二个元素是指定有符号求和是否导致溢出的位。"

#: ../../LangRef.rst:10696
msgid "'``llvm.uadd.with.overflow.*``' Intrinsics"
msgstr "'``llvm.uadd.with.overflow。*``'内在函数"

#: ../../LangRef.rst:10701
msgid "This is an overloaded intrinsic. You can use ``llvm.uadd.with.overflow`` on any integer bit width."
msgstr "这是一个过载的内在。你可以在任何整数位宽上使用``llvm.uadd.with.overflow``。"

#: ../../LangRef.rst:10713
msgid "The '``llvm.uadd.with.overflow``' family of intrinsic functions perform an unsigned addition of the two arguments, and indicate whether a carry occurred during the unsigned summation."
msgstr "'llvm.uadd.with.overflow``系列内部函数执行两个参数的无符号加法，并指示在无符号求和期间是否发生了进位。"

#: ../../LangRef.rst:10720
msgid "The arguments (%a and %b) and the first element of the result structure may be of integer types of any bit width, but they must have the same bit width. The second element of the result structure must be of type ``i1``. ``%a`` and ``%b`` are the two values that will undergo unsigned addition."
msgstr "参数（ %a和%b ）和结果结构的第一个元素可以是任何位宽的整数类型，但它们必须具有相同的位宽。结果结构的第二个元素必须是``i1``类型。 `` %a a``和`` %b b``是将进行无符号加法的两个值。"

#: ../../LangRef.rst:10729
msgid "The '``llvm.uadd.with.overflow``' family of intrinsic functions perform an unsigned addition of the two arguments. They return a structure --- the first element of which is the sum, and the second element of which is a bit specifying if the unsigned summation resulted in a carry."
msgstr "'llvm.uadd.with.overflow``'系列内部函数执行两个参数的无符号加法。它们返回一个结构---其中第一个元素是和，第二个元素是指定无符号求和是否导致进位的位。"

#: ../../LangRef.rst:10745
msgid "'``llvm.ssub.with.overflow.*``' Intrinsics"
msgstr "'``llvm.ssub.with.overflow。*``'内在学"

#: ../../LangRef.rst:10750
msgid "This is an overloaded intrinsic. You can use ``llvm.ssub.with.overflow`` on any integer bit width."
msgstr "这是一个过载的内在。你可以在任何整数位宽上使用``llvm.ssub.with.overflow``。"

#: ../../LangRef.rst:10762
msgid "The '``llvm.ssub.with.overflow``' family of intrinsic functions perform a signed subtraction of the two arguments, and indicate whether an overflow occurred during the signed subtraction."
msgstr "'llvm.ssub.with.overflow``系列内部函数执行两个参数的有符号减法，并指示在有符号减法期间是否发生溢出。"

#: ../../LangRef.rst:10769
msgid "The arguments (%a and %b) and the first element of the result structure may be of integer types of any bit width, but they must have the same bit width. The second element of the result structure must be of type ``i1``. ``%a`` and ``%b`` are the two values that will undergo signed subtraction."
msgstr "参数（ %a和%b ）和结果结构的第一个元素可以是任何位宽的整数类型，但它们必须具有相同的位宽。结果结构的第二个元素必须是``i1``类型。 `` %a a``和`` %b b``是经过有符号减法的两个值。"

#: ../../LangRef.rst:10778
msgid "The '``llvm.ssub.with.overflow``' family of intrinsic functions perform a signed subtraction of the two arguments. They return a structure --- the first element of which is the subtraction, and the second element of which is a bit specifying if the signed subtraction resulted in an overflow."
msgstr "'llvm.ssub.with.overflow``'内部函数族执行两个参数的有符号减法。它们返回一个结构---其中第一个元素是减法，其中第二个元素是指定有符号减法是否导致溢出的位。"

#: ../../LangRef.rst:10795
msgid "'``llvm.usub.with.overflow.*``' Intrinsics"
msgstr "'`llvm.usub.with.overflow。*``'内在函数"

#: ../../LangRef.rst:10800
msgid "This is an overloaded intrinsic. You can use ``llvm.usub.with.overflow`` on any integer bit width."
msgstr "这是一个过载的内在。你可以在任何整数位宽上使用``llvm.usub.with.overflow``。"

#: ../../LangRef.rst:10812
msgid "The '``llvm.usub.with.overflow``' family of intrinsic functions perform an unsigned subtraction of the two arguments, and indicate whether an overflow occurred during the unsigned subtraction."
msgstr "'llvm.usub.with.overflow``系列内部函数执行两个参数的无符号减法，并指示在无符号减法期间是否发生溢出。"

#: ../../LangRef.rst:10819
msgid "The arguments (%a and %b) and the first element of the result structure may be of integer types of any bit width, but they must have the same bit width. The second element of the result structure must be of type ``i1``. ``%a`` and ``%b`` are the two values that will undergo unsigned subtraction."
msgstr "参数（ %a和%b ）和结果结构的第一个元素可以是任何位宽的整数类型，但它们必须具有相同的位宽。结果结构的第二个元素必须是``i1``类型。 `` %a a``和`` %b b``是将进行无符号减法的两个值。"

#: ../../LangRef.rst:10828
msgid "The '``llvm.usub.with.overflow``' family of intrinsic functions perform an unsigned subtraction of the two arguments. They return a structure --- the first element of which is the subtraction, and the second element of which is a bit specifying if the unsigned subtraction resulted in an overflow."
msgstr "'llvm.usub.with.overflow``'系列内部函数执行两个参数的无符号减法。它们返回一个结构---其中第一个元素是减法，其中第二个元素是指定无符号减法是否导致溢出的位。"

#: ../../LangRef.rst:10845
msgid "'``llvm.smul.with.overflow.*``' Intrinsics"
msgstr "'``llvm.smul.with.overflow。*``'内在函数"

#: ../../LangRef.rst:10850
msgid "This is an overloaded intrinsic. You can use ``llvm.smul.with.overflow`` on any integer bit width."
msgstr "这是一个过载的内在。你可以在任何整数位宽上使用``llvm.smul.with.overflow``。"

#: ../../LangRef.rst:10862
msgid "The '``llvm.smul.with.overflow``' family of intrinsic functions perform a signed multiplication of the two arguments, and indicate whether an overflow occurred during the signed multiplication."
msgstr "'llvm.smul.with.overflow``'系列内部函数执行两个参数的有符号乘法，并指示在有符号乘法期间是否发生溢出。"

#: ../../LangRef.rst:10869
msgid "The arguments (%a and %b) and the first element of the result structure may be of integer types of any bit width, but they must have the same bit width. The second element of the result structure must be of type ``i1``. ``%a`` and ``%b`` are the two values that will undergo signed multiplication."
msgstr "参数（ %a和%b ）和结果结构的第一个元素可以是任何位宽的整数类型，但它们必须具有相同的位宽。结果结构的第二个元素必须是``i1``类型。 `` %a a``和`` %b b``是将进行有符号乘法的两个值。"

#: ../../LangRef.rst:10878
msgid "The '``llvm.smul.with.overflow``' family of intrinsic functions perform a signed multiplication of the two arguments. They return a structure --- the first element of which is the multiplication, and the second element of which is a bit specifying if the signed multiplication resulted in an overflow."
msgstr "'llvm.smul.with.overflow``'内部函数族执行两个参数的有符号乘法运算。它们返回一个结构---其中第一个元素是乘法，其中第二个元素是指定有符号乘法是否导致溢出的位。"

#: ../../LangRef.rst:10895
msgid "'``llvm.umul.with.overflow.*``' Intrinsics"
msgstr "'``llvm.umul.with.overflow。*``'内在的"

#: ../../LangRef.rst:10900
msgid "This is an overloaded intrinsic. You can use ``llvm.umul.with.overflow`` on any integer bit width."
msgstr "这是一个过载的内在。你可以在任何整数位宽上使用``llvm.umul.with.overflow``。"

#: ../../LangRef.rst:10912
msgid "The '``llvm.umul.with.overflow``' family of intrinsic functions perform a unsigned multiplication of the two arguments, and indicate whether an overflow occurred during the unsigned multiplication."
msgstr "'llvm.umul.with.overflow``系列内部函数执行两个参数的无符号乘法，并指示在无符号乘法期间是否发生溢出。"

#: ../../LangRef.rst:10919
msgid "The arguments (%a and %b) and the first element of the result structure may be of integer types of any bit width, but they must have the same bit width. The second element of the result structure must be of type ``i1``. ``%a`` and ``%b`` are the two values that will undergo unsigned multiplication."
msgstr "参数（ %a和%b ）和结果结构的第一个元素可以是任何位宽的整数类型，但它们必须具有相同的位宽。结果结构的第二个元素必须是``i1``类型。 `` %a a``和`` %b b``是将进行无符号乘法的两个值。"

#: ../../LangRef.rst:10928
msgid "The '``llvm.umul.with.overflow``' family of intrinsic functions perform an unsigned multiplication of the two arguments. They return a structure --- the first element of which is the multiplication, and the second element of which is a bit specifying if the unsigned multiplication resulted in an overflow."
msgstr "'llvm.umul.with.overflow``'内部函数族执行两个参数的无符号乘法运算。它们返回一个结构---其中第一个元素是乘法，其中第二个元素是指定无符号乘法是否导致溢出的位。"

#: ../../LangRef.rst:10945
msgid "Specialised Arithmetic Intrinsics"
msgstr "专业算术内在函数"

#: ../../LangRef.rst:10948
msgid "'``llvm.canonicalize.*``' Intrinsic"
msgstr "'``llvm.canonicalize。*``'内在"

#: ../../LangRef.rst:10961
msgid "The '``llvm.canonicalize.*``' intrinsic returns the platform specific canonical encoding of a floating point number. This canonicalization is useful for implementing certain numeric primitives such as frexp. The canonical encoding is defined by IEEE-754-2008 to be:"
msgstr "'llvm.canonicalize。*``'内在函数返回浮点数的平台特定规范编码。这种规范化对于实现某些数字原语（例如frexp）很有用。规范编码由IEEE-754-2008定义为："

#: ../../LangRef.rst:10972
msgid "This operation can also be considered equivalent to the IEEE-754-2008 conversion of a floating-point value to the same format. NaNs are handled according to section 6.2."
msgstr "此操作也可以被认为等同于IEEE-754-2008将浮点值转换为相同格式。 NaNs根据6.2节处理。"

#: ../../LangRef.rst:10976
msgid "Examples of non-canonical encodings:"
msgstr "非规范编码的示例："

#: ../../LangRef.rst:10978
msgid "x87 pseudo denormals, pseudo NaNs, pseudo Infinity, Unnormals. These are converted to a canonical representation per hardware-specific protocol."
msgstr "x87伪非正规，伪NaNs，伪无穷大，异常。根据特定于硬件的协议将它们转换为规范表示。"

#: ../../LangRef.rst:10980
msgid "Many normal decimal floating point numbers have non-canonical alternative encodings."
msgstr "许多正常的十进制浮点数具有非规范的替代编码。"

#: ../../LangRef.rst:10982
msgid "Some machines, like GPUs or ARMv7 NEON, do not support subnormal values. These are treated as non-canonical encodings of zero and with be flushed to a zero of the same sign by this operation."
msgstr "某些机器（如GPU或ARMv7 NEON）不支持次正常值。这些被视为零的非规范编码，并且通过该操作被刷新到相同符号的零。"

#: ../../LangRef.rst:10986
msgid "Note that per IEEE-754-2008 6.2, systems that support signaling NaNs with default exception handling must signal an invalid exception, and produce a quiet NaN result."
msgstr "请注意，根据IEEE-754-2008 6.2，支持具有默认异常处理的信令NaN的系统必须发出无效异常信号，并产生安静的NaN结果。"

#: ../../LangRef.rst:10990
msgid "This function should always be implementable as multiplication by 1.0, provided that the compiler does not constant fold the operation. Likewise, division by 1.0 and ``llvm.minnum(x, x)`` are possible implementations. Addition with -0.0 is also sufficient provided that the rounding mode is not -Infinity."
msgstr "如果编译器不对常量进行折叠操作，则此函数应始终可以实现为乘以1.0。同样，除以1.0和``llvm.minnum（x，x）``是可能的实现。如果舍入模式不是-Infinity，则添加-0.0也是足够的。"

#: ../../LangRef.rst:10995
msgid "``@llvm.canonicalize`` must preserve the equality relation. That is:"
msgstr "``@llvm.canonicalize``必须保持平等关系。那是："

#: ../../LangRef.rst:10997
msgid "``(@llvm.canonicalize(x) == x)`` is equivalent to ``(x == x)``"
msgstr "``（@ llvm.canonicalize（x）== x）``相当于```（x == x）``"

#: ../../LangRef.rst:10998
msgid "``(@llvm.canonicalize(x) == @llvm.canonicalize(y))`` is equivalent to to ``(x == y)``"
msgstr "``（@ llvm.canonicalize（x）== @ llvm.canonicalize（y））``相当于```（x == y）``"

#: ../../LangRef.rst:11001
msgid "Additionally, the sign of zero must be conserved: ``@llvm.canonicalize(-0.0) = -0.0`` and ``@llvm.canonicalize(+0.0) = +0.0``"
msgstr "此外，必须保留零的符号：``@ llvm.canonicalize（-0.0）= -0.0``和``@ llvm.canonicalize（+0.0）= + 0.0``"

#: ../../LangRef.rst:11004
msgid "The payload bits of a NaN must be conserved, with two exceptions. First, environments which use only a single canonical representation of NaN must perform said canonicalization. Second, SNaNs must be quieted per the usual methods."
msgstr "必须保留NaN的有效负载位，但有两个例外。首先，仅使用NaN的单个规范表示的环境必须执行所述规范化。其次，SNaN必须按照通常的方法安静。"

#: ../../LangRef.rst:11009
msgid "The canonicalization operation may be optimized away if:"
msgstr "如果符合以下情况，可以优化规范化操作："

#: ../../LangRef.rst:11011
msgid "The input is known to be canonical. For example, it was produced by a floating-point operation that is required by the standard to be canonical."
msgstr "已知输入是规范的。例如，它是由标准要求的浮点运算产生的规范。"

#: ../../LangRef.rst:11013
msgid "The result is consumed only by (or fused with) other floating-point operations. That is, the bits of the floating point value are not examined."
msgstr "结果仅由其他浮点运算（或与其融合）消耗。也就是说，不检查浮点值的位。"

#: ../../LangRef.rst:11017
msgid "'``llvm.fmuladd.*``' Intrinsic"
msgstr "'`llvm.fmuladd。*``'内在"

#: ../../LangRef.rst:11030
msgid "The '``llvm.fmuladd.*``' intrinsic functions represent multiply-add expressions that can be fused if the code generator determines that (a) the target instruction set has support for a fused operation, and (b) that the fused operation is more efficient than the equivalent, separate pair of mul and add instructions."
msgstr "'llvm.fmuladd。*``'内部函数表示可以融合的乘法 - 加法表达式，如果代码生成器确定（a）目标指令集支持融合操作，并且（b）融合操作操作比等效的，单独的mul和添加指令更有效。"

#: ../../LangRef.rst:11039
msgid "The '``llvm.fmuladd.*``' intrinsics each take three arguments: two multiplicands, a and b, and an addend c."
msgstr "'llvm.fmuladd。*``'内在函数每个都有三个参数：两个被乘数，a和b，以及一个加数c。"

#: ../../LangRef.rst:11045
msgid "The expression:"
msgstr "表达方式："

#: ../../LangRef.rst:11051
msgid "is equivalent to the expression a \\* b + c, except that rounding will not be performed between the multiplication and addition steps if the code generator fuses the operations. Fusion is not guaranteed, even if the target platform supports it. If a fused multiply-add is required the corresponding llvm.fma.\\* intrinsic function should be used instead. This never sets errno, just as '``llvm.fma.*``'."
msgstr "等价于表达式a \\ * b + c，除非如果代码生成器对操作进行融合，则不会在乘法和加法步骤之间执行舍入。即使目标平台支持Fusion，也无法保证Fusion。如果需要融合乘法加法，则应使用相应的llvm.fma。\\ *内部函数。这永远不会设置errno，就像'llvm.fma。*``'一样。"

#: ../../LangRef.rst:11066
msgid "Half Precision Floating Point Intrinsics"
msgstr "半精度浮点内在函数"

#: ../../LangRef.rst:11068
msgid "For most target platforms, half precision floating point is a storage-only format. This means that it is a dense encoding (in memory) but does not support computation in the format."
msgstr "对于大多数目标平台，半精度浮点是仅存储格式。这意味着它是一种密集编码（在内存中），但不支持格式化计算。"

#: ../../LangRef.rst:11072
msgid "This means that code must first load the half-precision floating point value as an i16, then convert it to float with :ref:`llvm.convert.from.fp16 <int_convert_from_fp16>`. Computation can then be performed on the float value (including extending to double etc). To store the value back to memory, it is first converted to float if needed, then converted to i16 with :ref:`llvm.convert.to.fp16 <int_convert_to_fp16>`, then storing as an i16 value."
msgstr "这意味着代码必须首先将半精度浮点值加载为i16，然后将其转换为float：ref：`llvm.convert.from.fp16 <int_convert_from_fp16>`。然后可以对浮点值执行计算（包括扩展到double等）。要将值存储回内存，如果需要，首先将其转换为float，然后使用：ref：`llvm.convert.to.fp16 <int_convert_to_fp16>`转换为i16，然后存储为i16值。"

#: ../../LangRef.rst:11084
msgid "'``llvm.convert.to.fp16``' Intrinsic"
msgstr "'``llvm.convert.to.fp16``'内在"

#: ../../LangRef.rst:11097
msgid "The '``llvm.convert.to.fp16``' intrinsic function performs a conversion from a conventional floating point type to half precision floating point format."
msgstr "'`llvm.convert.to.fp16``'内在函数执行从传统浮点类型到半精度浮点格式的转换。"

#: ../../LangRef.rst:11103 ../../LangRef.rst:11144
msgid "The intrinsic function contains single argument - the value to be converted."
msgstr "内部函数包含单个参数 - 要转换的值。"

#: ../../LangRef.rst:11109
msgid "The '``llvm.convert.to.fp16``' intrinsic function performs a conversion from a conventional floating point format to half precision floating point format. The return value is an ``i16`` which contains the converted number."
msgstr "'`llvm.convert.to.fp16``'内在函数执行从传统浮点格式到半精度浮点格式的转换。返回值是一个“i16”，其中包含转换后的数字。"

#: ../../LangRef.rst:11124
msgid "'``llvm.convert.from.fp16``' Intrinsic"
msgstr "'``llvm.convert.from.fp16``'内在"

#: ../../LangRef.rst:11137
msgid "The '``llvm.convert.from.fp16``' intrinsic function performs a conversion from half precision floating point format to single precision floating point format."
msgstr "'`llvm.convert.from.fp16``'内部函数执行从半精度浮点格式到单精度浮点格式的转换。"

#: ../../LangRef.rst:11150
msgid "The '``llvm.convert.from.fp16``' intrinsic function performs a conversion from half single precision floating point format to single precision floating point format. The input half-float value is represented by an ``i16`` value."
msgstr "'`llvm.convert.from.fp16``'内部函数执行从半精度浮点格式到单精度浮点格式的转换。输入的半浮点值由“i16”值表示。"

#: ../../LangRef.rst:11166
msgid "Debugger Intrinsics"
msgstr "调试器内在函数"

#: ../../LangRef.rst:11168
msgid "The LLVM debugger intrinsics (which all start with ``llvm.dbg.`` prefix), are described in the `LLVM Source Level Debugging <SourceLevelDebugging.html#format_common_intrinsics>`_ document."
msgstr "LLVM调试器内在函数（都以``llvm.dbg .`前缀开头）在`LLVM源级调试<SourceLevelDebugging.html #format_common_intrinsics>`_文档中描述。"

#: ../../LangRef.rst:11174
msgid "Exception Handling Intrinsics"
msgstr "异常处理内在函数"

#: ../../LangRef.rst:11176
msgid "The LLVM exception handling intrinsics (which all start with ``llvm.eh.`` prefix), are described in the `LLVM Exception Handling <ExceptionHandling.html#format_common_intrinsics>`_ document."
msgstr "LLVM异常处理内在函数（都以``llvm.eh .`前缀开头）在`LLVM异常处理<ExceptionHandling.html＃format_common_intrinsics>`_ document中描述。"

#: ../../LangRef.rst:11183
msgid "Trampoline Intrinsics"
msgstr "蹦床内在症"

#: ../../LangRef.rst:11185
msgid "These intrinsics make it possible to excise one parameter, marked with the :ref:`nest <nest>` attribute, from a function. The result is a callable function pointer lacking the nest parameter - the caller does not need to provide a value for it. Instead, the value to use is stored in advance in a \"trampoline\", a block of memory usually allocated on the stack, which also contains code to splice the nest value into the argument list. This is used to implement the GCC nested function address extension."
msgstr "这些内在函数可以从函数中删除一个用：ref：`nest <nest>`属性标记的参数。结果是一个缺少nest参数的可调用函数指针 - 调用者不需要为它提供值。相反，要使用的值预先存储在一个“trampoline”中，这是一个通常在堆栈上分配的内存块，它还包含将嵌套值拼接到参数列表中的代码。这用于实现GCC嵌套函数地址扩展。"

#: ../../LangRef.rst:11194
#, python-format
msgid "For example, if the function is ``i32 f(i8* nest %c, i32 %x, i32 %y)`` then the resulting function pointer has signature ``i32 (i32, i32)*``. It can be created as follows:"
msgstr "例如，如果函数是``i32 f（i8 * nest %c ，i32 %x ，i32％y）``，则生成的函数指针具有签名“i32（i32，i32）*``。它可以创建如下："

#: ../../LangRef.rst:11206
#, python-format
msgid "The call ``%val = call i32 %fp(i32 %x, i32 %y)`` is then equivalent to ``%val = call i32 %f(i8* %nval, i32 %x, i32 %y)``."
msgstr "调用``％val =调用i32％fp（i32％x，i32％y）``等于``％val =调用i32％f（i8 *％nval，i32％x，i32％y）` `。"

#: ../../LangRef.rst:11212
msgid "'``llvm.init.trampoline``' Intrinsic"
msgstr "'`llvm.init.trampoline``'内在"

#: ../../LangRef.rst:11224
msgid "This fills the memory pointed to by ``tramp`` with executable code, turning it into a trampoline."
msgstr "这用可执行代码填充``tramp``指向的内存，将其变成蹦床。"

#: ../../LangRef.rst:11230
msgid "The ``llvm.init.trampoline`` intrinsic takes three arguments, all pointers. The ``tramp`` argument must point to a sufficiently large and sufficiently aligned block of memory; this memory is written to by the intrinsic. Note that the size and the alignment are target-specific - LLVM currently provides no portable way of determining them, so a front-end that generates this intrinsic needs to have some target-specific knowledge. The ``func`` argument must hold a function bitcast to an ``i8*``."
msgstr "``llvm.init.trampoline``内在函数有三个参数，都是指针。 ``tramp``参数必须指向足够大且充分对齐的内存块;这个记忆是由内在写的。请注意，大小和对齐是特定于目标的 -  LLVM目前不提供确定它们的可移植方式，因此生成此内在函数的前端需要具有一些特定于目标的知识。 ``func``参数必须包含一个函数bitcast到``i8 *``。"

#: ../../LangRef.rst:11242
msgid ""
"The block of memory pointed to by ``tramp`` is filled with target dependent code, turning it into a function. Then ``tramp`` needs to be passed to :ref:`llvm.adjust.trampoline <int_at>` to get a pointer which can be :ref:`bitcast (to a new function) and called <int_trampoline>`. The new function's signature is the same as that of ``func`` with any arguments marked with the ``nest`` attribute removed. At most one such ``nest`` argument is allowed, and it must be of pointer type. Calling the new function is equivalent to calling ``func`` with the same argument list, but "
"with ``nval`` used for the missing ``nest`` argument. If, after calling ``llvm.init.trampoline``, the memory pointed to by ``tramp`` is modified, then the effect of any later call to the returned function pointer is undefined."
msgstr "``tramp``指向的内存块充满了目标相关代码，将其转换为函数。然后``tramp``需要传递给：ref：`llvm.adjust.trampoline <int_at>`得到一个指针，它可以是：ref：`bitcast（到一个新函数）并且叫做<int_trampoline>`。新函数的签名与``func``的签名相同，删除了标有``nest``属性的任何参数。最多允许一个这样的``nest``参数，它必须是指针类型。调用新函数相当于使用相同的参数列表调用``func``，但使用``nval``用于缺少``nest``参数。如果在调用``llvm.init.trampoline``之后，修改了``tramp``指向的内存，那么以后调用返回的函数指针的效果是不确定的。"

#: ../../LangRef.rst:11258
msgid "'``llvm.adjust.trampoline``' Intrinsic"
msgstr "'`llvm.adjust.trampoline``'内在"

#: ../../LangRef.rst:11270
msgid "This performs any required machine-specific adjustment to the address of a trampoline (passed as ``tramp``)."
msgstr "这将对蹦床的地址执行任何所需的机器特定调整（作为“tramp``传递）。"

#: ../../LangRef.rst:11276
msgid "``tramp`` must point to a block of memory which already has trampoline code filled in by a previous call to :ref:`llvm.init.trampoline <int_it>`."
msgstr "``tramp``必须指向一个内存块，它已经有一个前面调用填充的trampoline代码：ref：`llvm.init.trampoline <int_it>`。"

#: ../../LangRef.rst:11283
msgid "On some architectures the address of the code to be executed needs to be different than the address where the trampoline is actually stored. This intrinsic returns the executable address corresponding to ``tramp`` after performing the required machine specific adjustments. The pointer returned can then be :ref:`bitcast and executed <int_trampoline>`."
msgstr "在某些体系结构中，要执行的代码的地址需要与实际存储蹦床的地址不同。在执行所需的机器特定调整之后，此内在函数返回对应于“tramp”的可执行地址。返回的指针可以是：ref：`bitcast和execution <int_trampoline>`。"

#: ../../LangRef.rst:11292
msgid "Masked Vector Load and Store Intrinsics"
msgstr "蒙面矢量加载和存储内在"

#: ../../LangRef.rst:11294
msgid "LLVM provides intrinsics for predicated vector load and store operations. The predicate is specified by a mask operand, which holds one bit per vector element, switching the associated vector lane on or off. The memory addresses corresponding to the \"off\" lanes are not accessed. When all bits of the mask are on, the intrinsic is identical to a regular vector load or store. When all bits are off, no memory is accessed."
msgstr "LLVM为谓词向量加载和存储操作提供内在函数。谓词由掩码操作数指定，该操作数为每个向量元素保留一位，打开或关闭相关的向量通道。不访问与“关闭”通道对应的存储器地址。当掩码的所有位都打开时，内在函数与常规向量加载或存储相同。当所有位都关闭时，不访问任何内存。"

#: ../../LangRef.rst:11299
msgid "'``llvm.masked.load.*``' Intrinsics"
msgstr "'``llvm.masked.load。*``'内在函数"

#: ../../LangRef.rst:11303
msgid "This is an overloaded intrinsic. The loaded data is a vector of any integer, floating point or pointer data type."
msgstr "这是一个过载的内在。加载的数据是任何整数，浮点或指针数据类型的向量。"

#: ../../LangRef.rst:11317
msgid "Reads a vector from memory according to the provided mask. The mask holds a bit for each vector lane, and is used to prevent memory accesses to the masked-off lanes. The masked-off lanes in the result vector are taken from the corresponding lanes of the '``passthru``' operand."
msgstr "根据提供的掩码从内存中读取矢量。掩码为每个矢量通道保持一个位，用于防止存储器访问屏蔽的通道。结果向量中被屏蔽掉的通道取自“passthru``'操作数的相应通道。"

#: ../../LangRef.rst:11323
msgid "The first operand is the base pointer for the load. The second operand is the alignment of the source location. It must be a constant integer value. The third operand, mask, is a vector of boolean values with the same number of elements as the return type. The fourth is a pass-through value that is used to fill the masked-off lanes of the result. The return type, underlying type of the base pointer and the type of the '``passthru``' operand are the same vector types."
msgstr "第一个操作数是加载的基指针。第二个操作数是源位置的对齐方式。它必须是一个常量整数值。第三个操作数mask是布尔值的向量，其元素数量与返回类型相同。第四个是传递值，用于填充结果的屏蔽通道。返回类型，基指针的基础类型和'`paspashru``'操作数的类型是相同的向量类型。"

#: ../../LangRef.rst:11329
msgid ""
"The '``llvm.masked.load``' intrinsic is designed for conditional reading of selected vector elements in a single IR operation. It is useful for targets that support vector masked loads and allows vectorizing predicated basic blocks on these targets. Other targets may support this intrinsic differently, for example by lowering it into a sequence of branches that guard scalar load operations. The result of this operation is equivalent to a regular vector load instruction followed by a 'select' between the loaded and the passthru values, predicated on the same mask. "
"However, using this intrinsic prevents exceptions on memory access to masked-off lanes."
msgstr "'llvm.masked.load``'内在设计用于在单个IR操作中对所选向量元素进行条件读取。它对于支持矢量屏蔽负载的目标很有用，并允许对这些目标上的谓词基本块进行矢量化。其他目标可以不同地支持这种内在，例如通过将其降低为保护标量加载操作的一系列分支。此操作的结果相当于常规向量加载指令，后跟加载值和passthru值之间的“select”，以相同的掩码为基础。但是，使用此内在函数可防止对内存访问掩盖的通道的异常。"

#: ../../LangRef.rst:11344
msgid "'``llvm.masked.store.*``' Intrinsics"
msgstr "'``llvm.masked.store。*``'内在的"

#: ../../LangRef.rst:11348
msgid "This is an overloaded intrinsic. The data stored in memory is a vector of any integer, floating point or pointer data type."
msgstr "这是一个过载的内在。存储在存储器中的数据是任何整数，浮点或指针数据类型的向量。"

#: ../../LangRef.rst:11362
msgid "Writes a vector to memory according to the provided mask. The mask holds a bit for each vector lane, and is used to prevent memory accesses to the masked-off lanes."
msgstr "根据提供的掩码将向量写入内存。掩码为每个矢量通道保持一个位，用于防止存储器访问屏蔽的通道。"

#: ../../LangRef.rst:11367
msgid "The first operand is the vector value to be written to memory. The second operand is the base pointer for the store, it has the same underlying type as the value operand. The third operand is the alignment of the destination location. The fourth operand, mask, is a vector of boolean values. The types of the mask and the value operand must have the same number of vector elements."
msgstr "第一个操作数是要写入内存的向量值。第二个操作数是商店的基指针，它与值操作数具有相同的基础类型。第三个操作数是目标位置的对齐方式。第四个操作数mask是布尔值的向量。掩码的类型和值操作数必须具有相同数量的向量元素。"

#: ../../LangRef.rst:11373
msgid ""
"The '``llvm.masked.store``' intrinsics is designed for conditional writing of selected vector elements in a single IR operation. It is useful for targets that support vector masked store and allows vectorizing predicated basic blocks on these targets. Other targets may support this intrinsic differently, for example by lowering it into a sequence of branches that guard scalar store operations. The result of this operation is equivalent to a load-modify-store sequence. However, using this intrinsic prevents exceptions and data races on memory access to masked-off lanes."
msgstr "'llvm.masked.store``'内在函数用于在单个IR操作中对所选向量元素进行条件写入。它对于支持矢量屏蔽存储的目标很有用，并允许在这些目标上矢量化谓词基本块。其他目标可以不同地支持这种内在，例如通过将其降低为保护标量存储操作的一系列分支。此操作的结果等同于加载 - 修改 - 存储序列。但是，使用此内在函数可防止对屏蔽掉的通道进行内存访问时的异常和数据争用。"

#: ../../LangRef.rst:11387
msgid "Masked Vector Gather and Scatter Intrinsics"
msgstr "蒙面的矢量集合和散点内在"

#: ../../LangRef.rst:11389
msgid "LLVM provides intrinsics for vector gather and scatter operations. They are similar to :ref:`Masked Vector Load and Store <int_mload_mstore>`, except they are designed for arbitrary memory accesses, rather than sequential memory accesses. Gather and scatter also employ a mask operand, which holds one bit per vector element, switching the associated vector lane on or off. The memory addresses corresponding to the \"off\" lanes are not accessed. When all bits are off, no memory is accessed."
msgstr "LLVM为向量收集和分散操作提供内在函数。它们类似于：ref：`Masked Vector Load和Store <int_mload_mstore>`，除了它们是为任意内存访问而不是顺序内存访问而设计的。收集和散布还使用掩码操作数，每个向量元素保持一位，打开或关闭相关的矢量通道。不访问与“关闭”通道对应的存储器地址。当所有位都关闭时，不访问任何内存。"

#: ../../LangRef.rst:11394
msgid "'``llvm.masked.gather.*``' Intrinsics"
msgstr "'``llvm.masked.gather。*``'内在学"

#: ../../LangRef.rst:11398
msgid "This is an overloaded intrinsic. The loaded data are multiple scalar values of any integer, floating point or pointer data type gathered together into one vector."
msgstr "这是一个过载的内在。加载的数据是一起收集到一个向量中的任何整数，浮点或指针数据类型的多个标量值。"

#: ../../LangRef.rst:11409
msgid "Reads scalar values from arbitrary memory locations and gathers them into one vector. The memory locations are provided in the vector of pointers '``ptrs``'. The memory is accessed according to the provided mask. The mask holds a bit for each vector lane, and is used to prevent memory accesses to the masked-off lanes. The masked-off lanes in the result vector are taken from the corresponding lanes of the '``passthru``' operand."
msgstr "从任意内存位置读取标量值并将它们收集到一个向量中。内存位置在指针'`'ptrs``'的矢量中提供。根据提供的掩码访问存储器。掩码为每个矢量通道保持一个位，用于防止存储器访问屏蔽的通道。结果向量中被屏蔽掉的通道取自“passthru``'操作数的相应通道。"

#: ../../LangRef.rst:11415
msgid "The first operand is a vector of pointers which holds all memory addresses to read. The second operand is an alignment of the source addresses. It must be a constant integer value. The third operand, mask, is a vector of boolean values with the same number of elements as the return type. The fourth is a pass-through value that is used to fill the masked-off lanes of the result. The return type, underlying type of the vector of pointers and the type of the '``passthru``' operand are the same vector types."
msgstr "第一个操作数是一个指针向量，它保存所有要读取的内存地址。第二个操作数是源地址的对齐方式。它必须是一个常量整数值。第三个操作数mask是布尔值的向量，其元素数量与返回类型相同。第四个是传递值，用于填充结果的屏蔽通道。返回类型，指针向量的基础类型和“`passthru``'操作数的类型是相同的向量类型。"

#: ../../LangRef.rst:11421
msgid ""
"The '``llvm.masked.gather``' intrinsic is designed for conditional reading of multiple scalar values from arbitrary memory locations in a single IR operation. It is useful for targets that support vector masked gathers and allows vectorizing basic blocks with data and control divergence. Other targets may support this intrinsic differently, for example by lowering it into a sequence of scalar load operations. The semantics of this operation are equivalent to a sequence of conditional scalar loads with subsequent gathering all loaded values into a single vector. The "
"mask restricts memory access to certain lanes and facilitates vectorization of predicated basic blocks."
msgstr "'llvm.masked.gather``'内在设计用于在单个IR操作中从任意存储器位置条件读取多个标量值。它对于支持向量蒙版道集的目标很有用，并允许使用数据和控制偏差对基本块进行矢量化。其他目标可以不同地支持这种内在，例如通过将其降低为一系列标量加载操作。此操作的语义等同于一系列条件标量加载，随后将所有加载的值收集到单个向量中。掩码限制对某些通道的存储器访问，并促进谓词基本块的向量化。"

#: ../../LangRef.rst:11448
msgid "'``llvm.masked.scatter.*``' Intrinsics"
msgstr "'`llvm.masked.scatter。*``'内在学"

#: ../../LangRef.rst:11452
msgid "This is an overloaded intrinsic. The data stored in memory is a vector of any integer, floating point or pointer data type. Each vector element is stored in an arbitrary memory address. Scatter with overlapping addresses is guaranteed to be ordered from least-significant to most-significant element."
msgstr "这是一个过载的内在。存储在存储器中的数据是任何整数，浮点或指针数据类型的向量。每个向量元素存储在任意存储器地址中。保证重叠地址的分散从最不重要到最重要的元素排序。"

#: ../../LangRef.rst:11463
msgid "Writes each element from the value vector to the corresponding memory address. The memory addresses are represented as a vector of pointers. Writing is done according to the provided mask. The mask holds a bit for each vector lane, and is used to prevent memory accesses to the masked-off lanes."
msgstr "将每个元素从值向量写入相应的内存地址。存储器地址表示为指针向量。根据提供的面具进行书写。掩码为每个矢量通道保持一个位，用于防止存储器访问屏蔽的通道。"

#: ../../LangRef.rst:11468
msgid "The first operand is a vector value to be written to memory. The second operand is a vector of pointers, pointing to where the value elements should be stored. It has the same underlying type as the value operand. The third operand is an alignment of the destination addresses. The fourth operand, mask, is a vector of boolean values. The types of the mask and the value operand must have the same number of vector elements."
msgstr "第一个操作数是要写入内存的向量值。第二个操作数是指针向量，指向应存储值元素的位置。它与值操作数具有相同的基础类型。第三个操作数是目标地址的对齐方式。第四个操作数mask是布尔值的向量。掩码的类型和值操作数必须具有相同数量的向量元素。"

#: ../../LangRef.rst:11474
msgid "The '``llvm.masked.scatter``' intrinsics is designed for writing selected vector elements to arbitrary memory addresses in a single IR operation. The operation may be conditional, when not all bits in the mask are switched on. It is useful for targets that support vector masked scatter and allows vectorizing basic blocks with data and control divergence. Other targets may support this intrinsic differently, for example by lowering it into a sequence of branches that guard scalar store operations."
msgstr "'llvm.masked.scatter``'内在函数用于在单个IR操作中将选定的向量元素写入任意内存地址。当不是掩模中的所有位都接通时，操作可以是有条件的。它对于支持向量屏蔽分散的目标很有用，并允许使用数据和控制偏差对基本块进行矢量化。其他目标可以不同地支持这种内在，例如通过将其降低为保护标量存储操作的一系列分支。"

#: ../../LangRef.rst:11498
msgid "Memory Use Markers"
msgstr "记忆使用标记"

#: ../../LangRef.rst:11500
msgid "This class of intrinsics provides information about the lifetime of memory objects and ranges where variables are immutable."
msgstr "此类内在函数提供有关内存对象的生存期和变量不可变的范围的信息。"

#: ../../LangRef.rst:11506
msgid "'``llvm.lifetime.start``' Intrinsic"
msgstr "'`llvm.lifetime.start``'内在"

#: ../../LangRef.rst:11518
msgid "The '``llvm.lifetime.start``' intrinsic specifies the start of a memory object's lifetime."
msgstr "'`llvm.lifetime.start``'内在函数指定了内存对象生命周期的开始。"

#: ../../LangRef.rst:11524 ../../LangRef.rst:11557 ../../LangRef.rst:11588
msgid "The first argument is a constant integer representing the size of the object, or -1 if it is variable sized. The second argument is a pointer to the object."
msgstr "第一个参数是表示对象大小的常量整数，如果是可变大小，则为-1。第二个参数是指向对象的指针。"

#: ../../LangRef.rst:11531
msgid "This intrinsic indicates that before this point in the code, the value of the memory pointed to by ``ptr`` is dead. This means that it is known to never be used and has an undefined value. A load from the pointer that precedes this intrinsic can be replaced with ``'undef'``."
msgstr "这个内在函数表明在代码中的这一点之前，``ptr``指向的内存值已经死了。这意味着它永远不会被使用并且具有未定义的值。来自该内在函数之前的指针的加载可以用``'undef'``替换。"

#: ../../LangRef.rst:11539
msgid "'``llvm.lifetime.end``' Intrinsic"
msgstr "'`llvm.lifetime.end``'内在"

#: ../../LangRef.rst:11551
msgid "The '``llvm.lifetime.end``' intrinsic specifies the end of a memory object's lifetime."
msgstr "'llvm.lifetime.end``'内在函数指定了内存对象生命周期的结束。"

#: ../../LangRef.rst:11564
msgid "This intrinsic indicates that after this point in the code, the value of the memory pointed to by ``ptr`` is dead. This means that it is known to never be used and has an undefined value. Any stores into the memory object following this intrinsic may be removed as dead."
msgstr "这个内在函数表明在代码中的这一点之后，``ptr``指向的内存值已经死了。这意味着它永远不会被使用并且具有未定义的值。任何存储在此内在函数之后的内存对象中的存储可能会被删除。"

#: ../../LangRef.rst:11570
msgid "'``llvm.invariant.start``' Intrinsic"
msgstr "'`llvm.invariant.start``'内在"

#: ../../LangRef.rst:11582
msgid "The '``llvm.invariant.start``' intrinsic specifies that the contents of a memory object will not change."
msgstr "'`llvm.invariant.start``'内在函数指定内存对象的内容不会改变。"

#: ../../LangRef.rst:11595
msgid "This intrinsic indicates that until an ``llvm.invariant.end`` that uses the return value, the referenced memory location is constant and unchanging."
msgstr "这个内在函数表明，在使用返回值的``llvm.invariant.end``之前，引用的内存位置是常量且不变的。"

#: ../../LangRef.rst:11600
msgid "'``llvm.invariant.end``' Intrinsic"
msgstr "'`llvm.invariant.end``'内在"

#: ../../LangRef.rst:11612
msgid "The '``llvm.invariant.end``' intrinsic specifies that the contents of a memory object are mutable."
msgstr "'`llvm.invariant.end``'内在函数指定内存对象的内容是可变的。"

#: ../../LangRef.rst:11618
msgid "The first argument is the matching ``llvm.invariant.start`` intrinsic. The second argument is a constant integer representing the size of the object, or -1 if it is variable sized and the third argument is a pointer to the object."
msgstr "第一个参数是匹配的``llvm.invariant.start``内在函数。第二个参数是表示对象大小的常量整数，如果是可变大小则为-1，第三个参数是指向对象的指针。"

#: ../../LangRef.rst:11626
msgid "This intrinsic indicates that the memory is mutable again."
msgstr "此内在函数表明内存再次可变。"

#: ../../LangRef.rst:11629
msgid "'``llvm.invariant.group.barrier``' Intrinsic"
msgstr "'``llvm.invariant.group.barrier``'内在"

#: ../../LangRef.rst:11641
msgid "The '``llvm.invariant.group.barrier``' intrinsic can be used when an invariant established by invariant.group metadata no longer holds, to obtain a new pointer value that does not carry the invariant information."
msgstr "当由invariant.group元数据建立的不变量不再成立时，可以使用'`llvm.invariant.group.barrier``'内在函数，以获得不携带不变信息的新指针值。"

#: ../../LangRef.rst:11649
msgid "The ``llvm.invariant.group.barrier`` takes only one argument, which is the pointer to the memory for which the ``invariant.group`` no longer holds."
msgstr "``llvm.invariant.group.barrier``只接受一个参数，它是指向``invariant.group``不再成立的内存的指针。"

#: ../../LangRef.rst:11655
msgid "Returns another pointer that aliases its argument but which is considered different for the purposes of ``load``/``store`` ``invariant.group`` metadata."
msgstr "返回另一个指针，该指针将其参数别名，但出于``load`` /``store````inviantiant.group``元数据的目的，它被认为是不同的。"

#: ../../LangRef.rst:11659
msgid "General Intrinsics"
msgstr "一般内在学"

#: ../../LangRef.rst:11661
msgid "This class of intrinsics is designed to be generic and has no specific purpose."
msgstr "这类内在函数是通用的，没有特定的目的。"

#: ../../LangRef.rst:11665
msgid "'``llvm.var.annotation``' Intrinsic"
msgstr "'``llvm.var.annotation``' 内建指令"

#: ../../LangRef.rst:11677
msgid "The '``llvm.var.annotation``' intrinsic."
msgstr "'llvm.var.annotation``' 内建指令。"

#: ../../LangRef.rst:11682
msgid "The first argument is a pointer to a value, the second is a pointer to a global string, the third is a pointer to a global string which is the source file name, and the last argument is the line number."
msgstr "第一个参数是指向值的指针，第二个参数是指向全局字符串的指针，第三个参数是指向全局字符串的指针，该字符串是源文件名，最后一个参数是行号。"

#: ../../LangRef.rst:11689
msgid "This intrinsic allows annotation of local variables with arbitrary strings. This can be useful for special purpose optimizations that want to look for these annotations. These have no other defined use; they are ignored by code generation and optimization."
msgstr "此内在函数允许使用任意字符串注释局部变量。这对于想要查找这些注释的特殊用途优化非常有用。这些没有其他明确的用途;代码生成和优化会忽略它们。"

#: ../../LangRef.rst:11695
msgid "'``llvm.ptr.annotation.*``' Intrinsic"
msgstr "'``llvm.ptr.annotation。*``' 内建指令"

#: ../../LangRef.rst:11700
msgid "This is an overloaded intrinsic. You can use '``llvm.ptr.annotation``' on a pointer to an integer of any width. *NOTE* you must specify an address space for the pointer. The identifier for the default address space is the integer '``0``'."
msgstr "这是一个过载的内在。你可以在指向任何宽度的整数的指针上使用'`llvm.ptr.annotation``'。 *注*您必须指定指针的地址空间。默认地址空间的标识符是整数'``0``'。"

#: ../../LangRef.rst:11716
msgid "The '``llvm.ptr.annotation``' intrinsic."
msgstr "'llvm.ptr.annotation``' 内建指令。"

#: ../../LangRef.rst:11721
msgid "The first argument is a pointer to an integer value of arbitrary bitwidth (result of some expression), the second is a pointer to a global string, the third is a pointer to a global string which is the source file name, and the last argument is the line number. It returns the value of the first argument."
msgstr "第一个参数是指向任意位宽的整数值的指针（某个表达式的结果），第二个是指向全局字符串的指针，第三个是指向全局字符串的指针，该字符串是源文件名，最后一个参数是行号。它返回第一个参数的值。"

#: ../../LangRef.rst:11729
msgid "This intrinsic allows annotation of a pointer to an integer with arbitrary strings. This can be useful for special purpose optimizations that want to look for these annotations. These have no other defined use; they are ignored by code generation and optimization."
msgstr "此内在函数允许注释指向具有任意字符串的整数的指针。这对于想要查找这些注释的特殊用途优化非常有用。这些没有其他明确的用途;代码生成和优化会忽略它们。"

#: ../../LangRef.rst:11735
msgid "'``llvm.annotation.*``' Intrinsic"
msgstr "'``llvm.annotation。*``' 内建指令"

#: ../../LangRef.rst:11740
msgid "This is an overloaded intrinsic. You can use '``llvm.annotation``' on any integer bit width."
msgstr "这是一个过载的内在。你可以在任何整数位宽上使用'``llvm.annotation``'。"

#: ../../LangRef.rst:11754
msgid "The '``llvm.annotation``' intrinsic."
msgstr "'llvm.annotation``' 内建指令。"

#: ../../LangRef.rst:11759
msgid "The first argument is an integer value (result of some expression), the second is a pointer to a global string, the third is a pointer to a global string which is the source file name, and the last argument is the line number. It returns the value of the first argument."
msgstr "第一个参数是整数值（某个表达式的结果），第二个是指向全局字符串的指针，第三个是指向全局字符串的指针，该字符串是源文件名，最后一个参数是行号。它返回第一个参数的值。"

#: ../../LangRef.rst:11767
msgid "This intrinsic allows annotations to be put on arbitrary expressions with arbitrary strings. This can be useful for special purpose optimizations that want to look for these annotations. These have no other defined use; they are ignored by code generation and optimization."
msgstr "此内在函数允许将注释放在具有任意字符串的任意表达式上。这对于想要查找这些注释的特殊用途优化非常有用。这些没有其他明确的用途;代码生成和优化会忽略它们。"

#: ../../LangRef.rst:11773
msgid "'``llvm.trap``' Intrinsic"
msgstr "'`llvm.trap``' 内建指令"

#: ../../LangRef.rst:11785
msgid "The '``llvm.trap``' intrinsic."
msgstr "'llvm.trap``' 内建指令。"

#: ../../LangRef.rst:11790 ../../LangRef.rst:11817 ../../LangRef.rst:12058
msgid "None."
msgstr "没有。"

#: ../../LangRef.rst:11795
msgid "This intrinsic is lowered to the target dependent trap instruction. If the target does not have a trap instruction, this intrinsic will be lowered to a call of the ``abort()`` function."
msgstr "该内在函数降低到目标依赖陷阱指令。如果目标没有陷阱指令，则此内在函数将降低为调用``abort（）``函数。"

#: ../../LangRef.rst:11800
msgid "'``llvm.debugtrap``' Intrinsic"
msgstr "'``llvm.debugtrap``' 内建指令"

#: ../../LangRef.rst:11812
msgid "The '``llvm.debugtrap``' intrinsic."
msgstr "'llvm.debugtrap``' 内建指令。"

#: ../../LangRef.rst:11822
msgid "This intrinsic is lowered to code which is intended to cause an execution trap with the intention of requesting the attention of a debugger."
msgstr "此内在函数降低到代码，该代码旨在导致执行陷阱，其目的是请求调试器注意。"

#: ../../LangRef.rst:11827
msgid "'``llvm.stackprotector``' Intrinsic"
msgstr "'``llvm.stackprotector``' 内建指令"

#: ../../LangRef.rst:11839
msgid "The ``llvm.stackprotector`` intrinsic takes the ``guard`` and stores it onto the stack at ``slot``. The stack slot is adjusted to ensure that it is placed on the stack before local variables."
msgstr "``llvm.stackprotector`` 内建指令使用``guard``并将它存储在``slot``的堆栈中。调整堆栈插槽以确保在局部变量之前将其放置在堆栈上。"

#: ../../LangRef.rst:11846
msgid "The ``llvm.stackprotector`` intrinsic requires two pointer arguments. The first argument is the value loaded from the stack guard ``@__stack_chk_guard``. The second variable is an ``alloca`` that has enough space to hold the value of the guard."
msgstr "``llvm.stackprotector`` 内建指令需要两个指针参数。第一个参数是从堆栈防护“`__ stack_chk_guard``加载的值。第二个变量是一个“alloca”，它有足够的空间来保存守卫的值。"

#: ../../LangRef.rst:11854
msgid "This intrinsic causes the prologue/epilogue inserter to force the position of the ``AllocaInst`` stack slot to be before local variables on the stack. This is to ensure that if a local variable on the stack is overwritten, it will destroy the value of the guard. When the function exits, the guard on the stack is checked against the original guard by ``llvm.stackprotectorcheck``. If they are different, then ``llvm.stackprotectorcheck`` causes the program to abort by calling the ``__stack_chk_fail()`` function."
msgstr "这个内在因素导致序言/结尾插入器强制“AllocaInst”堆栈槽的位置在堆栈上的局部变量之前。这是为了确保如果堆栈上的局部变量被覆盖，它将破坏防护的值。当函数退出时，通过``llvm.stackprotectorcheck``检查堆栈上的防护对照原始防护。如果它们不同，那么``llvm.stackprotectorcheck``会导致程序通过调用``__stack_chk_fail（）``函数来中止。"

#: ../../LangRef.rst:11863
msgid "'``llvm.stackprotectorcheck``' Intrinsic"
msgstr "'``llvm.stackprotectorcheck``' 内建指令"

#: ../../LangRef.rst:11875
msgid "The ``llvm.stackprotectorcheck`` intrinsic compares ``guard`` against an already created stack protector and if they are not equal calls the ``__stack_chk_fail()`` function."
msgstr "``llvm.stackprotectorcheck`` 内建指令将``guard``与已经创建的堆栈保护器进行比较，如果它们不相等，则调用``__stack_chk_fail（）``函数。"

#: ../../LangRef.rst:11882
msgid "The ``llvm.stackprotectorcheck`` intrinsic requires one pointer argument, the the variable ``@__stack_chk_guard``."
msgstr "``llvm.stackprotectorcheck`` 内建指令需要一个指针参数，变量``@__ stack_chk_guard``。"

#: ../../LangRef.rst:11888
msgid "This intrinsic is provided to perform the stack protector check by comparing ``guard`` with the stack slot created by ``llvm.stackprotector`` and if the values do not match call the ``__stack_chk_fail()`` function."
msgstr "提供此内在函数是为了执行堆栈保护程序检查，方法是将``guard``与`llvm.stackprotector``创建的堆栈槽进行比较，如果值不匹配则调用``__stack_chk_fail（）``函数。"

#: ../../LangRef.rst:11892
msgid "The reason to provide this as an IR level intrinsic instead of implementing it via other IR operations is that in order to perform this operation at the IR level without an intrinsic, one would need to create additional basic blocks to handle the success/failure cases. This makes it difficult to stop the stack protector check from disrupting sibling tail calls in Codegen. With this intrinsic, we are able to generate the stack protector basic blocks late in codegen after the tail call decision has occurred."
msgstr "提供此作为IR级内在而不是通过其他IR操作实现它的原因是，为了在没有内在的IR级别执行此操作，需要创建额外的基本块来处理成功/失败情况。这使得很难阻止堆栈保护器检查中断Codegen中的兄弟尾部调用。有了这个内在函数，我们能够在尾调用决策发生后在codegen后期生成堆栈保护器基本块。"

#: ../../LangRef.rst:11901
msgid "'``llvm.objectsize``' Intrinsic"
msgstr "'`llvm.objectsize``' 内建指令"

#: ../../LangRef.rst:11914
msgid "The ``llvm.objectsize`` intrinsic is designed to provide information to the optimizers to determine at compile time whether a) an operation (like memcpy) will overflow a buffer that corresponds to an object, or b) that a runtime check for overflow isn't necessary. An object in this context means an allocation of a specific class, structure, array, or other object."
msgstr "`llvm.objectsize`` 内建指令旨在为优化器提供信息，以便在编译时确定a）操作（如memcpy）是否会溢出对应于对象的缓冲区，或b）运行时检查溢出没有必要。此上下文中的对象表示特定类，结构，数组或其他对象的分配。"

#: ../../LangRef.rst:11924
msgid "The ``llvm.objectsize`` intrinsic takes two arguments. The first argument is a pointer to or into the ``object``. The second argument is a boolean and determines whether ``llvm.objectsize`` returns 0 (if true) or -1 (if false) when the object size is unknown. The second argument only accepts constants."
msgstr "``llvm.objectsize`` 内建指令有两个参数。第一个参数是指向“对象”的指针。第二个参数是一个布尔值，用于确定当对象大小未知时，``llvm.objectsize``是返回0（如果为true）还是-1（如果为false）。第二个参数只接受常量。"

#: ../../LangRef.rst:11933
msgid "The ``llvm.objectsize`` intrinsic is lowered to a constant representing the size of the object concerned. If the size cannot be determined at compile time, ``llvm.objectsize`` returns ``i32/i64 -1 or 0`` (depending on the ``min`` argument)."
msgstr "将`llvm.objectsize`` 内建指令降低为表示相关对象大小的常量。如果在编译时无法确定大小，``llvm.objectsize``将返回``i32 / i64 -1或0``（取决于``min``参数）。"

#: ../../LangRef.rst:11939
msgid "'``llvm.expect``' Intrinsic"
msgstr "'``llvm.expect``' 内建指令"

#: ../../LangRef.rst:11944
msgid "This is an overloaded intrinsic. You can use ``llvm.expect`` on any integer bit width."
msgstr "这是一个重载的内建指令。你可以在任何整数位宽度上使用``llvm.expect``。"

#: ../../LangRef.rst:11956
msgid "The ``llvm.expect`` intrinsic provides information about expected (the most probable) value of ``val``, which can be used by optimizers."
msgstr "``llvm.expect`` 内建指令提供了有关``val``的预期（最可能）值的信息，优化器可以使用它。"

#: ../../LangRef.rst:11962
msgid "The ``llvm.expect`` intrinsic takes two arguments. The first argument is a value. The second argument is an expected value, this needs to be a constant value, variables are not allowed."
msgstr "``llvm.expect`` 内建指令有两个参数。第一个参数是一个值。第二个参数是期望值，这需要是一个常量值，不允许变量。"

#: ../../LangRef.rst:11969
msgid "This intrinsic is lowered to the ``val``."
msgstr "这种内在降低到了“val”。"

#: ../../LangRef.rst:11974
msgid "'``llvm.assume``' Intrinsic"
msgstr "'``llvm.assume``' 内建指令"

#: ../../LangRef.rst:11986
msgid "The ``llvm.assume`` allows the optimizer to assume that the provided condition is true. This information can then be used in simplifying other parts of the code."
msgstr "``llvm.assume``允许优化器假设提供的条件为真。然后，可以使用此信息简化代码的其他部分。"

#: ../../LangRef.rst:11993
msgid "The condition which the optimizer may assume is always true."
msgstr "优化器可能采用的条件始终为真。"

#: ../../LangRef.rst:11998
msgid "The intrinsic allows the optimizer to assume that the provided condition is always true whenever the control flow reaches the intrinsic call. No code is generated for this intrinsic, and instructions that contribute only to the provided condition are not used for code generation. If the condition is violated during execution, the behavior is undefined."
msgstr "内在函数允许优化器在控制流到达内部调用时假设提供的条件始终为true。没有为此内在函数生成代码，并且仅用于提供条件的指令不用于代码生成。如果在执行期间违反了条件，则行为未定义。"

#: ../../LangRef.rst:12004
msgid "Note that the optimizer might limit the transformations performed on values used by the ``llvm.assume`` intrinsic in order to preserve the instructions only used to form the intrinsic's input argument. This might prove undesirable if the extra information provided by the ``llvm.assume`` intrinsic does not cause sufficient overall improvement in code quality. For this reason, ``llvm.assume`` should not be used to document basic mathematical invariants that the optimizer can otherwise deduce or facts that are of little use to the optimizer."
msgstr "请注意，优化器可能会限制对`llvm.assume``内在函数使用的值执行的转换，以便保留仅用于形成内在输入参数的指令。如果由`llvm.assume``内在提供的额外信息不会导致代码质量的全面改善，那么这可能是不合需要的。出于这个原因，``llvm.assume``不应该用于记录优化器可以推导出的基本数学不变量或者对优化器没什么用处的事实。"

#: ../../LangRef.rst:12016
msgid "'``llvm.bitset.test``' Intrinsic"
msgstr "'``llvm.bitset.test``' 内建指令"

#: ../../LangRef.rst:12029
msgid "The first argument is a pointer to be tested. The second argument is a metadata object representing an identifier for a :doc:`bitset <BitSets>`."
msgstr "第一个参数是要测试的指针。第二个参数是一个元数据对象，表示：doc：`bitset <BitSets>`的标识符。"

#: ../../LangRef.rst:12035
msgid "The ``llvm.bitset.test`` intrinsic tests whether the given pointer is a member of the given bitset."
msgstr "``llvm.bitset.test``内在函数测试给定指针是否是给定bitset的成员。"

#: ../../LangRef.rst:12039
msgid "'``llvm.donothing``' Intrinsic"
msgstr "'`llvm.donothing``' 内建指令"

#: ../../LangRef.rst:12051
msgid "The ``llvm.donothing`` intrinsic doesn't perform any operation. It's one of only two intrinsics (besides ``llvm.experimental.patchpoint``) that can be called with an invoke instruction."
msgstr "``llvm.donothing`` 内建指令不执行任何操作。它是仅有的两个内在函数之一（除了``llvm.experimental.patchpoint``），可以使用invoke指令调用它。"

#: ../../LangRef.rst:12063
msgid "This intrinsic does nothing, and it's removed by optimizers and ignored by codegen."
msgstr "这个 内建指令什么都不做，它被优化器删除并被codegen忽略。"

#: ../../LangRef.rst:12067
msgid "Stack Map Intrinsics"
msgstr "Stack Map内建指令"

#: ../../LangRef.rst:12069
msgid "LLVM provides experimental intrinsics to support runtime patching mechanisms commonly desired in dynamic language JITs. These intrinsics are described in :doc:`StackMaps`."
msgstr "LLVM提供实验内在函数来支持动态语言JIT中通常需要的运行时修补机制。这些内在函数描述于：doc：`StackMaps`。"
