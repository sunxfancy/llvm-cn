# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2003-2016, LLVM Project
# This file is distributed under the same license as the LLVM package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2016.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: LLVM 3.8\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2016-04-17 11:36+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.3.3\n"

#: ../../LangRef.rst:3
msgid "LLVM Language Reference Manual"
msgstr ""

#: ../../LangRef.rst:10
msgid "Abstract"
msgstr ""

#: ../../LangRef.rst:12
msgid ""
"This document is a reference manual for the LLVM assembly language. LLVM "
"is a Static Single Assignment (SSA) based representation that provides "
"type safety, low-level operations, flexibility, and the capability of "
"representing 'all' high-level languages cleanly. It is the common code "
"representation used throughout all phases of the LLVM compilation "
"strategy."
msgstr ""

#: ../../LangRef.rst:20
msgid "Introduction"
msgstr ""

#: ../../LangRef.rst:22
msgid ""
"The LLVM code representation is designed to be used in three different "
"forms: as an in-memory compiler IR, as an on-disk bitcode representation "
"(suitable for fast loading by a Just-In-Time compiler), and as a human "
"readable assembly language representation. This allows LLVM to provide a "
"powerful intermediate representation for efficient compiler "
"transformations and analysis, while providing a natural means to debug "
"and visualize the transformations. The three different forms of LLVM are "
"all equivalent. This document describes the human readable representation"
" and notation."
msgstr ""

#: ../../LangRef.rst:32
msgid ""
"The LLVM representation aims to be light-weight and low-level while being"
" expressive, typed, and extensible at the same time. It aims to be a "
"\"universal IR\" of sorts, by being at a low enough level that high-level"
" ideas may be cleanly mapped to it (similar to how microprocessors are "
"\"universal IR's\", allowing many source languages to be mapped to them)."
" By providing type information, LLVM can be used as the target of "
"optimizations: for example, through pointer analysis, it can be proven "
"that a C automatic variable is never accessed outside of the current "
"function, allowing it to be promoted to a simple SSA value instead of a "
"memory location."
msgstr ""

#: ../../LangRef.rst:46
msgid "Well-Formedness"
msgstr ""

#: ../../LangRef.rst:48
msgid ""
"It is important to note that this document describes 'well formed' LLVM "
"assembly language. There is a difference between what the parser accepts "
"and what is considered 'well formed'. For example, the following "
"instruction is syntactically okay, but not well formed:"
msgstr ""

#: ../../LangRef.rst:57
#, python-format
msgid ""
"because the definition of ``%x`` does not dominate all of its uses. The "
"LLVM infrastructure provides a verification pass that may be used to "
"verify that an LLVM module is well formed. This pass is automatically run"
" by the parser after parsing input assembly and by the optimizer before "
"it outputs bitcode. The violations pointed out by the verifier pass "
"indicate bugs in transformation passes or input to the parser."
msgstr ""

#: ../../LangRef.rst:67
msgid "Identifiers"
msgstr ""

#: ../../LangRef.rst:69
msgid ""
"LLVM identifiers come in two basic types: global and local. Global "
"identifiers (functions, global variables) begin with the ``'@'`` "
"character. Local identifiers (register names, types) begin with the "
"``'%'`` character. Additionally, there are three different formats for "
"identifiers, for different purposes:"
msgstr ""

#: ../../LangRef.rst:75
#, python-format
msgid ""
"Named values are represented as a string of characters with their prefix."
" For example, ``%foo``, ``@DivisionByZero``, "
"``%a.really.long.identifier``. The actual regular expression used is "
"'``[%@][-a-zA-Z$._][-a-zA-Z$._0-9]*``'. Identifiers that require other "
"characters in their names can be surrounded with quotes. Special "
"characters may be escaped using ``\"\\xx\"`` where ``xx`` is the ASCII "
"code for the character in hexadecimal. In this way, any character can be "
"used in a name value, even quotes themselves. The ``\"\\01\"`` prefix can"
" be used on global variables to suppress mangling."
msgstr ""

#: ../../LangRef.rst:84
msgid ""
"Unnamed values are represented as an unsigned numeric value with their "
"prefix. For example, ``%12``, ``@2``, ``%44``."
msgstr ""

#: ../../LangRef.rst:86
msgid "Constants, which are described in the section Constants_ below."
msgstr ""

#: ../../LangRef.rst:88
msgid ""
"LLVM requires that values start with a prefix for two reasons: Compilers "
"don't need to worry about name clashes with reserved words, and the set "
"of reserved words may be expanded in the future without penalty. "
"Additionally, unnamed identifiers allow a compiler to quickly come up "
"with a temporary variable without having to avoid symbol table conflicts."
msgstr ""

#: ../../LangRef.rst:95
msgid ""
"Reserved words in LLVM are very similar to reserved words in other "
"languages. There are keywords for different opcodes ('``add``', "
"'``bitcast``', '``ret``', etc...), for primitive type names ('``void``', "
"'``i32``', etc...), and others. These reserved words cannot conflict with"
" variable names, because none of them start with a prefix character "
"(``'%'`` or ``'@'``)."
msgstr ""

#: ../../LangRef.rst:102
#, python-format
msgid ""
"Here is an example of LLVM code to multiply the integer variable '``%X``'"
" by 8:"
msgstr ""

#: ../../LangRef.rst:105
msgid "The easy way:"
msgstr ""

#: ../../LangRef.rst:111
msgid "After strength reduction:"
msgstr ""

#: ../../LangRef.rst:117
msgid "And the hard way:"
msgstr ""

#: ../../LangRef.rst:125
#, python-format
msgid ""
"This last way of multiplying ``%X`` by 8 illustrates several important "
"lexical features of LLVM:"
msgstr ""

#: ../../LangRef.rst:128
msgid "Comments are delimited with a '``;``' and go until the end of line."
msgstr ""

#: ../../LangRef.rst:129
msgid ""
"Unnamed temporaries are created when the result of a computation is not "
"assigned to a named value."
msgstr ""

#: ../../LangRef.rst:131
msgid ""
"Unnamed temporaries are numbered sequentially (using a per-function "
"incrementing counter, starting with 0). Note that basic blocks and "
"unnamed function parameters are included in this numbering. For example, "
"if the entry basic block is not given a label name and all function "
"parameters are named, then it will get number 0."
msgstr ""

#: ../../LangRef.rst:137
msgid ""
"It also shows a convention that we follow in this document. When "
"demonstrating instructions, we will follow an instruction with a comment "
"that defines the type and name of value produced."
msgstr ""

#: ../../LangRef.rst:142
msgid "High Level Structure"
msgstr ""

#: ../../LangRef.rst:145
msgid "Module Structure"
msgstr ""

#: ../../LangRef.rst:147
msgid ""
"LLVM programs are composed of ``Module``'s, each of which is a "
"translation unit of the input programs. Each module consists of "
"functions, global variables, and symbol table entries. Modules may be "
"combined together with the LLVM linker, which merges function (and global"
" variable) definitions, resolves forward declarations, and merges symbol "
"table entries. Here is an example of the \"hello world\" module:"
msgstr ""

#: ../../LangRef.rst:176
msgid ""
"This example is made up of a :ref:`global variable <globalvars>` named "
"\"``.str``\", an external declaration of the \"``puts``\" function, a "
":ref:`function definition <functionstructure>` for \"``main``\" and "
":ref:`named metadata <namedmetadatastructure>` \"``foo``\"."
msgstr ""

#: ../../LangRef.rst:181
msgid ""
"In general, a module is made up of a list of global values (where both "
"functions and global variables are global values). Global values are "
"represented by a pointer to a memory location (in this case, a pointer to"
" an array of char, and a pointer to a function), and have one of the "
"following :ref:`linkage types <linkage>`."
msgstr ""

#: ../../LangRef.rst:190
msgid "Linkage Types"
msgstr ""

#: ../../LangRef.rst:192
msgid ""
"All Global Variables and Functions have one of the following types of "
"linkage:"
msgstr ""

#: ../../LangRef.rst:200
msgid "``private``"
msgstr ""

#: ../../LangRef.rst:196
msgid ""
"Global values with \"``private``\" linkage are only directly accessible "
"by objects in the current module. In particular, linking code into a "
"module with an private global value may cause the private to be renamed "
"as necessary to avoid collisions. Because the symbol is private to the "
"module, all references can be updated. This doesn't show up in any symbol"
" table in the object file."
msgstr ""

#: ../../LangRef.rst:204
msgid "``internal``"
msgstr ""

#: ../../LangRef.rst:203
msgid ""
"Similar to private, but the value shows as a local symbol (``STB_LOCAL`` "
"in the case of ELF) in the object file. This corresponds to the notion of"
" the '``static``' keyword in C."
msgstr ""

#: ../../LangRef.rst:214
msgid "``available_externally``"
msgstr ""

#: ../../LangRef.rst:207
msgid ""
"Globals with \"``available_externally``\" linkage are never emitted into "
"the object file corresponding to the LLVM module. From the linker's "
"perspective, an ``available_externally`` global is equivalent to an "
"external declaration. They exist to allow inlining and other "
"optimizations to take place given knowledge of the definition of the "
"global, which is known to be somewhere outside the module. Globals with "
"``available_externally`` linkage are allowed to be discarded at will, and"
" allow inlining and other optimizations. This linkage type is only "
"allowed on definitions, not declarations."
msgstr ""

#: ../../LangRef.rst:227
msgid "``linkonce``"
msgstr ""

#: ../../LangRef.rst:217
msgid ""
"Globals with \"``linkonce``\" linkage are merged with other globals of "
"the same name when linkage occurs. This can be used to implement some "
"forms of inline functions, templates, or other code which must be "
"generated in each translation unit that uses it, but where the body may "
"be overridden with a more definitive definition later. Unreferenced "
"``linkonce`` globals are allowed to be discarded. Note that ``linkonce`` "
"linkage does not actually allow the optimizer to inline the body of this "
"function into callers because it doesn't know if this definition of the "
"function is the definitive definition within the program or whether it "
"will be overridden by a stronger definition. To enable inlining and other"
" optimizations, use \"``linkonce_odr``\" linkage."
msgstr ""

#: ../../LangRef.rst:232
msgid "``weak``"
msgstr ""

#: ../../LangRef.rst:230
msgid ""
"\"``weak``\" linkage has the same merging semantics as ``linkonce`` "
"linkage, except that unreferenced globals with ``weak`` linkage may not "
"be discarded. This is used for globals that are declared \"weak\" in C "
"source code."
msgstr ""

#: ../../LangRef.rst:242
msgid "``common``"
msgstr ""

#: ../../LangRef.rst:235
msgid ""
"\"``common``\" linkage is most similar to \"``weak``\" linkage, but they "
"are used for tentative definitions in C, such as \"``int X;``\" at global"
" scope. Symbols with \"``common``\" linkage are merged in the same way as"
" ``weak symbols``, and they may not be deleted if unreferenced. "
"``common`` symbols may not have an explicit section, must have a zero "
"initializer, and may not be marked ':ref:`constant <globalvars>`'. "
"Functions and aliases may not have common linkage."
msgstr ""

#: ../../LangRef.rst:251
msgid "``appending``"
msgstr ""

#: ../../LangRef.rst:247
msgid ""
"\"``appending``\" linkage may only be applied to global variables of "
"pointer to array type. When two global variables with appending linkage "
"are linked together, the two global arrays are appended together. This is"
" the LLVM, typesafe, equivalent of having the system linker append "
"together \"sections\" with identical names when .o files are linked."
msgstr ""

#: ../../LangRef.rst:255
msgid "``extern_weak``"
msgstr ""

#: ../../LangRef.rst:254
msgid ""
"The semantics of this linkage follow the ELF object file model: the "
"symbol is weak until linked, if not linked, the symbol becomes null "
"instead of being an undefined reference."
msgstr ""

#: ../../LangRef.rst:263
msgid "``linkonce_odr``, ``weak_odr``"
msgstr ""

#: ../../LangRef.rst:258
msgid ""
"Some languages allow differing globals to be merged, such as two "
"functions with different semantics. Other languages, such as ``C++``, "
"ensure that only equivalent globals are ever merged (the \"one definition"
" rule\" --- \"ODR\"). Such languages can use the ``linkonce_odr`` and "
"``weak_odr`` linkage types to indicate that the global will only be "
"merged with equivalent globals. These linkage types are otherwise the "
"same as their non-``odr`` versions."
msgstr ""

#: ../../LangRef.rst:268
msgid "``external``"
msgstr ""

#: ../../LangRef.rst:266
msgid ""
"If none of the above identifiers are used, the global is externally "
"visible, meaning that it participates in linkage and can be used to "
"resolve external symbol references."
msgstr ""

#: ../../LangRef.rst:270
msgid ""
"It is illegal for a function *declaration* to have any linkage type other"
" than ``external`` or ``extern_weak``."
msgstr ""

#: ../../LangRef.rst:276
msgid "Calling Conventions"
msgstr ""

#: ../../LangRef.rst:278
msgid ""
"LLVM :ref:`functions <functionstructure>`, :ref:`calls <i_call>` and "
":ref:`invokes <i_invoke>` can all have an optional calling convention "
"specified for the call. The calling convention of any pair of dynamic "
"caller/callee must match, or the behavior of the program is undefined. "
"The following calling conventions are supported by LLVM, and more may be "
"added in the future:"
msgstr ""

#: ../../LangRef.rst:289
msgid "\"``ccc``\" - The C calling convention"
msgstr ""

#: ../../LangRef.rst:286
msgid ""
"This calling convention (the default if no other calling convention is "
"specified) matches the target C calling conventions. This calling "
"convention supports varargs function calls and tolerates some mismatch in"
" the declared prototype and implemented declaration of the function (as "
"does normal C)."
msgstr ""

#: ../../LangRef.rst:299
msgid "\"``fastcc``\" - The fast calling convention"
msgstr ""

#: ../../LangRef.rst:292
msgid ""
"This calling convention attempts to make calls as fast as possible (e.g. "
"by passing things in registers). This calling convention allows the "
"target to use whatever tricks it wants to produce fast code for the "
"target, without having to conform to an externally specified ABI "
"(Application Binary Interface). `Tail calls can only be optimized when "
"this, the GHC or the HiPE convention is used. <CodeGenerator.html#id80>`_"
" This calling convention does not support varargs and requires the "
"prototype of all callees to exactly match the prototype of the function "
"definition."
msgstr ""

#: ../../LangRef.rst:308
msgid "\"``coldcc``\" - The cold calling convention"
msgstr ""

#: ../../LangRef.rst:302
msgid ""
"This calling convention attempts to make code in the caller as efficient "
"as possible under the assumption that the call is not commonly executed. "
"As such, these calls often preserve all registers so that the call does "
"not break any live ranges in the caller side. This calling convention "
"does not support varargs and requires the prototype of all callees to "
"exactly match the prototype of the function definition. Furthermore the "
"inliner doesn't consider such function calls for inlining."
msgstr ""

#: ../../LangRef.rst:327
msgid "\"``cc 10``\" - GHC convention"
msgstr ""

#: ../../LangRef.rst:311
msgid ""
"This calling convention has been implemented specifically for use by the "
"`Glasgow Haskell Compiler (GHC) <http://www.haskell.org/ghc>`_. It passes"
" everything in registers, going to extremes to achieve this by disabling "
"callee save registers. This calling convention should not be used lightly"
" but only for specific situations such as an alternative to the *register"
" pinning* performance technique often used when implementing functional "
"programming languages. At the moment only X86 supports this convention "
"and it has the following limitations:"
msgstr ""

#: ../../LangRef.rst:321
msgid ""
"On *X86-32* only supports up to 4 bit type parameters. No floating point "
"types are supported."
msgstr ""

#: ../../LangRef.rst:323
msgid ""
"On *X86-64* only supports up to 10 bit type parameters and 6 floating "
"point parameters."
msgstr ""

#: ../../LangRef.rst:326
msgid ""
"This calling convention supports `tail call optimization "
"<CodeGenerator.html#id80>`_ but requires both the caller and callee are "
"using it."
msgstr ""

#: ../../LangRef.rst:342
msgid "\"``cc 11``\" - The HiPE calling convention"
msgstr ""

#: ../../LangRef.rst:330
msgid ""
"This calling convention has been implemented specifically for use by the "
"`High-Performance Erlang (HiPE) "
"<http://www.it.uu.se/research/group/hipe/>`_ compiler, *the* native code "
"compiler of the `Ericsson's Open Source Erlang/OTP system "
"<http://www.erlang.org/download.shtml>`_. It uses more registers for "
"argument passing than the ordinary C calling convention and defines no "
"callee-saved registers. The calling convention properly supports `tail "
"call optimization <CodeGenerator.html#id80>`_ but requires that both the "
"caller and the callee use it. It uses a *register pinning* mechanism, "
"similar to GHC's convention, for keeping frequently accessed runtime "
"components pinned to specific hardware registers. At the moment only X86 "
"supports this convention (both 32 and 64 bit)."
msgstr ""

#: ../../LangRef.rst:347
msgid "\"``webkit_jscc``\" - WebKit's JavaScript calling convention"
msgstr ""

#: ../../LangRef.rst:345
msgid ""
"This calling convention has been implemented for `WebKit FTL JIT "
"<https://trac.webkit.org/wiki/FTLJIT>`_. It passes arguments on the stack"
" right to left (as cdecl does), and returns a value in the platform's "
"customary return register."
msgstr ""

#: ../../LangRef.rst:354
msgid "\"``anyregcc``\" - Dynamic calling convention for code patching"
msgstr ""

#: ../../LangRef.rst:350
msgid ""
"This is a special convention that supports patching an arbitrary code "
"sequence in place of a call site. This convention forces the call "
"arguments into registers but allows them to be dynamically allocated. "
"This can currently only be used with calls to "
"llvm.experimental.patchpoint because only this intrinsic records the "
"location of its arguments in a side table. See :doc:`StackMaps`."
msgstr ""

#: ../../LangRef.rst:387
msgid "\"``preserve_mostcc``\" - The `PreserveMost` calling convention"
msgstr ""

#: ../../LangRef.rst:357
msgid ""
"This calling convention attempts to make the code in the caller as "
"unintrusive as possible. This convention behaves identically to the `C` "
"calling convention on how arguments and return values are passed, but it "
"uses a different set of caller/callee-saved registers. This alleviates "
"the burden of saving and recovering a large register set before and after"
" the call in the caller. If the arguments are passed in callee-saved "
"registers, then they will be preserved by the callee across the call. "
"This doesn't apply for values returned in callee-saved registers."
msgstr ""

#: ../../LangRef.rst:366
msgid ""
"On X86-64 the callee preserves all general purpose registers, except for "
"R11. R11 can be used as a scratch register. Floating-point registers "
"(XMMs/YMMs) are not preserved and need to be saved by the caller."
msgstr ""

#: ../../LangRef.rst:370
msgid ""
"The idea behind this convention is to support calls to runtime functions "
"that have a hot path and a cold path. The hot path is usually a small "
"piece of code that doesn't use many registers. The cold path might need "
"to call out to another function and therefore only needs to preserve the "
"caller-saved registers, which haven't already been saved by the caller. "
"The `PreserveMost` calling convention is very similar to the `cold` "
"calling convention in terms of caller/callee-saved registers, but they "
"are used for different types of function calls. `coldcc` is for function "
"calls that are rarely executed, whereas `preserve_mostcc` function calls "
"are intended to be on the hot path and definitely executed a lot. "
"Furthermore `preserve_mostcc` doesn't prevent the inliner from inlining "
"the function call."
msgstr ""

#: ../../LangRef.rst:382
msgid ""
"This calling convention will be used by a future version of the "
"ObjectiveC runtime and should therefore still be considered experimental "
"at this time. Although this convention was created to optimize certain "
"runtime calls to the ObjectiveC runtime, it is not limited to this "
"runtime and might be used by other runtimes in the future too. The "
"current implementation only supports X86-64, but the intention is to "
"support more architectures in the future."
msgstr ""

#: ../../LangRef.rst:408
msgid "\"``preserve_allcc``\" - The `PreserveAll` calling convention"
msgstr ""

#: ../../LangRef.rst:390
msgid ""
"This calling convention attempts to make the code in the caller even less"
" intrusive than the `PreserveMost` calling convention. This calling "
"convention also behaves identical to the `C` calling convention on how "
"arguments and return values are passed, but it uses a different set of "
"caller/callee-saved registers. This removes the burden of saving and "
"recovering a large register set before and after the call in the caller. "
"If the arguments are passed in callee-saved registers, then they will be "
"preserved by the callee across the call. This doesn't apply for values "
"returned in callee-saved registers."
msgstr ""

#: ../../LangRef.rst:400
msgid ""
"On X86-64 the callee preserves all general purpose registers, except for "
"R11. R11 can be used as a scratch register. Furthermore it also preserves"
" all floating-point registers (XMMs/YMMs)."
msgstr ""

#: ../../LangRef.rst:404
msgid ""
"The idea behind this convention is to support calls to runtime functions "
"that don't need to call out to any other functions."
msgstr ""

#: ../../LangRef.rst:407
msgid ""
"This calling convention, like the `PreserveMost` calling convention, will"
" be used by a future version of the ObjectiveC runtime and should be "
"considered experimental at this time."
msgstr ""

#: ../../LangRef.rst:428
msgid ""
"\"``cxx_fast_tlscc``\" - The `CXX_FAST_TLS` calling convention for access"
" functions"
msgstr ""

#: ../../LangRef.rst:411
msgid ""
"Clang generates an access function to access C++-style TLS. The access "
"function generally has an entry block, an exit block and an "
"initialization block that is run at the first time. The entry and exit "
"blocks can access a few TLS IR variables, each access will be lowered to "
"a platform-specific sequence."
msgstr ""

#: ../../LangRef.rst:417
msgid ""
"This calling convention aims to minimize overhead in the caller by "
"preserving as many registers as possible (all the registers that are "
"perserved on the fast path, composed of the entry and exit blocks)."
msgstr ""

#: ../../LangRef.rst:421
msgid ""
"This calling convention behaves identical to the `C` calling convention "
"on how arguments and return values are passed, but it uses a different "
"set of caller/callee-saved registers."
msgstr ""

#: ../../LangRef.rst:425
msgid ""
"Given that each platform has its own lowering sequence, hence its own set"
" of preserved registers, we can't use the existing `PreserveMost`."
msgstr ""

#: ../../LangRef.rst:428
msgid ""
"On X86-64 the callee preserves all general purpose registers, except for "
"RDI and RAX."
msgstr ""

#: ../../LangRef.rst:433
msgid "\"``cc <n>``\" - Numbered convention"
msgstr ""

#: ../../LangRef.rst:431
msgid ""
"Any calling convention may be specified by number, allowing target-"
"specific calling conventions to be used. Target specific calling "
"conventions start at 64."
msgstr ""

#: ../../LangRef.rst:435
msgid ""
"More calling conventions can be added/defined on an as-needed basis, to "
"support Pascal conventions or any other well-known target-independent "
"convention."
msgstr ""

#: ../../LangRef.rst:442
msgid "Visibility Styles"
msgstr ""

#: ../../LangRef.rst:444
msgid ""
"All Global Variables and Functions have one of the following visibility "
"styles:"
msgstr ""

#: ../../LangRef.rst:452
msgid "\"``default``\" - Default style"
msgstr ""

#: ../../LangRef.rst:448
msgid ""
"On targets that use the ELF object file format, default visibility means "
"that the declaration is visible to other modules and, in shared "
"libraries, means that the declared entity may be overridden. On Darwin, "
"default visibility means that the declaration is visible to other "
"modules. Default visibility corresponds to \"external linkage\" in the "
"language."
msgstr ""

#: ../../LangRef.rst:458
msgid "\"``hidden``\" - Hidden style"
msgstr ""

#: ../../LangRef.rst:455
msgid ""
"Two declarations of an object with hidden visibility refer to the same "
"object if they are in the same shared object. Usually, hidden visibility "
"indicates that the symbol will not be placed into the dynamic symbol "
"table, so no other module (executable or shared library) can reference it"
" directly."
msgstr ""

#: ../../LangRef.rst:464
msgid "\"``protected``\" - Protected style"
msgstr ""

#: ../../LangRef.rst:461
msgid ""
"On ELF, protected visibility indicates that the symbol will be placed in "
"the dynamic symbol table, but that references within the defining module "
"will bind to the local symbol. That is, the symbol cannot be overridden "
"by another module."
msgstr ""

#: ../../LangRef.rst:466
msgid ""
"A symbol with ``internal`` or ``private`` linkage must have ``default`` "
"visibility."
msgstr ""

#: ../../LangRef.rst:472
msgid "DLL Storage Classes"
msgstr ""

#: ../../LangRef.rst:474
msgid ""
"All Global Variables, Functions and Aliases can have one of the following"
" DLL storage class:"
msgstr ""

#: ../../LangRef.rst:480
msgid "``dllimport``"
msgstr ""

#: ../../LangRef.rst:478
msgid ""
"\"``dllimport``\" causes the compiler to reference a function or variable"
" via a global pointer to a pointer that is set up by the DLL exporting "
"the symbol. On Microsoft Windows targets, the pointer name is formed by "
"combining ``__imp_`` and the function or variable name."
msgstr ""

#: ../../LangRef.rst:488
msgid "``dllexport``"
msgstr ""

#: ../../LangRef.rst:483
msgid ""
"\"``dllexport``\" causes the compiler to provide a global pointer to a "
"pointer in a DLL, so that it can be referenced with the ``dllimport`` "
"attribute. On Microsoft Windows targets, the pointer name is formed by "
"combining ``__imp_`` and the function or variable name. Since this "
"storage class exists for defining a dll interface, the compiler, "
"assembler and linker know it is externally referenced and must refrain "
"from deleting the symbol."
msgstr ""

#: ../../LangRef.rst:493
msgid "Thread Local Storage Models"
msgstr ""

#: ../../LangRef.rst:495
msgid ""
"A variable may be defined as ``thread_local``, which means that it will "
"not be shared by threads (each thread will have a separated copy of the "
"variable). Not all targets support thread-local variables. Optionally, a "
"TLS model may be specified:"
msgstr ""

#: ../../LangRef.rst:500
msgid "``localdynamic``"
msgstr ""

#: ../../LangRef.rst:501
msgid "For variables that are only used within the current shared library."
msgstr ""

#: ../../LangRef.rst:502
msgid "``initialexec``"
msgstr ""

#: ../../LangRef.rst:503
msgid "For variables in modules that will not be loaded dynamically."
msgstr ""

#: ../../LangRef.rst:505
msgid "``localexec``"
msgstr ""

#: ../../LangRef.rst:505
msgid "For variables defined in the executable and only used within it."
msgstr ""

#: ../../LangRef.rst:507
msgid "If no explicit model is given, the \"general dynamic\" model is used."
msgstr ""

#: ../../LangRef.rst:509
msgid ""
"The models correspond to the ELF TLS models; see `ELF Handling For "
"Thread-Local Storage <http://people.redhat.com/drepper/tls.pdf>`_ for "
"more information on under which circumstances the different models may be"
" used. The target may choose a different TLS model if the specified model"
" is not supported, or if a better choice of model can be made."
msgstr ""

#: ../../LangRef.rst:515
msgid ""
"A model can also be specified in an alias, but then it only governs how "
"the alias is accessed. It will not have any effect in the aliasee."
msgstr ""

#: ../../LangRef.rst:518
msgid ""
"For platforms without linker support of ELF TLS model, the -femulated-tls"
" flag can be used to generate GCC compatible emulated TLS code."
msgstr ""

#: ../../LangRef.rst:524
msgid "Structure Types"
msgstr ""

#: ../../LangRef.rst:526
msgid ""
"LLVM IR allows you to specify both \"identified\" and \"literal\" "
":ref:`structure types <t_struct>`. Literal types are uniqued "
"structurally, but identified types are never uniqued. An :ref:`opaque "
"structural type <t_opaque>` can also be used to forward declare a type "
"that is not yet available."
msgstr ""

#: ../../LangRef.rst:531
msgid "An example of an identified structure specification is:"
msgstr ""

#: ../../LangRef.rst:537
msgid ""
"Prior to the LLVM 3.0 release, identified types were structurally "
"uniqued. Only literal types are uniqued in recent versions of LLVM."
msgstr ""

#: ../../LangRef.rst:543
msgid "Global Variables"
msgstr ""

#: ../../LangRef.rst:545
msgid ""
"Global variables define regions of memory allocated at compilation time "
"instead of run-time."
msgstr ""

#: ../../LangRef.rst:548
msgid "Global variable definitions must be initialized."
msgstr ""

#: ../../LangRef.rst:550
msgid ""
"Global variables in other translation units can also be declared, in "
"which case they don't have an initializer."
msgstr ""

#: ../../LangRef.rst:553
msgid ""
"Either global variable definitions or declarations may have an explicit "
"section to be placed in and may have an optional explicit alignment "
"specified."
msgstr ""

#: ../../LangRef.rst:556
msgid ""
"A variable may be defined as a global ``constant``, which indicates that "
"the contents of the variable will **never** be modified (enabling better "
"optimization, allowing the global data to be placed in the read-only "
"section of an executable, etc). Note that variables that need runtime "
"initialization cannot be marked ``constant`` as there is a store to the "
"variable."
msgstr ""

#: ../../LangRef.rst:563
msgid ""
"LLVM explicitly allows *declarations* of global variables to be marked "
"constant, even if the final definition of the global is not. This "
"capability can be used to enable slightly better optimization of the "
"program, but requires the language definition to guarantee that "
"optimizations based on the 'constantness' are valid for the translation "
"units that do not include the definition."
msgstr ""

#: ../../LangRef.rst:570
msgid ""
"As SSA values, global variables define pointer values that are in scope "
"(i.e. they dominate) all basic blocks in the program. Global variables "
"always define a pointer to their \"content\" type because they describe a"
" region of memory, and all memory objects in LLVM are accessed through "
"pointers."
msgstr ""

#: ../../LangRef.rst:576
msgid ""
"Global variables can be marked with ``unnamed_addr`` which indicates that"
" the address is not significant, only the content. Constants marked like "
"this can be merged with other constants if they have the same "
"initializer. Note that a constant with significant address *can* be "
"merged with a ``unnamed_addr`` constant, the result being a constant "
"whose address is significant."
msgstr ""

#: ../../LangRef.rst:583
msgid ""
"A global variable may be declared to reside in a target-specific numbered"
" address space. For targets that support them, address spaces may affect "
"how optimizations are performed and/or what target instructions are used "
"to access the variable. The default address space is zero. The address "
"space qualifier must precede any other attributes."
msgstr ""

#: ../../LangRef.rst:589
msgid ""
"LLVM allows an explicit section to be specified for globals. If the "
"target supports it, it will emit globals to the section specified. "
"Additionally, the global can placed in a comdat if the target has the "
"necessary support."
msgstr ""

#: ../../LangRef.rst:594
msgid ""
"By default, global initializers are optimized by assuming that global "
"variables defined within the module are not modified from their initial "
"values before the start of the global initializer. This is true even for "
"variables potentially accessible from outside the module, including those"
" with external linkage or appearing in ``@llvm.used`` or dllexported "
"variables. This assumption may be suppressed by marking the variable with"
" ``externally_initialized``."
msgstr ""

#: ../../LangRef.rst:602
msgid ""
"An explicit alignment may be specified for a global, which must be a "
"power of 2. If not present, or if the alignment is set to zero, the "
"alignment of the global is set by the target to whatever it feels "
"convenient. If an explicit alignment is specified, the global is forced "
"to have exactly that alignment. Targets and optimizers are not allowed to"
" over-align the global if the global has an assigned section. In this "
"case, the extra alignment could be observable: for example, code could "
"assume that the globals are densely packed in their section and try to "
"iterate over them as an array, alignment padding would break this "
"iteration. The maximum alignment is ``1 << 29``."
msgstr ""

#: ../../LangRef.rst:613
msgid "Globals can also have a :ref:`DLL storage class <dllstorageclass>`."
msgstr ""

#: ../../LangRef.rst:615
msgid ""
"Variables and aliases can have a :ref:`Thread Local Storage Model "
"<tls_model>`."
msgstr ""

#: ../../LangRef.rst:618 ../../LangRef.rst:706 ../../LangRef.rst:718
#: ../../LangRef.rst:738 ../../LangRef.rst:778 ../../LangRef.rst:871
#: ../../LangRef.rst:1487
msgid "Syntax::"
msgstr ""

#: ../../LangRef.rst:626
msgid ""
"For example, the following defines a global in a numbered address space "
"with an initializer, section, and alignment:"
msgstr ""

#: ../../LangRef.rst:633
msgid "The following example just declares a global variable"
msgstr ""

#: ../../LangRef.rst:639
msgid ""
"The following example defines a thread-local global with the "
"``initialexec`` TLS model:"
msgstr ""

#: ../../LangRef.rst:649
msgid "Functions"
msgstr ""

#: ../../LangRef.rst:651
msgid ""
"LLVM function definitions consist of the \"``define``\" keyword, an "
"optional :ref:`linkage type <linkage>`, an optional :ref:`visibility "
"style <visibility>`, an optional :ref:`DLL storage class "
"<dllstorageclass>`, an optional :ref:`calling convention <callingconv>`, "
"an optional ``unnamed_addr`` attribute, a return type, an optional "
":ref:`parameter attribute <paramattrs>` for the return type, a function "
"name, a (possibly empty) argument list (each with optional "
":ref:`parameter attributes <paramattrs>`), optional :ref:`function "
"attributes <fnattrs>`, an optional section, an optional alignment, an "
"optional :ref:`comdat <langref_comdats>`, an optional :ref:`garbage "
"collector name <gc>`, an optional :ref:`prefix <prefixdata>`, an optional"
" :ref:`prologue <prologuedata>`, an optional :ref:`personality "
"<personalityfn>`, an optional list of attached :ref:`metadata "
"<metadata>`, an opening curly brace, a list of basic blocks, and a "
"closing curly brace."
msgstr ""

#: ../../LangRef.rst:667
msgid ""
"LLVM function declarations consist of the \"``declare``\" keyword, an "
"optional :ref:`linkage type <linkage>`, an optional :ref:`visibility "
"style <visibility>`, an optional :ref:`DLL storage class "
"<dllstorageclass>`, an optional :ref:`calling convention <callingconv>`, "
"an optional ``unnamed_addr`` attribute, a return type, an optional "
":ref:`parameter attribute <paramattrs>` for the return type, a function "
"name, a possibly empty list of arguments, an optional alignment, an "
"optional :ref:`garbage collector name <gc>`, an optional :ref:`prefix "
"<prefixdata>`, and an optional :ref:`prologue <prologuedata>`."
msgstr ""

#: ../../LangRef.rst:677
msgid ""
"A function definition contains a list of basic blocks, forming the CFG "
"(Control Flow Graph) for the function. Each basic block may optionally "
"start with a label (giving the basic block a symbol table entry), "
"contains a list of instructions, and ends with a :ref:`terminator "
"<terminators>` instruction (such as a branch or function return). If an "
"explicit label is not provided, a block is assigned an implicit numbered "
"label, using the next value from the same counter as used for unnamed "
"temporaries (:ref:`see above<identifiers>`). For example, if a function "
"entry block does not have an explicit label, it will be assigned label "
"\"%0\", then the first unnamed temporary in that block will be \"%1\", "
"etc."
msgstr ""

#: ../../LangRef.rst:687
msgid ""
"The first basic block in a function is special in two ways: it is "
"immediately executed on entrance to the function, and it is not allowed "
"to have predecessor basic blocks (i.e. there can not be any branches to "
"the entry block of a function). Because the block can have no "
"predecessors, it also cannot have any :ref:`PHI nodes <i_phi>`."
msgstr ""

#: ../../LangRef.rst:693
msgid ""
"LLVM allows an explicit section to be specified for functions. If the "
"target supports it, it will emit functions to the section specified. "
"Additionally, the function can be placed in a COMDAT."
msgstr ""

#: ../../LangRef.rst:697
msgid ""
"An explicit alignment may be specified for a function. If not present, or"
" if the alignment is set to zero, the alignment of the function is set by"
" the target to whatever it feels convenient. If an explicit alignment is "
"specified, the function is forced to have at least that much alignment. "
"All alignments must be a power of 2."
msgstr ""

#: ../../LangRef.rst:703
msgid ""
"If the ``unnamed_addr`` attribute is given, the address is known to not "
"be significant and two identical functions can be merged."
msgstr ""

#: ../../LangRef.rst:715
msgid ""
"The argument list is a comma separated sequence of arguments where each "
"argument is of the following form:"
msgstr ""

#: ../../LangRef.rst:726
msgid "Aliases"
msgstr ""

#: ../../LangRef.rst:728
msgid ""
"Aliases, unlike function or variables, don't create any new data. They "
"are just a new symbol and metadata for an existing position."
msgstr ""

#: ../../LangRef.rst:731
msgid ""
"Aliases have a name and an aliasee that is either a global value or a "
"constant expression."
msgstr ""

#: ../../LangRef.rst:734
msgid ""
"Aliases may have an optional :ref:`linkage type <linkage>`, an optional "
":ref:`visibility style <visibility>`, an optional :ref:`DLL storage class"
" <dllstorageclass>` and an optional :ref:`tls model <tls_model>`."
msgstr ""

#: ../../LangRef.rst:742
msgid ""
"The linkage must be one of ``private``, ``internal``, ``linkonce``, "
"``weak``, ``linkonce_odr``, ``weak_odr``, ``external``. Note that some "
"system linkers might not correctly handle dropping a weak symbol that is "
"aliased."
msgstr ""

#: ../../LangRef.rst:746
msgid ""
"Aliases that are not ``unnamed_addr`` are guaranteed to have the same "
"address as the aliasee expression. ``unnamed_addr`` ones are only "
"guaranteed to point to the same content."
msgstr ""

#: ../../LangRef.rst:750
msgid ""
"Since aliases are only a second name, some restrictions apply, of which "
"some can only be checked when producing an object file:"
msgstr ""

#: ../../LangRef.rst:753
msgid ""
"The expression defining the aliasee must be computable at assembly time. "
"Since it is just a name, no relocations can be used."
msgstr ""

#: ../../LangRef.rst:756
msgid ""
"No alias in the expression can be weak as the possibility of the "
"intermediate alias being overridden cannot be represented in an object "
"file."
msgstr ""

#: ../../LangRef.rst:760
msgid ""
"No global value in the expression can be a declaration, since that would "
"require a relocation, which is not possible."
msgstr ""

#: ../../LangRef.rst:766
msgid "Comdats"
msgstr ""

#: ../../LangRef.rst:768
msgid ""
"Comdat IR provides access to COFF and ELF object file COMDAT "
"functionality."
msgstr ""

#: ../../LangRef.rst:770
msgid ""
"Comdats have a name which represents the COMDAT key. All global objects "
"that specify this key will only end up in the final object file if the "
"linker chooses that key over some other key. Aliases are placed in the "
"same COMDAT that their aliasee computes to, if any."
msgstr ""

#: ../../LangRef.rst:775
msgid ""
"Comdats have a selection kind to provide input on how the linker should "
"choose between keys in two different object files."
msgstr ""

#: ../../LangRef.rst:782
msgid "The selection kind must be one of the following:"
msgstr ""

#: ../../LangRef.rst:784
msgid "``any``"
msgstr ""

#: ../../LangRef.rst:785
msgid "The linker may choose any COMDAT key, the choice is arbitrary."
msgstr ""

#: ../../LangRef.rst:787
msgid "``exactmatch``"
msgstr ""

#: ../../LangRef.rst:787
msgid ""
"The linker may choose any COMDAT key but the sections must contain the "
"same data."
msgstr ""

#: ../../LangRef.rst:789
msgid "``largest``"
msgstr ""

#: ../../LangRef.rst:790
msgid "The linker will choose the section containing the largest COMDAT key."
msgstr ""

#: ../../LangRef.rst:791
msgid "``noduplicates``"
msgstr ""

#: ../../LangRef.rst:792
msgid "The linker requires that only section with this COMDAT key exist."
msgstr ""

#: ../../LangRef.rst:795
msgid "``samesize``"
msgstr ""

#: ../../LangRef.rst:794
msgid ""
"The linker may choose any COMDAT key but the sections must contain the "
"same amount of data."
msgstr ""

#: ../../LangRef.rst:797
msgid ""
"Note that the Mach-O platform doesn't support COMDATs and ELF only "
"supports ``any`` as a selection kind."
msgstr ""

#: ../../LangRef.rst:800
msgid ""
"Here is an example of a COMDAT group where a function will only be "
"selected if the COMDAT key's section is the largest:"
msgstr ""

#: ../../LangRef.rst:812
msgid ""
"As a syntactic sugar the ``$name`` can be omitted if the name is the same"
" as the global name:"
msgstr ""

#: ../../LangRef.rst:821
msgid ""
"In a COFF object file, this will create a COMDAT section with selection "
"kind ``IMAGE_COMDAT_SELECT_LARGEST`` containing the contents of the "
"``@foo`` symbol and another COMDAT section with selection kind "
"``IMAGE_COMDAT_SELECT_ASSOCIATIVE`` which is associated with the first "
"COMDAT section and contains the contents of the ``@bar`` symbol."
msgstr ""

#: ../../LangRef.rst:827
msgid ""
"There are some restrictions on the properties of the global object. It, "
"or an alias to it, must have the same name as the COMDAT group when "
"targeting COFF. The contents and size of this object may be used during "
"link-time to determine which COMDAT groups get selected depending on the "
"selection kind. Because the name of the object must match the name of the"
" COMDAT group, the linkage of the global object must not be local; local "
"symbols can get renamed if a collision occurs in the symbol table."
msgstr ""

#: ../../LangRef.rst:836
msgid ""
"The combined use of COMDATS and section attributes may yield surprising "
"results. For example:"
msgstr ""

#: ../../LangRef.rst:846
msgid ""
"From the object file perspective, this requires the creation of two "
"sections with the same name. This is necessary because both globals "
"belong to different COMDAT groups and COMDATs, at the object file level, "
"are represented by sections."
msgstr ""

#: ../../LangRef.rst:851
msgid ""
"Note that certain IR constructs like global variables and functions may "
"create COMDATs in the object file in addition to any which are specified "
"using COMDAT IR. This arises when the code generator is configured to "
"emit globals in individual sections (e.g. when `-data-sections` or "
"`-function-sections` is supplied to `llc`)."
msgstr ""

#: ../../LangRef.rst:860
msgid "Named Metadata"
msgstr ""

#: ../../LangRef.rst:862
msgid ""
"Named metadata is a collection of metadata. :ref:`Metadata nodes "
"<metadata>` (but not metadata strings) are the only valid operands for a "
"named metadata."
msgstr ""

#: ../../LangRef.rst:866
msgid ""
"Named metadata are represented as a string of characters with the "
"metadata prefix. The rules for metadata names are the same as for "
"identifiers, but quoted names are not allowed. ``\"\\xx\"`` type escapes "
"are still valid, which allows any character to be part of a name."
msgstr ""

#: ../../LangRef.rst:883
msgid "Parameter Attributes"
msgstr ""

#: ../../LangRef.rst:885
msgid ""
"The return type and each parameter of a function type may have a set of "
"*parameter attributes* associated with them. Parameter attributes are "
"used to communicate additional information about the result or parameters"
" of a function. Parameter attributes are considered to be part of the "
"function, not of the function type, so functions with different parameter"
" attributes can have the same function type."
msgstr ""

#: ../../LangRef.rst:892
msgid ""
"Parameter attributes are simple keywords that follow the type specified. "
"If multiple parameter attributes are needed, they are space separated. "
"For example:"
msgstr ""

#: ../../LangRef.rst:902
msgid ""
"Note that any attributes for the function result (``nounwind``, "
"``readonly``) come immediately after the argument list."
msgstr ""

#: ../../LangRef.rst:905
msgid "Currently, only the following parameter attributes are defined:"
msgstr ""

#: ../../LangRef.rst:910
msgid "``zeroext``"
msgstr ""

#: ../../LangRef.rst:908
msgid ""
"This indicates to the code generator that the parameter or return value "
"should be zero-extended to the extent required by the target's ABI (which"
" is usually 32-bits, but is 8-bits for a i1 on x86-64) by the caller (for"
" a parameter) or the callee (for a return value)."
msgstr ""

#: ../../LangRef.rst:915
msgid "``signext``"
msgstr ""

#: ../../LangRef.rst:913
msgid ""
"This indicates to the code generator that the parameter or return value "
"should be sign-extended to the extent required by the target's ABI (which"
" is usually 32-bits) by the caller (for a parameter) or the callee (for a"
" return value)."
msgstr ""

#: ../../LangRef.rst:922
msgid "``inreg``"
msgstr ""

#: ../../LangRef.rst:918
msgid ""
"This indicates that this parameter or return value should be treated in a"
" special target-dependent fashion while emitting code for a function call"
" or return (usually, by putting it in a register as opposed to memory, "
"though some targets use it to distinguish between two different kinds of "
"registers). Use of this attribute is target-specific."
msgstr ""

#: ../../LangRef.rst:940
msgid "``byval``"
msgstr ""

#: ../../LangRef.rst:925
msgid ""
"This indicates that the pointer parameter should really be passed by "
"value to the function. The attribute implies that a hidden copy of the "
"pointee is made between the caller and the callee, so the callee is "
"unable to modify the value in the caller. This attribute is only valid on"
" LLVM pointer arguments. It is generally used to pass structs and arrays "
"by value, but is also valid on pointers to scalars. The copy is "
"considered to belong to the caller not the callee (for example, "
"``readonly`` functions should not write to ``byval`` parameters). This is"
" not a valid attribute for return values."
msgstr ""

#: ../../LangRef.rst:936
msgid ""
"The byval attribute also supports specifying an alignment with the align "
"attribute. It indicates the alignment of the stack slot to form and the "
"known alignment of the pointer specified to the call site. If the "
"alignment is not specified, then the code generator makes a target-"
"specific assumption."
msgstr ""

#: ../../LangRef.rst:944
msgid "``inalloca``"
msgstr ""

#: ../../LangRef.rst:946
msgid ""
"The ``inalloca`` argument attribute allows the caller to take the address"
" of outgoing stack arguments. An ``inalloca`` argument must be a pointer "
"to stack memory produced by an ``alloca`` instruction. The alloca, or "
"argument allocation, must also be tagged with the inalloca keyword. Only "
"the last argument may have the ``inalloca`` attribute, and that argument "
"is guaranteed to be passed in memory."
msgstr ""

#: ../../LangRef.rst:953
msgid ""
"An argument allocation may be used by a call at most once because the "
"call may deallocate it. The ``inalloca`` attribute cannot be used in "
"conjunction with other attributes that affect argument storage, like "
"``inreg``, ``nest``, ``sret``, or ``byval``. The ``inalloca`` attribute "
"also disables LLVM's implicit lowering of large aggregate return values, "
"which means that frontend authors must lower them with ``sret`` pointers."
msgstr ""

#: ../../LangRef.rst:961
msgid ""
"When the call site is reached, the argument allocation must have been the"
" most recent stack allocation that is still live, or the results are "
"undefined. It is possible to allocate additional stack space after an "
"argument allocation and before its call site, but it must be cleared off "
"with :ref:`llvm.stackrestore <int_stackrestore>`."
msgstr ""

#: ../../LangRef.rst:968
msgid "See :doc:`InAlloca` for more information on how to use this attribute."
msgstr ""

#: ../../LangRef.rst:978
msgid "``sret``"
msgstr ""

#: ../../LangRef.rst:972
msgid ""
"This indicates that the pointer parameter specifies the address of a "
"structure that is the return value of the function in the source program."
" This pointer must be guaranteed by the caller to be valid: loads and "
"stores to the structure may be assumed by the callee not to trap and to "
"be properly aligned. This may only be applied to the first parameter. "
"This is not a valid attribute for return values."
msgstr ""

#: ../../LangRef.rst:985
msgid "``align <n>``"
msgstr ""

#: ../../LangRef.rst:981
msgid ""
"This indicates that the pointer value may be assumed by the optimizer to "
"have the specified alignment."
msgstr ""

#: ../../LangRef.rst:984
msgid ""
"Note that this attribute has additional semantics when combined with the "
"``byval`` attribute."
msgstr ""

#: ../../LangRef.rst:1008
msgid "``noalias``"
msgstr ""

#: ../../LangRef.rst:990
msgid ""
"This indicates that objects accessed via pointer values :ref:`based "
"<pointeraliasing>` on the argument or return value are not also accessed,"
" during the execution of the function, via pointer values not *based* on "
"the argument or return value. The attribute on a return value also has "
"additional semantics described below. The caller shares the "
"responsibility with the callee for ensuring that these requirements are "
"met. For further details, please see the discussion of the NoAlias "
"response in :ref:`alias analysis <Must, May, or No>`."
msgstr ""

#: ../../LangRef.rst:999
msgid ""
"Note that this definition of ``noalias`` is intentionally similar to the "
"definition of ``restrict`` in C99 for function arguments."
msgstr ""

#: ../../LangRef.rst:1002
msgid ""
"For function return values, C99's ``restrict`` is not meaningful, while "
"LLVM's ``noalias`` is. Furthermore, the semantics of the ``noalias`` "
"attribute on return values are stronger than the semantics of the "
"attribute when used on function arguments. On function return values, the"
" ``noalias`` attribute indicates that the function acts like a system "
"memory allocation function, returning a pointer to allocated storage "
"disjoint from the storage for any other object accessible to the caller."
msgstr ""

#: ../../LangRef.rst:1013
msgid "``nocapture``"
msgstr ""

#: ../../LangRef.rst:1011
msgid ""
"This indicates that the callee does not make any copies of the pointer "
"that outlive the callee itself. This is not a valid attribute for return "
"values."
msgstr ""

#: ../../LangRef.rst:1020
msgid "``nest``"
msgstr ""

#: ../../LangRef.rst:1018
msgid ""
"This indicates that the pointer parameter can be excised using the "
":ref:`trampoline intrinsics <int_trampoline>`. This is not a valid "
"attribute for return values and can only be applied to one parameter."
msgstr ""

#: ../../LangRef.rst:1029
msgid "``returned``"
msgstr ""

#: ../../LangRef.rst:1023
msgid ""
"This indicates that the function always returns the argument as its "
"return value. This is an optimization hint to the code generator when "
"generating the caller, allowing tail call optimization and omission of "
"register saves and restores in some cases; it is not checked or enforced "
"when generating the callee. The parameter and the function return type "
"must be valid operands for the :ref:`bitcast instruction <i_bitcast>`. "
"This is not a valid attribute for return values and can only be applied "
"to one parameter."
msgstr ""

#: ../../LangRef.rst:1036
msgid "``nonnull``"
msgstr ""

#: ../../LangRef.rst:1032
msgid ""
"This indicates that the parameter or return pointer is not null. This "
"attribute may only be applied to pointer typed parameters. This is not "
"checked or enforced by LLVM, the caller must ensure that the pointer "
"passed in is non-null, or the callee must ensure that the returned "
"pointer is non-null."
msgstr ""

#: ../../LangRef.rst:1047
msgid "``dereferenceable(<n>)``"
msgstr ""

#: ../../LangRef.rst:1039
msgid ""
"This indicates that the parameter or return pointer is dereferenceable. "
"This attribute may only be applied to pointer typed parameters. A pointer"
" that is dereferenceable can be loaded from speculatively without a risk "
"of trapping. The number of bytes known to be dereferenceable must be "
"provided in parentheses. It is legal for the number of bytes to be less "
"than the size of the pointee type. The ``nonnull`` attribute does not "
"imply dereferenceability (consider a pointer to one element past the end "
"of an array), however ``dereferenceable(<n>)`` does imply ``nonnull`` in "
"``addrspace(0)`` (which is the default address space)."
msgstr ""

#: ../../LangRef.rst:1060
msgid "``dereferenceable_or_null(<n>)``"
msgstr ""

#: ../../LangRef.rst:1050
msgid ""
"This indicates that the parameter or return value isn't both non-null and"
" non-dereferenceable (up to ``<n>`` bytes) at the same time. All non-null"
" pointers tagged with ``dereferenceable_or_null(<n>)`` are "
"``dereferenceable(<n>)``. For address space 0 "
"``dereferenceable_or_null(<n>)`` implies that a pointer is exactly one of"
" ``dereferenceable(<n>)`` or ``null``, and in other address spaces "
"``dereferenceable_or_null(<n>)`` implies that a pointer is at least one "
"of ``dereferenceable(<n>)`` or ``null`` (i.e. it may be both ``null`` and"
" ``dereferenceable(<n>)``). This attribute may only be applied to pointer"
" typed parameters."
msgstr ""

#: ../../LangRef.rst:1065
msgid "Garbage Collector Strategy Names"
msgstr ""

#: ../../LangRef.rst:1067
msgid ""
"Each function may specify a garbage collector strategy name, which is "
"simply a string:"
msgstr ""

#: ../../LangRef.rst:1074
msgid ""
"The supported values of *name* includes those :ref:`built in to LLVM "
"<builtin-gc-strategies>` and any provided by loaded plugins. Specifying a"
" GC strategy will cause the compiler to alter its output in order to "
"support the named garbage collection algorithm. Note that LLVM itself "
"does not contain a garbage collector, this functionality is restricted to"
" generating machine code which can interoperate with a collector provided"
" externally."
msgstr ""

#: ../../LangRef.rst:1084
msgid "Prefix Data"
msgstr ""

#: ../../LangRef.rst:1086
msgid ""
"Prefix data is data associated with a function which the code generator "
"will emit immediately before the function's entrypoint. The purpose of "
"this feature is to allow frontends to associate language-specific runtime"
" metadata with specific functions and make it available through the "
"function pointer while still allowing the function pointer to be called."
msgstr ""

#: ../../LangRef.rst:1093
msgid ""
"To access the data for a given function, a program may bitcast the "
"function pointer to a pointer to the constant's type and dereference "
"index -1. This implies that the IR symbol points just past the end of the"
" prefix data. For instance, take the example of a function annotated with"
" a single ``i32``,"
msgstr ""

#: ../../LangRef.rst:1103
msgid "The prefix data can be referenced as,"
msgstr ""

#: ../../LangRef.rst:1111
msgid ""
"Prefix data is laid out as if it were an initializer for a global "
"variable of the prefix data's type. The function will be placed such that"
" the beginning of the prefix data is aligned. This means that if the size"
" of the prefix data is not a multiple of the alignment size, the "
"function's entrypoint will not be aligned. If alignment of the function's"
" entrypoint is desired, padding must be added to the prefix data."
msgstr ""

#: ../../LangRef.rst:1119
msgid ""
"A function may have prefix data but no body. This has similar semantics "
"to the ``available_externally`` linkage in that the data may be used by "
"the optimizers but will not be emitted in the object file."
msgstr ""

#: ../../LangRef.rst:1126
msgid "Prologue Data"
msgstr ""

#: ../../LangRef.rst:1128
msgid ""
"The ``prologue`` attribute allows arbitrary code (encoded as bytes) to be"
" inserted prior to the function body. This can be used for enabling "
"function hot-patching and instrumentation."
msgstr ""

#: ../../LangRef.rst:1132
msgid ""
"To maintain the semantics of ordinary function calls, the prologue data "
"must have a particular format. Specifically, it must begin with a "
"sequence of bytes which decode to a sequence of machine instructions, "
"valid for the module's target, which transfer control to the point "
"immediately succeeding the prologue data, without performing any other "
"visible action. This allows the inliner and other passes to reason about "
"the semantics of the function definition without needing to reason about "
"the prologue data. Obviously this makes the format of the prologue data "
"highly target dependent."
msgstr ""

#: ../../LangRef.rst:1141
msgid ""
"A trivial example of valid prologue data for the x86 architecture is ``i8"
" 144``, which encodes the ``nop`` instruction:"
msgstr ""

#: ../../LangRef.rst:1148
msgid ""
"Generally prologue data can be formed by encoding a relative branch "
"instruction which skips the metadata, as in this example of valid "
"prologue data for the x86_64 architecture, where the first two bytes "
"encode ``jmp .+10``:"
msgstr ""

#: ../../LangRef.rst:1158
msgid ""
"A function may have prologue data but no body. This has similar semantics"
" to the ``available_externally`` linkage in that the data may be used by "
"the optimizers but will not be emitted in the object file."
msgstr ""

#: ../../LangRef.rst:1165
msgid "Personality Function"
msgstr ""

#: ../../LangRef.rst:1167
msgid ""
"The ``personality`` attribute permits functions to specify what function "
"to use for exception handling."
msgstr ""

#: ../../LangRef.rst:1173
msgid "Attribute Groups"
msgstr ""

#: ../../LangRef.rst:1175
msgid ""
"Attribute groups are groups of attributes that are referenced by objects "
"within the IR. They are important for keeping ``.ll`` files readable, "
"because a lot of functions will use the same set of attributes. In the "
"degenerative case of a ``.ll`` file that corresponds to a single ``.c`` "
"file, the single attribute group will capture the important command line "
"flags used to build that file."
msgstr ""

#: ../../LangRef.rst:1181
msgid ""
"An attribute group is a module-level object. To use an attribute group, "
"an object references the attribute group's ID (e.g. ``#37``). An object "
"may refer to more than one attribute group. In that situation, the "
"attributes from the different groups are merged."
msgstr ""

#: ../../LangRef.rst:1186
msgid ""
"Here is an example of attribute groups for a function that should always "
"be inlined, has a stack alignment of 4, and which shouldn't use SSE "
"instructions:"
msgstr ""

#: ../../LangRef.rst:1203
msgid "Function Attributes"
msgstr ""

#: ../../LangRef.rst:1205
msgid ""
"Function attributes are set to communicate additional information about a"
" function. Function attributes are considered to be part of the function,"
" not of the function type, so functions with different function "
"attributes can have the same function type."
msgstr ""

#: ../../LangRef.rst:1210
msgid ""
"Function attributes are simple keywords that follow the type specified. "
"If multiple attributes are needed, they are space separated. For example:"
msgstr ""

#: ../../LangRef.rst:1224
msgid "``alignstack(<n>)``"
msgstr ""

#: ../../LangRef.rst:1222
msgid ""
"This attribute indicates that, when emitting the prologue and epilogue, "
"the backend should forcibly align the stack pointer. Specify the desired "
"alignment, which must be a power of two, in parentheses."
msgstr ""

#: ../../LangRef.rst:1228
msgid "``alwaysinline``"
msgstr ""

#: ../../LangRef.rst:1227
msgid ""
"This attribute indicates that the inliner should attempt to inline this "
"function into callers whenever possible, ignoring any active inlining "
"size threshold for this caller."
msgstr ""

#: ../../LangRef.rst:1234
msgid "``builtin``"
msgstr ""

#: ../../LangRef.rst:1231
msgid ""
"This indicates that the callee function at a call site should be "
"recognized as a built-in function, even though the function's declaration"
" uses the ``nobuiltin`` attribute. This is only valid at call sites for "
"direct calls to functions that are declared with the ``nobuiltin`` "
"attribute."
msgstr ""

#: ../../LangRef.rst:1239
msgid "``cold``"
msgstr ""

#: ../../LangRef.rst:1237
msgid ""
"This attribute indicates that this function is rarely called. When "
"computing edge weights, basic blocks post-dominated by a cold function "
"call are also considered to be cold; and, thus, given low weight."
msgstr ""

#: ../../LangRef.rst:1244
msgid "``convergent``"
msgstr ""

#: ../../LangRef.rst:1242
msgid ""
"This attribute indicates that the callee is dependent on a convergent "
"thread execution pattern under certain parallel execution models. "
"Transformations that are execution model agnostic may not make the "
"execution of a convergent operation control dependent on any additional "
"values."
msgstr ""

#: ../../LangRef.rst:1248
msgid "``inaccessiblememonly``"
msgstr ""

#: ../../LangRef.rst:1247
msgid ""
"This attribute indicates that the function may only access memory that is"
" not accessible by the module being compiled. This is a weaker form of "
"``readnone``."
msgstr ""

#: ../../LangRef.rst:1252
msgid "``inaccessiblemem_or_argmemonly``"
msgstr ""

#: ../../LangRef.rst:1251
msgid ""
"This attribute indicates that the function may only access memory that is"
" either not accessible by the module being compiled, or is pointed to by "
"its pointer arguments. This is a weaker form of  ``argmemonly``"
msgstr ""

#: ../../LangRef.rst:1257
msgid "``inlinehint``"
msgstr ""

#: ../../LangRef.rst:1255
msgid ""
"This attribute indicates that the source code contained a hint that "
"inlining this function is desirable (such as the \"inline\" keyword in "
"C/C++). It is just a hint; it imposes no requirements on the inliner."
msgstr ""

#: ../../LangRef.rst:1265
msgid "``jumptable``"
msgstr ""

#: ../../LangRef.rst:1260
msgid ""
"This attribute indicates that the function should be added to a jump-"
"instruction table at code-generation time, and that all address-taken "
"references to this function should be replaced with a reference to the "
"appropriate jump-instruction-table function pointer. Note that this "
"creates a new pointer for the original function, which means that code "
"that depends on function-pointer identity can break. So, any function "
"annotated with ``jumptable`` must also be ``unnamed_addr``."
msgstr ""

#: ../../LangRef.rst:1270
msgid "``minsize``"
msgstr ""

#: ../../LangRef.rst:1268
msgid ""
"This attribute suggests that optimization passes and code generator "
"passes make choices that keep the code size of this function as small as "
"possible and perform optimizations that may sacrifice runtime performance"
" in order to minimize the size of the generated code."
msgstr ""

#: ../../LangRef.rst:1273
msgid "``naked``"
msgstr ""

#: ../../LangRef.rst:1273
msgid ""
"This attribute disables prologue / epilogue emission for the function. "
"This can have very system-specific consequences."
msgstr ""

#: ../../LangRef.rst:1279
msgid "``nobuiltin``"
msgstr ""

#: ../../LangRef.rst:1276
msgid ""
"This indicates that the callee function at a call site is not recognized "
"as a built-in function. LLVM will retain the original call and not "
"replace it with equivalent code based on the semantics of the built-in "
"function, unless the call site uses the ``builtin`` attribute. This is "
"valid at call sites and on function declarations and definitions."
msgstr ""

#: ../../LangRef.rst:1290
msgid "``noduplicate``"
msgstr ""

#: ../../LangRef.rst:1282
msgid ""
"This attribute indicates that calls to the function cannot be duplicated."
" A call to a ``noduplicate`` function may be moved within its parent "
"function, but may not be duplicated within its parent function."
msgstr ""

#: ../../LangRef.rst:1287
msgid ""
"A function containing a ``noduplicate`` call may still be an inlining "
"candidate, provided that the call is not duplicated by inlining. That "
"implies that the function has internal linkage and only has one call "
"site, so the original call is dead after inlining."
msgstr ""

#: ../../LangRef.rst:1292
msgid "``noimplicitfloat``"
msgstr ""

#: ../../LangRef.rst:1293
msgid "This attributes disables implicit floating point instructions."
msgstr ""

#: ../../LangRef.rst:1296
msgid "``noinline``"
msgstr ""

#: ../../LangRef.rst:1295
msgid ""
"This attribute indicates that the inliner should never inline this "
"function in any situation. This attribute may not be used together with "
"the ``alwaysinline`` attribute."
msgstr ""

#: ../../LangRef.rst:1300
msgid "``nonlazybind``"
msgstr ""

#: ../../LangRef.rst:1299
msgid ""
"This attribute suppresses lazy symbol binding for the function. This may "
"make calls to the function faster, at the cost of extra program startup "
"time if the function is not called during program startup."
msgstr ""

#: ../../LangRef.rst:1303
msgid "``noredzone``"
msgstr ""

#: ../../LangRef.rst:1303
msgid ""
"This attribute indicates that the code generator should not use a red "
"zone, even if the target-specific ABI normally permits it."
msgstr ""

#: ../../LangRef.rst:1307
msgid "``noreturn``"
msgstr ""

#: ../../LangRef.rst:1306
msgid ""
"This function attribute indicates that the function never returns "
"normally. This produces undefined behavior at runtime if the function "
"ever does dynamically return."
msgstr ""

#: ../../LangRef.rst:1311
msgid "``norecurse``"
msgstr ""

#: ../../LangRef.rst:1310
msgid ""
"This function attribute indicates that the function does not call itself "
"either directly or indirectly down any possible call path. This produces "
"undefined behavior at runtime if the function ever does recurse."
msgstr ""

#: ../../LangRef.rst:1318
msgid "``nounwind``"
msgstr ""

#: ../../LangRef.rst:1314
msgid ""
"This function attribute indicates that the function never raises an "
"exception. If the function does raise an exception, its runtime behavior "
"is undefined. However, functions marked nounwind may still trap or "
"generate asynchronous exceptions. Exception handling schemes that are "
"recognized by LLVM to handle asynchronous exceptions, such as SEH, will "
"still provide their implementation defined semantics."
msgstr ""

#: ../../LangRef.rst:1330
msgid "``optnone``"
msgstr ""

#: ../../LangRef.rst:1321
msgid ""
"This function attribute indicates that most optimization passes will skip"
" this function, with the exception of interprocedural optimization "
"passes. Code generation defaults to the \"fast\" instruction selector. "
"This attribute cannot be used together with the ``alwaysinline`` "
"attribute; this attribute is also incompatible with the ``minsize`` "
"attribute and the ``optsize`` attribute."
msgstr ""

#: ../../LangRef.rst:1328
msgid ""
"This attribute requires the ``noinline`` attribute to be specified on the"
" function as well, so the function is never inlined into any caller. Only"
" functions with the ``alwaysinline`` attribute are valid candidates for "
"inlining into the body of this function."
msgstr ""

#: ../../LangRef.rst:1335
msgid "``optsize``"
msgstr ""

#: ../../LangRef.rst:1333
msgid ""
"This attribute suggests that optimization passes and code generator "
"passes make choices that keep the code size of this function low, and "
"otherwise do optimizations specifically to reduce code size as long as "
"they do not significantly impact runtime performance."
msgstr ""

#: ../../LangRef.rst:1348
msgid "``readnone``"
msgstr ""

#: ../../LangRef.rst:1338
msgid ""
"On a function, this attribute indicates that the function computes its "
"result (or decides to unwind an exception) based strictly on its "
"arguments, without dereferencing any pointer arguments or otherwise "
"accessing any mutable state (e.g. memory, control registers, etc) visible"
" to caller functions. It does not write through any pointer arguments "
"(including ``byval`` arguments) and never changes any state visible to "
"callers. This means that it cannot unwind exceptions by calling the "
"``C++`` exception throwing methods."
msgstr ""

#: ../../LangRef.rst:1347
msgid ""
"On an argument, this attribute indicates that the function does not "
"dereference that pointer argument, even though it may read or write the "
"memory that the pointer points to if accessed through other pointers."
msgstr ""

#: ../../LangRef.rst:1362
msgid "``readonly``"
msgstr ""

#: ../../LangRef.rst:1351
msgid ""
"On a function, this attribute indicates that the function does not write "
"through any pointer arguments (including ``byval`` arguments) or "
"otherwise modify any state (e.g. memory, control registers, etc) visible "
"to caller functions. It may dereference pointer arguments and read state "
"that may be set in the caller. A readonly function always returns the "
"same value (or unwinds an exception identically) when called with the "
"same set of arguments and global state. It cannot unwind an exception by "
"calling the ``C++`` exception throwing methods."
msgstr ""

#: ../../LangRef.rst:1361
msgid ""
"On an argument, this attribute indicates that the function does not write"
" through this pointer argument, even though it may write to the memory "
"that the pointer points to."
msgstr ""

#: ../../LangRef.rst:1370
msgid "``argmemonly``"
msgstr ""

#: ../../LangRef.rst:1365
msgid ""
"This attribute indicates that the only memory accesses inside function "
"are loads and stores from objects pointed to by its pointer-typed "
"arguments, with arbitrary offsets. Or in other words, all memory "
"operations in the function can refer to memory only using pointers based "
"on its function arguments. Note that ``argmemonly`` can be used together "
"with ``readonly`` attribute in order to specify that function reads only "
"from its arguments."
msgstr ""

#: ../../LangRef.rst:1375
msgid "``returns_twice``"
msgstr ""

#: ../../LangRef.rst:1373
msgid ""
"This attribute indicates that this function can return twice. The C "
"``setjmp`` is an example of such a function. The compiler disables some "
"optimizations (like tail calls) in the caller of these functions."
msgstr ""

#: ../../LangRef.rst:1384
msgid "``safestack``"
msgstr ""

#: ../../LangRef.rst:1378
msgid ""
"This attribute indicates that `SafeStack "
"<http://clang.llvm.org/docs/SafeStack.html>`_ protection is enabled for "
"this function."
msgstr ""

#: ../../LangRef.rst:1382
msgid ""
"If a function that has a ``safestack`` attribute is inlined into a "
"function that doesn't have a ``safestack`` attribute or which has an "
"``ssp``, ``sspstrong`` or ``sspreq`` attribute, then the resulting "
"function will have a ``safestack`` attribute."
msgstr ""

#: ../../LangRef.rst:1387
msgid "``sanitize_address``"
msgstr ""

#: ../../LangRef.rst:1387
msgid ""
"This attribute indicates that AddressSanitizer checks (dynamic address "
"safety analysis) are enabled for this function."
msgstr ""

#: ../../LangRef.rst:1390
msgid "``sanitize_memory``"
msgstr ""

#: ../../LangRef.rst:1390
msgid ""
"This attribute indicates that MemorySanitizer checks (dynamic detection "
"of accesses to uninitialized memory) are enabled for this function."
msgstr ""

#: ../../LangRef.rst:1393
msgid "``sanitize_thread``"
msgstr ""

#: ../../LangRef.rst:1393
msgid ""
"This attribute indicates that ThreadSanitizer checks (dynamic thread "
"safety analysis) are enabled for this function."
msgstr ""

#: ../../LangRef.rst:1412
msgid "``ssp``"
msgstr ""

#: ../../LangRef.rst:1396
msgid ""
"This attribute indicates that the function should emit a stack smashing "
"protector. It is in the form of a \"canary\" --- a random value placed on"
" the stack before the local variables that's checked upon return from the"
" function to see if it has been overwritten. A heuristic is used to "
"determine if a function needs stack protectors or not. The heuristic used"
" will enable protectors for functions with:"
msgstr ""

#: ../../LangRef.rst:1403
msgid "Character arrays larger than ``ssp-buffer-size`` (default 8)."
msgstr ""

#: ../../LangRef.rst:1404
msgid "Aggregates containing character arrays larger than ``ssp-buffer-size``."
msgstr ""

#: ../../LangRef.rst:1405
msgid ""
"Calls to alloca() with variable sizes or constant sizes greater than "
"``ssp-buffer-size``."
msgstr ""

#: ../../LangRef.rst:1408
msgid ""
"Variables that are identified as requiring a protector will be arranged "
"on the stack such that they are adjacent to the stack protector guard."
msgstr ""

#: ../../LangRef.rst:1411
msgid ""
"If a function that has an ``ssp`` attribute is inlined into a function "
"that doesn't have an ``ssp`` attribute, then the resulting function will "
"have an ``ssp`` attribute."
msgstr ""

#: ../../LangRef.rst:1432
msgid "``sspreq``"
msgstr ""

#: ../../LangRef.rst:1415
msgid ""
"This attribute indicates that the function should *always* emit a stack "
"smashing protector. This overrides the ``ssp`` function attribute."
msgstr ""

#: ../../LangRef.rst:1419 ../../LangRef.rst:1445
msgid ""
"Variables that are identified as requiring a protector will be arranged "
"on the stack such that they are adjacent to the stack protector guard. "
"The specific layout rules are:"
msgstr ""

#: ../../LangRef.rst:1423 ../../LangRef.rst:1449
msgid ""
"Large arrays and structures containing large arrays (``>= ssp-buffer-"
"size``) are closest to the stack protector."
msgstr ""

#: ../../LangRef.rst:1425 ../../LangRef.rst:1451
msgid ""
"Small arrays and structures containing small arrays (``< ssp-buffer-"
"size``) are 2nd closest to the protector."
msgstr ""

#: ../../LangRef.rst:1427 ../../LangRef.rst:1453
msgid ""
"Variables that have had their address taken are 3rd closest to the "
"protector."
msgstr ""

#: ../../LangRef.rst:1430
msgid ""
"If a function that has an ``sspreq`` attribute is inlined into a function"
" that doesn't have an ``sspreq`` attribute or which has an ``ssp`` or "
"``sspstrong`` attribute, then the resulting function will have an "
"``sspreq`` attribute."
msgstr ""

#: ../../LangRef.rst:1459
msgid "``sspstrong``"
msgstr ""

#: ../../LangRef.rst:1435
msgid ""
"This attribute indicates that the function should emit a stack smashing "
"protector. This attribute causes a strong heuristic to be used when "
"determining if a function needs stack protectors. The strong heuristic "
"will enable protectors for functions with:"
msgstr ""

#: ../../LangRef.rst:1440
msgid "Arrays of any size and type"
msgstr ""

#: ../../LangRef.rst:1441
msgid "Aggregates containing an array of any size and type."
msgstr ""

#: ../../LangRef.rst:1442
msgid "Calls to alloca()."
msgstr ""

#: ../../LangRef.rst:1443
msgid "Local variables that have had their address taken."
msgstr ""

#: ../../LangRef.rst:1456
msgid "This overrides the ``ssp`` function attribute."
msgstr ""

#: ../../LangRef.rst:1458
msgid ""
"If a function that has an ``sspstrong`` attribute is inlined into a "
"function that doesn't have an ``sspstrong`` attribute, then the resulting"
" function will have an ``sspstrong`` attribute."
msgstr ""

#: ../../LangRef.rst:1464
msgid "``\"thunk\"``"
msgstr ""

#: ../../LangRef.rst:1462
msgid ""
"This attribute indicates that the function will delegate to some other "
"function with a tail call. The prototype of a thunk should not be used "
"for optimization purposes. The caller is expected to cast the thunk "
"prototype to match the thunk target prototype."
msgstr ""

#: ../../LangRef.rst:1472
msgid "``uwtable``"
msgstr ""

#: ../../LangRef.rst:1467
msgid ""
"This attribute indicates that the ABI being targeted requires that an "
"unwind table entry be produced for this function even if we can show that"
" no exceptions passes by it. This is normally the case for the ELF x86-64"
" abi, but it can be disabled for some compilation units."
msgstr ""

#: ../../LangRef.rst:1477
msgid "Operand Bundles"
msgstr ""

#: ../../LangRef.rst:1479
msgid ""
"Note: operand bundles are a work in progress, and they should be "
"considered experimental at this time."
msgstr ""

#: ../../LangRef.rst:1482
msgid ""
"Operand bundles are tagged sets of SSA values that can be associated with"
" certain LLVM instructions (currently only ``call`` s and ``invoke`` s)."
"  In a way they are like metadata, but dropping them is incorrect and "
"will change program semantics."
msgstr ""

#: ../../LangRef.rst:1494
msgid ""
"Operand bundles are **not** part of a function's signature, and a given "
"function may be called from multiple places with different kinds of "
"operand bundles.  This reflects the fact that the operand bundles are "
"conceptually a part of the ``call`` (or ``invoke``), not the callee being"
" dispatched to."
msgstr ""

#: ../../LangRef.rst:1500
msgid ""
"Operand bundles are a generic mechanism intended to support runtime-"
"introspection-like functionality for managed languages.  While the exact "
"semantics of an operand bundle depend on the bundle tag, there are "
"certain limitations to how much the presence of an operand bundle can "
"influence the semantics of a program.  These restrictions are described "
"as the semantics of an \"unknown\" operand bundle.  As long as the "
"behavior of an operand bundle is describable within these restrictions, "
"LLVM does not need to have special knowledge of the operand bundle to not"
" miscompile programs containing it."
msgstr ""

#: ../../LangRef.rst:1510
msgid ""
"The bundle operands for an unknown operand bundle escape in unknown ways "
"before control is transferred to the callee or invokee."
msgstr ""

#: ../../LangRef.rst:1512
msgid ""
"Calls and invokes with operand bundles have unknown read / write effect "
"on the heap on entry and exit (even if the call target is ``readnone`` or"
" ``readonly``), unless they're overriden with callsite specific "
"attributes."
msgstr ""

#: ../../LangRef.rst:1516
msgid ""
"An operand bundle at a call site cannot change the implementation of the "
"called function.  Inter-procedural optimizations work as usual as long as"
" they take into account the first two properties."
msgstr ""

#: ../../LangRef.rst:1520
msgid "More specific types of operand bundles are described below."
msgstr ""

#: ../../LangRef.rst:1523
msgid "Deoptimization Operand Bundles"
msgstr ""

#: ../../LangRef.rst:1525
msgid ""
"Deoptimization operand bundles are characterized by the ``\"deopt\"`` "
"operand bundle tag.  These operand bundles represent an alternate "
"\"safe\" continuation for the call site they're attached to, and can be "
"used by a suitable runtime to deoptimize the compiled frame at the "
"specified call site.  There can be at most one ``\"deopt\"`` operand "
"bundle attached to a call site.  Exact details of deoptimization is out "
"of scope for the language reference, but it usually involves rewriting a "
"compiled frame into a set of interpreted frames."
msgstr ""

#: ../../LangRef.rst:1534
msgid ""
"From the compiler's perspective, deoptimization operand bundles make the "
"call sites they're attached to at least ``readonly``.  They read through "
"all of their pointer typed operands (even if they're not otherwise "
"escaped) and the entire visible heap.  Deoptimization operand bundles do "
"not capture their operands except during deoptimization, in which case "
"control will not be returned to the compiled frame."
msgstr ""

#: ../../LangRef.rst:1542
msgid ""
"The inliner knows how to inline through calls that have deoptimization "
"operand bundles.  Just like inlining through a normal call site involves "
"composing the normal and exceptional continuations, inlining through a "
"call site with a deoptimization operand bundle needs to appropriately "
"compose the \"safe\" deoptimization continuation.  The inliner does this "
"by prepending the parent's deoptimization continuation to every "
"deoptimization continuation in the inlined body. E.g. inlining ``@f`` "
"into ``@g`` in the following example"
msgstr ""

#: ../../LangRef.rst:1565
msgid "will result in"
msgstr ""

#: ../../LangRef.rst:1576
msgid ""
"It is the frontend's responsibility to structure or encode the "
"deoptimization state in a way that syntactically prepending the caller's "
"deoptimization state to the callee's deoptimization state is semantically"
" equivalent to composing the caller's deoptimization continuation after "
"the callee's deoptimization continuation."
msgstr ""

#: ../../LangRef.rst:1585
msgid "Funclet Operand Bundles"
msgstr ""

#: ../../LangRef.rst:1587
msgid ""
"Funclet operand bundles are characterized by the ``\"funclet\"`` operand "
"bundle tag.  These operand bundles indicate that a call site is within a "
"particular funclet.  There can be at most one ``\"funclet\"`` operand "
"bundle attached to a call site and it must have exactly one bundle "
"operand."
msgstr ""

#: ../../LangRef.rst:1593
msgid ""
"If any funclet EH pads have been \"entered\" but not \"exited\" (per the "
"`description in the EH doc\\ <ExceptionHandling.html#wineh-"
"constraints>`_), it is undefined behavior to execute a ``call`` or "
"``invoke`` which:"
msgstr ""

#: ../../LangRef.rst:1597
msgid ""
"does not have a ``\"funclet\"`` bundle and is not a ``call`` to a "
"nounwind intrinsic, or"
msgstr ""

#: ../../LangRef.rst:1599
msgid ""
"has a ``\"funclet\"`` bundle whose operand is not the most-recently-"
"entered not-yet-exited funclet EH pad."
msgstr ""

#: ../../LangRef.rst:1602
msgid ""
"Similarly, if no funclet EH pads have been entered-but-not-yet-exited, "
"executing a ``call`` or ``invoke`` with a ``\"funclet\"`` bundle is "
"undefined behavior."
msgstr ""

#: ../../LangRef.rst:1608
msgid "Module-Level Inline Assembly"
msgstr ""

#: ../../LangRef.rst:1610
msgid ""
"Modules may contain \"module-level inline asm\" blocks, which corresponds"
" to the GCC \"file scope inline asm\" blocks. These blocks are internally"
" concatenated by LLVM and treated as a single unit, but may be separated "
"in the ``.ll`` file if desired. The syntax is very simple:"
msgstr ""

#: ../../LangRef.rst:1620
msgid ""
"The strings can contain any character by escaping non-printable "
"characters. The escape sequence used is simply \"\\\\xx\" where \"xx\" is"
" the two digit hex code for the number."
msgstr ""

#: ../../LangRef.rst:1624
msgid ""
"Note that the assembly string *must* be parseable by LLVM's integrated "
"assembler (unless it is disabled), even when emitting a ``.s`` file."
msgstr ""

#: ../../LangRef.rst:1630
msgid "Data Layout"
msgstr ""

#: ../../LangRef.rst:1632
msgid ""
"A module may specify a target specific data layout string that specifies "
"how data is to be laid out in memory. The syntax for the data layout is "
"simply:"
msgstr ""

#: ../../LangRef.rst:1640
msgid ""
"The *layout specification* consists of a list of specifications separated"
" by the minus sign character ('-'). Each specification starts with a "
"letter and may include other information after the letter to define some "
"aspect of the data layout. The specifications accepted are as follows:"
msgstr ""

#: ../../LangRef.rst:1648
msgid "``E``"
msgstr ""

#: ../../LangRef.rst:1647
msgid ""
"Specifies that the target lays out data in big-endian form. That is, the "
"bits with the most significance have the lowest address location."
msgstr ""

#: ../../LangRef.rst:1652
msgid "``e``"
msgstr ""

#: ../../LangRef.rst:1651
msgid ""
"Specifies that the target lays out data in little-endian form. That is, "
"the bits with the least significance have the lowest address location."
msgstr ""

#: ../../LangRef.rst:1659
msgid "``S<size>``"
msgstr ""

#: ../../LangRef.rst:1655
msgid ""
"Specifies the natural alignment of the stack in bits. Alignment promotion"
" of stack variables is limited to the natural stack alignment to avoid "
"dynamic stack realignment. The stack alignment must be a multiple of "
"8-bits. If omitted, the natural stack alignment defaults to "
"\"unspecified\", which does not prevent any alignment promotions."
msgstr ""

#: ../../LangRef.rst:1665
msgid "``p[n]:<size>:<abi>:<pref>``"
msgstr ""

#: ../../LangRef.rst:1662
msgid ""
"This specifies the *size* of a pointer and its ``<abi>`` and "
"``<pref>``\\erred alignments for address space ``n``. All sizes are in "
"bits. The address space, ``n``, is optional, and if not specified, "
"denotes the default address space 0. The value of ``n`` must be in the "
"range [1,2^23)."
msgstr ""

#: ../../LangRef.rst:1668
msgid "``i<size>:<abi>:<pref>``"
msgstr ""

#: ../../LangRef.rst:1668
msgid ""
"This specifies the alignment for an integer type of a given bit "
"``<size>``. The value of ``<size>`` must be in the range [1,2^23)."
msgstr ""

#: ../../LangRef.rst:1671
msgid "``v<size>:<abi>:<pref>``"
msgstr ""

#: ../../LangRef.rst:1671
msgid "This specifies the alignment for a vector type of a given bit ``<size>``."
msgstr ""

#: ../../LangRef.rst:1677
msgid "``f<size>:<abi>:<pref>``"
msgstr ""

#: ../../LangRef.rst:1674
msgid ""
"This specifies the alignment for a floating point type of a given bit "
"``<size>``. Only values of ``<size>`` that are supported by the target "
"will work. 32 (float) and 64 (double) are supported on all targets; 80 or"
" 128 (different flavors of long double) are also supported on some "
"targets."
msgstr ""

#: ../../LangRef.rst:1679
msgid "``a:<abi>:<pref>``"
msgstr ""

#: ../../LangRef.rst:1680
msgid "This specifies the alignment for an object of aggregate type."
msgstr ""

#: ../../LangRef.rst:1691
msgid "``m:<mangling>``"
msgstr ""

#: ../../LangRef.rst:1682
msgid ""
"If present, specifies that llvm names are mangled in the output. The "
"options are"
msgstr ""

#: ../../LangRef.rst:1685
msgid "``e``: ELF mangling: Private symbols get a ``.L`` prefix."
msgstr ""

#: ../../LangRef.rst:1686
msgid "``m``: Mips mangling: Private symbols get a ``$`` prefix."
msgstr ""

#: ../../LangRef.rst:1687
msgid ""
"``o``: Mach-O mangling: Private symbols get ``L`` prefix. Other symbols "
"get a ``_`` prefix."
msgstr ""

#: ../../LangRef.rst:1689
msgid ""
"``w``: Windows COFF prefix:  Similar to Mach-O, but stdcall and fastcall "
"functions also get a suffix based on the frame size."
msgstr ""

#: ../../LangRef.rst:1691
msgid ""
"``x``: Windows x86 COFF prefix:  Similar to Windows COFF, but use a ``_``"
" prefix for ``__cdecl`` functions."
msgstr ""

#: ../../LangRef.rst:1698
msgid "``n<size1>:<size2>:<size3>...``"
msgstr ""

#: ../../LangRef.rst:1694
msgid ""
"This specifies a set of native integer widths for the target CPU in bits."
" For example, it might contain ``n32`` for 32-bit PowerPC, ``n32:64`` for"
" PowerPC 64, or ``n8:16:32:64`` for X86-64. Elements of this set are "
"considered to support most general arithmetic operations efficiently."
msgstr ""

#: ../../LangRef.rst:1700
msgid ""
"On every specification that takes a ``<abi>:<pref>``, specifying the "
"``<pref>`` alignment is optional. If omitted, the preceding ``:`` should "
"be omitted too and ``<pref>`` will be equal to ``<abi>``."
msgstr ""

#: ../../LangRef.rst:1704
msgid ""
"When constructing the data layout for a given target, LLVM starts with a "
"default set of specifications which are then (possibly) overridden by the"
" specifications in the ``datalayout`` keyword. The default specifications"
" are given in this list:"
msgstr ""

#: ../../LangRef.rst:1709
msgid "``E`` - big endian"
msgstr ""

#: ../../LangRef.rst:1710
msgid "``p:64:64:64`` - 64-bit pointers with 64-bit alignment."
msgstr ""

#: ../../LangRef.rst:1711
msgid ""
"``p[n]:64:64:64`` - Other address spaces are assumed to be the same as "
"the default address space."
msgstr ""

#: ../../LangRef.rst:1713
msgid "``S0`` - natural stack alignment is unspecified"
msgstr ""

#: ../../LangRef.rst:1714
msgid "``i1:8:8`` - i1 is 8-bit (byte) aligned"
msgstr ""

#: ../../LangRef.rst:1715
msgid "``i8:8:8`` - i8 is 8-bit (byte) aligned"
msgstr ""

#: ../../LangRef.rst:1716
msgid "``i16:16:16`` - i16 is 16-bit aligned"
msgstr ""

#: ../../LangRef.rst:1717
msgid "``i32:32:32`` - i32 is 32-bit aligned"
msgstr ""

#: ../../LangRef.rst:1718
msgid ""
"``i64:32:64`` - i64 has ABI alignment of 32-bits but preferred alignment "
"of 64-bits"
msgstr ""

#: ../../LangRef.rst:1720
msgid "``f16:16:16`` - half is 16-bit aligned"
msgstr ""

#: ../../LangRef.rst:1721
msgid "``f32:32:32`` - float is 32-bit aligned"
msgstr ""

#: ../../LangRef.rst:1722
msgid "``f64:64:64`` - double is 64-bit aligned"
msgstr ""

#: ../../LangRef.rst:1723
msgid "``f128:128:128`` - quad is 128-bit aligned"
msgstr ""

#: ../../LangRef.rst:1724
msgid "``v64:64:64`` - 64-bit vector is 64-bit aligned"
msgstr ""

#: ../../LangRef.rst:1725
msgid "``v128:128:128`` - 128-bit vector is 128-bit aligned"
msgstr ""

#: ../../LangRef.rst:1726
msgid "``a:0:64`` - aggregates are 64-bit aligned"
msgstr ""

#: ../../LangRef.rst:1728
msgid ""
"When LLVM is determining the alignment for a given type, it uses the "
"following rules:"
msgstr ""

#: ../../LangRef.rst:1731
msgid ""
"If the type sought is an exact match for one of the specifications, that "
"specification is used."
msgstr ""

#: ../../LangRef.rst:1733
msgid ""
"If no match is found, and the type sought is an integer type, then the "
"smallest integer type that is larger than the bitwidth of the sought type"
" is used. If none of the specifications are larger than the bitwidth then"
" the largest integer type is used. For example, given the default "
"specifications above, the i7 type will use the alignment of i8 (next "
"largest) while both i65 and i256 will use the alignment of i64 (largest "
"specified)."
msgstr ""

#: ../../LangRef.rst:1740
msgid ""
"If no match is found, and the type sought is a vector type, then the "
"largest vector type that is smaller than the sought vector type will be "
"used as a fall back. This happens because <128 x double> can be "
"implemented in terms of 64 <2 x double>, for example."
msgstr ""

#: ../../LangRef.rst:1745
msgid ""
"The function of the data layout string may not be what you expect. "
"Notably, this is not a specification from the frontend of what alignment "
"the code generator should use."
msgstr ""

#: ../../LangRef.rst:1749
msgid ""
"Instead, if specified, the target data layout is required to match what "
"the ultimate *code generator* expects. This string is used by the mid-"
"level optimizers to improve code, and this only works if it matches what "
"the ultimate code generator uses. There is no way to generate IR that "
"does not embed this target-specific detail into the IR. If you don't "
"specify the string, the default specifications will be used to generate a"
" Data Layout and the optimization phases will operate accordingly and "
"introduce target specificity into the IR with respect to these default "
"specifications."
msgstr ""

#: ../../LangRef.rst:1762
msgid "Target Triple"
msgstr ""

#: ../../LangRef.rst:1764
msgid ""
"A module may specify a target triple string that describes the target "
"host. The syntax for the target triple is simply:"
msgstr ""

#: ../../LangRef.rst:1771
msgid ""
"The *target triple* string consists of a series of identifiers delimited "
"by the minus sign character ('-'). The canonical forms are:"
msgstr ""

#: ../../LangRef.rst:1779
msgid ""
"This information is passed along to the backend so that it generates code"
" for the proper architecture. It's possible to override this on the "
"command line with the ``-mtriple`` command line option."
msgstr ""

#: ../../LangRef.rst:1786
msgid "Pointer Aliasing Rules"
msgstr ""

#: ../../LangRef.rst:1788
msgid ""
"Any memory access must be done through a pointer value associated with an"
" address range of the memory access, otherwise the behavior is undefined."
" Pointer values are associated with address ranges according to the "
"following rules:"
msgstr ""

#: ../../LangRef.rst:1793
msgid ""
"A pointer value is associated with the addresses associated with any "
"value it is *based* on."
msgstr ""

#: ../../LangRef.rst:1795
msgid ""
"An address of a global variable is associated with the address range of "
"the variable's storage."
msgstr ""

#: ../../LangRef.rst:1797
msgid ""
"The result value of an allocation instruction is associated with the "
"address range of the allocated storage."
msgstr ""

#: ../../LangRef.rst:1799
msgid "A null pointer in the default address-space is associated with no address."
msgstr ""

#: ../../LangRef.rst:1801
msgid ""
"An integer constant other than zero or a pointer value returned from a "
"function not defined within LLVM may be associated with address ranges "
"allocated through mechanisms other than those provided by LLVM. Such "
"ranges shall not overlap with any ranges of addresses allocated by "
"mechanisms provided by LLVM."
msgstr ""

#: ../../LangRef.rst:1807
msgid ""
"A pointer value is *based* on another pointer value according to the "
"following rules:"
msgstr ""

#: ../../LangRef.rst:1810
msgid ""
"A pointer value formed from a ``getelementptr`` operation is *based* on "
"the first value operand of the ``getelementptr``."
msgstr ""

#: ../../LangRef.rst:1812
msgid ""
"The result value of a ``bitcast`` is *based* on the operand of the "
"``bitcast``."
msgstr ""

#: ../../LangRef.rst:1814
msgid ""
"A pointer value formed by an ``inttoptr`` is *based* on all pointer "
"values that contribute (directly or indirectly) to the computation of the"
" pointer's value."
msgstr ""

#: ../../LangRef.rst:1817
msgid "The \"*based* on\" relationship is transitive."
msgstr ""

#: ../../LangRef.rst:1819
msgid ""
"Note that this definition of *\"based\"* is intentionally similar to the "
"definition of *\"based\"* in C99, though it is slightly weaker."
msgstr ""

#: ../../LangRef.rst:1822
msgid ""
"LLVM IR does not associate types with memory. The result type of a "
"``load`` merely indicates the size and alignment of the memory from which"
" to load, as well as the interpretation of the value. The first operand "
"type of a ``store`` similarly only indicates the size and alignment of "
"the store."
msgstr ""

#: ../../LangRef.rst:1828
msgid ""
"Consequently, type-based alias analysis, aka TBAA, aka ``-fstrict-"
"aliasing``, is not applicable to general unadorned LLVM IR. "
":ref:`Metadata <metadata>` may be used to encode additional information "
"which specialized optimization passes may use to implement type-based "
"alias analysis."
msgstr ""

#: ../../LangRef.rst:1837
msgid "Volatile Memory Accesses"
msgstr ""

#: ../../LangRef.rst:1839
msgid ""
"Certain memory accesses, such as :ref:`load <i_load>`'s, :ref:`store "
"<i_store>`'s, and :ref:`llvm.memcpy <int_memcpy>`'s may be marked "
"``volatile``. The optimizers must not change the number of volatile "
"operations or change their order of execution relative to other volatile "
"operations. The optimizers *may* change the order of volatile operations "
"relative to non-volatile operations. This is not Java's \"volatile\" and "
"has no cross-thread synchronization behavior."
msgstr ""

#: ../../LangRef.rst:1847
msgid ""
"IR-level volatile loads and stores cannot safely be optimized into "
"llvm.memcpy or llvm.memmove intrinsics even when those intrinsics are "
"flagged volatile. Likewise, the backend should never split or merge "
"target-legal volatile load/store instructions."
msgstr ""

#: ../../LangRef.rst:1852
msgid "Rationale"
msgstr ""

#: ../../LangRef.rst:1854
msgid ""
"Platforms may rely on volatile loads and stores of natively supported "
"data width to be executed as single instruction. For example, in C this "
"holds for an l-value of volatile primitive type with native hardware "
"support, but not necessarily for aggregate types. The frontend upholds "
"these expectations, which are intentionally unspecified in the IR. The "
"rules above ensure that IR transformations do not violate the frontend's "
"contract with the language."
msgstr ""

#: ../../LangRef.rst:1865
msgid "Memory Model for Concurrent Operations"
msgstr ""

#: ../../LangRef.rst:1867
msgid ""
"The LLVM IR does not define any way to start parallel threads of "
"execution or to register signal handlers. Nonetheless, there are "
"platform-specific ways to create them, and we define LLVM IR's behavior "
"in their presence. This model is inspired by the C++0x memory model."
msgstr ""

#: ../../LangRef.rst:1872
msgid "For a more informal introduction to this model, see the :doc:`Atomics`."
msgstr ""

#: ../../LangRef.rst:1874
msgid "We define a *happens-before* partial order as the least partial order that"
msgstr ""

#: ../../LangRef.rst:1877
msgid "Is a superset of single-thread program order, and"
msgstr ""

#: ../../LangRef.rst:1878
msgid ""
"When a *synchronizes-with* ``b``, includes an edge from ``a`` to ``b``. "
"*Synchronizes-with* pairs are introduced by platform-specific techniques,"
" like pthread locks, thread creation, thread joining, etc., and by atomic"
" instructions. (See also :ref:`Atomic Memory Ordering Constraints "
"<ordering>`)."
msgstr ""

#: ../../LangRef.rst:1884
msgid ""
"Note that program order does not introduce *happens-before* edges between"
" a thread and signals executing inside that thread."
msgstr ""

#: ../../LangRef.rst:1887
msgid ""
"Every (defined) read operation (load instructions, memcpy, atomic loads"
"/read-modify-writes, etc.) R reads a series of bytes written by (defined)"
" write operations (store instructions, atomic stores/read-modify-writes, "
"memcpy, etc.). For the purposes of this section, initialized globals are "
"considered to have a write of the initializer which is atomic and happens"
" before any other read or write of the memory in question. For each byte "
"of a read R, R\\ :sub:`byte` may see any write to the same byte, except:"
msgstr ""

#: ../../LangRef.rst:1896
msgid ""
"If write\\ :sub:`1`  happens before write\\ :sub:`2`, and write\\ "
":sub:`2` happens before R\\ :sub:`byte`, then R\\ :sub:`byte` does not "
"see write\\ :sub:`1`."
msgstr ""

#: ../../LangRef.rst:1899
msgid ""
"If R\\ :sub:`byte` happens before write\\ :sub:`3`, then R\\ :sub:`byte` "
"does not see write\\ :sub:`3`."
msgstr ""

#: ../../LangRef.rst:1902
msgid "Given that definition, R\\ :sub:`byte` is defined as follows:"
msgstr ""

#: ../../LangRef.rst:1904
msgid ""
"If R is volatile, the result is target-dependent. (Volatile is supposed "
"to give guarantees which can support ``sig_atomic_t`` in C/C++, and may "
"be used for accesses to addresses that do not behave like normal memory. "
"It does not generally provide cross-thread synchronization.)"
msgstr ""

#: ../../LangRef.rst:1909
msgid ""
"Otherwise, if there is no write to the same byte that happens before R\\ "
":sub:`byte`, R\\ :sub:`byte` returns ``undef`` for that byte."
msgstr ""

#: ../../LangRef.rst:1911
msgid ""
"Otherwise, if R\\ :sub:`byte` may see exactly one write, R\\ :sub:`byte` "
"returns the value written by that write."
msgstr ""

#: ../../LangRef.rst:1913
msgid ""
"Otherwise, if R is atomic, and all the writes R\\ :sub:`byte` may see are"
" atomic, it chooses one of the values written. See the :ref:`Atomic "
"Memory Ordering Constraints <ordering>` section for additional "
"constraints on how the choice is made."
msgstr ""

#: ../../LangRef.rst:1917
msgid "Otherwise R\\ :sub:`byte` returns ``undef``."
msgstr ""

#: ../../LangRef.rst:1919
msgid ""
"R returns the value composed of the series of bytes it read. This implies"
" that some bytes within the value may be ``undef`` **without** the entire"
" value being ``undef``. Note that this only defines the semantics of the "
"operation; it doesn't mean that targets will emit more than one "
"instruction to read the series of bytes."
msgstr ""

#: ../../LangRef.rst:1925
msgid ""
"Note that in cases where none of the atomic intrinsics are used, this "
"model places only one restriction on IR transformations on top of what is"
" required for single-threaded execution: introducing a store to a byte "
"which might not otherwise be stored is not allowed in general. "
"(Specifically, in the case where another thread might write to and read "
"from an address, introducing a store can change a load that may see "
"exactly one write into a load that may see multiple writes.)"
msgstr ""

#: ../../LangRef.rst:1936
msgid "Atomic Memory Ordering Constraints"
msgstr ""

#: ../../LangRef.rst:1938
msgid ""
"Atomic instructions (:ref:`cmpxchg <i_cmpxchg>`, :ref:`atomicrmw "
"<i_atomicrmw>`, :ref:`fence <i_fence>`, :ref:`atomic load <i_load>`, and "
":ref:`atomic store <i_store>`) take ordering parameters that determine "
"which other atomic instructions on the same address they *synchronize "
"with*. These semantics are borrowed from Java and C++0x, but are somewhat"
" more colloquial. If these descriptions aren't precise enough, check "
"those specs (see spec references in the :doc:`atomics guide <Atomics>`). "
":ref:`fence <i_fence>` instructions treat these orderings somewhat "
"differently since they don't take an address. See that instruction's "
"documentation for details."
msgstr ""

#: ../../LangRef.rst:1950
msgid ""
"For a simpler introduction to the ordering constraints, see the "
":doc:`Atomics`."
msgstr ""

#: ../../LangRef.rst:1958
msgid "``unordered``"
msgstr ""

#: ../../LangRef.rst:1954
msgid ""
"The set of values that can be read is governed by the happens-before "
"partial order. A value cannot be read unless some operation wrote it. "
"This is intended to provide a guarantee strong enough to model Java's "
"non-volatile shared variables. This ordering cannot be specified for "
"read-modify-write operations; it is not strong enough to make them atomic"
" in any interesting way."
msgstr ""

#: ../../LangRef.rst:1976
msgid "``monotonic``"
msgstr ""

#: ../../LangRef.rst:1961
msgid ""
"In addition to the guarantees of ``unordered``, there is a single total "
"order for modifications by ``monotonic`` operations on each address. All "
"modification orders must be compatible with the happens-before order. "
"There is no guarantee that the modification orders can be combined to a "
"global total order for the whole program (and this often will not be "
"possible). The read in an atomic read-modify-write operation "
"(:ref:`cmpxchg <i_cmpxchg>` and :ref:`atomicrmw <i_atomicrmw>`) reads the"
" value in the modification order immediately before the value it writes. "
"If one atomic read happens before another atomic read of the same "
"address, the later read must see the same value or a later value in the "
"address's modification order. This disallows reordering of ``monotonic`` "
"(or stronger) operations on the same address. If an address is written "
"``monotonic``-ally by one thread, and other threads ``monotonic``-ally "
"read that address repeatedly, the other threads must eventually see the "
"write. This corresponds to the C++0x/C1x ``memory_order_relaxed``."
msgstr ""

#: ../../LangRef.rst:1980
msgid "``acquire``"
msgstr ""

#: ../../LangRef.rst:1979
msgid ""
"In addition to the guarantees of ``monotonic``, a *synchronizes-with* "
"edge may be formed with a ``release`` operation. This is intended to "
"model C++'s ``memory_order_acquire``."
msgstr ""

#: ../../LangRef.rst:1987
msgid "``release``"
msgstr ""

#: ../../LangRef.rst:1983
msgid ""
"In addition to the guarantees of ``monotonic``, if this operation writes "
"a value which is subsequently read by an ``acquire`` operation, it "
"*synchronizes-with* that operation. (This isn't a complete description; "
"see the C++0x definition of a release sequence.) This corresponds to the "
"C++0x/C1x ``memory_order_release``."
msgstr ""

#: ../../LangRef.rst:1990
msgid "``acq_rel`` (acquire+release)"
msgstr ""

#: ../../LangRef.rst:1990
msgid ""
"Acts as both an ``acquire`` and ``release`` operation on its address. "
"This corresponds to the C++0x/C1x ``memory_order_acq_rel``."
msgstr ""

#: ../../LangRef.rst:2001
msgid "``seq_cst`` (sequentially consistent)"
msgstr ""

#: ../../LangRef.rst:1993
msgid ""
"In addition to the guarantees of ``acq_rel`` (``acquire`` for an "
"operation that only reads, ``release`` for an operation that only "
"writes), there is a global total order on all sequentially-consistent "
"operations on all addresses, which is consistent with the *happens-"
"before* partial order and with the modification orders of all the "
"affected addresses. Each sequentially-consistent read sees the last "
"preceding write to the same address in this global order. This "
"corresponds to the C++0x/C1x ``memory_order_seq_cst`` and Java volatile."
msgstr ""

#: ../../LangRef.rst:2005
msgid ""
"If an atomic operation is marked ``singlethread``, it only *synchronizes "
"with* or participates in modification and seq\\_cst total orderings with "
"other operations running in the same thread (for example, in signal "
"handlers)."
msgstr ""

#: ../../LangRef.rst:2013
msgid "Fast-Math Flags"
msgstr ""

#: ../../LangRef.rst:2015
msgid ""
"LLVM IR floating-point binary ops (:ref:`fadd <i_fadd>`, :ref:`fsub "
"<i_fsub>`, :ref:`fmul <i_fmul>`, :ref:`fdiv <i_fdiv>`, :ref:`frem "
"<i_frem>`, :ref:`fcmp <i_fcmp>`) have the following flags that can be set"
" to enable otherwise unsafe floating point operations"
msgstr ""

#: ../../LangRef.rst:2023
msgid "``nnan``"
msgstr ""

#: ../../LangRef.rst:2021
msgid ""
"No NaNs - Allow optimizations to assume the arguments and result are not "
"NaN. Such optimizations are required to retain defined behavior over "
"NaNs, but the value of the result is undefined."
msgstr ""

#: ../../LangRef.rst:2028
msgid "``ninf``"
msgstr ""

#: ../../LangRef.rst:2026
msgid ""
"No Infs - Allow optimizations to assume the arguments and result are not "
"+/-Inf. Such optimizations are required to retain defined behavior over "
"+/-Inf, but the value of the result is undefined."
msgstr ""

#: ../../LangRef.rst:2032
msgid "``nsz``"
msgstr ""

#: ../../LangRef.rst:2031
msgid ""
"No Signed Zeros - Allow optimizations to treat the sign of a zero "
"argument or result as insignificant."
msgstr ""

#: ../../LangRef.rst:2036
msgid "``arcp``"
msgstr ""

#: ../../LangRef.rst:2035
msgid ""
"Allow Reciprocal - Allow optimizations to use the reciprocal of an "
"argument rather than perform division."
msgstr ""

#: ../../LangRef.rst:2041
msgid "``fast``"
msgstr ""

#: ../../LangRef.rst:2039
msgid ""
"Fast - Allow algebraically equivalent transformations that may "
"dramatically change results in floating point (e.g. reassociate). This "
"flag implies all the others."
msgstr ""

#: ../../LangRef.rst:2046
msgid "Use-list Order Directives"
msgstr ""

#: ../../LangRef.rst:2048
msgid ""
"Use-list directives encode the in-memory order of each use-list, allowing"
" the order to be recreated. ``<order-indexes>`` is a comma-separated list"
" of indexes that are assigned to the referenced value's uses. The "
"referenced value's use-list is immediately sorted by these indexes."
msgstr ""

#: ../../LangRef.rst:2053
msgid ""
"Use-list directives may appear at function scope or global scope. They "
"are not instructions, and have no effect on the semantics of the IR. When"
" they're at function scope, they must appear after the terminator of the "
"final basic block."
msgstr ""

#: ../../LangRef.rst:2057
msgid ""
"If basic blocks have their address taken via ``blockaddress()`` "
"expressions, ``uselistorder_bb`` can be used to reorder their use-lists "
"from outside their function's scope."
msgstr ""

#: ../../LangRef.rst:2092
msgid "Type System"
msgstr ""

#: ../../LangRef.rst:2094
msgid ""
"The LLVM type system is one of the most important features of the "
"intermediate representation. Being typed enables a number of "
"optimizations to be performed on the intermediate representation "
"directly, without having to do extra analyses on the side before the "
"transformation. A strong type system makes it easier to read the "
"generated code and enables novel analyses and transformations that are "
"not feasible to perform on normal three address code representations."
msgstr ""

#: ../../LangRef.rst:2105
msgid "Void Type"
msgstr ""

#: ../../LangRef.rst:2110
msgid "The void type does not represent any value and has no size."
msgstr ""

#: ../../LangRef.rst:2123
msgid "Function Type"
msgstr ""

#: ../../LangRef.rst:2128
msgid ""
"The function type can be thought of as a function signature. It consists "
"of a return type and a list of formal parameter types. The return type of"
" a function type is a void type or first class type --- except for "
":ref:`label <t_label>` and :ref:`metadata <t_metadata>` types."
msgstr ""

#: ../../LangRef.rst:2139
msgid ""
"...where '``<parameter list>``' is a comma-separated list of type "
"specifiers. Optionally, the parameter list may include a type ``...``, "
"which indicates that the function takes a variable number of arguments. "
"Variable argument functions can access their arguments with the "
":ref:`variable argument handling intrinsic <int_varargs>` functions. "
"'``<returntype>``' is any type except :ref:`label <t_label>` and "
":ref:`metadata <t_metadata>`."
msgstr ""

#: ../../LangRef.rst:2149
msgid "``i32 (i32)``"
msgstr ""

#: ../../LangRef.rst:2149
msgid "function taking an ``i32``, returning an ``i32``"
msgstr ""

#: ../../LangRef.rst:2151
msgid "``float (i16, i32 *) *``"
msgstr ""

#: ../../LangRef.rst:2151
msgid ""
":ref:`Pointer <t_pointer>` to a function that takes an ``i16`` and a "
":ref:`pointer <t_pointer>` to ``i32``, returning ``float``."
msgstr ""

#: ../../LangRef.rst:2153
msgid "``i32 (i8*, ...)``"
msgstr ""

#: ../../LangRef.rst:2153
msgid ""
"A vararg function that takes at least one :ref:`pointer <t_pointer>` to "
"``i8`` (char in C), which returns an integer. This is the signature for "
"``printf`` in LLVM."
msgstr ""

#: ../../LangRef.rst:2155
msgid "``{i32, i32} (i32)``"
msgstr ""

#: ../../LangRef.rst:2155
msgid ""
"A function taking an ``i32``, returning a :ref:`structure <t_struct>` "
"containing two ``i32`` values"
msgstr ""

#: ../../LangRef.rst:2161
msgid "First Class Types"
msgstr ""

#: ../../LangRef.rst:2163
msgid ""
"The :ref:`first class <t_firstclass>` types are perhaps the most "
"important. Values of these types are the only ones which can be produced "
"by instructions."
msgstr ""

#: ../../LangRef.rst:2170
msgid "Single Value Types"
msgstr ""

#: ../../LangRef.rst:2172
msgid ""
"These are the types that are valid in registers from CodeGen's "
"perspective."
msgstr ""

#: ../../LangRef.rst:2177
msgid "Integer Type"
msgstr ""

#: ../../LangRef.rst:2181
msgid ""
"The integer type is a very simple type that simply specifies an arbitrary"
" bit width for the integer type desired. Any bit width from 1 bit to 2\\ "
":sup:`23`\\ -1 (about 8 million) can be specified."
msgstr ""

#: ../../LangRef.rst:2191
msgid ""
"The number of bits the integer will occupy is specified by the ``N`` "
"value."
msgstr ""

#: ../../LangRef.rst:2195 ../../LangRef.rst:4361 ../../LangRef.rst:4644
#: ../../LangRef.rst:6877 ../../LangRef.rst:10686 ../../LangRef.rst:10735
#: ../../LangRef.rst:10785 ../../LangRef.rst:10835 ../../LangRef.rst:10885
#: ../../LangRef.rst:10935 ../../LangRef.rst:11059 ../../LangRef.rst:11114
#: ../../LangRef.rst:11156
msgid "Examples:"
msgstr ""

#: ../../LangRef.rst:2198
msgid "``i1``"
msgstr ""

#: ../../LangRef.rst:2198
msgid "a single-bit integer."
msgstr ""

#: ../../LangRef.rst:2200
msgid "``i32``"
msgstr ""

#: ../../LangRef.rst:2200
msgid "a 32-bit integer."
msgstr ""

#: ../../LangRef.rst:2202
msgid "``i1942652``"
msgstr ""

#: ../../LangRef.rst:2202
msgid "a really big integer of over 1 million bits."
msgstr ""

#: ../../LangRef.rst:2208
msgid "Floating Point Types"
msgstr ""

#: ../../LangRef.rst:2213
msgid "Type"
msgstr ""

#: ../../LangRef.rst:2214
msgid "Description"
msgstr ""

#: ../../LangRef.rst:2216
msgid "``half``"
msgstr ""

#: ../../LangRef.rst:2217
msgid "16-bit floating point value"
msgstr ""

#: ../../LangRef.rst:2219
msgid "``float``"
msgstr ""

#: ../../LangRef.rst:2220
msgid "32-bit floating point value"
msgstr ""

#: ../../LangRef.rst:2222
msgid "``double``"
msgstr ""

#: ../../LangRef.rst:2223
msgid "64-bit floating point value"
msgstr ""

#: ../../LangRef.rst:2225
msgid "``fp128``"
msgstr ""

#: ../../LangRef.rst:2226
msgid "128-bit floating point value (112-bit mantissa)"
msgstr ""

#: ../../LangRef.rst:2228
msgid "``x86_fp80``"
msgstr ""

#: ../../LangRef.rst:2229
msgid "80-bit floating point value (X87)"
msgstr ""

#: ../../LangRef.rst:2231
msgid "``ppc_fp128``"
msgstr ""

#: ../../LangRef.rst:2232
msgid "128-bit floating point value (two 64-bits)"
msgstr ""

#: ../../LangRef.rst:2235
msgid "X86_mmx Type"
msgstr ""

#: ../../LangRef.rst:2239
msgid ""
"The x86_mmx type represents a value held in an MMX register on an x86 "
"machine. The operations allowed on it are quite limited: parameters and "
"return values, load and store, and bitcast. User-specified MMX "
"instructions are represented as intrinsic or asm calls with arguments "
"and/or results of this type. There are no arrays, vectors or constants of"
" this type."
msgstr ""

#: ../../LangRef.rst:2256
msgid "Pointer Type"
msgstr ""

#: ../../LangRef.rst:2260
msgid ""
"The pointer type is used to specify memory locations. Pointers are "
"commonly used to reference objects in memory."
msgstr ""

#: ../../LangRef.rst:2263
msgid ""
"Pointer types may have an optional address space attribute defining the "
"numbered address space where the pointed-to object resides. The default "
"address space is number zero. The semantics of non-zero address spaces "
"are target-specific."
msgstr ""

#: ../../LangRef.rst:2268
msgid ""
"Note that LLVM does not permit pointers to void (``void*``) nor does it "
"permit pointers to labels (``label*``). Use ``i8*`` instead."
msgstr ""

#: ../../LangRef.rst:2280
msgid "``[4 x i32]*``"
msgstr ""

#: ../../LangRef.rst:2280
msgid ""
"A :ref:`pointer <t_pointer>` to :ref:`array <t_array>` of four ``i32`` "
"values."
msgstr ""

#: ../../LangRef.rst:2282
msgid "``i32 (i32*) *``"
msgstr ""

#: ../../LangRef.rst:2282
msgid ""
"A :ref:`pointer <t_pointer>` to a :ref:`function <t_function>` that takes"
" an ``i32*``, returning an ``i32``."
msgstr ""

#: ../../LangRef.rst:2284
msgid "``i32 addrspace(5)*``"
msgstr ""

#: ../../LangRef.rst:2284
msgid ""
"A :ref:`pointer <t_pointer>` to an ``i32`` value that resides in address "
"space #5."
msgstr ""

#: ../../LangRef.rst:2290
msgid "Vector Type"
msgstr ""

#: ../../LangRef.rst:2294
msgid ""
"A vector type is a simple derived type that represents a vector of "
"elements. Vector types are used when multiple primitive data are operated"
" in parallel using a single instruction (SIMD). A vector type requires a "
"size (number of elements) and an underlying primitive data type. Vector "
"types are considered :ref:`first class <t_firstclass>`."
msgstr ""

#: ../../LangRef.rst:2306
msgid ""
"The number of elements is a constant integer value larger than 0; "
"elementtype may be any integer, floating point or pointer type. Vectors "
"of size zero are not allowed."
msgstr ""

#: ../../LangRef.rst:2313
msgid "``<4 x i32>``"
msgstr ""

#: ../../LangRef.rst:2313
msgid "Vector of 4 32-bit integer values."
msgstr ""

#: ../../LangRef.rst:2315
msgid "``<8 x float>``"
msgstr ""

#: ../../LangRef.rst:2315
msgid "Vector of 8 32-bit floating-point values."
msgstr ""

#: ../../LangRef.rst:2317
msgid "``<2 x i64>``"
msgstr ""

#: ../../LangRef.rst:2317
msgid "Vector of 2 64-bit integer values."
msgstr ""

#: ../../LangRef.rst:2319
msgid "``<4 x i64*>``"
msgstr ""

#: ../../LangRef.rst:2319
msgid "Vector of 4 pointers to 64-bit integer values."
msgstr ""

#: ../../LangRef.rst:2325
msgid "Label Type"
msgstr ""

#: ../../LangRef.rst:2329
msgid "The label type represents code labels."
msgstr ""

#: ../../LangRef.rst:2340
msgid "Token Type"
msgstr ""

#: ../../LangRef.rst:2344
msgid ""
"The token type is used when a value is associated with an instruction but"
" all uses of the value must not attempt to introspect or obscure it. As "
"such, it is not appropriate to have a :ref:`phi <i_phi>` or :ref:`select "
"<i_select>` of type token."
msgstr ""

#: ../../LangRef.rst:2360
msgid "Metadata Type"
msgstr ""

#: ../../LangRef.rst:2364
msgid ""
"The metadata type represents embedded metadata. No derived types may be "
"created from metadata except for :ref:`function <t_function>` arguments."
msgstr ""

#: ../../LangRef.rst:2376
msgid "Aggregate Types"
msgstr ""

#: ../../LangRef.rst:2378
msgid ""
"Aggregate Types are a subset of derived types that can contain multiple "
"member types. :ref:`Arrays <t_array>` and :ref:`structs <t_struct>` are "
"aggregate types. :ref:`Vectors <t_vector>` are not considered to be "
"aggregate types."
msgstr ""

#: ../../LangRef.rst:2386
msgid "Array Type"
msgstr ""

#: ../../LangRef.rst:2390
msgid ""
"The array type is a very simple derived type that arranges elements "
"sequentially in memory. The array type requires a size (number of "
"elements) and an underlying data type."
msgstr ""

#: ../../LangRef.rst:2400
msgid ""
"The number of elements is a constant integer value; ``elementtype`` may "
"be any type with a size."
msgstr ""

#: ../../LangRef.rst:2406
msgid "``[40 x i32]``"
msgstr ""

#: ../../LangRef.rst:2406
msgid "Array of 40 32-bit integer values."
msgstr ""

#: ../../LangRef.rst:2408
msgid "``[41 x i32]``"
msgstr ""

#: ../../LangRef.rst:2408
msgid "Array of 41 32-bit integer values."
msgstr ""

#: ../../LangRef.rst:2410
msgid "``[4 x i8]``"
msgstr ""

#: ../../LangRef.rst:2410
msgid "Array of 4 8-bit integer values."
msgstr ""

#: ../../LangRef.rst:2413
msgid "Here are some examples of multidimensional arrays:"
msgstr ""

#: ../../LangRef.rst:2416
msgid "``[3 x [4 x i32]]``"
msgstr ""

#: ../../LangRef.rst:2416
msgid "3x4 array of 32-bit integer values."
msgstr ""

#: ../../LangRef.rst:2418
msgid "``[12 x [10 x float]]``"
msgstr ""

#: ../../LangRef.rst:2418
msgid "12x10 array of single precision floating point values."
msgstr ""

#: ../../LangRef.rst:2420
msgid "``[2 x [3 x [4 x i16]]]``"
msgstr ""

#: ../../LangRef.rst:2420
msgid "2x3x4 array of 16-bit integer values."
msgstr ""

#: ../../LangRef.rst:2423
msgid ""
"There is no restriction on indexing beyond the end of the array implied "
"by a static type (though there are restrictions on indexing beyond the "
"bounds of an allocated object in some cases). This means that single-"
"dimension 'variable sized array' addressing can be implemented in LLVM "
"with a zero length array type. An implementation of 'pascal style arrays'"
" in LLVM could use the type \"``{ i32, [0 x float]}``\", for example."
msgstr ""

#: ../../LangRef.rst:2434
msgid "Structure Type"
msgstr ""

#: ../../LangRef.rst:2438
msgid ""
"The structure type is used to represent a collection of data members "
"together in memory. The elements of a structure may be any type that has "
"a size."
msgstr ""

#: ../../LangRef.rst:2442
msgid ""
"Structures in memory are accessed using '``load``' and '``store``' by "
"getting a pointer to a field with the '``getelementptr``' instruction. "
"Structures in registers are accessed using the '``extractvalue``' and "
"'``insertvalue``' instructions."
msgstr ""

#: ../../LangRef.rst:2447
msgid ""
"Structures may optionally be \"packed\" structures, which indicate that "
"the alignment of the struct is one byte, and that there is no padding "
"between the elements. In non-packed structs, padding between field types "
"is inserted as defined by the DataLayout string in the module, which is "
"required to match what the underlying code generator expects."
msgstr ""

#: ../../LangRef.rst:2453
msgid ""
"Structures can either be \"literal\" or \"identified\". A literal "
"structure is defined inline with other types (e.g. ``{i32, i32}*``) "
"whereas identified types are always defined at the top level with a name."
" Literal types are uniqued by their contents and can never be recursive "
"or opaque since there is no way to write one. Identified types can be "
"recursive, can be opaqued, and are never uniqued."
msgstr ""

#: ../../LangRef.rst:2470
msgid "``{ i32, i32, i32 }``"
msgstr ""

#: ../../LangRef.rst:2470
msgid "A triple of three ``i32`` values"
msgstr ""

#: ../../LangRef.rst:2472
msgid "``{ float, i32 (i32) * }``"
msgstr ""

#: ../../LangRef.rst:2472
msgid ""
"A pair, where the first element is a ``float`` and the second element is "
"a :ref:`pointer <t_pointer>` to a :ref:`function <t_function>` that takes"
" an ``i32``, returning an ``i32``."
msgstr ""

#: ../../LangRef.rst:2474
msgid "``<{ i8, i32 }>``"
msgstr ""

#: ../../LangRef.rst:2474
msgid "A packed struct known to be 5 bytes in size."
msgstr ""

#: ../../LangRef.rst:2480
msgid "Opaque Structure Types"
msgstr ""

#: ../../LangRef.rst:2484
msgid ""
"Opaque structure types are used to represent named structure types that "
"do not have a body specified. This corresponds (for example) to the C "
"notion of a forward declared structure."
msgstr ""

#: ../../LangRef.rst:2498
msgid "``opaque``"
msgstr ""

#: ../../LangRef.rst:2498
msgid "An opaque type."
msgstr ""

#: ../../LangRef.rst:2504
msgid "Constants"
msgstr ""

#: ../../LangRef.rst:2506
msgid ""
"LLVM has several different basic types of constants. This section "
"describes them all and their syntax."
msgstr ""

#: ../../LangRef.rst:2510
msgid "Simple Constants"
msgstr ""

#: ../../LangRef.rst:2513
msgid "**Boolean constants**"
msgstr ""

#: ../../LangRef.rst:2513
msgid ""
"The two strings '``true``' and '``false``' are both valid constants of "
"the ``i1`` type."
msgstr ""

#: ../../LangRef.rst:2517
msgid "**Integer constants**"
msgstr ""

#: ../../LangRef.rst:2516
msgid ""
"Standard integers (such as '4') are constants of the :ref:`integer "
"<t_integer>` type. Negative numbers may be used with integer types."
msgstr ""

#: ../../LangRef.rst:2525
msgid "**Floating point constants**"
msgstr ""

#: ../../LangRef.rst:2520
msgid ""
"Floating point constants use standard decimal notation (e.g. 123.421), "
"exponential notation (e.g. 1.23421e+2), or a more precise hexadecimal "
"notation (see below). The assembler requires the exact decimal value of a"
" floating-point constant. For example, the assembler accepts 1.25 but "
"rejects 1.3 because 1.3 is a repeating decimal in binary. Floating point "
"constants must have a :ref:`floating point <t_floating>` type."
msgstr ""

#: ../../LangRef.rst:2528
msgid "**Null pointer constants**"
msgstr ""

#: ../../LangRef.rst:2528
msgid ""
"The identifier '``null``' is recognized as a null pointer constant and "
"must be of :ref:`pointer type <t_pointer>`."
msgstr ""

#: ../../LangRef.rst:2532
msgid "**Token constants**"
msgstr ""

#: ../../LangRef.rst:2531
msgid ""
"The identifier '``none``' is recognized as an empty token constant and "
"must be of :ref:`token type <t_token>`."
msgstr ""

#: ../../LangRef.rst:2534
msgid ""
"The one non-intuitive notation for constants is the hexadecimal form of "
"floating point constants. For example, the form '``double    "
"0x432ff973cafa8000``' is equivalent to (but harder to read than) "
"'``double 4.5e+15``'. The only time hexadecimal floating point constants "
"are required (and the only time that they are generated by the "
"disassembler) is when a floating point constant must be emitted but it "
"cannot be represented as a decimal floating point number in a reasonable "
"number of digits. For example, NaN's, infinities, and other special "
"values are represented in their IEEE hexadecimal format so that assembly "
"and disassembly do not cause any bits to change in the constants."
msgstr ""

#: ../../LangRef.rst:2545
msgid ""
"When using the hexadecimal form, constants of types half, float, and "
"double are represented using the 16-digit form shown above (which matches"
" the IEEE754 representation for double); half and float values must, "
"however, be exactly representable as IEEE 754 half and single precision, "
"respectively. Hexadecimal format is always used for long double, and "
"there are three forms of long double. The 80-bit format used by x86 is "
"represented as ``0xK`` followed by 20 hexadecimal digits. The 128-bit "
"format used by PowerPC (two adjacent doubles) is represented by ``0xM`` "
"followed by 32 hexadecimal digits. The IEEE 128-bit format is represented"
" by ``0xL`` followed by 32 hexadecimal digits. Long doubles will only "
"work if they match the long double format on your target. The IEEE 16-bit"
" format (half precision) is represented by ``0xH`` followed by 4 "
"hexadecimal digits. All hexadecimal formats are big-endian (sign bit at "
"the left)."
msgstr ""

#: ../../LangRef.rst:2560
msgid "There are no constants of type x86_mmx."
msgstr ""

#: ../../LangRef.rst:2565
msgid "Complex Constants"
msgstr ""

#: ../../LangRef.rst:2567
msgid ""
"Complex constants are a (potentially recursive) combination of simple "
"constants and smaller complex constants."
msgstr ""

#: ../../LangRef.rst:2576
msgid "**Structure constants**"
msgstr ""

#: ../../LangRef.rst:2571
msgid ""
"Structure constants are represented with notation similar to structure "
"type definitions (a comma separated list of elements, surrounded by "
"braces (``{}``)). For example: \"``{ i32 4, float 17.0, i32* @G }``\", "
"where \"``@G``\" is declared as \"``@G = external global i32``\". "
"Structure constants must have :ref:`structure type <t_struct>`, and the "
"number and types of elements must match those specified by the type."
msgstr ""

#: ../../LangRef.rst:2585
msgid "**Array constants**"
msgstr ""

#: ../../LangRef.rst:2579
msgid ""
"Array constants are represented with notation similar to array type "
"definitions (a comma separated list of elements, surrounded by square "
"brackets (``[]``)). For example: \"``[ i32 42, i32 11, i32 74 ]``\". "
"Array constants must have :ref:`array type <t_array>`, and the number and"
" types of elements must match those specified by the type. As a special "
"case, character array constants may also be represented as a double-"
"quoted string using the ``c`` prefix. For example: \"``c\"Hello "
"World\\0A\\00\"``\"."
msgstr ""

#: ../../LangRef.rst:2592
msgid "**Vector constants**"
msgstr ""

#: ../../LangRef.rst:2588
msgid ""
"Vector constants are represented with notation similar to vector type "
"definitions (a comma separated list of elements, surrounded by less-than"
"/greater-than's (``<>``)). For example: \"``< i32 42, i32 11, i32 74, i32"
" 100 >``\". Vector constants must have :ref:`vector type <t_vector>`, and"
" the number and types of elements must match those specified by the type."
msgstr ""

#: ../../LangRef.rst:2598
msgid "**Zero initialization**"
msgstr ""

#: ../../LangRef.rst:2595
msgid ""
"The string '``zeroinitializer``' can be used to zero initialize a value "
"to zero of *any* type, including scalar and :ref:`aggregate "
"<t_aggregate>` types. This is often used to avoid having to print large "
"zero initializers (e.g. for large arrays) and is always exactly "
"equivalent to using explicit zero initializers."
msgstr ""

#: ../../LangRef.rst:2606
msgid "**Metadata node**"
msgstr ""

#: ../../LangRef.rst:2601
msgid ""
"A metadata node is a constant tuple without types. For example: \"``!{!0,"
" !{!2, !0}, !\"test\"}``\". Metadata can reference constant values, for "
"example: \"``!{!0, i32 0, i8* @global, i64 (i64)* @function, "
"!\"str\"}``\". Unlike other typed constants that are meant to be "
"interpreted as part of the instruction stream, metadata is a place to "
"attach additional information such as debug info."
msgstr ""

#: ../../LangRef.rst:2609
msgid "Global Variable and Function Addresses"
msgstr ""

#: ../../LangRef.rst:2611
msgid ""
"The addresses of :ref:`global variables <globalvars>` and :ref:`functions"
" <functionstructure>` are always implicitly valid (link-time) constants. "
"These constants are explicitly referenced when the :ref:`identifier for "
"the global <identifiers>` is used and always have :ref:`pointer "
"<t_pointer>` type. For example, the following is a legal LLVM file:"
msgstr ""

#: ../../LangRef.rst:2627
msgid "Undefined Values"
msgstr ""

#: ../../LangRef.rst:2629
msgid ""
"The string '``undef``' can be used anywhere a constant is expected, and "
"indicates that the user of the value may receive an unspecified bit-"
"pattern. Undefined values may be of any type (other than '``label``' or "
"'``void``') and be used anywhere a constant is permitted."
msgstr ""

#: ../../LangRef.rst:2634
msgid ""
"Undefined values are useful because they indicate to the compiler that "
"the program is well defined no matter what value is used. This gives the "
"compiler more freedom to optimize. Here are some examples of (potentially"
" surprising) transformations that are valid (in pseudo IR):"
msgstr ""

#: ../../LangRef.rst:2649
msgid ""
"This is safe because all of the output bits are affected by the undef "
"bits. Any output bit can have a zero or one depending on the input bits."
msgstr ""

#: ../../LangRef.rst:2663
#, python-format
msgid ""
"These logical operations have bits that are not always affected by the "
"input. For example, if ``%X`` has a zero bit, then the output of the "
"'``and``' operation will always be a zero for that bit, no matter what "
"the corresponding bit from the '``undef``' is. As such, it is unsafe to "
"optimize or assume that the result of the '``and``' is '``undef``'. "
"However, it is safe to assume that all bits of the '``undef``' could be "
"0, and optimize the '``and``' to 0. Likewise, it is safe to assume that "
"all the bits of the '``undef``' operand to the '``or``' could be set, "
"allowing the '``or``' to be folded to -1."
msgstr ""

#: ../../LangRef.rst:2687
#, python-format
msgid ""
"This set of examples shows that undefined '``select``' (and conditional "
"branch) conditions can go *either way*, but they have to come from one of"
" the two operands. In the ``%A`` example, if ``%X`` and ``%Y`` were both "
"known to have a clear low bit, then ``%A`` would have to have a cleared "
"low bit. However, in the ``%C`` example, the optimizer is allowed to "
"assume that the '``undef``' operand could be the same as ``%Y``, allowing"
" the whole '``select``' to be eliminated."
msgstr ""

#: ../../LangRef.rst:2714
msgid ""
"This example points out that two '``undef``' operands are not necessarily"
" the same. This can be surprising to people (and also matches C "
"semantics) where they assume that \"``X^X``\" is always zero, even if "
"``X`` is undefined. This isn't true for a number of reasons, but the "
"short answer is that an '``undef``' \"variable\" can arbitrarily change "
"its value over its \"live range\". This is true because the variable "
"doesn't actually *have a live range*. Instead, the value is logically "
"read from arbitrary registers that happen to be around when needed, so "
"the value is not necessarily consistent over time. In fact, ``%A`` and "
"``%C`` need to have the same semantics or the core LLVM \"replace all "
"uses with\" concept would not hold."
msgstr ""

#: ../../LangRef.rst:2734
msgid ""
"These examples show the crucial difference between an *undefined value* "
"and *undefined behavior*. An undefined value (like '``undef``') is "
"allowed to have an arbitrary bit-pattern. This means that the ``%A`` "
"operation can be constant folded to '``undef``', because the '``undef``' "
"could be an SNaN, and ``fdiv`` is not (currently) defined on SNaN's. "
"However, in the second example, we can make a more aggressive assumption:"
" because the ``undef`` is allowed to be an arbitrary value, we are "
"allowed to assume that it could be zero. Since a divide by zero has "
"*undefined behavior*, we are allowed to assume that the operation does "
"not execute at all. This allows us to delete the divide and all code "
"after it. Because the undefined operation \"can't happen\", the optimizer"
" can assume that it occurs in dead code."
msgstr ""

#: ../../LangRef.rst:2755
msgid ""
"These examples reiterate the ``fdiv`` example: a store *of* an undefined "
"value can be assumed to not have any effect; we can assume that the value"
" is overwritten with bits that happen to match what was already there. "
"However, a store *to* an undefined location could clobber arbitrary "
"memory, therefore, it has undefined behavior."
msgstr ""

#: ../../LangRef.rst:2764
msgid "Poison Values"
msgstr ""

#: ../../LangRef.rst:2766
msgid ""
"Poison values are similar to :ref:`undef values <undefvalues>`, however "
"they also represent the fact that an instruction or constant expression "
"that cannot evoke side effects has nevertheless detected a condition that"
" results in undefined behavior."
msgstr ""

#: ../../LangRef.rst:2771
msgid ""
"There is currently no way of representing a poison value in the IR; they "
"only exist when produced by operations such as :ref:`add <i_add>` with "
"the ``nsw`` flag."
msgstr ""

#: ../../LangRef.rst:2775
msgid "Poison value behavior is defined in terms of value *dependence*:"
msgstr ""

#: ../../LangRef.rst:2777
msgid "Values other than :ref:`phi <i_phi>` nodes depend on their operands."
msgstr ""

#: ../../LangRef.rst:2778
msgid ""
":ref:`Phi <i_phi>` nodes depend on the operand corresponding to their "
"dynamic predecessor basic block."
msgstr ""

#: ../../LangRef.rst:2780
msgid ""
"Function arguments depend on the corresponding actual argument values in "
"the dynamic callers of their functions."
msgstr ""

#: ../../LangRef.rst:2782
msgid ""
":ref:`Call <i_call>` instructions depend on the :ref:`ret <i_ret>` "
"instructions that dynamically transfer control back to them."
msgstr ""

#: ../../LangRef.rst:2784
msgid ""
":ref:`Invoke <i_invoke>` instructions depend on the :ref:`ret <i_ret>`, "
":ref:`resume <i_resume>`, or exception-throwing call instructions that "
"dynamically transfer control back to them."
msgstr ""

#: ../../LangRef.rst:2787
msgid ""
"Non-volatile loads and stores depend on the most recent stores to all of "
"the referenced memory addresses, following the order in the IR (including"
" loads and stores implied by intrinsics such as :ref:`@llvm.memcpy "
"<int_memcpy>`.)"
msgstr ""

#: ../../LangRef.rst:2791
msgid ""
"An instruction with externally visible side effects depends on the most "
"recent preceding instruction with externally visible side effects, "
"following the order in the IR. (This includes :ref:`volatile operations "
"<volatile>`.)"
msgstr ""

#: ../../LangRef.rst:2795
msgid ""
"An instruction *control-depends* on a :ref:`terminator instruction "
"<terminators>` if the terminator instruction has multiple successors and "
"the instruction is always executed when control transfers to one of the "
"successors, and may not be executed when control is transferred to "
"another."
msgstr ""

#: ../../LangRef.rst:2800
msgid ""
"Additionally, an instruction also *control-depends* on a terminator "
"instruction if the set of instructions it otherwise depends on would be "
"different if the terminator had transferred control to a different "
"successor."
msgstr ""

#: ../../LangRef.rst:2804
msgid "Dependence is transitive."
msgstr ""

#: ../../LangRef.rst:2806
msgid ""
"Poison values have the same behavior as :ref:`undef values "
"<undefvalues>`, with the additional effect that any instruction that has "
"a *dependence* on a poison value has undefined behavior."
msgstr ""

#: ../../LangRef.rst:2810
msgid "Here are some examples:"
msgstr ""

#: ../../LangRef.rst:2866
msgid "Addresses of Basic Blocks"
msgstr ""

#: ../../LangRef.rst:2868
msgid "``blockaddress(@function, %block)``"
msgstr ""

#: ../../LangRef.rst:2870
msgid ""
"The '``blockaddress``' constant computes the address of the specified "
"basic block in the specified function, and always has an ``i8*`` type. "
"Taking the address of the entry block is illegal."
msgstr ""

#: ../../LangRef.rst:2874
msgid ""
"This value only has defined behavior when used as an operand to the "
"':ref:`indirectbr <i_indirectbr>`' instruction, or for comparisons "
"against null. Pointer equality tests between labels addresses results in "
"undefined behavior --- though, again, comparison against null is ok, and "
"no label is equal to the null pointer. This may be passed around as an "
"opaque pointer sized value as long as the bits are not inspected. This "
"allows ``ptrtoint`` and arithmetic to be performed on these values so "
"long as the original value is reconstituted before the ``indirectbr`` "
"instruction."
msgstr ""

#: ../../LangRef.rst:2884
msgid ""
"Finally, some targets may provide defined semantics when using the value "
"as the operand to an inline assembly, but that is target specific."
msgstr ""

#: ../../LangRef.rst:2890
msgid "Constant Expressions"
msgstr ""

#: ../../LangRef.rst:2892
msgid ""
"Constant expressions are used to allow expressions involving other "
"constants to be used as constants. Constant expressions may be of any "
":ref:`first class <t_firstclass>` type and may involve any LLVM operation"
" that does not have side effects (e.g. load and call are not supported). "
"The following is the syntax for constant expressions:"
msgstr ""

#: ../../LangRef.rst:2899
msgid "``trunc (CST to TYPE)``"
msgstr ""

#: ../../LangRef.rst:2899
msgid ""
"Truncate a constant to another type. The bit size of CST must be larger "
"than the bit size of TYPE. Both types must be integers."
msgstr ""

#: ../../LangRef.rst:2902
msgid "``zext (CST to TYPE)``"
msgstr ""

#: ../../LangRef.rst:2902
msgid ""
"Zero extend a constant to another type. The bit size of CST must be "
"smaller than the bit size of TYPE. Both types must be integers."
msgstr ""

#: ../../LangRef.rst:2905
msgid "``sext (CST to TYPE)``"
msgstr ""

#: ../../LangRef.rst:2905
msgid ""
"Sign extend a constant to another type. The bit size of CST must be "
"smaller than the bit size of TYPE. Both types must be integers."
msgstr ""

#: ../../LangRef.rst:2909
msgid "``fptrunc (CST to TYPE)``"
msgstr ""

#: ../../LangRef.rst:2908
msgid ""
"Truncate a floating point constant to another floating point type. The "
"size of CST must be larger than the size of TYPE. Both types must be "
"floating point."
msgstr ""

#: ../../LangRef.rst:2913
msgid "``fpext (CST to TYPE)``"
msgstr ""

#: ../../LangRef.rst:2912
msgid ""
"Floating point extend a constant to another type. The size of CST must be"
" smaller or equal to the size of TYPE. Both types must be floating point."
msgstr ""

#: ../../LangRef.rst:2919
msgid "``fptoui (CST to TYPE)``"
msgstr ""

#: ../../LangRef.rst:2916
msgid ""
"Convert a floating point constant to the corresponding unsigned integer "
"constant. TYPE must be a scalar or vector integer type. CST must be of "
"scalar or vector floating point type. Both CST and TYPE must be scalars, "
"or vectors of the same number of elements. If the value won't fit in the "
"integer type, the results are undefined."
msgstr ""

#: ../../LangRef.rst:2925
msgid "``fptosi (CST to TYPE)``"
msgstr ""

#: ../../LangRef.rst:2922
msgid ""
"Convert a floating point constant to the corresponding signed integer "
"constant. TYPE must be a scalar or vector integer type. CST must be of "
"scalar or vector floating point type. Both CST and TYPE must be scalars, "
"or vectors of the same number of elements. If the value won't fit in the "
"integer type, the results are undefined."
msgstr ""

#: ../../LangRef.rst:2931
msgid "``uitofp (CST to TYPE)``"
msgstr ""

#: ../../LangRef.rst:2928
msgid ""
"Convert an unsigned integer constant to the corresponding floating point "
"constant. TYPE must be a scalar or vector floating point type. CST must "
"be of scalar or vector integer type. Both CST and TYPE must be scalars, "
"or vectors of the same number of elements. If the value won't fit in the "
"floating point type, the results are undefined."
msgstr ""

#: ../../LangRef.rst:2937
msgid "``sitofp (CST to TYPE)``"
msgstr ""

#: ../../LangRef.rst:2934
msgid ""
"Convert a signed integer constant to the corresponding floating point "
"constant. TYPE must be a scalar or vector floating point type. CST must "
"be of scalar or vector integer type. Both CST and TYPE must be scalars, "
"or vectors of the same number of elements. If the value won't fit in the "
"floating point type, the results are undefined."
msgstr ""

#: ../../LangRef.rst:2942
msgid "``ptrtoint (CST to TYPE)``"
msgstr ""

#: ../../LangRef.rst:2940
msgid ""
"Convert a pointer typed constant to the corresponding integer constant. "
"``TYPE`` must be an integer type. ``CST`` must be of pointer type. The "
"``CST`` value is zero extended, truncated, or unchanged to make it fit in"
" ``TYPE``."
msgstr ""

#: ../../LangRef.rst:2947
msgid "``inttoptr (CST to TYPE)``"
msgstr ""

#: ../../LangRef.rst:2945
msgid ""
"Convert an integer constant to a pointer constant. TYPE must be a pointer"
" type. CST must be of integer type. The CST value is zero extended, "
"truncated, or unchanged to make it fit in a pointer size. This one is "
"*really* dangerous!"
msgstr ""

#: ../../LangRef.rst:2951
msgid "``bitcast (CST to TYPE)``"
msgstr ""

#: ../../LangRef.rst:2950
msgid ""
"Convert a constant, CST, to another TYPE. The constraints of the operands"
" are the same as those for the :ref:`bitcast instruction <i_bitcast>`."
msgstr ""

#: ../../LangRef.rst:2955
msgid "``addrspacecast (CST to TYPE)``"
msgstr ""

#: ../../LangRef.rst:2954
msgid ""
"Convert a constant pointer or constant vector of pointer, CST, to another"
" TYPE in a different address space. The constraints of the operands are "
"the same as those for the :ref:`addrspacecast instruction "
"<i_addrspacecast>`."
msgstr ""

#: ../../LangRef.rst:2960
msgid ""
"``getelementptr (TY, CSTPTR, IDX0, IDX1, ...)``, ``getelementptr inbounds"
" (TY, CSTPTR, IDX0, IDX1, ...)``"
msgstr ""

#: ../../LangRef.rst:2958
msgid ""
"Perform the :ref:`getelementptr operation <i_getelementptr>` on "
"constants. As with the :ref:`getelementptr <i_getelementptr>` "
"instruction, the index list may have zero or more indexes, which are "
"required to make sense for the type of \"pointer to TY\"."
msgstr ""

#: ../../LangRef.rst:2962
msgid "``select (COND, VAL1, VAL2)``"
msgstr ""

#: ../../LangRef.rst:2963
msgid "Perform the :ref:`select operation <i_select>` on constants."
msgstr ""

#: ../../LangRef.rst:2964
msgid "``icmp COND (VAL1, VAL2)``"
msgstr ""

#: ../../LangRef.rst:2965
msgid "Performs the :ref:`icmp operation <i_icmp>` on constants."
msgstr ""

#: ../../LangRef.rst:2966
msgid "``fcmp COND (VAL1, VAL2)``"
msgstr ""

#: ../../LangRef.rst:2967
msgid "Performs the :ref:`fcmp operation <i_fcmp>` on constants."
msgstr ""

#: ../../LangRef.rst:2969
msgid "``extractelement (VAL, IDX)``"
msgstr ""

#: ../../LangRef.rst:2969
msgid ""
"Perform the :ref:`extractelement operation <i_extractelement>` on "
"constants."
msgstr ""

#: ../../LangRef.rst:2972
msgid "``insertelement (VAL, ELT, IDX)``"
msgstr ""

#: ../../LangRef.rst:2972
msgid "Perform the :ref:`insertelement operation <i_insertelement>` on constants."
msgstr ""

#: ../../LangRef.rst:2975
msgid "``shufflevector (VEC1, VEC2, IDXMASK)``"
msgstr ""

#: ../../LangRef.rst:2975
msgid "Perform the :ref:`shufflevector operation <i_shufflevector>` on constants."
msgstr ""

#: ../../LangRef.rst:2980
msgid "``extractvalue (VAL, IDX0, IDX1, ...)``"
msgstr ""

#: ../../LangRef.rst:2978
msgid ""
"Perform the :ref:`extractvalue operation <i_extractvalue>` on constants. "
"The index list is interpreted in a similar manner as indices in a "
"':ref:`getelementptr <i_getelementptr>`' operation. At least one index "
"value must be specified."
msgstr ""

#: ../../LangRef.rst:2985
msgid "``insertvalue (VAL, ELT, IDX0, IDX1, ...)``"
msgstr ""

#: ../../LangRef.rst:2983
msgid ""
"Perform the :ref:`insertvalue operation <i_insertvalue>` on constants. "
"The index list is interpreted in a similar manner as indices in a "
"':ref:`getelementptr <i_getelementptr>`' operation. At least one index "
"value must be specified."
msgstr ""

#: ../../LangRef.rst:2992
msgid "``OPCODE (LHS, RHS)``"
msgstr ""

#: ../../LangRef.rst:2988
msgid ""
"Perform the specified operation of the LHS and RHS constants. OPCODE may "
"be any of the :ref:`binary <binaryops>` or :ref:`bitwise binary "
"<bitwiseops>` operations. The constraints on operands are the same as "
"those for the corresponding instruction (e.g. no bitwise operations on "
"floating point values are allowed)."
msgstr ""

#: ../../LangRef.rst:2995
msgid "Other Values"
msgstr ""

#: ../../LangRef.rst:3000
msgid "Inline Assembler Expressions"
msgstr ""

#: ../../LangRef.rst:3002
msgid ""
"LLVM supports inline assembler expressions (as opposed to :ref:`Module-"
"Level Inline Assembly <moduleasm>`) through the use of a special value. "
"This value represents the inline assembler as a template string "
"(containing the instructions to emit), a list of operand constraints "
"(stored as a string), a flag that indicates whether or not the inline asm"
" expression has side effects, and a flag indicating whether the function "
"containing the asm needs to align its stack conservatively."
msgstr ""

#: ../../LangRef.rst:3010
msgid ""
"The template string supports argument substitution of the operands using "
"\"``$``\" followed by a number, to indicate substitution of the given "
"register/memory location, as specified by the constraint string. "
"\"``${NUM:MODIFIER}``\" may also be used, where ``MODIFIER`` is a target-"
"specific annotation for how to print the operand (See :ref:`inline-asm-"
"modifiers`)."
msgstr ""

#: ../../LangRef.rst:3016
msgid ""
"A literal \"``$``\" may be included by using \"``$$``\" in the template. "
"To include other special characters into the output, the usual "
"\"``\\XX``\" escapes may be used, just as in other strings. Note that "
"after template substitution, the resulting assembly string is parsed by "
"LLVM's integrated assembler unless it is disabled -- even when emitting a"
" ``.s`` file -- and thus must contain assembly syntax known to LLVM."
msgstr ""

#: ../../LangRef.rst:3023
msgid ""
"LLVM's support for inline asm is modeled closely on the requirements of "
"Clang's GCC-compatible inline-asm support. Thus, the feature-set and the "
"constraint and modifier codes listed here are similar or identical to "
"those in GCC's inline asm support. However, to be clear, the syntax of "
"the template and constraint strings described here is *not* the same as "
"the syntax accepted by GCC and Clang, and, while most constraint letters "
"are passed through as-is by Clang, some get translated to other codes "
"when converting from the C source to the LLVM assembly."
msgstr ""

#: ../../LangRef.rst:3032
msgid "An example inline assembler expression is:"
msgstr ""

#: ../../LangRef.rst:3038
msgid ""
"Inline assembler expressions may **only** be used as the callee operand "
"of a :ref:`call <i_call>` or an :ref:`invoke <i_invoke>` instruction. "
"Thus, typically we have:"
msgstr ""

#: ../../LangRef.rst:3046
msgid ""
"Inline asms with side effects not visible in the constraint list must be "
"marked as having side effects. This is done through the use of the "
"'``sideeffect``' keyword, like so:"
msgstr ""

#: ../../LangRef.rst:3054
msgid ""
"In some cases inline asms will contain code that will not work unless the"
" stack is aligned in some way, such as calls or SSE instructions on x86, "
"yet will not contain code that does that alignment within the asm. The "
"compiler should make conservative assumptions about what the asm might "
"contain and should generate its usual stack alignment code in the "
"prologue if the '``alignstack``' keyword is present:"
msgstr ""

#: ../../LangRef.rst:3065
msgid ""
"Inline asms also support using non-standard assembly dialects. The "
"assumed dialect is ATT. When the '``inteldialect``' keyword is present, "
"the inline asm is using the Intel dialect. Currently, ATT and Intel are "
"the only supported dialects. An example is:"
msgstr ""

#: ../../LangRef.rst:3074
msgid ""
"If multiple keywords appear the '``sideeffect``' keyword must come first,"
" the '``alignstack``' keyword second and the '``inteldialect``' keyword "
"last."
msgstr ""

#: ../../LangRef.rst:3079
msgid "Inline Asm Constraint String"
msgstr ""

#: ../../LangRef.rst:3081
msgid ""
"The constraint list is a comma-separated string, each element containing "
"one or more constraint codes."
msgstr ""

#: ../../LangRef.rst:3084
msgid ""
"For each element in the constraint list an appropriate register or memory"
" operand will be chosen, and it will be made available to assembly "
"template string expansion as ``$0`` for the first constraint in the list,"
" ``$1`` for the second, etc."
msgstr ""

#: ../../LangRef.rst:3089
msgid ""
"There are three different types of constraints, which are distinguished "
"by a prefix symbol in front of the constraint code: Output, Input, and "
"Clobber. The constraints must always be given in that order: outputs "
"first, then inputs, then clobbers. They cannot be intermingled."
msgstr ""

#: ../../LangRef.rst:3094
msgid "There are also three different categories of constraint codes:"
msgstr ""

#: ../../LangRef.rst:3096
msgid ""
"Register constraint. This is either a register class, or a fixed physical"
" register. This kind of constraint will allocate a register, and if "
"necessary, bitcast the argument or result to the appropriate type."
msgstr ""

#: ../../LangRef.rst:3099
msgid ""
"Memory constraint. This kind of constraint is for use with an instruction"
" taking a memory operand. Different constraints allow for different "
"addressing modes used by the target."
msgstr ""

#: ../../LangRef.rst:3102
msgid ""
"Immediate value constraint. This kind of constraint is for an integer or "
"other immediate value which can be rendered directly into an instruction."
" The various target-specific constraints allow the selection of a value "
"in the proper range for the instruction you wish to use it with."
msgstr ""

#: ../../LangRef.rst:3108
msgid "Output constraints"
msgstr ""

#: ../../LangRef.rst:3110
msgid ""
"Output constraints are specified by an \"``=``\" prefix (e.g. "
"\"``=r``\"). This indicates that the assembly will write to this operand,"
" and the operand will then be made available as a return value of the "
"``asm`` expression. Output constraints do not consume an argument from "
"the call instruction. (Except, see below about indirect outputs)."
msgstr ""

#: ../../LangRef.rst:3116
msgid ""
"Normally, it is expected that no output locations are written to by the "
"assembly expression until *all* of the inputs have been read. As such, "
"LLVM may assign the same register to an output and an input. If this is "
"not safe (e.g. if the assembly contains two instructions, where the first"
" writes to one output, and the second reads an input and writes to a "
"second output), then the \"``&``\" modifier must be used (e.g. "
"\"``=&r``\") to specify that the output is an \"early-clobber\" output. "
"Marking an ouput as \"early-clobber\" ensures that LLVM will not use the "
"same register for any inputs (other than an input tied to this output)."
msgstr ""

#: ../../LangRef.rst:3127
msgid "Input constraints"
msgstr ""

#: ../../LangRef.rst:3129
msgid ""
"Input constraints do not have a prefix -- just the constraint codes. Each"
" input constraint will consume one argument from the call instruction. It"
" is not permitted for the asm to write to any input register or memory "
"location (unless that input is tied to an output). Note also that "
"multiple inputs may all be assigned to the same register, if LLVM can "
"determine that they necessarily all contain the same value."
msgstr ""

#: ../../LangRef.rst:3136
msgid ""
"Instead of providing a Constraint Code, input constraints may also "
"\"tie\" themselves to an output constraint, by providing an integer as "
"the constraint string. Tied inputs still consume an argument from the "
"call instruction, and take up a position in the asm template numbering as"
" is usual -- they will simply be constrained to always use the same "
"register as the output they've been tied to. For example, a constraint "
"string of \"``=r,0``\" says to assign a register for output, and use that"
" register as an input as well (it being the 0'th constraint)."
msgstr ""

#: ../../LangRef.rst:3145
msgid ""
"It is permitted to tie an input to an \"early-clobber\" output. In that "
"case, no *other* input may share the same register as the input tied to "
"the early-clobber (even when the other input has the same value)."
msgstr ""

#: ../../LangRef.rst:3149
msgid ""
"You may only tie an input to an output which has a register constraint, "
"not a memory constraint. Only a single input may be tied to an output."
msgstr ""

#: ../../LangRef.rst:3152
msgid ""
"There is also an \"interesting\" feature which deserves a bit of "
"explanation: if a register class constraint allocates a register which is"
" too small for the value type operand provided as input, the input value "
"will be split into multiple registers, and all of them passed to the "
"inline asm."
msgstr ""

#: ../../LangRef.rst:3157
msgid "However, this feature is often not as useful as you might think."
msgstr ""

#: ../../LangRef.rst:3159
msgid ""
"Firstly, the registers are *not* guaranteed to be consecutive. So, on "
"those architectures that have instructions which operate on multiple "
"consecutive instructions, this is not an appropriate way to support them."
" (e.g. the 32-bit SparcV8 has a 64-bit load, which instruction takes a "
"single 32-bit register. The hardware then loads into both the named "
"register, and the next register. This feature of inline asm would not be "
"useful to support that.)"
msgstr ""

#: ../../LangRef.rst:3166
msgid ""
"A few of the targets provide a template string modifier allowing explicit"
" access to the second register of a two-register operand (e.g. MIPS "
"``L``, ``M``, and ``D``). On such an architecture, you can actually "
"access the second allocated register (yet, still, not any subsequent "
"ones). But, in that case, you're still probably better off simply "
"splitting the value into two separate operands, for clarity. (e.g. see "
"the description of the ``A`` constraint on X86, which, despite existing "
"only for use with this feature, is not really a good idea to use)"
msgstr ""

#: ../../LangRef.rst:3176
msgid "Indirect inputs and outputs"
msgstr ""

#: ../../LangRef.rst:3178
msgid ""
"Indirect output or input constraints can be specified by the \"``*``\" "
"modifier (which goes after the \"``=``\" in case of an output). This "
"indicates that the asm will write to or read from the contents of an "
"*address* provided as an input argument. (Note that in this way, indirect"
" outputs act more like an *input* than an output: just like an input, "
"they consume an argument of the call expression, rather than producing a "
"return value. An indirect output constraint is an \"output\" only in that"
" the asm is expected to write to the contents of the input memory "
"location, instead of just read from it)."
msgstr ""

#: ../../LangRef.rst:3187
msgid ""
"This is most typically used for memory constraint, e.g. \"``=*m``\", to "
"pass the address of a variable as a value."
msgstr ""

#: ../../LangRef.rst:3190
msgid ""
"It is also possible to use an indirect *register* constraint, but only on"
" output (e.g. \"``=*r``\"). This will cause LLVM to allocate a register "
"for an output value normally, and then, separately emit a store to the "
"address provided as input, after the provided inline asm. (It's not clear"
" what value this functionality provides, compared to writing the store "
"explicitly after the asm statement, and it can only produce worse code, "
"since it bypasses many optimization passes. I would recommend not using "
"it.)"
msgstr ""

#: ../../LangRef.rst:3200
msgid "Clobber constraints"
msgstr ""

#: ../../LangRef.rst:3202
msgid ""
"A clobber constraint is indicated by a \"``~``\" prefix. A clobber does "
"not consume an input operand, nor generate an output. Clobbers cannot use"
" any of the general constraint code letters -- they may use only explicit"
" register constraints, e.g. \"``~{eax}``\". The one exception is that a "
"clobber string of \"``~{memory}``\" indicates that the assembly writes to"
" arbitrary undeclared memory locations -- not only the memory pointed to "
"by a declared indirect output."
msgstr ""

#: ../../LangRef.rst:3212
msgid "Constraint Codes"
msgstr ""

#: ../../LangRef.rst:3213
msgid "After a potential prefix comes constraint code, or codes."
msgstr ""

#: ../../LangRef.rst:3215
msgid ""
"A Constraint Code is either a single letter (e.g. \"``r``\"), a \"``^``\""
" character followed by two letters (e.g. \"``^wc``\"), or \"``{``\" "
"register-name \"``}``\" (e.g. \"``{eax}``\")."
msgstr ""

#: ../../LangRef.rst:3219
msgid ""
"The one and two letter constraint codes are typically chosen to be the "
"same as GCC's constraint codes."
msgstr ""

#: ../../LangRef.rst:3222
msgid ""
"A single constraint may include one or more than constraint code in it, "
"leaving it up to LLVM to choose which one to use. This is included mainly"
" for compatibility with the translation of GCC inline asm coming from "
"clang."
msgstr ""

#: ../../LangRef.rst:3226
msgid ""
"There are two ways to specify alternatives, and either or both may be "
"used in an inline asm constraint list:"
msgstr ""

#: ../../LangRef.rst:3229
msgid ""
"Append the codes to each other, making a constraint code set. E.g. "
"\"``im``\" or \"``{eax}m``\". This means \"choose any of the options in "
"the set\". The choice of constraint is made independently for each "
"constraint in the constraint list."
msgstr ""

#: ../../LangRef.rst:3234
msgid ""
"Use \"``|``\" between constraint code sets, creating alternatives. Every "
"constraint in the constraint list must have the same number of "
"alternative sets. With this syntax, the same alternative in *all* of the "
"items in the constraint list will be chosen together."
msgstr ""

#: ../../LangRef.rst:3239
msgid ""
"Putting those together, you might have a two operand constraint string "
"like ``\"rm|r,ri|rm\"``. This indicates that if operand 0 is ``r`` or "
"``m``, then operand 1 may be one of ``r`` or ``i``. If operand 0 is "
"``r``, then operand 1 may be one of ``r`` or ``m``. But, operand 0 and 1 "
"cannot both be of type m."
msgstr ""

#: ../../LangRef.rst:3244
msgid ""
"However, the use of either of the alternatives features is *NOT* "
"recommended, as LLVM is not able to make an intelligent choice about "
"which one to use. (At the point it currently needs to choose, not enough "
"information is available to do so in a smart way.) Thus, it simply tries "
"to make a choice that's most likely to compile, not one that will be "
"optimal performance. (e.g., given \"``rm``\", it'll always choose to use "
"memory, not registers). And, if given multiple registers, or multiple "
"register classes, it will simply choose the first one. (In fact, it "
"doesn't currently even ensure explicitly specified physical registers are"
" unique, so specifying multiple physical registers as alternatives, like "
"``{r11}{r12},{r11}{r12}``, will assign r11 to both operands, not at all "
"what was intended.)"
msgstr ""

#: ../../LangRef.rst:3257
msgid "Supported Constraint Code List"
msgstr ""

#: ../../LangRef.rst:3259
msgid ""
"The constraint codes are, in general, expected to behave the same way "
"they do in GCC. LLVM's support is often implemented on an 'as-needed' "
"basis, to support C inline asm code which was supported by GCC. A "
"mismatch in behavior between LLVM and GCC likely indicates a bug in LLVM."
msgstr ""

#: ../../LangRef.rst:3264
msgid "Some constraint codes are typically supported by all targets:"
msgstr ""

#: ../../LangRef.rst:3266
msgid "``r``: A register in the target's general purpose register class."
msgstr ""

#: ../../LangRef.rst:3267
msgid ""
"``m``: A memory address operand. It is target-specific what addressing "
"modes are supported, typical examples are register, or register + "
"register offset, or register + immediate offset (of some target-specific "
"size)."
msgstr ""

#: ../../LangRef.rst:3270
msgid ""
"``i``: An integer constant (of target-specific width). Allows either a "
"simple immediate, or a relocatable value."
msgstr ""

#: ../../LangRef.rst:3272
msgid "``n``: An integer constant -- *not* including relocatable values."
msgstr ""

#: ../../LangRef.rst:3273
msgid "``s``: An integer constant, but allowing *only* relocatable values."
msgstr ""

#: ../../LangRef.rst:3274
msgid ""
"``X``: Allows an operand of any kind, no constraint whatsoever. Typically"
" useful to pass a label for an asm branch or call."
msgstr ""

#: ../../LangRef.rst:3280
msgid "``{register-name}``: Requires exactly the named physical register."
msgstr ""

#: ../../LangRef.rst:3282
msgid "Other constraints are target-specific:"
msgstr ""

#: ../../LangRef.rst:3284 ../../LangRef.rst:3527
msgid "AArch64:"
msgstr ""

#: ../../LangRef.rst:3286
msgid "``z``: An immediate integer 0. Outputs ``WZR`` or ``XZR``, as appropriate."
msgstr ""

#: ../../LangRef.rst:3287
msgid ""
"``I``: An immediate integer valid for an ``ADD`` or ``SUB`` instruction, "
"i.e. 0 to 4095 with optional shift by 12."
msgstr ""

#: ../../LangRef.rst:3289
msgid ""
"``J``: An immediate integer that, when negated, is valid for an ``ADD`` "
"or ``SUB`` instruction, i.e. -1 to -4095 with optional left shift by 12."
msgstr ""

#: ../../LangRef.rst:3291
msgid ""
"``K``: An immediate integer that is valid for the 'bitmask immediate 32' "
"of a logical instruction like ``AND``, ``EOR``, or ``ORR`` with a 32-bit "
"register."
msgstr ""

#: ../../LangRef.rst:3293
msgid ""
"``L``: An immediate integer that is valid for the 'bitmask immediate 64' "
"of a logical instruction like ``AND``, ``EOR``, or ``ORR`` with a 64-bit "
"register."
msgstr ""

#: ../../LangRef.rst:3295
msgid ""
"``M``: An immediate integer for use with the ``MOV`` assembly alias on a "
"32-bit register. This is a superset of ``K``: in addition to the bitmask "
"immediate, also allows immediate integers which can be loaded with a "
"single ``MOVZ`` or ``MOVL`` instruction."
msgstr ""

#: ../../LangRef.rst:3299
msgid ""
"``N``: An immediate integer for use with the ``MOV`` assembly alias on a "
"64-bit register. This is a superset of ``L``."
msgstr ""

#: ../../LangRef.rst:3301
msgid ""
"``Q``: Memory address operand must be in a single register (no offsets). "
"(However, LLVM currently does this for the ``m`` constraint as well.)"
msgstr ""

#: ../../LangRef.rst:3304
msgid "``r``: A 32 or 64-bit integer register (W* or X*)."
msgstr ""

#: ../../LangRef.rst:3305
msgid "``w``: A 32, 64, or 128-bit floating-point/SIMD register."
msgstr ""

#: ../../LangRef.rst:3306
msgid "``x``: A lower 128-bit floating-point/SIMD register (``V0`` to ``V15``)."
msgstr ""

#: ../../LangRef.rst:3308 ../../LangRef.rst:3536
msgid "AMDGPU:"
msgstr ""

#: ../../LangRef.rst:3310 ../../LangRef.rst:3425
msgid "``r``: A 32 or 64-bit integer register."
msgstr ""

#: ../../LangRef.rst:3311
msgid "``[0-9]v``: The 32-bit VGPR register, number 0-9."
msgstr ""

#: ../../LangRef.rst:3312
msgid "``[0-9]s``: The 32-bit SGPR register, number 0-9."
msgstr ""

#: ../../LangRef.rst:3315
msgid "All ARM modes:"
msgstr ""

#: ../../LangRef.rst:3317
msgid ""
"``Q``, ``Um``, ``Un``, ``Uq``, ``Us``, ``Ut``, ``Uv``, ``Uy``: Memory "
"address operand. Treated the same as operand ``m``, at the moment."
msgstr ""

#: ../../LangRef.rst:3320
msgid "ARM and ARM's Thumb2 mode:"
msgstr ""

#: ../../LangRef.rst:3322
msgid "``j``: An immediate integer between 0 and 65535 (valid for ``MOVW``)"
msgstr ""

#: ../../LangRef.rst:3323
msgid "``I``: An immediate integer valid for a data-processing instruction."
msgstr ""

#: ../../LangRef.rst:3324
msgid "``J``: An immediate integer between -4095 and 4095."
msgstr ""

#: ../../LangRef.rst:3325
msgid ""
"``K``: An immediate integer whose bitwise inverse is valid for a data-"
"processing instruction. (Can be used with template modifier \"``B``\" to "
"print the inverted value)."
msgstr ""

#: ../../LangRef.rst:3328
msgid ""
"``L``: An immediate integer whose negation is valid for a data-processing"
" instruction. (Can be used with template modifier \"``n``\" to print the "
"negated value)."
msgstr ""

#: ../../LangRef.rst:3331
msgid "``M``: A power of two or a integer between 0 and 32."
msgstr ""

#: ../../LangRef.rst:3332
msgid "``N``: Invalid immediate constraint."
msgstr ""

#: ../../LangRef.rst:3333
msgid "``O``: Invalid immediate constraint."
msgstr ""

#: ../../LangRef.rst:3334
msgid "``r``: A general-purpose 32-bit integer register (``r0-r15``)."
msgstr ""

#: ../../LangRef.rst:3335
msgid ""
"``l``: In Thumb2 mode, low 32-bit GPR registers (``r0-r7``). In ARM mode,"
" same as ``r``."
msgstr ""

#: ../../LangRef.rst:3337
msgid ""
"``h``: In Thumb2 mode, a high 32-bit GPR register (``r8-r15``). In ARM "
"mode, invalid."
msgstr ""

#: ../../LangRef.rst:3339 ../../LangRef.rst:3359
msgid ""
"``w``: A 32, 64, or 128-bit floating-point/SIMD register: ``s0-s31``, "
"``d0-d31``, or ``q0-q15``."
msgstr ""

#: ../../LangRef.rst:3341 ../../LangRef.rst:3361
msgid ""
"``x``: A 32, 64, or 128-bit floating-point/SIMD register: ``s0-s15``, "
"``d0-d7``, or ``q0-q3``."
msgstr ""

#: ../../LangRef.rst:3343 ../../LangRef.rst:3363
msgid ""
"``t``: A floating-point/SIMD register, only supports 32-bit values: "
"``s0-s31``."
msgstr ""

#: ../../LangRef.rst:3346
msgid "ARM's Thumb1 mode:"
msgstr ""

#: ../../LangRef.rst:3348
msgid "``I``: An immediate integer between 0 and 255."
msgstr ""

#: ../../LangRef.rst:3349
msgid "``J``: An immediate integer between -255 and -1."
msgstr ""

#: ../../LangRef.rst:3350
msgid ""
"``K``: An immediate integer between 0 and 255, with optional left-shift "
"by some amount."
msgstr ""

#: ../../LangRef.rst:3352
msgid "``L``: An immediate integer between -7 and 7."
msgstr ""

#: ../../LangRef.rst:3353
msgid "``M``: An immediate integer which is a multiple of 4 between 0 and 1020."
msgstr ""

#: ../../LangRef.rst:3354
msgid "``N``: An immediate integer between 0 and 31."
msgstr ""

#: ../../LangRef.rst:3355
msgid "``O``: An immediate integer which is a multiple of 4 between -508 and 508."
msgstr ""

#: ../../LangRef.rst:3356
msgid "``r``: A low 32-bit GPR register (``r0-r7``)."
msgstr ""

#: ../../LangRef.rst:3357
msgid "``l``: A low 32-bit GPR register (``r0-r7``)."
msgstr ""

#: ../../LangRef.rst:3358
msgid "``h``: A high GPR register (``r0-r7``)."
msgstr ""

#: ../../LangRef.rst:3367 ../../LangRef.rst:3569
msgid "Hexagon:"
msgstr ""

#: ../../LangRef.rst:3369
msgid ""
"``o``, ``v``: A memory address operand, treated the same as constraint "
"``m``, at the moment."
msgstr ""

#: ../../LangRef.rst:3371
msgid "``r``: A 32 or 64-bit register."
msgstr ""

#: ../../LangRef.rst:3373 ../../LangRef.rst:3580
msgid "MSP430:"
msgstr ""

#: ../../LangRef.rst:3375
msgid "``r``: An 8 or 16-bit register."
msgstr ""

#: ../../LangRef.rst:3377 ../../LangRef.rst:3584
msgid "MIPS:"
msgstr ""

#: ../../LangRef.rst:3379 ../../LangRef.rst:3414
msgid "``I``: An immediate signed 16-bit integer."
msgstr ""

#: ../../LangRef.rst:3380
msgid "``J``: An immediate integer zero."
msgstr ""

#: ../../LangRef.rst:3381 ../../LangRef.rst:3416
msgid "``K``: An immediate unsigned 16-bit integer."
msgstr ""

#: ../../LangRef.rst:3382
msgid "``L``: An immediate 32-bit integer, where the lower 16 bits are 0."
msgstr ""

#: ../../LangRef.rst:3383
msgid "``N``: An immediate integer between -65535 and -1."
msgstr ""

#: ../../LangRef.rst:3384
msgid "``O``: An immediate signed 15-bit integer."
msgstr ""

#: ../../LangRef.rst:3385
msgid "``P``: An immediate integer between 1 and 65535."
msgstr ""

#: ../../LangRef.rst:3386
msgid ""
"``m``: A memory address operand. In MIPS-SE mode, allows a base address "
"register plus 16-bit immediate offset. In MIPS mode, just a base "
"register."
msgstr ""

#: ../../LangRef.rst:3388
msgid ""
"``R``: A memory address operand. In MIPS-SE mode, allows a base address "
"register plus a 9-bit signed offset. In MIPS mode, the same as constraint"
" ``m``."
msgstr ""

#: ../../LangRef.rst:3391
msgid ""
"``ZC``: A memory address operand, suitable for use in a ``pref``, ``ll``,"
" or ``sc`` instruction on the given subtarget (details vary)."
msgstr ""

#: ../../LangRef.rst:3393
msgid "``r``, ``d``,  ``y``: A 32 or 64-bit GPR register."
msgstr ""

#: ../../LangRef.rst:3394
msgid ""
"``f``: A 32 or 64-bit FPU register (``F0-F31``), or a 128-bit MSA "
"register (``W0-W31``). In the case of MSA registers, it is recommended to"
" use the ``w`` argument modifier for compatibility with GCC."
msgstr ""

#: ../../LangRef.rst:3397
msgid ""
"``c``: A 32-bit or 64-bit GPR register suitable for indirect jump (always"
" ``25``)."
msgstr ""

#: ../../LangRef.rst:3399
msgid "``l``: The ``lo`` register, 32 or 64-bit."
msgstr ""

#: ../../LangRef.rst:3400
msgid "``x``: Invalid."
msgstr ""

#: ../../LangRef.rst:3402 ../../LangRef.rst:3609
msgid "NVPTX:"
msgstr ""

#: ../../LangRef.rst:3404
msgid "``b``: A 1-bit integer register."
msgstr ""

#: ../../LangRef.rst:3405
msgid "``c`` or ``h``: A 16-bit integer register."
msgstr ""

#: ../../LangRef.rst:3406 ../../LangRef.rst:3447 ../../LangRef.rst:3502
msgid "``r``: A 32-bit integer register."
msgstr ""

#: ../../LangRef.rst:3407
msgid "``l`` or ``N``: A 64-bit integer register."
msgstr ""

#: ../../LangRef.rst:3408
msgid "``f``: A 32-bit float register."
msgstr ""

#: ../../LangRef.rst:3409
msgid "``d``: A 64-bit float register."
msgstr ""

#: ../../LangRef.rst:3412 ../../LangRef.rst:3613
msgid "PowerPC:"
msgstr ""

#: ../../LangRef.rst:3415
msgid "``J``: An immediate unsigned 16-bit integer, shifted left 16 bits."
msgstr ""

#: ../../LangRef.rst:3417
msgid "``L``: An immediate signed 16-bit integer, shifted left 16 bits."
msgstr ""

#: ../../LangRef.rst:3418
msgid "``M``: An immediate integer greater than 31."
msgstr ""

#: ../../LangRef.rst:3419
msgid "``N``: An immediate integer that is an exact power of 2."
msgstr ""

#: ../../LangRef.rst:3420
msgid "``O``: The immediate integer constant 0."
msgstr ""

#: ../../LangRef.rst:3421
msgid ""
"``P``: An immediate integer constant whose negation is a signed 16-bit "
"constant."
msgstr ""

#: ../../LangRef.rst:3423
msgid ""
"``es``, ``o``, ``Q``, ``Z``, ``Zy``: A memory address operand, currently "
"treated the same as ``m``."
msgstr ""

#: ../../LangRef.rst:3426
msgid ""
"``b``: A 32 or 64-bit integer register, excluding ``R0`` (that is: "
"``R1-R31``)."
msgstr ""

#: ../../LangRef.rst:3428
msgid ""
"``f``: A 32 or 64-bit float register (``F0-F31``), or when QPX is "
"enabled, a 128 or 256-bit QPX register (``Q0-Q31``; aliases the ``F`` "
"registers)."
msgstr ""

#: ../../LangRef.rst:3430
msgid ""
"``v``: For ``4 x f32`` or ``4 x f64`` types, when QPX is enabled, a 128 "
"or 256-bit QPX register (``Q0-Q31``), otherwise a 128-bit altivec vector "
"register (``V0-V31``)."
msgstr ""

#: ../../LangRef.rst:3437
msgid "``y``: Condition register (``CR0-CR7``)."
msgstr ""

#: ../../LangRef.rst:3438
msgid "``wc``: An individual CR bit in a CR register."
msgstr ""

#: ../../LangRef.rst:3439
msgid ""
"``wa``, ``wd``, ``wf``: Any 128-bit VSX vector register, from the full "
"VSX register set (overlapping both the floating-point and vector register"
" files)."
msgstr ""

#: ../../LangRef.rst:3441
msgid ""
"``ws``: A 32 or 64-bit floating point register, from the full VSX "
"register set."
msgstr ""

#: ../../LangRef.rst:3444 ../../LangRef.rst:3631
msgid "Sparc:"
msgstr ""

#: ../../LangRef.rst:3446
msgid "``I``: An immediate 13-bit signed integer."
msgstr ""

#: ../../LangRef.rst:3449 ../../LangRef.rst:3635
msgid "SystemZ:"
msgstr ""

#: ../../LangRef.rst:3451
msgid "``I``: An immediate unsigned 8-bit integer."
msgstr ""

#: ../../LangRef.rst:3452
msgid "``J``: An immediate unsigned 12-bit integer."
msgstr ""

#: ../../LangRef.rst:3453
msgid "``K``: An immediate signed 16-bit integer."
msgstr ""

#: ../../LangRef.rst:3454
msgid "``L``: An immediate signed 20-bit integer."
msgstr ""

#: ../../LangRef.rst:3455
msgid "``M``: An immediate integer 0x7fffffff."
msgstr ""

#: ../../LangRef.rst:3456
msgid ""
"``Q``, ``R``, ``S``, ``T``: A memory address operand, treated the same as"
" ``m``, at the moment."
msgstr ""

#: ../../LangRef.rst:3458
msgid "``r`` or ``d``: A 32, 64, or 128-bit integer register."
msgstr ""

#: ../../LangRef.rst:3459
msgid ""
"``a``: A 32, 64, or 128-bit integer address register (excludes R0, which "
"in an address context evaluates as zero)."
msgstr ""

#: ../../LangRef.rst:3461
msgid ""
"``h``: A 32-bit value in the high part of a 64bit data register (LLVM-"
"specific)"
msgstr ""

#: ../../LangRef.rst:3463
msgid "``f``: A 32, 64, or 128-bit floating point register."
msgstr ""

#: ../../LangRef.rst:3465 ../../LangRef.rst:3640
msgid "X86:"
msgstr ""

#: ../../LangRef.rst:3467
msgid "``I``: An immediate integer between 0 and 31."
msgstr ""

#: ../../LangRef.rst:3468
msgid "``J``: An immediate integer between 0 and 64."
msgstr ""

#: ../../LangRef.rst:3469
msgid "``K``: An immediate signed 8-bit integer."
msgstr ""

#: ../../LangRef.rst:3470
msgid ""
"``L``: An immediate integer, 0xff or 0xffff or (in 64-bit mode only) "
"0xffffffff."
msgstr ""

#: ../../LangRef.rst:3472
msgid "``M``: An immediate integer between 0 and 3."
msgstr ""

#: ../../LangRef.rst:3473
msgid "``N``: An immediate unsigned 8-bit integer."
msgstr ""

#: ../../LangRef.rst:3474
msgid "``O``: An immediate integer between 0 and 127."
msgstr ""

#: ../../LangRef.rst:3475
msgid "``e``: An immediate 32-bit signed integer."
msgstr ""

#: ../../LangRef.rst:3476
msgid "``Z``: An immediate 32-bit unsigned integer."
msgstr ""

#: ../../LangRef.rst:3477
msgid "``o``, ``v``: Treated the same as ``m``, at the moment."
msgstr ""

#: ../../LangRef.rst:3478
msgid ""
"``q``: An 8, 16, 32, or 64-bit register which can be accessed as an 8-bit"
" ``l`` integer register. On X86-32, this is the ``a``, ``b``, ``c``, and "
"``d`` registers, and on X86-64, it is all of the integer registers."
msgstr ""

#: ../../LangRef.rst:3481
msgid ""
"``Q``: An 8, 16, 32, or 64-bit register which can be accessed as an 8-bit"
" ``h`` integer register. This is the ``a``, ``b``, ``c``, and ``d`` "
"registers."
msgstr ""

#: ../../LangRef.rst:3483
msgid "``r`` or ``l``: An 8, 16, 32, or 64-bit integer register."
msgstr ""

#: ../../LangRef.rst:3484
msgid ""
"``R``: An 8, 16, 32, or 64-bit \"legacy\" integer register -- one which "
"has existed since i386, and can be accessed without the REX prefix."
msgstr ""

#: ../../LangRef.rst:3486
msgid "``f``: A 32, 64, or 80-bit '387 FPU stack pseudo-register."
msgstr ""

#: ../../LangRef.rst:3487
msgid "``y``: A 64-bit MMX register, if MMX is enabled."
msgstr ""

#: ../../LangRef.rst:3488
msgid ""
"``x``: If SSE is enabled: a 32 or 64-bit scalar operand, or 128-bit "
"vector operand in a SSE register. If AVX is also enabled, can also be a "
"256-bit vector operand in an AVX register. If AVX-512 is also enabled, "
"can also be a 512-bit vector operand in an AVX512 register, Otherwise, an"
" error."
msgstr ""

#: ../../LangRef.rst:3492
msgid "``Y``: The same as ``x``, if *SSE2* is enabled, otherwise an error."
msgstr ""

#: ../../LangRef.rst:3493
msgid ""
"``A``: Special case: allocates EAX first, then EDX, for a single operand "
"(in 32-bit mode, a 64-bit integer operand will get split into two "
"registers). It is not recommended to use this constraint, as in 64-bit "
"mode, the 64-bit operand will get allocated only to RAX -- if two 32-bit "
"operands are needed, you're better off splitting it yourself, before "
"passing it to the asm statement."
msgstr ""

#: ../../LangRef.rst:3500 ../../LangRef.rst:3663
msgid "XCore:"
msgstr ""

#: ../../LangRef.rst:3508
msgid "Asm template argument modifiers"
msgstr ""

#: ../../LangRef.rst:3510
msgid ""
"In the asm template string, modifiers can be used on the operand "
"reference, like \"``${0:n}``\"."
msgstr ""

#: ../../LangRef.rst:3513
msgid ""
"The modifiers are, in general, expected to behave the same way they do in"
" GCC. LLVM's support is often implemented on an 'as-needed' basis, to "
"support C inline asm code which was supported by GCC. A mismatch in "
"behavior between LLVM and GCC likely indicates a bug in LLVM."
msgstr ""

#: ../../LangRef.rst:3518
msgid "Target-independent:"
msgstr ""

#: ../../LangRef.rst:3520
msgid ""
"``c``: Print an immediate integer constant unadorned, without the target-"
"specific immediate punctuation (e.g. no ``$`` prefix)."
msgstr ""

#: ../../LangRef.rst:3522
msgid ""
"``n``: Negate and print immediate integer constant unadorned, without the"
" target-specific immediate punctuation (e.g. no ``$`` prefix)."
msgstr ""

#: ../../LangRef.rst:3524
msgid ""
"``l``: Print as an unadorned label, without the target-specific label "
"punctuation (e.g. no ``$`` prefix)."
msgstr ""

#: ../../LangRef.rst:3529
msgid ""
"``w``: Print a GPR register with a ``w*`` name instead of ``x*`` name. "
"E.g., instead of ``x30``, print ``w30``."
msgstr ""

#: ../../LangRef.rst:3531
msgid ""
"``x``: Print a GPR register with a ``x*`` name. (this is the default, "
"anyhow)."
msgstr ""

#: ../../LangRef.rst:3532
msgid ""
"``b``, ``h``, ``s``, ``d``, ``q``: Print a floating-point/SIMD register "
"with a ``b*``, ``h*``, ``s*``, ``d*``, or ``q*`` name, rather than the "
"default of ``v*``."
msgstr ""

#: ../../LangRef.rst:3538 ../../LangRef.rst:3611 ../../LangRef.rst:3633
msgid "``r``: No effect."
msgstr ""

#: ../../LangRef.rst:3540
msgid "ARM:"
msgstr ""

#: ../../LangRef.rst:3542
msgid ""
"``a``: Print an operand as an address (with ``[`` and ``]`` surrounding a"
" register)."
msgstr ""

#: ../../LangRef.rst:3544
msgid "``P``: No effect."
msgstr ""

#: ../../LangRef.rst:3545
msgid "``q``: No effect."
msgstr ""

#: ../../LangRef.rst:3546
msgid ""
"``y``: Print a VFP single-precision register as an indexed double (e.g. "
"print as ``d4[1]`` instead of ``s9``)"
msgstr ""

#: ../../LangRef.rst:3548
msgid ""
"``B``: Bitwise invert and print an immediate integer constant without "
"``#`` prefix."
msgstr ""

#: ../../LangRef.rst:3550
msgid "``L``: Print the low 16-bits of an immediate integer constant."
msgstr ""

#: ../../LangRef.rst:3551
msgid ""
"``M``: Print as a register set suitable for ldm/stm. Also prints *all* "
"register operands subsequent to the specified one (!), so use carefully."
msgstr ""

#: ../../LangRef.rst:3553
msgid ""
"``Q``: Print the low-order register of a register-pair, or the low-order "
"register of a two-register operand."
msgstr ""

#: ../../LangRef.rst:3555
msgid ""
"``R``: Print the high-order register of a register-pair, or the high-"
"order register of a two-register operand."
msgstr ""

#: ../../LangRef.rst:3557
msgid ""
"``H``: Print the second register of a register-pair. (On a big-endian "
"system, ``H`` is equivalent to ``Q``, and on little-endian system, ``H`` "
"is equivalent to ``R``.)"
msgstr ""

#: ../../LangRef.rst:3564
msgid "``e``: Print the low doubleword register of a NEON quad register."
msgstr ""

#: ../../LangRef.rst:3565
msgid "``f``: Print the high doubleword register of a NEON quad register."
msgstr ""

#: ../../LangRef.rst:3566
msgid ""
"``m``: Print the base register of a memory operand without the ``[`` and "
"``]`` adornment."
msgstr ""

#: ../../LangRef.rst:3571 ../../LangRef.rst:3615
msgid ""
"``L``: Print the second register of a two-register operand. Requires that"
" it has been allocated consecutively to the first."
msgstr ""

#: ../../LangRef.rst:3577 ../../LangRef.rst:3621
msgid ""
"``I``: Print the letter 'i' if the operand is an integer constant, "
"otherwise nothing. Used to print 'addi' vs 'add' instructions."
msgstr ""

#: ../../LangRef.rst:3582 ../../LangRef.rst:3665
msgid "No additional modifiers."
msgstr ""

#: ../../LangRef.rst:3586
msgid "``X``: Print an immediate integer as hexadecimal"
msgstr ""

#: ../../LangRef.rst:3587
msgid "``x``: Print the low 16 bits of an immediate integer as hexadecimal."
msgstr ""

#: ../../LangRef.rst:3588
msgid "``d``: Print an immediate integer as decimal."
msgstr ""

#: ../../LangRef.rst:3589
msgid "``m``: Subtract one and print an immediate integer as decimal."
msgstr ""

#: ../../LangRef.rst:3590
msgid "``z``: Print $0 if an immediate zero, otherwise print normally."
msgstr ""

#: ../../LangRef.rst:3591
msgid ""
"``L``: Print the low-order register of a two-register operand, or prints "
"the address of the low-order word of a double-word memory operand."
msgstr ""

#: ../../LangRef.rst:3596
msgid ""
"``M``: Print the high-order register of a two-register operand, or prints"
" the address of the high-order word of a double-word memory operand."
msgstr ""

#: ../../LangRef.rst:3601
msgid ""
"``D``: Print the second register of a two-register operand, or prints the"
" second word of a double-word memory operand. (On a big-endian system, "
"``D`` is equivalent to ``L``, and on little-endian system, ``D`` is "
"equivalent to ``M``.)"
msgstr ""

#: ../../LangRef.rst:3605
msgid ""
"``w``: No effect. Provided for compatibility with GCC which requires this"
" modifier in order to print MSA registers (``W0-W31``) with the ``f`` "
"constraint."
msgstr ""

#: ../../LangRef.rst:3623
msgid ""
"``y``: For a memory operand, prints formatter for a two-register X-form "
"instruction. (Currently always prints ``r0,OPERAND``)."
msgstr ""

#: ../../LangRef.rst:3625
msgid ""
"``U``: Prints 'u' if the memory operand is an update form, and nothing "
"otherwise. (NOTE: LLVM does not support update form, so this will "
"currently always print nothing)"
msgstr ""

#: ../../LangRef.rst:3628
msgid ""
"``X``: Prints 'x' if the memory operand is an indexed form. (NOTE: LLVM "
"does not support indexed form, so this will currently always print "
"nothing)"
msgstr ""

#: ../../LangRef.rst:3637
msgid ""
"SystemZ implements only ``n``, and does *not* support any of the other "
"target-independent modifiers."
msgstr ""

#: ../../LangRef.rst:3642
msgid ""
"``c``: Print an unadorned integer or symbol name. (The latter is target-"
"specific behavior for this typically target-independent modifier)."
msgstr ""

#: ../../LangRef.rst:3644
msgid "``A``: Print a register name with a '``*``' before it."
msgstr ""

#: ../../LangRef.rst:3645
msgid ""
"``b``: Print an 8-bit register name (e.g. ``al``); do nothing on a memory"
" operand."
msgstr ""

#: ../../LangRef.rst:3647
msgid ""
"``h``: Print the upper 8-bit register name (e.g. ``ah``); do nothing on a"
" memory operand."
msgstr ""

#: ../../LangRef.rst:3649
msgid ""
"``w``: Print the 16-bit register name (e.g. ``ax``); do nothing on a "
"memory operand."
msgstr ""

#: ../../LangRef.rst:3651
msgid ""
"``k``: Print the 32-bit register name (e.g. ``eax``); do nothing on a "
"memory operand."
msgstr ""

#: ../../LangRef.rst:3653
msgid ""
"``q``: Print the 64-bit register name (e.g. ``rax``), if 64-bit registers"
" are available, otherwise the 32-bit register name; do nothing on a "
"memory operand."
msgstr ""

#: ../../LangRef.rst:3655
msgid ""
"``n``: Negate and print an unadorned integer, or, for operands other than"
" an immediate integer (e.g. a relocatable symbol expression), print a '-'"
" before the operand. (The behavior for relocatable symbol expressions is "
"a target-specific behavior for this typically target-independent "
"modifier)"
msgstr ""

#: ../../LangRef.rst:3659
msgid "``H``: Print a memory reference with additional offset +8."
msgstr ""

#: ../../LangRef.rst:3660
msgid ""
"``P``: Print a memory reference or operand for use as the argument of a "
"call instruction. (E.g. omit ``(rip)``, even though it's PC-relative.)"
msgstr ""

#: ../../LangRef.rst:3669
msgid "Inline Asm Metadata"
msgstr ""

#: ../../LangRef.rst:3671
msgid ""
"The call instructions that wrap inline asm nodes may have a "
"\"``!srcloc``\" MDNode attached to it that contains a list of constant "
"integers. If present, the code generator will use the integer as the "
"location cookie value when report errors through the ``LLVMContext`` "
"error reporting mechanisms. This allows a front-end to correlate backend "
"errors that occur with inline asm back to the source code that produced "
"it. For example:"
msgstr ""

#: ../../LangRef.rst:3685
msgid ""
"It is up to the front-end to make sense of the magic numbers it places in"
" the IR. If the MDNode contains multiple constants, the code generator "
"will use the one that corresponds to the line of the asm that the error "
"occurs on."
msgstr ""

#: ../../LangRef.rst:3693
msgid "Metadata"
msgstr ""

#: ../../LangRef.rst:3695
msgid ""
"LLVM IR allows metadata to be attached to instructions in the program "
"that can convey extra information about the code to the optimizers and "
"code generator. One example application of metadata is source-level debug"
" information. There are two metadata primitives: strings and nodes."
msgstr ""

#: ../../LangRef.rst:3700
msgid ""
"Metadata does not have a type, and is not a value. If referenced from a "
"``call`` instruction, it uses the ``metadata`` type."
msgstr ""

#: ../../LangRef.rst:3703
msgid "All metadata are identified in syntax by a exclamation point ('``!``')."
msgstr ""

#: ../../LangRef.rst:3708
msgid "Metadata Nodes and Metadata Strings"
msgstr ""

#: ../../LangRef.rst:3710
msgid ""
"A metadata string is a string surrounded by double quotes. It can contain"
" any character by escaping non-printable characters with \"``\\xx``\" "
"where \"``xx``\" is the two digit hex code. For example: "
"\"``!\"test\\00\"``\"."
msgstr ""

#: ../../LangRef.rst:3715
msgid ""
"Metadata nodes are represented with notation similar to structure "
"constants (a comma separated list of elements, surrounded by braces and "
"preceded by an exclamation point). Metadata nodes can have any values as "
"their operand. For example:"
msgstr ""

#: ../../LangRef.rst:3724
msgid ""
"Metadata nodes that aren't uniqued use the ``distinct`` keyword. For "
"example:"
msgstr ""

#: ../../LangRef.rst:3730
msgid ""
"``distinct`` nodes are useful when nodes shouldn't be merged based on "
"their content. They can also occur when transformations cause uniquing "
"collisions when metadata operands change."
msgstr ""

#: ../../LangRef.rst:3734
msgid ""
"A :ref:`named metadata <namedmetadatastructure>` is a collection of "
"metadata nodes, which can be looked up in the module symbol table. For "
"example:"
msgstr ""

#: ../../LangRef.rst:3742
msgid ""
"Metadata can be used as function arguments. Here ``llvm.dbg.value`` "
"function is using two metadata arguments:"
msgstr ""

#: ../../LangRef.rst:3749
msgid ""
"Metadata can be attached to an instruction. Here metadata ``!21`` is "
"attached to the ``add`` instruction using the ``!dbg`` identifier:"
msgstr ""

#: ../../LangRef.rst:3756
msgid ""
"Metadata can also be attached to a function definition. Here metadata "
"``!22`` is attached to the ``foo`` function using the ``!dbg`` "
"identifier:"
msgstr ""

#: ../../LangRef.rst:3765
msgid ""
"More information about specific metadata nodes recognized by the "
"optimizers and code generator is found below."
msgstr ""

#: ../../LangRef.rst:3771
msgid "Specialized Metadata Nodes"
msgstr ""

#: ../../LangRef.rst:3773
msgid ""
"Specialized metadata nodes are custom data structures in metadata (as "
"opposed to generic tuples). Their fields are labelled, and can be "
"specified in any order."
msgstr ""

#: ../../LangRef.rst:3777
msgid ""
"These aren't inherently debug info centric, but currently all the "
"specialized metadata nodes are related to debug info."
msgstr ""

#: ../../LangRef.rst:3783
msgid "DICompileUnit"
msgstr ""

#: ../../LangRef.rst:3785
msgid ""
"``DICompileUnit`` nodes represent a compile unit. The ``enums:``, "
"``retainedTypes:``, ``subprograms:``, ``globals:``, ``imports:`` and "
"``macros:`` fields are tuples containing the debug info to be emitted "
"along with the compile unit, regardless of code optimizations (some nodes"
" are only emitted if there are references to them from instructions)."
msgstr ""

#: ../../LangRef.rst:3799
msgid ""
"Compile unit descriptors provide the root scope for objects declared in a"
" specific compilation unit. File descriptors are defined using this "
"scope. These descriptors are collected by a named metadata "
"``!llvm.dbg.cu``. They keep track of subprograms, global variables, type "
"information, and imported entities (declarations and namespaces)."
msgstr ""

#: ../../LangRef.rst:3808
msgid "DIFile"
msgstr ""

#: ../../LangRef.rst:3810
msgid "``DIFile`` nodes represent files. The ``filename:`` can include slashes."
msgstr ""

#: ../../LangRef.rst:3816
msgid ""
"Files are sometimes used in ``scope:`` fields, and are the only valid "
"target for ``file:`` fields."
msgstr ""

#: ../../LangRef.rst:3822
msgid "DIBasicType"
msgstr ""

#: ../../LangRef.rst:3824
msgid ""
"``DIBasicType`` nodes represent primitive types, such as ``int``, "
"``bool`` and ``float``. ``tag:`` defaults to ``DW_TAG_base_type``."
msgstr ""

#: ../../LangRef.rst:3833
msgid ""
"The ``encoding:`` describes the details of the type. Usually it's one of "
"the following:"
msgstr ""

#: ../../LangRef.rst:3849
msgid "DISubroutineType"
msgstr ""

#: ../../LangRef.rst:3851
msgid ""
"``DISubroutineType`` nodes represent subroutine types. Their ``types:`` "
"field refers to a tuple; the first operand is the return type, while the "
"rest are the types of the formal arguments in order. If the first operand"
" is ``null``, that represents a function with no return value (such as "
"``void foo() {}`` in C++)."
msgstr ""

#: ../../LangRef.rst:3865
msgid "DIDerivedType"
msgstr ""

#: ../../LangRef.rst:3867
msgid ""
"``DIDerivedType`` nodes represent types derived from other types, such as"
" qualified types."
msgstr ""

#: ../../LangRef.rst:3877 ../../LangRef.rst:3927
msgid "The following ``tag:`` values are valid:"
msgstr ""

#: ../../LangRef.rst:3891
msgid ""
"``DW_TAG_member`` is used to define a member of a :ref:`composite type "
"<DICompositeType>` or :ref:`subprogram <DISubprogram>`. The type of the "
"member is the ``baseType:``. The ``offset:`` is the member's bit offset. "
"``DW_TAG_formal_parameter`` is used to define a member which is a formal "
"argument of a subprogram."
msgstr ""

#: ../../LangRef.rst:3897
msgid "``DW_TAG_typedef`` is used to provide a name for the ``baseType:``."
msgstr ""

#: ../../LangRef.rst:3899
msgid ""
"``DW_TAG_pointer_type``, ``DW_TAG_reference_type``, "
"``DW_TAG_const_type``, ``DW_TAG_volatile_type`` and "
"``DW_TAG_restrict_type`` are used to qualify the ``baseType:``."
msgstr ""

#: ../../LangRef.rst:3903
msgid "Note that the ``void *`` type is expressed as a type derived from NULL."
msgstr ""

#: ../../LangRef.rst:3908
msgid "DICompositeType"
msgstr ""

#: ../../LangRef.rst:3910
msgid ""
"``DICompositeType`` nodes represent types composed of other types, like "
"structures and unions. ``elements:`` points to a tuple of the composed "
"types."
msgstr ""

#: ../../LangRef.rst:3913
msgid ""
"If the source language supports ODR, the ``identifier:`` field gives the "
"unique identifier used for type merging between modules. When specified, "
"other types can refer to composite types indirectly via a :ref:`metadata "
"string <metadata-string>` that matches their identifier."
msgstr ""

#: ../../LangRef.rst:3940
msgid ""
"For ``DW_TAG_array_type``, the ``elements:`` should be :ref:`subrange "
"descriptors <DISubrange>`, each representing the range of subscripts at "
"that level of indexing. The ``DIFlagVector`` flag to ``flags:`` indicates"
" that an array type is a native packed vector."
msgstr ""

#: ../../LangRef.rst:3945
msgid ""
"For ``DW_TAG_enumeration_type``, the ``elements:`` should be "
":ref:`enumerator descriptors <DIEnumerator>`, each representing the "
"definition of an enumeration value for the set. All enumeration type "
"descriptors are collected in the ``enums:`` field of the :ref:`compile "
"unit <DICompileUnit>`."
msgstr ""

#: ../../LangRef.rst:3950
msgid ""
"For ``DW_TAG_structure_type``, ``DW_TAG_class_type``, and "
"``DW_TAG_union_type``, the ``elements:`` should be :ref:`derived types "
"<DIDerivedType>` with ``tag: DW_TAG_member`` or ``tag: "
"DW_TAG_inheritance``."
msgstr ""

#: ../../LangRef.rst:3957
msgid "DISubrange"
msgstr ""

#: ../../LangRef.rst:3959
msgid ""
"``DISubrange`` nodes are the elements for ``DW_TAG_array_type`` variants "
"of :ref:`DICompositeType`. ``count: -1`` indicates an empty array."
msgstr ""

#: ../../LangRef.rst:3971
msgid "DIEnumerator"
msgstr ""

#: ../../LangRef.rst:3973
msgid ""
"``DIEnumerator`` nodes are the elements for ``DW_TAG_enumeration_type`` "
"variants of :ref:`DICompositeType`."
msgstr ""

#: ../../LangRef.rst:3983
msgid "DITemplateTypeParameter"
msgstr ""

#: ../../LangRef.rst:3985
msgid ""
"``DITemplateTypeParameter`` nodes represent type parameters to generic "
"source language constructs. They are used (optionally) in "
":ref:`DICompositeType` and :ref:`DISubprogram` ``templateParams:`` "
"fields."
msgstr ""

#: ../../LangRef.rst:3994
msgid "DITemplateValueParameter"
msgstr ""

#: ../../LangRef.rst:3996
msgid ""
"``DITemplateValueParameter`` nodes represent value parameters to generic "
"source language constructs. ``tag:`` defaults to "
"``DW_TAG_template_value_parameter``, but if specified can also be set to "
"``DW_TAG_GNU_template_template_param`` or "
"``DW_TAG_GNU_template_param_pack``. They are used (optionally) in "
":ref:`DICompositeType` and :ref:`DISubprogram` ``templateParams:`` "
"fields."
msgstr ""

#: ../../LangRef.rst:4007
msgid "DINamespace"
msgstr ""

#: ../../LangRef.rst:4009
msgid "``DINamespace`` nodes represent namespaces in the source language."
msgstr ""

#: ../../LangRef.rst:4016
msgid "DIGlobalVariable"
msgstr ""

#: ../../LangRef.rst:4018
msgid ""
"``DIGlobalVariable`` nodes represent global variables in the source "
"language."
msgstr ""

#: ../../LangRef.rst:4027
msgid ""
"All global variables should be referenced by the `globals:` field of a "
":ref:`compile unit <DICompileUnit>`."
msgstr ""

#: ../../LangRef.rst:4033
msgid "DISubprogram"
msgstr ""

#: ../../LangRef.rst:4035
msgid ""
"``DISubprogram`` nodes represent functions from the source language. A "
"``DISubprogram`` may be attached to a function definition using ``!dbg`` "
"metadata. The ``variables:`` field points at :ref:`variables "
"<DILocalVariable>` that must be retained, even if their IR counterparts "
"are optimized out of the IR. The ``type:`` field must point at an "
":ref:`DISubroutineType`."
msgstr ""

#: ../../LangRef.rst:4059
msgid "DILexicalBlock"
msgstr ""

#: ../../LangRef.rst:4061
msgid ""
"``DILexicalBlock`` nodes describe nested blocks within a :ref:`subprogram"
" <DISubprogram>`. The line number and column numbers are used to "
"distinguish two lexical blocks at same depth. They are valid targets for "
"``scope:`` fields."
msgstr ""

#: ../../LangRef.rst:4070
msgid ""
"Usually lexical blocks are ``distinct`` to prevent node merging based on "
"operands."
msgstr ""

#: ../../LangRef.rst:4076
msgid "DILexicalBlockFile"
msgstr ""

#: ../../LangRef.rst:4078
msgid ""
"``DILexicalBlockFile`` nodes are used to discriminate between sections of"
" a :ref:`lexical block <DILexicalBlock>`. The ``file:`` field can be "
"changed to indicate textual inclusion, or the ``discriminator:`` field "
"can be used to discriminate between control flow within a single block in"
" the source language."
msgstr ""

#: ../../LangRef.rst:4092
msgid "DILocation"
msgstr ""

#: ../../LangRef.rst:4094
msgid ""
"``DILocation`` nodes represent source debug locations. The ``scope:`` "
"field is mandatory, and points at an :ref:`DILexicalBlockFile`, an "
":ref:`DILexicalBlock`, or an :ref:`DISubprogram`."
msgstr ""

#: ../../LangRef.rst:4105
msgid "DILocalVariable"
msgstr ""

#: ../../LangRef.rst:4107
msgid ""
"``DILocalVariable`` nodes represent local variables in the source "
"language. If the ``arg:`` field is set to non-zero, then this variable is"
" a subprogram parameter, and it will be included in the ``variables:`` "
"field of its :ref:`DISubprogram`."
msgstr ""

#: ../../LangRef.rst:4121
msgid "DIExpression"
msgstr ""

#: ../../LangRef.rst:4123
msgid ""
"``DIExpression`` nodes represent DWARF expression sequences. They are "
"used in :ref:`debug intrinsics<dbg_intrinsics>` (such as "
"``llvm.dbg.declare``) to describe how the referenced LLVM variable "
"relates to the source language variable."
msgstr ""

#: ../../LangRef.rst:4128
msgid "The current supported vocabulary is limited:"
msgstr ""

#: ../../LangRef.rst:4130
msgid "``DW_OP_deref`` dereferences the working expression."
msgstr ""

#: ../../LangRef.rst:4131
msgid "``DW_OP_plus, 93`` adds ``93`` to the working expression."
msgstr ""

#: ../../LangRef.rst:4132
msgid ""
"``DW_OP_bit_piece, 16, 8`` specifies the offset and size (``16`` and "
"``8`` here, respectively) of the variable piece from the working "
"expression."
msgstr ""

#: ../../LangRef.rst:4143
msgid "DIObjCProperty"
msgstr ""

#: ../../LangRef.rst:4145
msgid "``DIObjCProperty`` nodes represent Objective-C property nodes."
msgstr ""

#: ../../LangRef.rst:4153
msgid "DIImportedEntity"
msgstr ""

#: ../../LangRef.rst:4155
msgid ""
"``DIImportedEntity`` nodes represent entities (such as modules) imported "
"into a compile unit."
msgstr ""

#: ../../LangRef.rst:4164
msgid "DIMacro"
msgstr ""

#: ../../LangRef.rst:4166
msgid ""
"``DIMacro`` nodes represent definition or undefinition of a macro "
"identifiers. The ``name:`` field is the macro identifier, followed by "
"macro parameters when definining a function-like macro, and the ``value``"
" field is the token-string used to expand the macro identifier."
msgstr ""

#: ../../LangRef.rst:4178
msgid "DIMacroFile"
msgstr ""

#: ../../LangRef.rst:4180
msgid ""
"``DIMacroFile`` nodes represent inclusion of source files. The ``nodes:``"
" field is a list of ``DIMacro`` and ``DIMacroFile`` nodes that appear in "
"the included source file."
msgstr ""

#: ../../LangRef.rst:4190
msgid "'``tbaa``' Metadata"
msgstr ""

#: ../../LangRef.rst:4192
msgid ""
"In LLVM IR, memory does not have types, so LLVM's own type system is not "
"suitable for doing TBAA. Instead, metadata is added to the IR to describe"
" a type system of a higher level language. This can be used to implement "
"typical C/C++ TBAA, but it can also be used to implement custom alias "
"analysis behavior for other languages."
msgstr ""

#: ../../LangRef.rst:4198
msgid ""
"The current metadata format is very simple. TBAA metadata nodes have up "
"to three fields, e.g.:"
msgstr ""

#: ../../LangRef.rst:4208
msgid ""
"The first field is an identity field. It can be any value, usually a "
"metadata string, which uniquely identifies the type. The most important "
"name in the tree is the name of the root node. Two trees with different "
"root node names are entirely disjoint, even if they have leaves with "
"common names."
msgstr ""

#: ../../LangRef.rst:4214
msgid ""
"The second field identifies the type's parent node in the tree, or is "
"null or omitted for a root node. A type is considered to alias all of its"
" descendants and all of its ancestors in the tree. Also, a type is "
"considered to alias all types in other trees, so that bitcode produced "
"from multiple front-ends is handled conservatively."
msgstr ""

#: ../../LangRef.rst:4220
msgid ""
"If the third field is present, it's an integer which if equal to 1 "
"indicates that the type is \"constant\" (meaning "
"``pointsToConstantMemory`` should return true; see `other useful "
"AliasAnalysis methods <AliasAnalysis.html#OtherItfs>`_)."
msgstr ""

#: ../../LangRef.rst:4226
msgid "'``tbaa.struct``' Metadata"
msgstr ""

#: ../../LangRef.rst:4228
msgid ""
"The :ref:`llvm.memcpy <int_memcpy>` is often used to implement aggregate "
"assignment operations in C and similar languages, however it is defined "
"to copy a contiguous region of memory, which is more than strictly "
"necessary for aggregate types which contain holes due to padding. Also, "
"it doesn't contain any TBAA information about the fields of the "
"aggregate."
msgstr ""

#: ../../LangRef.rst:4235
msgid ""
"``!tbaa.struct`` metadata can describe which memory subregions in a "
"memcpy are padding and what the TBAA tags of the struct are."
msgstr ""

#: ../../LangRef.rst:4238
msgid ""
"The current metadata format is very simple. ``!tbaa.struct`` metadata "
"nodes are a list of operands which are in conceptual groups of three. For"
" each group of three, the first operand gives the byte offset of a field "
"in bytes, the second gives its size in bytes, and the third gives its "
"tbaa tag. e.g.:"
msgstr ""

#: ../../LangRef.rst:4248
msgid ""
"This describes a struct with two fields. The first is at offset 0 bytes "
"with size 4 bytes, and has tbaa tag !1. The second is at offset 8 bytes "
"and has size 4 bytes and has tbaa tag !2."
msgstr ""

#: ../../LangRef.rst:4252
msgid ""
"Note that the fields need not be contiguous. In this example, there is a "
"4 byte gap between the two fields. This gap represents padding which does"
" not carry useful data and need not be preserved."
msgstr ""

#: ../../LangRef.rst:4257
msgid "'``noalias``' and '``alias.scope``' Metadata"
msgstr ""

#: ../../LangRef.rst:4259
msgid ""
"``noalias`` and ``alias.scope`` metadata provide the ability to specify "
"generic noalias memory-access sets. This means that some collection of "
"memory access instructions (loads, stores, memory-accessing calls, etc.) "
"that carry ``noalias`` metadata can specifically be specified not to "
"alias with some other collection of memory access instructions that carry"
" ``alias.scope`` metadata. Each type of metadata specifies a list of "
"scopes where each scope has an id and a domain. When evaluating an "
"aliasing query, if for some domain, the set of scopes with that domain in"
" one instruction's ``alias.scope`` list is a subset of (or equal to) the "
"set of scopes for that domain in another instruction's ``noalias`` list, "
"then the two memory accesses are assumed not to alias."
msgstr ""

#: ../../LangRef.rst:4271
msgid ""
"The metadata identifying each domain is itself a list containing one or "
"two entries. The first entry is the name of the domain. Note that if the "
"name is a string then it can be combined across functions and translation"
" units. A self-reference can be used to create globally unique domain "
"names. A descriptive string may optionally be provided as a second list "
"entry."
msgstr ""

#: ../../LangRef.rst:4277
msgid ""
"The metadata identifying each scope is also itself a list containing two "
"or three entries. The first entry is the name of the scope. Note that if "
"the name is a string then it can be combined across functions and "
"translation units. A self-reference can be used to create globally unique"
" scope names. A metadata reference to the scope's domain is the second "
"entry. A descriptive string may optionally be provided as a third list "
"entry."
msgstr ""

#: ../../LangRef.rst:4284
msgid "For example,"
msgstr ""

#: ../../LangRef.rst:4318
msgid "'``fpmath``' Metadata"
msgstr ""

#: ../../LangRef.rst:4320
msgid ""
"``fpmath`` metadata may be attached to any instruction of floating point "
"type. It can be used to express the maximum acceptable error in the "
"result of that instruction, in ULPs, thus potentially allowing the "
"compiler to use a more efficient but less accurate method of computing "
"it. ULP is defined as follows:"
msgstr ""

#: ../../LangRef.rst:4326
msgid ""
"If ``x`` is a real number that lies between two finite consecutive "
"floating-point numbers ``a`` and ``b``, without being equal to one of "
"them, then ``ulp(x) = |b - a|``, otherwise ``ulp(x)`` is the distance "
"between the two non-equal finite floating-point numbers nearest ``x``. "
"Moreover, ``ulp(NaN)`` is ``NaN``."
msgstr ""

#: ../../LangRef.rst:4332
msgid ""
"The metadata node shall consist of a single positive floating point "
"number representing the maximum relative error, for example:"
msgstr ""

#: ../../LangRef.rst:4342
msgid "'``range``' Metadata"
msgstr ""

#: ../../LangRef.rst:4344
msgid ""
"``range`` metadata may be attached only to ``load``, ``call`` and "
"``invoke`` of integer types. It expresses the possible ranges the loaded "
"value or the value returned by the called function at this call site is "
"in. The ranges are represented with a flattened list of integers. The "
"loaded value or the value returned is known to be in the union of the "
"ranges defined by each consecutive pair. Each pair has the following "
"properties:"
msgstr ""

#: ../../LangRef.rst:4351
msgid "The type must match the type loaded by the instruction."
msgstr ""

#: ../../LangRef.rst:4352
msgid "The pair ``a,b`` represents the range ``[a,b)``."
msgstr ""

#: ../../LangRef.rst:4353
msgid "Both ``a`` and ``b`` are constants."
msgstr ""

#: ../../LangRef.rst:4354
msgid "The range is allowed to wrap."
msgstr ""

#: ../../LangRef.rst:4355
msgid "The range should not represent the full or empty set. That is, ``a!=b``."
msgstr ""

#: ../../LangRef.rst:4358
msgid ""
"In addition, the pairs must be in signed order of the lower bound and "
"they must be non-contiguous."
msgstr ""

#: ../../LangRef.rst:4377
msgid "'``unpredictable``' Metadata"
msgstr ""

#: ../../LangRef.rst:4379
msgid ""
"``unpredictable`` metadata may be attached to any branch or switch "
"instruction. It can be used to express the unpredictability of control "
"flow. Similar to the llvm.expect intrinsic, it may be used to alter "
"optimizations related to compare and branch instructions. The metadata is"
" treated as a boolean value; if it exists, it signals that the branch or "
"switch that it is attached to is completely unpredictable."
msgstr ""

#: ../../LangRef.rst:4387
msgid "'``llvm.loop``'"
msgstr ""

#: ../../LangRef.rst:4389
msgid ""
"It is sometimes useful to attach information to loop constructs. "
"Currently, loop metadata is implemented as metadata attached to the "
"branch instruction in the loop latch block. This type of metadata refer "
"to a metadata node that is guaranteed to be separate for each loop. The "
"loop identifier metadata is specified with the name ``llvm.loop``."
msgstr ""

#: ../../LangRef.rst:4395
msgid ""
"The loop identifier metadata is implemented using a metadata that refers "
"to itself to avoid merging it with any other identifier metadata, e.g., "
"during module linkage or function inlining. That is, each loop should "
"refer to their own identification metadata even if they reside in "
"separate functions. The following example contains loop identifier "
"metadata for two separate loop constructs:"
msgstr ""

#: ../../LangRef.rst:4407
msgid ""
"The loop identifier metadata can be used to specify additional per-loop "
"metadata. Any operands after the first operand can be treated as user-"
"defined metadata. For example the ``llvm.loop.unroll.count`` suggests an "
"unroll factor to the loop unroller:"
msgstr ""

#: ../../LangRef.rst:4420
msgid "'``llvm.loop.vectorize``' and '``llvm.loop.interleave``'"
msgstr ""

#: ../../LangRef.rst:4422
msgid ""
"Metadata prefixed with ``llvm.loop.vectorize`` or "
"``llvm.loop.interleave`` are used to control per-loop vectorization and "
"interleaving parameters such as vectorization width and interleave count."
" These metadata should be used in conjunction with ``llvm.loop`` loop "
"identification metadata. The ``llvm.loop.vectorize`` and "
"``llvm.loop.interleave`` metadata are only optimization hints and the "
"optimizer will only interleave and vectorize loops if it believes it is "
"safe to do so. The ``llvm.mem.parallel_loop_access`` metadata which "
"contains information about loop-carried memory dependencies can be "
"helpful in determining the safety of these transformations."
msgstr ""

#: ../../LangRef.rst:4433
msgid "'``llvm.loop.interleave.count``' Metadata"
msgstr ""

#: ../../LangRef.rst:4435
msgid ""
"This metadata suggests an interleave count to the loop interleaver. The "
"first operand is the string ``llvm.loop.interleave.count`` and the second"
" operand is an integer specifying the interleave count. For example:"
msgstr ""

#: ../../LangRef.rst:4444
msgid ""
"Note that setting ``llvm.loop.interleave.count`` to 1 disables "
"interleaving multiple iterations of the loop. If "
"``llvm.loop.interleave.count`` is set to 0 then the interleave count will"
" be determined automatically."
msgstr ""

#: ../../LangRef.rst:4449
msgid "'``llvm.loop.vectorize.enable``' Metadata"
msgstr ""

#: ../../LangRef.rst:4451
msgid ""
"This metadata selectively enables or disables vectorization for the loop."
" The first operand is the string ``llvm.loop.vectorize.enable`` and the "
"second operand is a bit. If the bit operand value is 1 vectorization is "
"enabled. A value of 0 disables vectorization:"
msgstr ""

#: ../../LangRef.rst:4462
msgid "'``llvm.loop.vectorize.width``' Metadata"
msgstr ""

#: ../../LangRef.rst:4464
msgid ""
"This metadata sets the target width of the vectorizer. The first operand "
"is the string ``llvm.loop.vectorize.width`` and the second operand is an "
"integer specifying the width. For example:"
msgstr ""

#: ../../LangRef.rst:4472
msgid ""
"Note that setting ``llvm.loop.vectorize.width`` to 1 disables "
"vectorization of the loop. If ``llvm.loop.vectorize.width`` is set to 0 "
"or if the loop does not have this metadata the width will be determined "
"automatically."
msgstr ""

#: ../../LangRef.rst:4478
msgid "'``llvm.loop.unroll``'"
msgstr ""

#: ../../LangRef.rst:4480
msgid ""
"Metadata prefixed with ``llvm.loop.unroll`` are loop unrolling "
"optimization hints such as the unroll factor. ``llvm.loop.unroll`` "
"metadata should be used in conjunction with ``llvm.loop`` loop "
"identification metadata. The ``llvm.loop.unroll`` metadata are only "
"optimization hints and the unrolling will only be performed if the "
"optimizer believes it is safe to do so."
msgstr ""

#: ../../LangRef.rst:4488
msgid "'``llvm.loop.unroll.count``' Metadata"
msgstr ""

#: ../../LangRef.rst:4490
msgid ""
"This metadata suggests an unroll factor to the loop unroller. The first "
"operand is the string ``llvm.loop.unroll.count`` and the second operand "
"is a positive integer specifying the unroll factor. For example:"
msgstr ""

#: ../../LangRef.rst:4499
msgid ""
"If the trip count of the loop is less than the unroll count the loop will"
" be partially unrolled."
msgstr ""

#: ../../LangRef.rst:4503
msgid "'``llvm.loop.unroll.disable``' Metadata"
msgstr ""

#: ../../LangRef.rst:4505
msgid ""
"This metadata disables loop unrolling. The metadata has a single operand "
"which is the string ``llvm.loop.unroll.disable``. For example:"
msgstr ""

#: ../../LangRef.rst:4513
msgid "'``llvm.loop.unroll.runtime.disable``' Metadata"
msgstr ""

#: ../../LangRef.rst:4515
msgid ""
"This metadata disables runtime loop unrolling. The metadata has a single "
"operand which is the string ``llvm.loop.unroll.runtime.disable``. For "
"example:"
msgstr ""

#: ../../LangRef.rst:4523
msgid "'``llvm.loop.unroll.enable``' Metadata"
msgstr ""

#: ../../LangRef.rst:4525
msgid ""
"This metadata suggests that the loop should be fully unrolled if the trip"
" count is known at compile time and partially unrolled if the trip count "
"is not known at compile time. The metadata has a single operand which is "
"the string ``llvm.loop.unroll.enable``.  For example:"
msgstr ""

#: ../../LangRef.rst:4535
msgid "'``llvm.loop.unroll.full``' Metadata"
msgstr ""

#: ../../LangRef.rst:4537
msgid ""
"This metadata suggests that the loop should be unrolled fully. The "
"metadata has a single operand which is the string "
"``llvm.loop.unroll.full``. For example:"
msgstr ""

#: ../../LangRef.rst:4546
msgid "'``llvm.mem``'"
msgstr ""

#: ../../LangRef.rst:4548
msgid ""
"Metadata types used to annotate memory accesses with information helpful "
"for optimizations are prefixed with ``llvm.mem``."
msgstr ""

#: ../../LangRef.rst:4552
msgid "'``llvm.mem.parallel_loop_access``' Metadata"
msgstr ""

#: ../../LangRef.rst:4554
msgid ""
"The ``llvm.mem.parallel_loop_access`` metadata refers to a loop "
"identifier, or metadata containing a list of loop identifiers for nested "
"loops. The metadata is attached to memory accessing instructions and "
"denotes that no loop carried memory dependence exist between it and other"
" instructions denoted with the same loop identifier."
msgstr ""

#: ../../LangRef.rst:4560
msgid ""
"Precisely, given two instructions ``m1`` and ``m2`` that both have the "
"``llvm.mem.parallel_loop_access`` metadata, with ``L1`` and ``L2`` being "
"the set of loops associated with that metadata, respectively, then there "
"is no loop carried dependence between ``m1`` and ``m2`` for loops in both"
" ``L1`` and ``L2``."
msgstr ""

#: ../../LangRef.rst:4566
msgid ""
"As a special case, if all memory accessing instructions in a loop have "
"``llvm.mem.parallel_loop_access`` metadata that refers to that loop, then"
" the loop has no loop carried memory dependences and is considered to be "
"a parallel loop."
msgstr ""

#: ../../LangRef.rst:4571
msgid ""
"Note that if not all memory access instructions have such metadata "
"referring to the loop, then the loop is considered not being trivially "
"parallel. Additional memory dependence analysis is required to make that "
"determination. As a fail safe mechanism, this causes loops that were "
"originally parallel to be considered sequential (if optimization passes "
"that are unaware of the parallel semantics insert new memory instructions"
" into the loop body)."
msgstr ""

#: ../../LangRef.rst:4578
msgid ""
"Example of a loop that is considered parallel due to its correct use of "
"both ``llvm.loop`` and ``llvm.mem.parallel_loop_access`` metadata types "
"that refer to the same loop identifier metadata."
msgstr ""

#: ../../LangRef.rst:4596
msgid ""
"It is also possible to have nested parallel loops. In that case the "
"memory accesses refer to a list of loop identifier metadata nodes instead"
" of the loop identifier metadata node directly:"
msgstr ""

#: ../../LangRef.rst:4629
msgid "'``llvm.bitsets``'"
msgstr ""

#: ../../LangRef.rst:4631
msgid ""
"The ``llvm.bitsets`` global metadata is used to implement :doc:`bitsets "
"<BitSets>`."
msgstr ""

#: ../../LangRef.rst:4635
msgid "'``invariant.group``' Metadata"
msgstr ""

#: ../../LangRef.rst:4637
msgid ""
"The ``invariant.group`` metadata may be attached to ``load``/``store`` "
"instructions. The existence of the ``invariant.group`` metadata on the "
"instruction tells the optimizer that every ``load`` and ``store`` to the "
"same pointer operand within the same invariant group can be assumed to "
"load or store the same value (but see the "
"``llvm.invariant.group.barrier`` intrinsic which affects when two "
"pointers are considered the same)."
msgstr ""

#: ../../LangRef.rst:4679
msgid "Module Flags Metadata"
msgstr ""

#: ../../LangRef.rst:4681
msgid ""
"Information about the module as a whole is difficult to convey to LLVM's "
"subsystems. The LLVM IR isn't sufficient to transmit this information. "
"The ``llvm.module.flags`` named metadata exists in order to facilitate "
"this. These flags are in the form of key / value pairs --- much like a "
"dictionary --- making it easy for any subsystem who cares about a flag to"
" look it up."
msgstr ""

#: ../../LangRef.rst:4688
msgid ""
"The ``llvm.module.flags`` metadata contains a list of metadata triplets. "
"Each triplet has the following form:"
msgstr ""

#: ../../LangRef.rst:4691
msgid ""
"The first element is a *behavior* flag, which specifies the behavior when"
" two (or more) modules are merged together, and it encounters two (or "
"more) metadata with the same ID. The supported behaviors are described "
"below."
msgstr ""

#: ../../LangRef.rst:4695
msgid ""
"The second element is a metadata string that is a unique ID for the "
"metadata. Each module may only have one flag entry for each unique ID "
"(not including entries with the **Require** behavior)."
msgstr ""

#: ../../LangRef.rst:4698
msgid "The third element is the value of the flag."
msgstr ""

#: ../../LangRef.rst:4700
msgid ""
"When two (or more) modules are merged together, the resulting "
"``llvm.module.flags`` metadata is the union of the modules' flags. That "
"is, for each unique metadata ID string, there will be exactly one entry "
"in the merged modules ``llvm.module.flags`` metadata table, and the value"
" for that entry will be determined by the merge behavior flag, as "
"described below. The only exception is that entries with the *Require* "
"behavior are always preserved."
msgstr ""

#: ../../LangRef.rst:4707
msgid "The following behaviors are supported:"
msgstr ""

#: ../../LangRef.rst:4713 ../../LangRef.rst:4810 ../../LangRef.rst:4895
msgid "Value"
msgstr ""

#: ../../LangRef.rst:4714
msgid "Behavior"
msgstr ""

#: ../../LangRef.rst:4716 ../../LangRef.rst:6331 ../../LangRef.rst:6333
#: ../../LangRef.rst:6335 ../../LangRef.rst:6380 ../../LangRef.rst:6382
#: ../../LangRef.rst:6384 ../../LangRef.rst:6430 ../../LangRef.rst:6432
#: ../../LangRef.rst:6434
msgid "1"
msgstr ""

#: ../../LangRef.rst:4719
msgid "**Error**"
msgstr ""

#: ../../LangRef.rst:4718
msgid ""
"Emits an error if two values disagree, otherwise the resulting value is "
"that of the operands."
msgstr ""

#: ../../LangRef.rst:4721
msgid "2"
msgstr ""

#: ../../LangRef.rst:4724
msgid "**Warning**"
msgstr ""

#: ../../LangRef.rst:4723
msgid ""
"Emits a warning if two values disagree. The result value will be the "
"operand for the flag from the first module being linked."
msgstr ""

#: ../../LangRef.rst:4726
msgid "3"
msgstr ""

#: ../../LangRef.rst:4734
msgid "**Require**"
msgstr ""

#: ../../LangRef.rst:4728
msgid ""
"Adds a requirement that another module flag be present and have a "
"specified value after linking is performed. The value must be a metadata "
"pair, where the first element of the pair is the ID of the module flag to"
" be restricted, and the second element of the pair is the value the "
"module flag should be restricted to. This behavior can be used to "
"restrict the allowable results (via triggering of an error) of linking "
"IDs with the **Override** behavior."
msgstr ""

#: ../../LangRef.rst:4736
msgid "4"
msgstr ""

#: ../../LangRef.rst:4740
msgid "**Override**"
msgstr ""

#: ../../LangRef.rst:4738
msgid ""
"Uses the specified value, regardless of the behavior or value of the "
"other module. If both modules specify **Override**, but the values "
"differ, an error will be emitted."
msgstr ""

#: ../../LangRef.rst:4742
msgid "5"
msgstr ""

#: ../../LangRef.rst:4744
msgid "**Append**"
msgstr ""

#: ../../LangRef.rst:4744
msgid "Appends the two values, which are required to be metadata nodes."
msgstr ""

#: ../../LangRef.rst:4746
msgid "6"
msgstr ""

#: ../../LangRef.rst:4749
msgid "**AppendUnique**"
msgstr ""

#: ../../LangRef.rst:4748
msgid ""
"Appends the two values, which are required to be metadata nodes. However,"
" duplicate entries in the second list are dropped during the append "
"operation."
msgstr ""

#: ../../LangRef.rst:4752
msgid ""
"It is an error for a particular unique flag ID to have multiple "
"behaviors, except in the case of **Require** (which adds restrictions on "
"another metadata value) or **Override**."
msgstr ""

#: ../../LangRef.rst:4756
msgid "An example of module flags:"
msgstr ""

#: ../../LangRef.rst:4770
msgid ""
"Metadata ``!0`` has the ID ``!\"foo\"`` and the value '1'. The behavior "
"if two or more ``!\"foo\"`` flags are seen is to emit an error if their "
"values are not equal."
msgstr ""

#: ../../LangRef.rst:4774
msgid ""
"Metadata ``!1`` has the ID ``!\"bar\"`` and the value '37'. The behavior "
"if two or more ``!\"bar\"`` flags are seen is to use the value '37'."
msgstr ""

#: ../../LangRef.rst:4778
msgid ""
"Metadata ``!2`` has the ID ``!\"qux\"`` and the value '42'. The behavior "
"if two or more ``!\"qux\"`` flags are seen is to emit a warning if their "
"values are not equal."
msgstr ""

#: ../../LangRef.rst:4782
msgid "Metadata ``!3`` has the ID ``!\"qux\"`` and the value:"
msgstr ""

#: ../../LangRef.rst:4788
msgid ""
"The behavior is to emit an error if the ``llvm.module.flags`` does not "
"contain a flag with the ID ``!\"foo\"`` that has the value '1' after "
"linking is performed."
msgstr ""

#: ../../LangRef.rst:4793
msgid "Objective-C Garbage Collection Module Flags Metadata"
msgstr ""

#: ../../LangRef.rst:4795
msgid ""
"On the Mach-O platform, Objective-C stores metadata about garbage "
"collection in a special section called \"image info\". The metadata "
"consists of a version number and a bitmask specifying what types of "
"garbage collection are supported (if any) by the file. If two or more "
"modules are linked together their garbage collection metadata needs to be"
" merged rather than appended together."
msgstr ""

#: ../../LangRef.rst:4802
msgid ""
"The Objective-C garbage collection module flags metadata consists of the "
"following key-value pairs:"
msgstr ""

#: ../../LangRef.rst:4809 ../../LangRef.rst:4894
msgid "Key"
msgstr ""

#: ../../LangRef.rst:4812
msgid "``Objective-C Version``"
msgstr ""

#: ../../LangRef.rst:4813
msgid "**[Required]** --- The Objective-C ABI version. Valid values are 1 and 2."
msgstr ""

#: ../../LangRef.rst:4815
msgid "``Objective-C Image Info Version``"
msgstr ""

#: ../../LangRef.rst:4816
msgid ""
"**[Required]** --- The version of the image info section. Currently "
"always 0."
msgstr ""

#: ../../LangRef.rst:4819
msgid "``Objective-C Image Info Section``"
msgstr ""

#: ../../LangRef.rst:4820
msgid ""
"**[Required]** --- The section to place the metadata. Valid values are "
"``\"__OBJC, __image_info, regular\"`` for Objective-C ABI version 1, and "
"``\"__DATA,__objc_imageinfo, regular, no_dead_strip\"`` for Objective-C "
"ABI version 2."
msgstr ""

#: ../../LangRef.rst:4825
msgid "``Objective-C Garbage Collection``"
msgstr ""

#: ../../LangRef.rst:4826
msgid ""
"**[Required]** --- Specifies whether garbage collection is supported or "
"not. Valid values are 0, for no garbage collection, and 2, for garbage "
"collection supported."
msgstr ""

#: ../../LangRef.rst:4830
msgid "``Objective-C GC Only``"
msgstr ""

#: ../../LangRef.rst:4831
msgid ""
"**[Optional]** --- Specifies that only garbage collection is supported. "
"If present, its value must be 6. This flag requires that the "
"``Objective-C Garbage Collection`` flag have the value 2."
msgstr ""

#: ../../LangRef.rst:4835
msgid "Some important flag interactions:"
msgstr ""

#: ../../LangRef.rst:4837
msgid ""
"If a module with ``Objective-C Garbage Collection`` set to 0 is merged "
"with a module with ``Objective-C Garbage Collection`` set to 2, then the "
"resulting module has the ``Objective-C Garbage Collection`` flag set to "
"0."
msgstr ""

#: ../../LangRef.rst:4841
msgid ""
"A module with ``Objective-C Garbage Collection`` set to 0 cannot be "
"merged with a module with ``Objective-C GC Only`` set to 6."
msgstr ""

#: ../../LangRef.rst:4845
msgid "Automatic Linker Flags Module Flags Metadata"
msgstr ""

#: ../../LangRef.rst:4847
msgid ""
"Some targets support embedding flags to the linker inside individual "
"object files. Typically this is used in conjunction with language "
"extensions which allow source files to explicitly declare the libraries "
"they depend on, and have these automatically be transmitted to the linker"
" via object files."
msgstr ""

#: ../../LangRef.rst:4852
msgid ""
"These flags are encoded in the IR using metadata in the module flags "
"section, using the ``Linker Options`` key. The merge behavior for this "
"flag is required to be ``AppendUnique``, and the value for the key is "
"expected to be a metadata node which should be a list of other metadata "
"nodes, each of which should be a list of metadata strings defining linker"
" options."
msgstr ""

#: ../../LangRef.rst:4858
msgid ""
"For example, the following metadata section specifies two separate sets "
"of linker options, presumably to link against ``libz`` and the ``Cocoa`` "
"framework::"
msgstr ""

#: ../../LangRef.rst:4868
msgid ""
"The metadata encoding as lists of lists of options, as opposed to a "
"collapsed list of options, is chosen so that the IR encoding can use "
"multiple option strings to specify e.g., a single library, while still "
"having that specifier be preserved as an atomic element that can be "
"recognized by a target specific assembly writer or object file emitter."
msgstr ""

#: ../../LangRef.rst:4874
msgid ""
"Each individual option is required to be either a valid option for the "
"target's linker, or an option that is reserved by the target specific "
"assembly writer or object file emitter. No other aspect of these options "
"is defined by the IR."
msgstr ""

#: ../../LangRef.rst:4879
msgid "C type width Module Flags Metadata"
msgstr ""

#: ../../LangRef.rst:4881
msgid ""
"The ARM backend emits a section into each generated object file "
"describing the options that it was compiled with (in a compiler-"
"independent way) to prevent linking incompatible objects, and to allow "
"automatic library selection. Some of these options are not visible at the"
" IR level, namely wchar_t width and enum width."
msgstr ""

#: ../../LangRef.rst:4887
msgid ""
"To pass this information to the backend, these options are encoded in "
"module flags metadata, using the following key-value pairs:"
msgstr ""

#: ../../LangRef.rst:4897
msgid "short_wchar"
msgstr ""

#: ../../LangRef.rst:4898
msgid "0 --- sizeof(wchar_t) == 4"
msgstr ""

#: ../../LangRef.rst:4899
msgid "1 --- sizeof(wchar_t) == 2"
msgstr ""

#: ../../LangRef.rst:4901
msgid "short_enum"
msgstr ""

#: ../../LangRef.rst:4902
msgid "0 --- Enums are at least as large as an ``int``."
msgstr ""

#: ../../LangRef.rst:4903
msgid ""
"1 --- Enums are stored in the smallest integer type which can represent "
"all of its values."
msgstr ""

#: ../../LangRef.rst:4906
msgid ""
"For example, the following metadata section specifies that the module was"
" compiled with a ``wchar_t`` width of 4 bytes, and the underlying type of"
" an enum is the smallest type which can represent all of its values::"
msgstr ""

#: ../../LangRef.rst:4917
msgid "Intrinsic Global Variables"
msgstr ""

#: ../../LangRef.rst:4919
msgid ""
"LLVM has a number of \"magic\" global variables that contain data that "
"affect code generation or other IR semantics. These are documented here. "
"All globals of this sort should have a section specified as "
"\"``llvm.metadata``\". This section and all globals that start with "
"\"``llvm.``\" are reserved for use by LLVM."
msgstr ""

#: ../../LangRef.rst:4928
msgid "The '``llvm.used``' Global Variable"
msgstr ""

#: ../../LangRef.rst:4930
msgid ""
"The ``@llvm.used`` global is an array which has :ref:`appending linkage "
"<linkage_appending>`. This array contains a list of pointers to named "
"global variables, functions and aliases which may optionally have a "
"pointer cast formed of bitcast or getelementptr. For example, a legal use"
" of it is:"
msgstr ""

#: ../../LangRef.rst:4946
msgid ""
"If a symbol appears in the ``@llvm.used`` list, then the compiler, "
"assembler, and linker are required to treat the symbol as if there is a "
"reference to the symbol that it cannot see (which is why they have to be "
"named). For example, if a variable has internal linkage and no references"
" other than that from the ``@llvm.used`` list, it cannot be deleted. This"
" is commonly used to represent references from inline asms and other "
"things the compiler cannot \"see\", and corresponds to "
"\"``attribute((used))``\" in GNU C."
msgstr ""

#: ../../LangRef.rst:4954
msgid ""
"On some targets, the code generator must emit a directive to the "
"assembler or object file to prevent the assembler and linker from "
"molesting the symbol."
msgstr ""

#: ../../LangRef.rst:4961
msgid "The '``llvm.compiler.used``' Global Variable"
msgstr ""

#: ../../LangRef.rst:4963
msgid ""
"The ``@llvm.compiler.used`` directive is the same as the ``@llvm.used`` "
"directive, except that it only prevents the compiler from touching the "
"symbol. On targets that support it, this allows an intelligent linker to "
"optimize references to the symbol without being impeded as it would be by"
" ``@llvm.used``."
msgstr ""

#: ../../LangRef.rst:4969
msgid ""
"This is a rare construct that should only be used in rare circumstances, "
"and should not be exposed to source languages."
msgstr ""

#: ../../LangRef.rst:4975
msgid "The '``llvm.global_ctors``' Global Variable"
msgstr ""

#: ../../LangRef.rst:4982
msgid ""
"The ``@llvm.global_ctors`` array contains a list of constructor "
"functions, priorities, and an optional associated global or function. The"
" functions referenced by this array will be called in ascending order of "
"priority (i.e. lowest first) when the module is loaded. The order of "
"functions with the same priority is not defined."
msgstr ""

#: ../../LangRef.rst:4988
msgid ""
"If the third field is present, non-null, and points to a global variable "
"or function, the initializer function will only run if the associated "
"data from the current module is not discarded."
msgstr ""

#: ../../LangRef.rst:4995
msgid "The '``llvm.global_dtors``' Global Variable"
msgstr ""

#: ../../LangRef.rst:5002
msgid ""
"The ``@llvm.global_dtors`` array contains a list of destructor functions,"
" priorities, and an optional associated global or function. The functions"
" referenced by this array will be called in descending order of priority "
"(i.e. highest first) when the module is unloaded. The order of functions "
"with the same priority is not defined."
msgstr ""

#: ../../LangRef.rst:5008
msgid ""
"If the third field is present, non-null, and points to a global variable "
"or function, the destructor function will only run if the associated data"
" from the current module is not discarded."
msgstr ""

#: ../../LangRef.rst:5013
msgid "Instruction Reference"
msgstr ""

#: ../../LangRef.rst:5015
msgid ""
"The LLVM instruction set consists of several different classifications of"
" instructions: :ref:`terminator instructions <terminators>`, :ref:`binary"
" instructions <binaryops>`, :ref:`bitwise binary instructions "
"<bitwiseops>`, :ref:`memory instructions <memoryops>`, and :ref:`other "
"instructions <otherops>`."
msgstr ""

#: ../../LangRef.rst:5024
msgid "Terminator Instructions"
msgstr ""

#: ../../LangRef.rst:5026
msgid ""
"As mentioned :ref:`previously <functionstructure>`, every basic block in "
"a program ends with a \"Terminator\" instruction, which indicates which "
"block should be executed after the current block is finished. These "
"terminator instructions typically yield a '``void``' value: they produce "
"control flow, not values (the one exception being the ':ref:`invoke "
"<i_invoke>`' instruction)."
msgstr ""

#: ../../LangRef.rst:5033
msgid ""
"The terminator instructions are: ':ref:`ret <i_ret>`', ':ref:`br "
"<i_br>`', ':ref:`switch <i_switch>`', ':ref:`indirectbr <i_indirectbr>`',"
" ':ref:`invoke <i_invoke>`', ':ref:`resume <i_resume>`', "
"':ref:`catchswitch <i_catchswitch>`', ':ref:`catchret <i_catchret>`', "
"':ref:`cleanupret <i_cleanupret>`', and ':ref:`unreachable "
"<i_unreachable>`'."
msgstr ""

#: ../../LangRef.rst:5044
msgid "'``ret``' Instruction"
msgstr ""

#: ../../LangRef.rst:5047 ../../LangRef.rst:5104 ../../LangRef.rst:5153
#: ../../LangRef.rst:5215 ../../LangRef.rst:5266 ../../LangRef.rst:5361
#: ../../LangRef.rst:5400 ../../LangRef.rst:5456 ../../LangRef.rst:5504
#: ../../LangRef.rst:5555 ../../LangRef.rst:5593 ../../LangRef.rst:5644
#: ../../LangRef.rst:5681 ../../LangRef.rst:5736 ../../LangRef.rst:5777
#: ../../LangRef.rst:5832 ../../LangRef.rst:5869 ../../LangRef.rst:5913
#: ../../LangRef.rst:5961 ../../LangRef.rst:5998 ../../LangRef.rst:6040
#: ../../LangRef.rst:6097 ../../LangRef.rst:6146 ../../LangRef.rst:6201
#: ../../LangRef.rst:6251 ../../LangRef.rst:6302 ../../LangRef.rst:6351
#: ../../LangRef.rst:6400 ../../LangRef.rst:6463 ../../LangRef.rst:6503
#: ../../LangRef.rst:6545 ../../LangRef.rst:6606 ../../LangRef.rst:6652
#: ../../LangRef.rst:6707 ../../LangRef.rst:6765 ../../LangRef.rst:6891
#: ../../LangRef.rst:6972 ../../LangRef.rst:7028 ../../LangRef.rst:7114
#: ../../LangRef.rst:7187 ../../LangRef.rst:7394 ../../LangRef.rst:7436
#: ../../LangRef.rst:7476 ../../LangRef.rst:7517 ../../LangRef.rst:7558
#: ../../LangRef.rst:7598 ../../LangRef.rst:7640 ../../LangRef.rst:7682
#: ../../LangRef.rst:7723 ../../LangRef.rst:7766 ../../LangRef.rst:7812
#: ../../LangRef.rst:7857 ../../LangRef.rst:7909 ../../LangRef.rst:7962
#: ../../LangRef.rst:8053 ../../LangRef.rst:8168 ../../LangRef.rst:8222
#: ../../LangRef.rst:8269 ../../LangRef.rst:8404 ../../LangRef.rst:8455
#: ../../LangRef.rst:8539 ../../LangRef.rst:8607 ../../LangRef.rst:8772
#: ../../LangRef.rst:8804 ../../LangRef.rst:8837 ../../LangRef.rst:8896
#: ../../LangRef.rst:8931 ../../LangRef.rst:8967 ../../LangRef.rst:9007
#: ../../LangRef.rst:9045 ../../LangRef.rst:9082 ../../LangRef.rst:9135
#: ../../LangRef.rst:9179 ../../LangRef.rst:9211 ../../LangRef.rst:9237
#: ../../LangRef.rst:9277 ../../LangRef.rst:9314 ../../LangRef.rst:9347
#: ../../LangRef.rst:9378 ../../LangRef.rst:9411 ../../LangRef.rst:9455
#: ../../LangRef.rst:9514 ../../LangRef.rst:9567 ../../LangRef.rst:9622
#: ../../LangRef.rst:9673 ../../LangRef.rst:9713 ../../LangRef.rst:9751
#: ../../LangRef.rst:9787 ../../LangRef.rst:9823 ../../LangRef.rst:9860
#: ../../LangRef.rst:9895 ../../LangRef.rst:9930 ../../LangRef.rst:9965
#: ../../LangRef.rst:10000 ../../LangRef.rst:10035 ../../LangRef.rst:10071
#: ../../LangRef.rst:10107 ../../LangRef.rst:10149 ../../LangRef.rst:10190
#: ../../LangRef.rst:10226 ../../LangRef.rst:10261 ../../LangRef.rst:10296
#: ../../LangRef.rst:10332 ../../LangRef.rst:10369 ../../LangRef.rst:10405
#: ../../LangRef.rst:10447 ../../LangRef.rst:10475 ../../LangRef.rst:10510
#: ../../LangRef.rst:10548 ../../LangRef.rst:10595 ../../LangRef.rst:10649
#: ../../LangRef.rst:10699 ../../LangRef.rst:10748 ../../LangRef.rst:10798
#: ../../LangRef.rst:10848 ../../LangRef.rst:10898 ../../LangRef.rst:10951
#: ../../LangRef.rst:11020 ../../LangRef.rst:11087 ../../LangRef.rst:11127
#: ../../LangRef.rst:11215 ../../LangRef.rst:11261 ../../LangRef.rst:11302
#: ../../LangRef.rst:11347 ../../LangRef.rst:11397 ../../LangRef.rst:11451
#: ../../LangRef.rst:11509 ../../LangRef.rst:11542 ../../LangRef.rst:11573
#: ../../LangRef.rst:11603 ../../LangRef.rst:11632 ../../LangRef.rst:11668
#: ../../LangRef.rst:11698 ../../LangRef.rst:11738 ../../LangRef.rst:11776
#: ../../LangRef.rst:11803 ../../LangRef.rst:11830 ../../LangRef.rst:11866
#: ../../LangRef.rst:11904 ../../LangRef.rst:11942 ../../LangRef.rst:11977
#: ../../LangRef.rst:12019 ../../LangRef.rst:12042
msgid "Syntax:"
msgstr ""

#: ../../LangRef.rst:5055 ../../LangRef.rst:5112 ../../LangRef.rst:5160
#: ../../LangRef.rst:5222 ../../LangRef.rst:5274 ../../LangRef.rst:5368
#: ../../LangRef.rst:5408 ../../LangRef.rst:5463 ../../LangRef.rst:5512
#: ../../LangRef.rst:5562 ../../LangRef.rst:5603 ../../LangRef.rst:5651
#: ../../LangRef.rst:5691 ../../LangRef.rst:5743 ../../LangRef.rst:5787
#: ../../LangRef.rst:5839 ../../LangRef.rst:5877 ../../LangRef.rst:5921
#: ../../LangRef.rst:5968 ../../LangRef.rst:6005 ../../LangRef.rst:6047
#: ../../LangRef.rst:6104 ../../LangRef.rst:6156 ../../LangRef.rst:6209
#: ../../LangRef.rst:6259 ../../LangRef.rst:6309 ../../LangRef.rst:6358
#: ../../LangRef.rst:6407 ../../LangRef.rst:6470 ../../LangRef.rst:6510
#: ../../LangRef.rst:6552 ../../LangRef.rst:6613 ../../LangRef.rst:6659
#: ../../LangRef.rst:6714 ../../LangRef.rst:6776 ../../LangRef.rst:6899
#: ../../LangRef.rst:6979 ../../LangRef.rst:7035 ../../LangRef.rst:7121
#: ../../LangRef.rst:7196 ../../LangRef.rst:7401 ../../LangRef.rst:7443
#: ../../LangRef.rst:7483 ../../LangRef.rst:7524 ../../LangRef.rst:7565
#: ../../LangRef.rst:7605 ../../LangRef.rst:7647 ../../LangRef.rst:7689
#: ../../LangRef.rst:7730 ../../LangRef.rst:7773 ../../LangRef.rst:7819
#: ../../LangRef.rst:7864 ../../LangRef.rst:7916 ../../LangRef.rst:7969
#: ../../LangRef.rst:8060 ../../LangRef.rst:8175 ../../LangRef.rst:8231
#: ../../LangRef.rst:8277 ../../LangRef.rst:8411 ../../LangRef.rst:8466
#: ../../LangRef.rst:8546 ../../LangRef.rst:8614 ../../LangRef.rst:8779
#: ../../LangRef.rst:8811 ../../LangRef.rst:8844 ../../LangRef.rst:8903
#: ../../LangRef.rst:8938 ../../LangRef.rst:8974 ../../LangRef.rst:9014
#: ../../LangRef.rst:9052 ../../LangRef.rst:9090 ../../LangRef.rst:9146
#: ../../LangRef.rst:9186 ../../LangRef.rst:9218 ../../LangRef.rst:9284
#: ../../LangRef.rst:9321 ../../LangRef.rst:9354 ../../LangRef.rst:9385
#: ../../LangRef.rst:9419 ../../LangRef.rst:9464 ../../LangRef.rst:9528
#: ../../LangRef.rst:9581 ../../LangRef.rst:9636 ../../LangRef.rst:9688
#: ../../LangRef.rst:9728 ../../LangRef.rst:9766 ../../LangRef.rst:9802
#: ../../LangRef.rst:9838 ../../LangRef.rst:9875 ../../LangRef.rst:9910
#: ../../LangRef.rst:9945 ../../LangRef.rst:9980 ../../LangRef.rst:10015
#: ../../LangRef.rst:10050 ../../LangRef.rst:10086 ../../LangRef.rst:10122
#: ../../LangRef.rst:10164 ../../LangRef.rst:10205 ../../LangRef.rst:10241
#: ../../LangRef.rst:10276 ../../LangRef.rst:10311 ../../LangRef.rst:10347
#: ../../LangRef.rst:10384 ../../LangRef.rst:10420 ../../LangRef.rst:10459
#: ../../LangRef.rst:10487 ../../LangRef.rst:10526 ../../LangRef.rst:10564
#: ../../LangRef.rst:10611 ../../LangRef.rst:10661 ../../LangRef.rst:10711
#: ../../LangRef.rst:10760 ../../LangRef.rst:10810 ../../LangRef.rst:10860
#: ../../LangRef.rst:10910 ../../LangRef.rst:10959 ../../LangRef.rst:11028
#: ../../LangRef.rst:11095 ../../LangRef.rst:11135 ../../LangRef.rst:11222
#: ../../LangRef.rst:11268 ../../LangRef.rst:11315 ../../LangRef.rst:11360
#: ../../LangRef.rst:11407 ../../LangRef.rst:11461 ../../LangRef.rst:11516
#: ../../LangRef.rst:11549 ../../LangRef.rst:11580 ../../LangRef.rst:11610
#: ../../LangRef.rst:11639 ../../LangRef.rst:11675 ../../LangRef.rst:11714
#: ../../LangRef.rst:11752 ../../LangRef.rst:11783 ../../LangRef.rst:11810
#: ../../LangRef.rst:11837 ../../LangRef.rst:11873 ../../LangRef.rst:11912
#: ../../LangRef.rst:11954 ../../LangRef.rst:11984 ../../LangRef.rst:12033
#: ../../LangRef.rst:12049
msgid "Overview:"
msgstr ""

#: ../../LangRef.rst:5057
msgid ""
"The '``ret``' instruction is used to return control flow (and optionally "
"a value) from a function back to the caller."
msgstr ""

#: ../../LangRef.rst:5060
msgid ""
"There are two forms of the '``ret``' instruction: one that returns a "
"value and then causes control flow, and one that just causes control flow"
" to occur."
msgstr ""

#: ../../LangRef.rst:5065 ../../LangRef.rst:5120 ../../LangRef.rst:5168
#: ../../LangRef.rst:5230 ../../LangRef.rst:5296 ../../LangRef.rst:5374
#: ../../LangRef.rst:5415 ../../LangRef.rst:5470 ../../LangRef.rst:5519
#: ../../LangRef.rst:5608 ../../LangRef.rst:5656 ../../LangRef.rst:5699
#: ../../LangRef.rst:5751 ../../LangRef.rst:5792 ../../LangRef.rst:5844
#: ../../LangRef.rst:5882 ../../LangRef.rst:5926 ../../LangRef.rst:5973
#: ../../LangRef.rst:6011 ../../LangRef.rst:6055 ../../LangRef.rst:6110
#: ../../LangRef.rst:6162 ../../LangRef.rst:6215 ../../LangRef.rst:6266
#: ../../LangRef.rst:6315 ../../LangRef.rst:6364 ../../LangRef.rst:6414
#: ../../LangRef.rst:6476 ../../LangRef.rst:6516 ../../LangRef.rst:6559
#: ../../LangRef.rst:6619 ../../LangRef.rst:6665 ../../LangRef.rst:6722
#: ../../LangRef.rst:6781 ../../LangRef.rst:6904 ../../LangRef.rst:6985
#: ../../LangRef.rst:7042 ../../LangRef.rst:7126 ../../LangRef.rst:7204
#: ../../LangRef.rst:7406 ../../LangRef.rst:7448 ../../LangRef.rst:7488
#: ../../LangRef.rst:7529 ../../LangRef.rst:7571 ../../LangRef.rst:7611
#: ../../LangRef.rst:7653 ../../LangRef.rst:7695 ../../LangRef.rst:7736
#: ../../LangRef.rst:7779 ../../LangRef.rst:7825 ../../LangRef.rst:7870
#: ../../LangRef.rst:7922 ../../LangRef.rst:7976 ../../LangRef.rst:8073
#: ../../LangRef.rst:8181 ../../LangRef.rst:8237 ../../LangRef.rst:8282
#: ../../LangRef.rst:8418 ../../LangRef.rst:8476 ../../LangRef.rst:8554
#: ../../LangRef.rst:8630 ../../LangRef.rst:8785 ../../LangRef.rst:8817
#: ../../LangRef.rst:8850 ../../LangRef.rst:8909 ../../LangRef.rst:8945
#: ../../LangRef.rst:8981 ../../LangRef.rst:9021 ../../LangRef.rst:9058
#: ../../LangRef.rst:9098 ../../LangRef.rst:9292 ../../LangRef.rst:9333
#: ../../LangRef.rst:9427 ../../LangRef.rst:9472 ../../LangRef.rst:9538
#: ../../LangRef.rst:9593 ../../LangRef.rst:9646 ../../LangRef.rst:9698
#: ../../LangRef.rst:9736 ../../LangRef.rst:9771 ../../LangRef.rst:9807
#: ../../LangRef.rst:9844 ../../LangRef.rst:9880 ../../LangRef.rst:9915
#: ../../LangRef.rst:9950 ../../LangRef.rst:9985 ../../LangRef.rst:10020
#: ../../LangRef.rst:10056 ../../LangRef.rst:10092 ../../LangRef.rst:10129
#: ../../LangRef.rst:10171 ../../LangRef.rst:10211 ../../LangRef.rst:10246
#: ../../LangRef.rst:10281 ../../LangRef.rst:10317 ../../LangRef.rst:10354
#: ../../LangRef.rst:10390 ../../LangRef.rst:10426 ../../LangRef.rst:10532
#: ../../LangRef.rst:10570 ../../LangRef.rst:10617 ../../LangRef.rst:10668
#: ../../LangRef.rst:10718 ../../LangRef.rst:10767 ../../LangRef.rst:10817
#: ../../LangRef.rst:10867 ../../LangRef.rst:10917 ../../LangRef.rst:11037
#: ../../LangRef.rst:11101 ../../LangRef.rst:11142 ../../LangRef.rst:11228
#: ../../LangRef.rst:11274 ../../LangRef.rst:11321 ../../LangRef.rst:11365
#: ../../LangRef.rst:11413 ../../LangRef.rst:11466 ../../LangRef.rst:11522
#: ../../LangRef.rst:11555 ../../LangRef.rst:11586 ../../LangRef.rst:11616
#: ../../LangRef.rst:11647 ../../LangRef.rst:11680 ../../LangRef.rst:11719
#: ../../LangRef.rst:11757 ../../LangRef.rst:11788 ../../LangRef.rst:11815
#: ../../LangRef.rst:11844 ../../LangRef.rst:11880 ../../LangRef.rst:11922
#: ../../LangRef.rst:11960 ../../LangRef.rst:11991 ../../LangRef.rst:12027
#: ../../LangRef.rst:12056
msgid "Arguments:"
msgstr ""

#: ../../LangRef.rst:5067
msgid ""
"The '``ret``' instruction optionally accepts a single argument, the "
"return value. The type of the return value must be a ':ref:`first class "
"<t_firstclass>`' type."
msgstr ""

#: ../../LangRef.rst:5071
msgid ""
"A function is not :ref:`well formed <wellformed>` if it it has a non-void"
" return type and contains a '``ret``' instruction with no return value or"
" a return value with a type that does not match its type, or if it has a "
"void return type and contains a '``ret``' instruction with a return "
"value."
msgstr ""

#: ../../LangRef.rst:5078 ../../LangRef.rst:5127 ../../LangRef.rst:5176
#: ../../LangRef.rst:5241 ../../LangRef.rst:5328 ../../LangRef.rst:5381
#: ../../LangRef.rst:5430 ../../LangRef.rst:5478 ../../LangRef.rst:5534
#: ../../LangRef.rst:5570 ../../LangRef.rst:5615 ../../LangRef.rst:5663
#: ../../LangRef.rst:5706 ../../LangRef.rst:5758 ../../LangRef.rst:5799
#: ../../LangRef.rst:5851 ../../LangRef.rst:5889 ../../LangRef.rst:5933
#: ../../LangRef.rst:5980 ../../LangRef.rst:6018 ../../LangRef.rst:6062
#: ../../LangRef.rst:6117 ../../LangRef.rst:6169 ../../LangRef.rst:6222
#: ../../LangRef.rst:6273 ../../LangRef.rst:6322 ../../LangRef.rst:6371
#: ../../LangRef.rst:6421 ../../LangRef.rst:6484 ../../LangRef.rst:6525
#: ../../LangRef.rst:6571 ../../LangRef.rst:6634 ../../LangRef.rst:6676
#: ../../LangRef.rst:6737 ../../LangRef.rst:6866 ../../LangRef.rst:6946
#: ../../LangRef.rst:6992 ../../LangRef.rst:7070 ../../LangRef.rst:7153
#: ../../LangRef.rst:7261 ../../LangRef.rst:7415 ../../LangRef.rst:7456
#: ../../LangRef.rst:7496 ../../LangRef.rst:7537 ../../LangRef.rst:7578
#: ../../LangRef.rst:7620 ../../LangRef.rst:7662 ../../LangRef.rst:7704
#: ../../LangRef.rst:7745 ../../LangRef.rst:7787 ../../LangRef.rst:7832
#: ../../LangRef.rst:7882 ../../LangRef.rst:7929 ../../LangRef.rst:7998
#: ../../LangRef.rst:8104 ../../LangRef.rst:8200 ../../LangRef.rst:8244
#: ../../LangRef.rst:8366 ../../LangRef.rst:8426 ../../LangRef.rst:8490
#: ../../LangRef.rst:8571 ../../LangRef.rst:8636 ../../LangRef.rst:8790
#: ../../LangRef.rst:8822 ../../LangRef.rst:8856 ../../LangRef.rst:8917
#: ../../LangRef.rst:8953 ../../LangRef.rst:8989 ../../LangRef.rst:9029
#: ../../LangRef.rst:9066 ../../LangRef.rst:9118 ../../LangRef.rst:9154
#: ../../LangRef.rst:9195 ../../LangRef.rst:9227 ../../LangRef.rst:9256
#: ../../LangRef.rst:9303 ../../LangRef.rst:9338 ../../LangRef.rst:9364
#: ../../LangRef.rst:9393 ../../LangRef.rst:9443 ../../LangRef.rst:9492
#: ../../LangRef.rst:9555 ../../LangRef.rst:9610 ../../LangRef.rst:9662
#: ../../LangRef.rst:9704 ../../LangRef.rst:9742 ../../LangRef.rst:9777
#: ../../LangRef.rst:9813 ../../LangRef.rst:9850 ../../LangRef.rst:9886
#: ../../LangRef.rst:9921 ../../LangRef.rst:9956 ../../LangRef.rst:9991
#: ../../LangRef.rst:10026 ../../LangRef.rst:10062 ../../LangRef.rst:10098
#: ../../LangRef.rst:10135 ../../LangRef.rst:10177 ../../LangRef.rst:10217
#: ../../LangRef.rst:10252 ../../LangRef.rst:10287 ../../LangRef.rst:10323
#: ../../LangRef.rst:10360 ../../LangRef.rst:10396 ../../LangRef.rst:10432
#: ../../LangRef.rst:10466 ../../LangRef.rst:10495 ../../LangRef.rst:10539
#: ../../LangRef.rst:10583 ../../LangRef.rst:10630 ../../LangRef.rst:10677
#: ../../LangRef.rst:10727 ../../LangRef.rst:10776 ../../LangRef.rst:10826
#: ../../LangRef.rst:10876 ../../LangRef.rst:10926 ../../LangRef.rst:11043
#: ../../LangRef.rst:11107 ../../LangRef.rst:11148 ../../LangRef.rst:11240
#: ../../LangRef.rst:11281 ../../LangRef.rst:11327 ../../LangRef.rst:11371
#: ../../LangRef.rst:11419 ../../LangRef.rst:11472 ../../LangRef.rst:11529
#: ../../LangRef.rst:11562 ../../LangRef.rst:11593 ../../LangRef.rst:11624
#: ../../LangRef.rst:11653 ../../LangRef.rst:11687 ../../LangRef.rst:11727
#: ../../LangRef.rst:11765 ../../LangRef.rst:11793 ../../LangRef.rst:11820
#: ../../LangRef.rst:11852 ../../LangRef.rst:11886 ../../LangRef.rst:11931
#: ../../LangRef.rst:11967 ../../LangRef.rst:11996 ../../LangRef.rst:12061
msgid "Semantics:"
msgstr ""

#: ../../LangRef.rst:5080
msgid ""
"When the '``ret``' instruction is executed, control flow returns back to "
"the calling function's context. If the caller is a \":ref:`call "
"<i_call>`\" instruction, execution continues at the instruction after the"
" call. If the caller was an \":ref:`invoke <i_invoke>`\" instruction, "
"execution continues at the beginning of the \"normal\" destination block."
" If the instruction returns a value, that value shall set the call or "
"invoke instruction's return value."
msgstr ""

#: ../../LangRef.rst:5090 ../../LangRef.rst:5135 ../../LangRef.rst:5193
#: ../../LangRef.rst:5254 ../../LangRef.rst:5346 ../../LangRef.rst:5388
#: ../../LangRef.rst:5441 ../../LangRef.rst:5492 ../../LangRef.rst:5542
#: ../../LangRef.rst:5632 ../../LangRef.rst:5671 ../../LangRef.rst:5723
#: ../../LangRef.rst:5766 ../../LangRef.rst:5820 ../../LangRef.rst:5859
#: ../../LangRef.rst:5903 ../../LangRef.rst:5949 ../../LangRef.rst:5988
#: ../../LangRef.rst:6030 ../../LangRef.rst:6085 ../../LangRef.rst:6125
#: ../../LangRef.rst:6187 ../../LangRef.rst:6236 ../../LangRef.rst:6287
#: ../../LangRef.rst:6339 ../../LangRef.rst:6388 ../../LangRef.rst:6438
#: ../../LangRef.rst:6491 ../../LangRef.rst:6533 ../../LangRef.rst:6581
#: ../../LangRef.rst:6640 ../../LangRef.rst:6683 ../../LangRef.rst:6750
#: ../../LangRef.rst:6958 ../../LangRef.rst:7015 ../../LangRef.rst:7089
#: ../../LangRef.rst:7175 ../../LangRef.rst:7314 ../../LangRef.rst:7423
#: ../../LangRef.rst:7464 ../../LangRef.rst:7505 ../../LangRef.rst:7547
#: ../../LangRef.rst:7587 ../../LangRef.rst:7628 ../../LangRef.rst:7670
#: ../../LangRef.rst:7712 ../../LangRef.rst:7753 ../../LangRef.rst:7798
#: ../../LangRef.rst:7842 ../../LangRef.rst:7894 ../../LangRef.rst:7940
#: ../../LangRef.rst:8033 ../../LangRef.rst:8150 ../../LangRef.rst:8207
#: ../../LangRef.rst:8257 ../../LangRef.rst:8375 ../../LangRef.rst:8441
#: ../../LangRef.rst:8518 ../../LangRef.rst:8591 ../../LangRef.rst:8661
msgid "Example:"
msgstr ""

#: ../../LangRef.rst:5101
msgid "'``br``' Instruction"
msgstr ""

#: ../../LangRef.rst:5114
msgid ""
"The '``br``' instruction is used to cause control flow to transfer to a "
"different basic block in the current function. There are two forms of "
"this instruction, corresponding to a conditional branch and an "
"unconditional branch."
msgstr ""

#: ../../LangRef.rst:5122
msgid ""
"The conditional branch form of the '``br``' instruction takes a single "
"'``i1``' value and two '``label``' values. The unconditional form of the "
"'``br``' instruction takes a single '``label``' value as a target."
msgstr ""

#: ../../LangRef.rst:5129
msgid ""
"Upon execution of a conditional '``br``' instruction, the '``i1``' "
"argument is evaluated. If the value is ``true``, control flows to the "
"'``iftrue``' ``label`` argument. If \"cond\" is ``false``, control flows "
"to the '``iffalse``' ``label`` argument."
msgstr ""

#: ../../LangRef.rst:5150
msgid "'``switch``' Instruction"
msgstr ""

#: ../../LangRef.rst:5162
msgid ""
"The '``switch``' instruction is used to transfer control flow to one of "
"several different places. It is a generalization of the '``br``' "
"instruction, allowing a branch to occur to one of many possible "
"destinations."
msgstr ""

#: ../../LangRef.rst:5170
msgid ""
"The '``switch``' instruction uses three parameters: an integer comparison"
" value '``value``', a default '``label``' destination, and an array of "
"pairs of comparison value constants and '``label``'s. The table is not "
"allowed to contain duplicate constant entries."
msgstr ""

#: ../../LangRef.rst:5178
msgid ""
"The ``switch`` instruction specifies a table of values and destinations. "
"When the '``switch``' instruction is executed, this table is searched for"
" the given value. If the value is found, control flow is transferred to "
"the corresponding destination; otherwise, control flow is transferred to "
"the default destination."
msgstr ""

#: ../../LangRef.rst:5185 ../../LangRef.rst:5249
msgid "Implementation:"
msgstr ""

#: ../../LangRef.rst:5187
msgid ""
"Depending on properties of the target machine and the particular "
"``switch`` instruction, this instruction may be code generated in "
"different ways. For example, it could be generated as a series of chained"
" conditional branches or with a lookup table."
msgstr ""

#: ../../LangRef.rst:5212
msgid "'``indirectbr``' Instruction"
msgstr ""

#: ../../LangRef.rst:5224
msgid ""
"The '``indirectbr``' instruction implements an indirect branch to a label"
" within the current function, whose address is specified by "
"\"``address``\". Address must be derived from a :ref:`blockaddress "
"<blockaddress>` constant."
msgstr ""

#: ../../LangRef.rst:5232
msgid ""
"The '``address``' argument is the address of the label to jump to. The "
"rest of the arguments indicate the full set of possible destinations that"
" the address may point to. Blocks are allowed to occur multiple times in "
"the destination list, though this isn't particularly useful."
msgstr ""

#: ../../LangRef.rst:5237
msgid ""
"This destination list is required so that dataflow analysis has an "
"accurate understanding of the CFG."
msgstr ""

#: ../../LangRef.rst:5243
msgid ""
"Control transfers to the block specified in the address argument. All "
"possible destination blocks must be listed in the label list, otherwise "
"this instruction has undefined behavior. This implies that jumps to "
"labels defined in other functions have undefined behavior as well."
msgstr ""

#: ../../LangRef.rst:5251
msgid "This is typically implemented with a jump through a register."
msgstr ""

#: ../../LangRef.rst:5263
msgid "'``invoke``' Instruction"
msgstr ""

#: ../../LangRef.rst:5276
msgid ""
"The '``invoke``' instruction causes control to transfer to a specified "
"function, with the possibility of control flow transfer to either the "
"'``normal``' label or the '``exception``' label. If the callee function "
"returns with the \"``ret``\" instruction, control flow will return to the"
" \"normal\" label. If the callee (or any indirect callees) returns via "
"the \":ref:`resume <i_resume>`\" instruction or other exception handling "
"mechanism, control is interrupted and continued at the dynamically "
"nearest \"exception\" label."
msgstr ""

#: ../../LangRef.rst:5285
msgid ""
"The '``exception``' label is a `landing pad "
"<ExceptionHandling.html#overview>`_ for the exception. As such, "
"'``exception``' label is required to have the \":ref:`landingpad "
"<i_landingpad>`\" instruction, which contains the information about the "
"behavior of the program after unwinding happens, as its first non-PHI "
"instruction. The restrictions on the \"``landingpad``\" instruction's "
"tightly couples it to the \"``invoke``\" instruction, so that the "
"important information contained within the \"``landingpad``\" instruction"
" can't be lost through normal code motion."
msgstr ""

#: ../../LangRef.rst:5298 ../../LangRef.rst:8284
msgid "This instruction requires several arguments:"
msgstr ""

#: ../../LangRef.rst:5300
msgid ""
"The optional \"cconv\" marker indicates which :ref:`calling convention "
"<callingconv>` the call should use. If none is specified, the call "
"defaults to using C calling conventions."
msgstr ""

#: ../../LangRef.rst:5303 ../../LangRef.rst:8340
msgid ""
"The optional :ref:`Parameter Attributes <paramattrs>` list for return "
"values. Only '``zeroext``', '``signext``', and '``inreg``' attributes are"
" valid here."
msgstr ""

#: ../../LangRef.rst:5306
msgid ""
"'``ptr to function ty``': shall be the signature of the pointer to "
"function value being invoked. In most cases, this is a direct function "
"invocation, but indirect ``invoke``'s are just as possible, branching off"
" an arbitrary pointer to function value."
msgstr ""

#: ../../LangRef.rst:5310
msgid ""
"'``function ptr val``': An LLVM value containing a pointer to a function "
"to be invoked."
msgstr ""

#: ../../LangRef.rst:5312 ../../LangRef.rst:8355
msgid ""
"'``function args``': argument list whose types match the function "
"signature argument types and parameter attributes. All arguments must be "
"of :ref:`first class <t_firstclass>` type. If the function signature "
"indicates the function accepts a variable number of arguments, the extra "
"arguments can be specified."
msgstr ""

#: ../../LangRef.rst:5317
msgid ""
"'``normal label``': the label reached when the called function executes a"
" '``ret``' instruction."
msgstr ""

#: ../../LangRef.rst:5319
msgid ""
"'``exception label``': the label reached when a callee returns via the "
":ref:`resume <i_resume>` instruction or other exception handling "
"mechanism."
msgstr ""

#: ../../LangRef.rst:5322 ../../LangRef.rst:8360
msgid ""
"The optional :ref:`function attributes <fnattrs>` list. Only "
"'``noreturn``', '``nounwind``', '``readonly``' and '``readnone``' "
"attributes are valid here."
msgstr ""

#: ../../LangRef.rst:5325 ../../LangRef.rst:8363
msgid "The optional :ref:`operand bundles <opbundles>` list."
msgstr ""

#: ../../LangRef.rst:5330
msgid ""
"This instruction is designed to operate as a standard '``call``' "
"instruction in most regards. The primary difference is that it "
"establishes an association with a label, which is used by the runtime "
"library to unwind the stack."
msgstr ""

#: ../../LangRef.rst:5335
msgid ""
"This instruction is used in languages with destructors to ensure that "
"proper cleanup is performed in the case of either a ``longjmp`` or a "
"thrown exception. Additionally, this is important for implementation of "
"'``catch``' clauses in high-level languages that support them."
msgstr ""

#: ../../LangRef.rst:5340
msgid ""
"For the purposes of the SSA form, the definition of the value returned by"
" the '``invoke``' instruction is deemed to occur on the edge from the "
"current block to the \"normal\" label. If the callee unwinds then no "
"return value is available."
msgstr ""

#: ../../LangRef.rst:5358
msgid "'``resume``' Instruction"
msgstr ""

#: ../../LangRef.rst:5370
msgid ""
"The '``resume``' instruction is a terminator instruction that has no "
"successors."
msgstr ""

#: ../../LangRef.rst:5376
msgid ""
"The '``resume``' instruction requires one argument, which must have the "
"same type as the result of any '``landingpad``' instruction in the same "
"function."
msgstr ""

#: ../../LangRef.rst:5383
msgid ""
"The '``resume``' instruction resumes propagation of an existing (in-"
"flight) exception whose unwinding was interrupted with a :ref:`landingpad"
" <i_landingpad>` instruction."
msgstr ""

#: ../../LangRef.rst:5397
msgid "'``catchswitch``' Instruction"
msgstr ""

#: ../../LangRef.rst:5410
msgid ""
"The '``catchswitch``' instruction is used by `LLVM's exception handling "
"system <ExceptionHandling.html#overview>`_ to describe the set of "
"possible catch handlers that may be executed by the :ref:`EH personality "
"routine <personalityfn>`."
msgstr ""

#: ../../LangRef.rst:5417
msgid ""
"The ``parent`` argument is the token of the funclet that contains the "
"``catchswitch`` instruction. If the ``catchswitch`` is not inside a "
"funclet, this operand may be the token ``none``."
msgstr ""

#: ../../LangRef.rst:5421
msgid ""
"The ``default`` argument is the label of another basic block beginning "
"with either a ``cleanuppad`` or ``catchswitch`` instruction.  This unwind"
" destination must be a legal target with respect to the ``parent`` links,"
" as described in the `exception handling documentation\\ "
"<ExceptionHandling.html#wineh-constraints>`_."
msgstr ""

#: ../../LangRef.rst:5426
msgid ""
"The ``handlers`` are a nonempty list of successor blocks that each begin "
"with a :ref:`catchpad <i_catchpad>` instruction."
msgstr ""

#: ../../LangRef.rst:5432
msgid ""
"Executing this instruction transfers control to one of the successors in "
"``handlers``, if appropriate, or continues to unwind via the unwind label"
" if present."
msgstr ""

#: ../../LangRef.rst:5436
msgid ""
"The ``catchswitch`` is both a terminator and a \"pad\" instruction, "
"meaning that it must be both the first non-phi instruction and last "
"instruction in the basic block. Therefore, it must be the only non-phi "
"instruction in the block."
msgstr ""

#: ../../LangRef.rst:5453
msgid "'``catchret``' Instruction"
msgstr ""

#: ../../LangRef.rst:5465
msgid ""
"The '``catchret``' instruction is a terminator instruction that has a "
"single successor."
msgstr ""

#: ../../LangRef.rst:5472
msgid ""
"The first argument to a '``catchret``' indicates which ``catchpad`` it "
"exits.  It must be a :ref:`catchpad <i_catchpad>`. The second argument to"
" a '``catchret``' specifies where control will transfer to next."
msgstr ""

#: ../../LangRef.rst:5480
msgid ""
"The '``catchret``' instruction ends an existing (in-flight) exception "
"whose unwinding was interrupted with a :ref:`catchpad <i_catchpad>` "
"instruction.  The :ref:`personality function <personalityfn>` gets a "
"chance to execute arbitrary code to, for example, destroy the active "
"exception.  Control then transfers to ``normal``."
msgstr ""

#: ../../LangRef.rst:5486
msgid ""
"The ``token`` argument must be a token produced by a ``catchpad`` "
"instruction. If the specified ``catchpad`` is not the most-recently-"
"entered not-yet-exited funclet pad (as described in the `EH "
"documentation\\ <ExceptionHandling.html#wineh-constraints>`_), the "
"``catchret``'s behavior is undefined."
msgstr ""

#: ../../LangRef.rst:5501
msgid "'``cleanupret``' Instruction"
msgstr ""

#: ../../LangRef.rst:5514
msgid ""
"The '``cleanupret``' instruction is a terminator instruction that has an "
"optional successor."
msgstr ""

#: ../../LangRef.rst:5521
msgid ""
"The '``cleanupret``' instruction requires one argument, which indicates "
"which ``cleanuppad`` it exits, and must be a :ref:`cleanuppad "
"<i_cleanuppad>`. If the specified ``cleanuppad`` is not the most-"
"recently-entered not-yet-exited funclet pad (as described in the `EH "
"documentation\\ <ExceptionHandling.html#wineh-constraints>`_), the "
"``cleanupret``'s behavior is undefined."
msgstr ""

#: ../../LangRef.rst:5527
msgid ""
"The '``cleanupret``' instruction also has an optional successor, "
"``continue``, which must be the label of another basic block beginning "
"with either a ``cleanuppad`` or ``catchswitch`` instruction.  This unwind"
" destination must be a legal target with respect to the ``parent`` links,"
" as described in the `exception handling documentation\\ "
"<ExceptionHandling.html#wineh-constraints>`_."
msgstr ""

#: ../../LangRef.rst:5536
msgid ""
"The '``cleanupret``' instruction indicates to the :ref:`personality "
"function <personalityfn>` that one :ref:`cleanuppad <i_cleanuppad>` it "
"transferred control to has ended. It transfers control to ``continue`` or"
" unwinds out of the function."
msgstr ""

#: ../../LangRef.rst:5552
msgid "'``unreachable``' Instruction"
msgstr ""

#: ../../LangRef.rst:5564
msgid ""
"The '``unreachable``' instruction has no defined semantics. This "
"instruction is used to inform the optimizer that a particular portion of "
"the code is not reachable. This can be used to indicate that the code "
"after a no-return function cannot be reached, and other facts."
msgstr ""

#: ../../LangRef.rst:5572
msgid "The '``unreachable``' instruction has no defined semantics."
msgstr ""

#: ../../LangRef.rst:5577
msgid "Binary Operations"
msgstr ""

#: ../../LangRef.rst:5579
msgid ""
"Binary operators are used to do most of the computation in a program. "
"They require two operands of the same type, execute an operation on them,"
" and produce a single value. The operands might represent multiple data, "
"as is the case with the :ref:`vector <t_vector>` data type. The result "
"value has the same type as its operands."
msgstr ""

#: ../../LangRef.rst:5585
msgid "There are several different binary operators:"
msgstr ""

#: ../../LangRef.rst:5590
msgid "'``add``' Instruction"
msgstr ""

#: ../../LangRef.rst:5605
msgid "The '``add``' instruction returns the sum of its two operands."
msgstr ""

#: ../../LangRef.rst:5610
msgid ""
"The two arguments to the '``add``' instruction must be :ref:`integer "
"<t_integer>` or :ref:`vector <t_vector>` of integer values. Both "
"arguments must have identical types."
msgstr ""

#: ../../LangRef.rst:5617
msgid "The value produced is the integer sum of the two operands."
msgstr ""

#: ../../LangRef.rst:5619
msgid ""
"If the sum has unsigned overflow, the result returned is the mathematical"
" result modulo 2\\ :sup:`n`\\ , where n is the bit width of the result."
msgstr ""

#: ../../LangRef.rst:5623 ../../LangRef.rst:5714
msgid ""
"Because LLVM integers use a two's complement representation, this "
"instruction is appropriate for both signed and unsigned integers."
msgstr ""

#: ../../LangRef.rst:5626
msgid ""
"``nuw`` and ``nsw`` stand for \"No Unsigned Wrap\" and \"No Signed "
"Wrap\", respectively. If the ``nuw`` and/or ``nsw`` keywords are present,"
" the result value of the ``add`` is a :ref:`poison value <poisonvalues>` "
"if unsigned and/or signed overflow, respectively, occurs."
msgstr ""

#: ../../LangRef.rst:5641
msgid "'``fadd``' Instruction"
msgstr ""

#: ../../LangRef.rst:5653
msgid "The '``fadd``' instruction returns the sum of its two operands."
msgstr ""

#: ../../LangRef.rst:5658
msgid ""
"The two arguments to the '``fadd``' instruction must be :ref:`floating "
"point <t_floating>` or :ref:`vector <t_vector>` of floating point values."
" Both arguments must have identical types."
msgstr ""

#: ../../LangRef.rst:5665
msgid ""
"The value produced is the floating point sum of the two operands. This "
"instruction can also take any number of :ref:`fast-math flags "
"<fastmath>`, which are optimization hints to enable otherwise unsafe "
"floating point optimizations:"
msgstr ""

#: ../../LangRef.rst:5678
msgid "'``sub``' Instruction"
msgstr ""

#: ../../LangRef.rst:5693
msgid "The '``sub``' instruction returns the difference of its two operands."
msgstr ""

#: ../../LangRef.rst:5695
msgid ""
"Note that the '``sub``' instruction is used to represent the '``neg``' "
"instruction present in most other intermediate representations."
msgstr ""

#: ../../LangRef.rst:5701
msgid ""
"The two arguments to the '``sub``' instruction must be :ref:`integer "
"<t_integer>` or :ref:`vector <t_vector>` of integer values. Both "
"arguments must have identical types."
msgstr ""

#: ../../LangRef.rst:5708
msgid "The value produced is the integer difference of the two operands."
msgstr ""

#: ../../LangRef.rst:5710
msgid ""
"If the difference has unsigned overflow, the result returned is the "
"mathematical result modulo 2\\ :sup:`n`\\ , where n is the bit width of "
"the result."
msgstr ""

#: ../../LangRef.rst:5717
msgid ""
"``nuw`` and ``nsw`` stand for \"No Unsigned Wrap\" and \"No Signed "
"Wrap\", respectively. If the ``nuw`` and/or ``nsw`` keywords are present,"
" the result value of the ``sub`` is a :ref:`poison value <poisonvalues>` "
"if unsigned and/or signed overflow, respectively, occurs."
msgstr ""

#: ../../LangRef.rst:5733
msgid "'``fsub``' Instruction"
msgstr ""

#: ../../LangRef.rst:5745
msgid "The '``fsub``' instruction returns the difference of its two operands."
msgstr ""

#: ../../LangRef.rst:5747
msgid ""
"Note that the '``fsub``' instruction is used to represent the '``fneg``' "
"instruction present in most other intermediate representations."
msgstr ""

#: ../../LangRef.rst:5753
msgid ""
"The two arguments to the '``fsub``' instruction must be :ref:`floating "
"point <t_floating>` or :ref:`vector <t_vector>` of floating point values."
" Both arguments must have identical types."
msgstr ""

#: ../../LangRef.rst:5760
msgid ""
"The value produced is the floating point difference of the two operands. "
"This instruction can also take any number of :ref:`fast-math flags "
"<fastmath>`, which are optimization hints to enable otherwise unsafe "
"floating point optimizations:"
msgstr ""

#: ../../LangRef.rst:5774
msgid "'``mul``' Instruction"
msgstr ""

#: ../../LangRef.rst:5789
msgid "The '``mul``' instruction returns the product of its two operands."
msgstr ""

#: ../../LangRef.rst:5794
msgid ""
"The two arguments to the '``mul``' instruction must be :ref:`integer "
"<t_integer>` or :ref:`vector <t_vector>` of integer values. Both "
"arguments must have identical types."
msgstr ""

#: ../../LangRef.rst:5801
msgid "The value produced is the integer product of the two operands."
msgstr ""

#: ../../LangRef.rst:5803
msgid ""
"If the result of the multiplication has unsigned overflow, the result "
"returned is the mathematical result modulo 2\\ :sup:`n`\\ , where n is "
"the bit width of the result."
msgstr ""

#: ../../LangRef.rst:5807
msgid ""
"Because LLVM integers use a two's complement representation, and the "
"result is the same width as the operands, this instruction returns the "
"correct result for both signed and unsigned integers. If a full product "
"(e.g. ``i32`` * ``i32`` -> ``i64``) is needed, the operands should be "
"sign-extended or zero-extended as appropriate to the width of the full "
"product."
msgstr ""

#: ../../LangRef.rst:5814
msgid ""
"``nuw`` and ``nsw`` stand for \"No Unsigned Wrap\" and \"No Signed "
"Wrap\", respectively. If the ``nuw`` and/or ``nsw`` keywords are present,"
" the result value of the ``mul`` is a :ref:`poison value <poisonvalues>` "
"if unsigned and/or signed overflow, respectively, occurs."
msgstr ""

#: ../../LangRef.rst:5829
msgid "'``fmul``' Instruction"
msgstr ""

#: ../../LangRef.rst:5841
msgid "The '``fmul``' instruction returns the product of its two operands."
msgstr ""

#: ../../LangRef.rst:5846
msgid ""
"The two arguments to the '``fmul``' instruction must be :ref:`floating "
"point <t_floating>` or :ref:`vector <t_vector>` of floating point values."
" Both arguments must have identical types."
msgstr ""

#: ../../LangRef.rst:5853
msgid ""
"The value produced is the floating point product of the two operands. "
"This instruction can also take any number of :ref:`fast-math flags "
"<fastmath>`, which are optimization hints to enable otherwise unsafe "
"floating point optimizations:"
msgstr ""

#: ../../LangRef.rst:5866
msgid "'``udiv``' Instruction"
msgstr ""

#: ../../LangRef.rst:5879
msgid "The '``udiv``' instruction returns the quotient of its two operands."
msgstr ""

#: ../../LangRef.rst:5884
msgid ""
"The two arguments to the '``udiv``' instruction must be :ref:`integer "
"<t_integer>` or :ref:`vector <t_vector>` of integer values. Both "
"arguments must have identical types."
msgstr ""

#: ../../LangRef.rst:5891
msgid "The value produced is the unsigned integer quotient of the two operands."
msgstr ""

#: ../../LangRef.rst:5893
msgid ""
"Note that unsigned integer division and signed integer division are "
"distinct operations; for signed integer division, use '``sdiv``'."
msgstr ""

#: ../../LangRef.rst:5896
msgid "Division by zero leads to undefined behavior."
msgstr ""

#: ../../LangRef.rst:5898
#, python-format
msgid ""
"If the ``exact`` keyword is present, the result value of the ``udiv`` is "
"a :ref:`poison value <poisonvalues>` if %op1 is not a multiple of %op2 "
"(as such, \"((a udiv exact b) mul b) == a\")."
msgstr ""

#: ../../LangRef.rst:5910
msgid "'``sdiv``' Instruction"
msgstr ""

#: ../../LangRef.rst:5923
msgid "The '``sdiv``' instruction returns the quotient of its two operands."
msgstr ""

#: ../../LangRef.rst:5928
msgid ""
"The two arguments to the '``sdiv``' instruction must be :ref:`integer "
"<t_integer>` or :ref:`vector <t_vector>` of integer values. Both "
"arguments must have identical types."
msgstr ""

#: ../../LangRef.rst:5935
msgid ""
"The value produced is the signed integer quotient of the two operands "
"rounded towards zero."
msgstr ""

#: ../../LangRef.rst:5938
msgid ""
"Note that signed integer division and unsigned integer division are "
"distinct operations; for unsigned integer division, use '``udiv``'."
msgstr ""

#: ../../LangRef.rst:5941
msgid ""
"Division by zero leads to undefined behavior. Overflow also leads to "
"undefined behavior; this is a rare case, but can occur, for example, by "
"doing a 32-bit division of -2147483648 by -1."
msgstr ""

#: ../../LangRef.rst:5945
msgid ""
"If the ``exact`` keyword is present, the result value of the ``sdiv`` is "
"a :ref:`poison value <poisonvalues>` if the result would be rounded."
msgstr ""

#: ../../LangRef.rst:5958
msgid "'``fdiv``' Instruction"
msgstr ""

#: ../../LangRef.rst:5970
msgid "The '``fdiv``' instruction returns the quotient of its two operands."
msgstr ""

#: ../../LangRef.rst:5975
msgid ""
"The two arguments to the '``fdiv``' instruction must be :ref:`floating "
"point <t_floating>` or :ref:`vector <t_vector>` of floating point values."
" Both arguments must have identical types."
msgstr ""

#: ../../LangRef.rst:5982
msgid ""
"The value produced is the floating point quotient of the two operands. "
"This instruction can also take any number of :ref:`fast-math flags "
"<fastmath>`, which are optimization hints to enable otherwise unsafe "
"floating point optimizations:"
msgstr ""

#: ../../LangRef.rst:5995
msgid "'``urem``' Instruction"
msgstr ""

#: ../../LangRef.rst:6007
msgid ""
"The '``urem``' instruction returns the remainder from the unsigned "
"division of its two arguments."
msgstr ""

#: ../../LangRef.rst:6013
msgid ""
"The two arguments to the '``urem``' instruction must be :ref:`integer "
"<t_integer>` or :ref:`vector <t_vector>` of integer values. Both "
"arguments must have identical types."
msgstr ""

#: ../../LangRef.rst:6020
msgid ""
"This instruction returns the unsigned integer *remainder* of a division. "
"This instruction always performs an unsigned division to get the "
"remainder."
msgstr ""

#: ../../LangRef.rst:6024
msgid ""
"Note that unsigned integer remainder and signed integer remainder are "
"distinct operations; for signed integer remainder, use '``srem``'."
msgstr ""

#: ../../LangRef.rst:6027
msgid "Taking the remainder of a division by zero leads to undefined behavior."
msgstr ""

#: ../../LangRef.rst:6037
msgid "'``srem``' Instruction"
msgstr ""

#: ../../LangRef.rst:6049
msgid ""
"The '``srem``' instruction returns the remainder from the signed division"
" of its two operands. This instruction can also take :ref:`vector "
"<t_vector>` versions of the values in which case the elements must be "
"integers."
msgstr ""

#: ../../LangRef.rst:6057
msgid ""
"The two arguments to the '``srem``' instruction must be :ref:`integer "
"<t_integer>` or :ref:`vector <t_vector>` of integer values. Both "
"arguments must have identical types."
msgstr ""

#: ../../LangRef.rst:6064
msgid ""
"This instruction returns the *remainder* of a division (where the result "
"is either zero or has the same sign as the dividend, ``op1``), not the "
"*modulo* operator (where the result is either zero or has the same sign "
"as the divisor, ``op2``) of a value. For more information about the "
"difference, see `The Math Forum "
"<http://mathforum.org/dr.math/problems/anne.4.28.99.html>`_. For a table "
"of how this is implemented in various languages, please see `Wikipedia: "
"modulo operation <http://en.wikipedia.org/wiki/Modulo_operation>`_."
msgstr ""

#: ../../LangRef.rst:6074
msgid ""
"Note that signed integer remainder and unsigned integer remainder are "
"distinct operations; for unsigned integer remainder, use '``urem``'."
msgstr ""

#: ../../LangRef.rst:6077
msgid ""
"Taking the remainder of a division by zero leads to undefined behavior. "
"Overflow also leads to undefined behavior; this is a rare case, but can "
"occur, for example, by taking the remainder of a 32-bit division of "
"-2147483648 by -1. (The remainder doesn't actually overflow, but this "
"rule lets srem be implemented using instructions that return both the "
"result of the division and the remainder.)"
msgstr ""

#: ../../LangRef.rst:6094
msgid "'``frem``' Instruction"
msgstr ""

#: ../../LangRef.rst:6106
msgid ""
"The '``frem``' instruction returns the remainder from the division of its"
" two operands."
msgstr ""

#: ../../LangRef.rst:6112
msgid ""
"The two arguments to the '``frem``' instruction must be :ref:`floating "
"point <t_floating>` or :ref:`vector <t_vector>` of floating point values."
" Both arguments must have identical types."
msgstr ""

#: ../../LangRef.rst:6119
msgid ""
"This instruction returns the *remainder* of a division. The remainder has"
" the same sign as the dividend. This instruction can also take any number"
" of :ref:`fast-math flags <fastmath>`, which are optimization hints to "
"enable otherwise unsafe floating point optimizations:"
msgstr ""

#: ../../LangRef.rst:6134
msgid "Bitwise Binary Operations"
msgstr ""

#: ../../LangRef.rst:6136
msgid ""
"Bitwise binary operators are used to do various forms of bit-twiddling in"
" a program. They are generally very efficient instructions and can "
"commonly be strength reduced from other instructions. They require two "
"operands of the same type, execute an operation on them, and produce a "
"single value. The resulting value is the same type as its operands."
msgstr ""

#: ../../LangRef.rst:6143
msgid "'``shl``' Instruction"
msgstr ""

#: ../../LangRef.rst:6158
msgid ""
"The '``shl``' instruction returns the first operand shifted to the left a"
" specified number of bits."
msgstr ""

#: ../../LangRef.rst:6164
msgid ""
"Both arguments to the '``shl``' instruction must be the same "
":ref:`integer <t_integer>` or :ref:`vector <t_vector>` of integer type. "
"'``op2``' is treated as an unsigned value."
msgstr ""

#: ../../LangRef.rst:6171
msgid ""
"The value produced is ``op1`` \\* 2\\ :sup:`op2` mod 2\\ :sup:`n`, where "
"``n`` is the width of the result. If ``op2`` is (statically or "
"dynamically) equal to or larger than the number of bits in ``op1``, the "
"result is undefined. If the arguments are vectors, each vector element of"
" ``op1`` is shifted by the corresponding shift amount in ``op2``."
msgstr ""

#: ../../LangRef.rst:6178
#, python-format
msgid ""
"If the ``nuw`` keyword is present, then the shift produces a :ref:`poison"
" value <poisonvalues>` if it shifts out any non-zero bits. If the ``nsw``"
" keyword is present, then the shift produces a :ref:`poison value "
"<poisonvalues>` if it shifts out any bits that disagree with the "
"resultant sign bit. As such, NUW/NSW have the same semantics as they "
"would if the shift were expressed as a mul instruction with the same "
"nsw/nuw bits in (mul %op1, (shl 1, %op2))."
msgstr ""

#: ../../LangRef.rst:6198
msgid "'``lshr``' Instruction"
msgstr ""

#: ../../LangRef.rst:6211
msgid ""
"The '``lshr``' instruction (logical shift right) returns the first "
"operand shifted to the right a specified number of bits with zero fill."
msgstr ""

#: ../../LangRef.rst:6217
msgid ""
"Both arguments to the '``lshr``' instruction must be the same "
":ref:`integer <t_integer>` or :ref:`vector <t_vector>` of integer type. "
"'``op2``' is treated as an unsigned value."
msgstr ""

#: ../../LangRef.rst:6224
msgid ""
"This instruction always performs a logical shift right operation. The "
"most significant bits of the result will be filled with zero bits after "
"the shift. If ``op2`` is (statically or dynamically) equal to or larger "
"than the number of bits in ``op1``, the result is undefined. If the "
"arguments are vectors, each vector element of ``op1`` is shifted by the "
"corresponding shift amount in ``op2``."
msgstr ""

#: ../../LangRef.rst:6231
msgid ""
"If the ``exact`` keyword is present, the result value of the ``lshr`` is "
"a :ref:`poison value <poisonvalues>` if any of the bits shifted out are "
"non-zero."
msgstr ""

#: ../../LangRef.rst:6248
msgid "'``ashr``' Instruction"
msgstr ""

#: ../../LangRef.rst:6261
msgid ""
"The '``ashr``' instruction (arithmetic shift right) returns the first "
"operand shifted to the right a specified number of bits with sign "
"extension."
msgstr ""

#: ../../LangRef.rst:6268
msgid ""
"Both arguments to the '``ashr``' instruction must be the same "
":ref:`integer <t_integer>` or :ref:`vector <t_vector>` of integer type. "
"'``op2``' is treated as an unsigned value."
msgstr ""

#: ../../LangRef.rst:6275
msgid ""
"This instruction always performs an arithmetic shift right operation, The"
" most significant bits of the result will be filled with the sign bit of "
"``op1``. If ``op2`` is (statically or dynamically) equal to or larger "
"than the number of bits in ``op1``, the result is undefined. If the "
"arguments are vectors, each vector element of ``op1`` is shifted by the "
"corresponding shift amount in ``op2``."
msgstr ""

#: ../../LangRef.rst:6282
msgid ""
"If the ``exact`` keyword is present, the result value of the ``ashr`` is "
"a :ref:`poison value <poisonvalues>` if any of the bits shifted out are "
"non-zero."
msgstr ""

#: ../../LangRef.rst:6299
msgid "'``and``' Instruction"
msgstr ""

#: ../../LangRef.rst:6311
msgid ""
"The '``and``' instruction returns the bitwise logical and of its two "
"operands."
msgstr ""

#: ../../LangRef.rst:6317
msgid ""
"The two arguments to the '``and``' instruction must be :ref:`integer "
"<t_integer>` or :ref:`vector <t_vector>` of integer values. Both "
"arguments must have identical types."
msgstr ""

#: ../../LangRef.rst:6324
msgid "The truth table used for the '``and``' instruction is:"
msgstr ""

#: ../../LangRef.rst:6327 ../../LangRef.rst:6376 ../../LangRef.rst:6426
msgid "In0"
msgstr ""

#: ../../LangRef.rst:6327 ../../LangRef.rst:6376 ../../LangRef.rst:6426
msgid "In1"
msgstr ""

#: ../../LangRef.rst:6327 ../../LangRef.rst:6376 ../../LangRef.rst:6426
msgid "Out"
msgstr ""

#: ../../LangRef.rst:6329 ../../LangRef.rst:6331 ../../LangRef.rst:6333
#: ../../LangRef.rst:6378 ../../LangRef.rst:6380 ../../LangRef.rst:6382
#: ../../LangRef.rst:6428 ../../LangRef.rst:6430 ../../LangRef.rst:6432
#: ../../LangRef.rst:6434
msgid "0"
msgstr ""

#: ../../LangRef.rst:6348
msgid "'``or``' Instruction"
msgstr ""

#: ../../LangRef.rst:6360
msgid ""
"The '``or``' instruction returns the bitwise logical inclusive or of its "
"two operands."
msgstr ""

#: ../../LangRef.rst:6366
msgid ""
"The two arguments to the '``or``' instruction must be :ref:`integer "
"<t_integer>` or :ref:`vector <t_vector>` of integer values. Both "
"arguments must have identical types."
msgstr ""

#: ../../LangRef.rst:6373
msgid "The truth table used for the '``or``' instruction is:"
msgstr ""

#: ../../LangRef.rst:6397
msgid "'``xor``' Instruction"
msgstr ""

#: ../../LangRef.rst:6409
msgid ""
"The '``xor``' instruction returns the bitwise logical exclusive or of its"
" two operands. The ``xor`` is used to implement the \"one's complement\" "
"operation, which is the \"~\" operator in C."
msgstr ""

#: ../../LangRef.rst:6416
msgid ""
"The two arguments to the '``xor``' instruction must be :ref:`integer "
"<t_integer>` or :ref:`vector <t_vector>` of integer values. Both "
"arguments must have identical types."
msgstr ""

#: ../../LangRef.rst:6423
msgid "The truth table used for the '``xor``' instruction is:"
msgstr ""

#: ../../LangRef.rst:6448
msgid "Vector Operations"
msgstr ""

#: ../../LangRef.rst:6450
msgid ""
"LLVM supports several instructions to represent vector operations in a "
"target-independent manner. These instructions cover the element-access "
"and vector-specific operations needed to process vectors effectively. "
"While LLVM does directly support these vector operations, many "
"sophisticated algorithms will want to use target-specific intrinsics to "
"take full advantage of a specific target."
msgstr ""

#: ../../LangRef.rst:6460
msgid "'``extractelement``' Instruction"
msgstr ""

#: ../../LangRef.rst:6472
msgid ""
"The '``extractelement``' instruction extracts a single scalar element "
"from a vector at a specified index."
msgstr ""

#: ../../LangRef.rst:6478
msgid ""
"The first operand of an '``extractelement``' instruction is a value of "
":ref:`vector <t_vector>` type. The second operand is an index indicating "
"the position from which to extract the element. The index may be a "
"variable of any integer type."
msgstr ""

#: ../../LangRef.rst:6486
msgid ""
"The result is a scalar of the same type as the element type of ``val``. "
"Its value is the value at position ``idx`` of ``val``. If ``idx`` exceeds"
" the length of ``val``, the results are undefined."
msgstr ""

#: ../../LangRef.rst:6500
msgid "'``insertelement``' Instruction"
msgstr ""

#: ../../LangRef.rst:6512
msgid ""
"The '``insertelement``' instruction inserts a scalar element into a "
"vector at a specified index."
msgstr ""

#: ../../LangRef.rst:6518
msgid ""
"The first operand of an '``insertelement``' instruction is a value of "
":ref:`vector <t_vector>` type. The second operand is a scalar value whose"
" type must equal the element type of the first operand. The third operand"
" is an index indicating the position at which to insert the value. The "
"index may be a variable of any integer type."
msgstr ""

#: ../../LangRef.rst:6527
msgid ""
"The result is a vector of the same type as ``val``. Its element values "
"are those of ``val`` except at position ``idx``, where it gets the value "
"``elt``. If ``idx`` exceeds the length of ``val``, the results are "
"undefined."
msgstr ""

#: ../../LangRef.rst:6542
msgid "'``shufflevector``' Instruction"
msgstr ""

#: ../../LangRef.rst:6554
msgid ""
"The '``shufflevector``' instruction constructs a permutation of elements "
"from two input vectors, returning a vector with the same element type as "
"the input and length that is the same as the shuffle mask."
msgstr ""

#: ../../LangRef.rst:6561
msgid ""
"The first two operands of a '``shufflevector``' instruction are vectors "
"with the same type. The third argument is a shuffle mask whose element "
"type is always 'i32'. The result of the instruction is a vector whose "
"length is the same as the shuffle mask and whose element type is the same"
" as the element type of the first two operands."
msgstr ""

#: ../../LangRef.rst:6567
msgid ""
"The shuffle mask operand is required to be a constant vector with either "
"constant integer or undef values."
msgstr ""

#: ../../LangRef.rst:6573
msgid ""
"The elements of the two input vectors are numbered from left to right "
"across both of the vectors. The shuffle mask operand specifies, for each "
"element of the result vector, which element of the two input vectors the "
"result element gets. The element selector may be undef (meaning \"don't "
"care\") and the second operand may be undef if performing a shuffle from "
"only one vector."
msgstr ""

#: ../../LangRef.rst:6595
msgid "Aggregate Operations"
msgstr ""

#: ../../LangRef.rst:6597
msgid ""
"LLVM supports several instructions for working with :ref:`aggregate "
"<t_aggregate>` values."
msgstr ""

#: ../../LangRef.rst:6603
msgid "'``extractvalue``' Instruction"
msgstr ""

#: ../../LangRef.rst:6615
msgid ""
"The '``extractvalue``' instruction extracts the value of a member field "
"from an :ref:`aggregate <t_aggregate>` value."
msgstr ""

#: ../../LangRef.rst:6621
msgid ""
"The first operand of an '``extractvalue``' instruction is a value of "
":ref:`struct <t_struct>` or :ref:`array <t_array>` type. The other "
"operands are constant indices to specify which value to extract in a "
"similar manner as indices in a '``getelementptr``' instruction."
msgstr ""

#: ../../LangRef.rst:6626
msgid "The major differences to ``getelementptr`` indexing are:"
msgstr ""

#: ../../LangRef.rst:6628
msgid ""
"Since the value being indexed is not a pointer, the first index is "
"omitted and assumed to be zero."
msgstr ""

#: ../../LangRef.rst:6630
msgid "At least one index must be specified."
msgstr ""

#: ../../LangRef.rst:6631
msgid "Not only struct indices but also array indices must be in bounds."
msgstr ""

#: ../../LangRef.rst:6636
msgid ""
"The result is the value at the position in the aggregate specified by the"
" index operands."
msgstr ""

#: ../../LangRef.rst:6649
msgid "'``insertvalue``' Instruction"
msgstr ""

#: ../../LangRef.rst:6661
msgid ""
"The '``insertvalue``' instruction inserts a value into a member field in "
"an :ref:`aggregate <t_aggregate>` value."
msgstr ""

#: ../../LangRef.rst:6667
msgid ""
"The first operand of an '``insertvalue``' instruction is a value of "
":ref:`struct <t_struct>` or :ref:`array <t_array>` type. The second "
"operand is a first-class value to insert. The following operands are "
"constant indices indicating the position at which to insert the value in "
"a similar manner as indices in a '``extractvalue``' instruction. The "
"value to insert must have the same type as the value identified by the "
"indices."
msgstr ""

#: ../../LangRef.rst:6678
msgid ""
"The result is an aggregate of the same type as ``val``. Its value is that"
" of ``val`` except that the value at the position specified by the "
"indices is that of ``elt``."
msgstr ""

#: ../../LangRef.rst:6694
msgid "Memory Access and Addressing Operations"
msgstr ""

#: ../../LangRef.rst:6696
msgid ""
"A key design point of an SSA-based representation is how it represents "
"memory. In LLVM, no memory locations are in SSA form, which makes things "
"very simple. This section describes how to read, write, and allocate "
"memory in LLVM."
msgstr ""

#: ../../LangRef.rst:6704
msgid "'``alloca``' Instruction"
msgstr ""

#: ../../LangRef.rst:6716
msgid ""
"The '``alloca``' instruction allocates memory on the stack frame of the "
"currently executing function, to be automatically released when this "
"function returns to its caller. The object is always allocated in the "
"generic address space (address space zero)."
msgstr ""

#: ../../LangRef.rst:6724
msgid ""
"The '``alloca``' instruction allocates ``sizeof(<type>)*NumElements`` "
"bytes of memory on the runtime stack, returning a pointer of the "
"appropriate type to the program. If \"NumElements\" is specified, it is "
"the number of elements allocated, otherwise \"NumElements\" is defaulted "
"to be one. If a constant alignment is specified, the value result of the "
"allocation is guaranteed to be aligned to at least that boundary. The "
"alignment may not be greater than ``1 << 29``. If not specified, or if "
"zero, the target can choose to align the allocation on any convenient "
"boundary compatible with the type."
msgstr ""

#: ../../LangRef.rst:6734
msgid "'``type``' may be any sized type."
msgstr ""

#: ../../LangRef.rst:6739
msgid ""
"Memory is allocated; a pointer is returned. The operation is undefined if"
" there is insufficient stack space for the allocation. '``alloca``'d "
"memory is automatically released when the function returns. The "
"'``alloca``' instruction is commonly used to represent automatic "
"variables that must have an address available. When the function returns "
"(either with the ``ret`` or ``resume`` instructions), the memory is "
"reclaimed. Allocating zero bytes is legal, but the result is undefined. "
"The order in which memory is allocated (ie., which way the stack grows) "
"is not specified."
msgstr ""

#: ../../LangRef.rst:6762
msgid "'``load``' Instruction"
msgstr ""

#: ../../LangRef.rst:6778
msgid "The '``load``' instruction is used to read from memory."
msgstr ""

#: ../../LangRef.rst:6783
msgid ""
"The argument to the ``load`` instruction specifies the memory address "
"from which to load. The type specified must be a :ref:`first class "
"<t_firstclass>` type. If the ``load`` is marked as ``volatile``, then the"
" optimizer is not allowed to modify the number or order of execution of "
"this ``load`` with other :ref:`volatile operations <volatile>`."
msgstr ""

#: ../../LangRef.rst:6790
msgid ""
"If the ``load`` is marked as ``atomic``, it takes an extra :ref:`ordering"
" <ordering>` and optional ``singlethread`` argument. The ``release`` and "
"``acq_rel`` orderings are not valid on ``load`` instructions. Atomic "
"loads produce :ref:`defined <memmodel>` results when they may see "
"multiple atomic stores. The type of the pointee must be an integer, "
"pointer, or floating-point type whose bit width is a power of two greater"
" than or equal to eight and less than or equal to a target-specific size "
"limit.  ``align`` must be explicitly specified on atomic loads, and the "
"load has undefined behavior if the alignment is not set to a value which "
"is at least the size in bytes of the pointee. ``!nontemporal`` does not "
"have any defined semantics for atomic loads."
msgstr ""

#: ../../LangRef.rst:6801 ../../LangRef.rst:6925
msgid ""
"The optional constant ``align`` argument specifies the alignment of the "
"operation (that is, the alignment of the memory address). A value of 0 or"
" an omitted ``align`` argument means that the operation has the ABI "
"alignment for the target. It is the responsibility of the code emitter to"
" ensure that the alignment information is correct. Overestimating the "
"alignment results in undefined behavior. Underestimating the alignment "
"may produce less efficient code. An alignment of 1 is always safe. The "
"maximum possible alignment is ``1 << 29``."
msgstr ""

#: ../../LangRef.rst:6810 ../../LangRef.rst:6934
msgid ""
"The optional ``!nontemporal`` metadata must reference a single metadata "
"name ``<index>`` corresponding to a metadata node with one ``i32`` entry "
"of value 1. The existence of the ``!nontemporal`` metadata on the "
"instruction tells the optimizer and code generator that this load is not "
"expected to be reused in the cache. The code generator may select special"
" instructions to save cache bandwidth, such as the ``MOVNT`` instruction "
"on x86."
msgstr ""

#: ../../LangRef.rst:6818
msgid ""
"The optional ``!invariant.load`` metadata must reference a single "
"metadata name ``<index>`` corresponding to a metadata node with no "
"entries. The existence of the ``!invariant.load`` metadata on the "
"instruction tells the optimizer and code generator that the address "
"operand to this load points to memory which can be assumed unchanged. "
"Being invariant does not imply that a location is dereferenceable, but it"
" does imply that once the location is known dereferenceable its value is "
"henceforth unchanging."
msgstr ""

#: ../../LangRef.rst:6828
msgid ""
"The optional ``!invariant.group`` metadata must reference a single "
"metadata name"
msgstr ""

#: ../../LangRef.rst:6828
msgid ""
"``<index>`` corresponding to a metadata node. See ``invariant.group`` "
"metadata."
msgstr ""

#: ../../LangRef.rst:6830
msgid ""
"The optional ``!nonnull`` metadata must reference a single metadata name "
"``<index>`` corresponding to a metadata node with no entries. The "
"existence of the ``!nonnull`` metadata on the instruction tells the "
"optimizer that the value loaded is known to never be null. This is "
"analogous to the ``nonnull`` attribute on parameters and return values. "
"This metadata can only be applied to loads of a pointer type."
msgstr ""

#: ../../LangRef.rst:6838
msgid ""
"The optional ``!dereferenceable`` metadata must reference a single "
"metadata name ``<deref_bytes_node>`` corresponding to a metadata node "
"with one ``i64`` entry. The existence of the ``!dereferenceable`` "
"metadata on the instruction tells the optimizer that the value loaded is "
"known to be dereferenceable. The number of bytes known to be "
"dereferenceable is specified by the integer value in the metadata node. "
"This is analogous to the ''dereferenceable'' attribute on parameters and "
"return values. This metadata can only be applied to loads of a pointer "
"type."
msgstr ""

#: ../../LangRef.rst:6847
msgid ""
"The optional ``!dereferenceable_or_null`` metadata must reference a "
"single metadata name ``<deref_bytes_node>`` corresponding to a metadata "
"node with one ``i64`` entry. The existence of the "
"``!dereferenceable_or_null`` metadata on the instruction tells the "
"optimizer that the value loaded is known to be either dereferenceable or "
"null. The number of bytes known to be dereferenceable is specified by the"
" integer value in the metadata node. This is analogous to the "
"''dereferenceable_or_null'' attribute on parameters and return values. "
"This metadata can only be applied to loads of a pointer type."
msgstr ""

#: ../../LangRef.rst:6857
msgid ""
"The optional ``!align`` metadata must reference a single metadata name "
"``<align_node>`` corresponding to a metadata node with one ``i64`` entry."
" The existence of the ``!align`` metadata on the instruction tells the "
"optimizer that the value loaded is known to be aligned to a boundary "
"specified by the integer value in the metadata node. The alignment must "
"be a power of 2. This is analogous to the ''align'' attribute on "
"parameters and return values. This metadata can only be applied to loads "
"of a pointer type."
msgstr ""

#: ../../LangRef.rst:6868
msgid ""
"The location of memory pointed to is loaded. If the value being loaded is"
" of scalar type then the number of bytes read does not exceed the minimum"
" number of bytes needed to hold all bits of the type. For example, "
"loading an ``i24`` reads at most three bytes. When loading a value of a "
"type like ``i20`` with a size that is not an integral number of bytes, "
"the result is undefined if the value was not originally written using a "
"store of the same type."
msgstr ""

#: ../../LangRef.rst:6888
msgid "'``store``' Instruction"
msgstr ""

#: ../../LangRef.rst:6901
msgid "The '``store``' instruction is used to write to memory."
msgstr ""

#: ../../LangRef.rst:6906
msgid ""
"There are two arguments to the ``store`` instruction: a value to store "
"and an address at which to store it. The type of the ``<pointer>`` "
"operand must be a pointer to the :ref:`first class <t_firstclass>` type "
"of the ``<value>`` operand. If the ``store`` is marked as ``volatile``, "
"then the optimizer is not allowed to modify the number or order of "
"execution of this ``store`` with other :ref:`volatile operations "
"<volatile>`."
msgstr ""

#: ../../LangRef.rst:6914
msgid ""
"If the ``store`` is marked as ``atomic``, it takes an extra "
":ref:`ordering <ordering>` and optional ``singlethread`` argument. The "
"``acquire`` and ``acq_rel`` orderings aren't valid on ``store`` "
"instructions. Atomic loads produce :ref:`defined <memmodel>` results when"
" they may see multiple atomic stores. The type of the pointee must be an "
"integer, pointer, or floating-point type whose bit width is a power of "
"two greater than or equal to eight and less than or equal to a target-"
"specific size limit.  ``align`` must be explicitly specified on atomic "
"stores, and the store has undefined behavior if the alignment is not set "
"to a value which is at least the size in bytes of the pointee. "
"``!nontemporal`` does not have any defined semantics for atomic stores."
msgstr ""

#: ../../LangRef.rst:6942
msgid ""
"The optional ``!invariant.group`` metadata must reference a single "
"metadata name ``<index>``. See ``invariant.group`` metadata."
msgstr ""

#: ../../LangRef.rst:6948
msgid ""
"The contents of memory are updated to contain ``<value>`` at the location"
" specified by the ``<pointer>`` operand. If ``<value>`` is of scalar type"
" then the number of bytes written does not exceed the minimum number of "
"bytes needed to hold all bits of the type. For example, storing an "
"``i24`` writes at most three bytes. When writing a value of a type like "
"``i20`` with a size that is not an integral number of bytes, it is "
"unspecified what happens to the extra bits that do not belong to the "
"type, but they will typically be overwritten."
msgstr ""

#: ../../LangRef.rst:6969
msgid "'``fence``' Instruction"
msgstr ""

#: ../../LangRef.rst:6981
msgid ""
"The '``fence``' instruction is used to introduce happens-before edges "
"between operations."
msgstr ""

#: ../../LangRef.rst:6987
msgid ""
"'``fence``' instructions take an :ref:`ordering <ordering>` argument "
"which defines what *synchronizes-with* edges they add. They can only be "
"given ``acquire``, ``release``, ``acq_rel``, and ``seq_cst`` orderings."
msgstr ""

#: ../../LangRef.rst:6994
msgid ""
"A fence A which has (at least) ``release`` ordering semantics "
"*synchronizes with* a fence B with (at least) ``acquire`` ordering "
"semantics if and only if there exist atomic operations X and Y, both "
"operating on some atomic object M, such that A is sequenced before X, X "
"modifies M (either directly or through some side effect of a sequence "
"headed by X), Y is sequenced before B, and Y observes M. This provides a "
"*happens-before* dependency between A and B. Rather than an explicit "
"``fence``, one (but not both) of the atomic operations X or Y might "
"provide a ``release`` or ``acquire`` (resp.) ordering constraint and "
"still *synchronize-with* the explicit ``fence`` and establish the "
"*happens-before* edge."
msgstr ""

#: ../../LangRef.rst:7006
msgid ""
"A ``fence`` which has ``seq_cst`` ordering, in addition to having both "
"``acquire`` and ``release`` semantics specified above, participates in "
"the global program order of other ``seq_cst`` operations and/or fences."
msgstr ""

#: ../../LangRef.rst:7010
msgid ""
"The optional \":ref:`singlethread <singlethread>`\" argument specifies "
"that the fence only synchronizes with other fences in the same thread. "
"(This is useful for interacting with signal handlers.)"
msgstr ""

#: ../../LangRef.rst:7025
msgid "'``cmpxchg``' Instruction"
msgstr ""

#: ../../LangRef.rst:7037
msgid ""
"The '``cmpxchg``' instruction is used to atomically modify memory. It "
"loads a value in memory and compares it to a given value. If they are "
"equal, it tries to store a new value into the memory."
msgstr ""

#: ../../LangRef.rst:7044
msgid ""
"There are three arguments to the '``cmpxchg``' instruction: an address to"
" operate on, a value to compare to the value currently be at that "
"address, and a new value to place at that address if the compared values "
"are equal. The type of '<cmp>' must be an integer type whose bit width is"
" a power of two greater than or equal to eight and less than or equal to "
"a target-specific size limit. '<cmp>' and '<new>' must have the same "
"type, and the type of '<pointer>' must be a pointer to that type. If the "
"``cmpxchg`` is marked as ``volatile``, then the optimizer is not allowed "
"to modify the number or order of execution of this ``cmpxchg`` with other"
" :ref:`volatile operations <volatile>`."
msgstr ""

#: ../../LangRef.rst:7055
msgid ""
"The success and failure :ref:`ordering <ordering>` arguments specify how "
"this ``cmpxchg`` synchronizes with other atomic operations. Both ordering"
" parameters must be at least ``monotonic``, the ordering constraint on "
"failure must be no stronger than that on success, and the failure "
"ordering cannot be either ``release`` or ``acq_rel``."
msgstr ""

#: ../../LangRef.rst:7061
msgid ""
"The optional \"``singlethread``\" argument declares that the ``cmpxchg`` "
"is only atomic with respect to code (usually signal handlers) running in "
"the same thread as the ``cmpxchg``. Otherwise the cmpxchg is atomic with "
"respect to all other code in the system."
msgstr ""

#: ../../LangRef.rst:7066
msgid ""
"The pointer passed into cmpxchg must have alignment greater than or equal"
" to the size in memory of the operand."
msgstr ""

#: ../../LangRef.rst:7072
msgid ""
"The contents of memory at the location specified by the '``<pointer>``' "
"operand is read and compared to '``<cmp>``'; if the read value is the "
"equal, the '``<new>``' is written. The original value at the location is "
"returned, together with a flag indicating success (true) or failure "
"(false)."
msgstr ""

#: ../../LangRef.rst:7077
msgid ""
"If the cmpxchg operation is marked as ``weak`` then a spurious failure is"
" permitted: the operation may not write ``<new>`` even if the comparison "
"matched."
msgstr ""

#: ../../LangRef.rst:7081
msgid ""
"If the cmpxchg operation is strong (the default), the i1 value is 1 if "
"and only if the value loaded equals ``cmp``."
msgstr ""

#: ../../LangRef.rst:7084
msgid ""
"A successful ``cmpxchg`` is a read-modify-write instruction for the "
"purpose of identifying release sequences. A failed ``cmpxchg`` is "
"equivalent to an atomic load with an ordering parameter determined the "
"second ordering parameter."
msgstr ""

#: ../../LangRef.rst:7111
msgid "'``atomicrmw``' Instruction"
msgstr ""

#: ../../LangRef.rst:7123
msgid "The '``atomicrmw``' instruction is used to atomically modify memory."
msgstr ""

#: ../../LangRef.rst:7128
msgid ""
"There are three arguments to the '``atomicrmw``' instruction: an "
"operation to apply, an address whose value to modify, an argument to the "
"operation. The operation must be one of the following keywords:"
msgstr ""

#: ../../LangRef.rst:7132
msgid "xchg"
msgstr ""

#: ../../LangRef.rst:7133
msgid "add"
msgstr ""

#: ../../LangRef.rst:7134
msgid "sub"
msgstr ""

#: ../../LangRef.rst:7135
msgid "and"
msgstr ""

#: ../../LangRef.rst:7136
msgid "nand"
msgstr ""

#: ../../LangRef.rst:7137
msgid "or"
msgstr ""

#: ../../LangRef.rst:7138
msgid "xor"
msgstr ""

#: ../../LangRef.rst:7139
msgid "max"
msgstr ""

#: ../../LangRef.rst:7140
msgid "min"
msgstr ""

#: ../../LangRef.rst:7141
msgid "umax"
msgstr ""

#: ../../LangRef.rst:7142
msgid "umin"
msgstr ""

#: ../../LangRef.rst:7144
msgid ""
"The type of '<value>' must be an integer type whose bit width is a power "
"of two greater than or equal to eight and less than or equal to a target-"
"specific size limit. The type of the '``<pointer>``' operand must be a "
"pointer to that type. If the ``atomicrmw`` is marked as ``volatile``, "
"then the optimizer is not allowed to modify the number or order of "
"execution of this ``atomicrmw`` with other :ref:`volatile operations "
"<volatile>`."
msgstr ""

#: ../../LangRef.rst:7155
msgid ""
"The contents of memory at the location specified by the '``<pointer>``' "
"operand are atomically read, modified, and written back. The original "
"value at the location is returned. The modification is specified by the "
"operation argument:"
msgstr ""

#: ../../LangRef.rst:7160
msgid "xchg: ``*ptr = val``"
msgstr ""

#: ../../LangRef.rst:7161
msgid "add: ``*ptr = *ptr + val``"
msgstr ""

#: ../../LangRef.rst:7162
msgid "sub: ``*ptr = *ptr - val``"
msgstr ""

#: ../../LangRef.rst:7163
msgid "and: ``*ptr = *ptr & val``"
msgstr ""

#: ../../LangRef.rst:7164
msgid "nand: ``*ptr = ~(*ptr & val)``"
msgstr ""

#: ../../LangRef.rst:7165
msgid "or: ``*ptr = *ptr | val``"
msgstr ""

#: ../../LangRef.rst:7166
msgid "xor: ``*ptr = *ptr ^ val``"
msgstr ""

#: ../../LangRef.rst:7167
msgid "max: ``*ptr = *ptr > val ? *ptr : val`` (using a signed comparison)"
msgstr ""

#: ../../LangRef.rst:7168
msgid "min: ``*ptr = *ptr < val ? *ptr : val`` (using a signed comparison)"
msgstr ""

#: ../../LangRef.rst:7169
msgid "umax: ``*ptr = *ptr > val ? *ptr : val`` (using an unsigned comparison)"
msgstr ""

#: ../../LangRef.rst:7171
msgid "umin: ``*ptr = *ptr < val ? *ptr : val`` (using an unsigned comparison)"
msgstr ""

#: ../../LangRef.rst:7184
msgid "'``getelementptr``' Instruction"
msgstr ""

#: ../../LangRef.rst:7198
msgid ""
"The '``getelementptr``' instruction is used to get the address of a "
"subelement of an :ref:`aggregate <t_aggregate>` data structure. It "
"performs address calculation only and does not access memory. The "
"instruction can also be used to calculate a vector of such addresses."
msgstr ""

#: ../../LangRef.rst:7206
msgid ""
"The first argument is always a type used as the basis for the "
"calculations. The second argument is always a pointer or a vector of "
"pointers, and is the base address to start from. The remaining arguments "
"are indices that indicate which of the elements of the aggregate object "
"are indexed. The interpretation of each index is dependent on the type "
"being indexed into. The first index always indexes the pointer value "
"given as the first argument, the second index indexes a value of the type"
" pointed to (not necessarily the value directly pointed to, since the "
"first index can be non-zero), etc. The first type indexed into must be a "
"pointer value, subsequent types can be arrays, vectors, and structs. Note"
" that subsequent types being indexed into can never be pointers, since "
"that would require loading the pointer before continuing calculation."
msgstr ""

#: ../../LangRef.rst:7219
msgid ""
"The type of each index argument depends on the type it is indexing into. "
"When indexing into a (optionally packed) structure, only ``i32`` integer "
"**constants** are allowed (when using a vector of indices they must all "
"be the **same** ``i32`` integer constant). When indexing into an array, "
"pointer or vector, integers of any width are allowed, and they are not "
"required to be constant. These integers are treated as signed values "
"where relevant."
msgstr ""

#: ../../LangRef.rst:7227
msgid ""
"For example, let's consider a C code fragment and how it gets compiled to"
" LLVM:"
msgstr ""

#: ../../LangRef.rst:7247
msgid "The LLVM code generated by Clang is:"
msgstr ""

#: ../../LangRef.rst:7263
#, python-format
msgid ""
"In the example above, the first index is indexing into the "
"'``%struct.ST*``' type, which is a pointer, yielding a '``%struct.ST``' ="
" '``{ i32, double, %struct.RT }``' type, a structure. The second index "
"indexes into the third element of the structure, yielding a "
"'``%struct.RT``' = '``{ i8 , [10 x [20 x i32]], i8 }``' type, another "
"structure. The third index indexes into the second element of the "
"structure, yielding a '``[10 x [20 x i32]]``' type, an array. The two "
"dimensions of the array are subscripted into, yielding an '``i32``' type."
" The '``getelementptr``' instruction returns a pointer to this element, "
"thus computing a value of '``i32*``' type."
msgstr ""

#: ../../LangRef.rst:7274
msgid ""
"Note that it is perfectly legal to index partially through a structure, "
"returning a pointer to an inner element. Because of this, the LLVM code "
"for the given testcase is equivalent to:"
msgstr ""

#: ../../LangRef.rst:7289
msgid ""
"If the ``inbounds`` keyword is present, the result value of the "
"``getelementptr`` is a :ref:`poison value <poisonvalues>` if the base "
"pointer is not an *in bounds* address of an allocated object, or if any "
"of the addresses that would be formed by successive addition of the "
"offsets implied by the indices to the base address with infinitely "
"precise signed arithmetic are not an *in bounds* address of that "
"allocated object. The *in bounds* addresses for an allocated object are "
"all the addresses that point into the object, plus the address one byte "
"past the end. In cases where the base is a vector of pointers the "
"``inbounds`` keyword applies to each of the computations element-wise."
msgstr ""

#: ../../LangRef.rst:7300
msgid ""
"If the ``inbounds`` keyword is not present, the offsets are added to the "
"base address with silently-wrapping two's complement arithmetic. If the "
"offsets have a different width from the pointer, they are sign-extended "
"or truncated to the width of the pointer. The result value of the "
"``getelementptr`` may be outside the object pointed to by the base "
"pointer. The result value may not necessarily be used to access memory "
"though, even if it happens to point into allocated storage. See the "
":ref:`Pointer Aliasing Rules <pointeraliasing>` section for more "
"information."
msgstr ""

#: ../../LangRef.rst:7310
msgid ""
"The getelementptr instruction is often confusing. For some more insight "
"into how it works, see :doc:`the getelementptr FAQ <GetElementPtr>`."
msgstr ""

#: ../../LangRef.rst:7328
msgid "Vector of pointers:"
msgstr ""

#: ../../LangRef.rst:7330
msgid ""
"The ``getelementptr`` returns a vector of pointers, instead of a single "
"address, when one or more of its arguments is a vector. In such cases, "
"all vector arguments should have the same number of elements, and every "
"scalar argument will be effectively broadcast into a vector during "
"address calculation."
msgstr ""

#: ../../LangRef.rst:7351
msgid "The two following instructions are equivalent:"
msgstr ""

#: ../../LangRef.rst:7364
msgid ""
"Let's look at the C code, where the vector version of ``getelementptr`` "
"makes sense:"
msgstr ""

#: ../../LangRef.rst:7384
msgid "Conversion Operations"
msgstr ""

#: ../../LangRef.rst:7386
msgid ""
"The instructions in this category are the conversion instructions "
"(casting) which all take a single operand and a type. They perform "
"various bit conversions on the operand."
msgstr ""

#: ../../LangRef.rst:7391
msgid "'``trunc .. to``' Instruction"
msgstr ""

#: ../../LangRef.rst:7403
msgid "The '``trunc``' instruction truncates its operand to the type ``ty2``."
msgstr ""

#: ../../LangRef.rst:7408
msgid ""
"The '``trunc``' instruction takes a value to trunc, and a type to trunc "
"it to. Both types must be of :ref:`integer <t_integer>` types, or vectors"
" of the same number of integers. The bit size of the ``value`` must be "
"larger than the bit size of the destination type, ``ty2``. Equal sized "
"types are not allowed."
msgstr ""

#: ../../LangRef.rst:7417
msgid ""
"The '``trunc``' instruction truncates the high order bits in ``value`` "
"and converts the remaining bits to ``ty2``. Since the source size must be"
" larger than the destination size, ``trunc`` cannot be a *no-op cast*. It"
" will always truncate bits."
msgstr ""

#: ../../LangRef.rst:7433
msgid "'``zext .. to``' Instruction"
msgstr ""

#: ../../LangRef.rst:7445
msgid "The '``zext``' instruction zero extends its operand to type ``ty2``."
msgstr ""

#: ../../LangRef.rst:7450
msgid ""
"The '``zext``' instruction takes a value to cast, and a type to cast it "
"to. Both types must be of :ref:`integer <t_integer>` types, or vectors of"
" the same number of integers. The bit size of the ``value`` must be "
"smaller than the bit size of the destination type, ``ty2``."
msgstr ""

#: ../../LangRef.rst:7458
msgid ""
"The ``zext`` fills the high order bits of the ``value`` with zero bits "
"until it reaches the size of the destination type, ``ty2``."
msgstr ""

#: ../../LangRef.rst:7461
msgid "When zero extending from i1, the result will always be either 0 or 1."
msgstr ""

#: ../../LangRef.rst:7473
msgid "'``sext .. to``' Instruction"
msgstr ""

#: ../../LangRef.rst:7485
msgid "The '``sext``' sign extends ``value`` to the type ``ty2``."
msgstr ""

#: ../../LangRef.rst:7490
msgid ""
"The '``sext``' instruction takes a value to cast, and a type to cast it "
"to. Both types must be of :ref:`integer <t_integer>` types, or vectors of"
" the same number of integers. The bit size of the ``value`` must be "
"smaller than the bit size of the destination type, ``ty2``."
msgstr ""

#: ../../LangRef.rst:7498
msgid ""
"The '``sext``' instruction performs a sign extension by copying the sign "
"bit (highest order bit) of the ``value`` until it reaches the bit size of"
" the type ``ty2``."
msgstr ""

#: ../../LangRef.rst:7502
msgid "When sign extending from i1, the extension always results in -1 or 0."
msgstr ""

#: ../../LangRef.rst:7514
msgid "'``fptrunc .. to``' Instruction"
msgstr ""

#: ../../LangRef.rst:7526
msgid "The '``fptrunc``' instruction truncates ``value`` to type ``ty2``."
msgstr ""

#: ../../LangRef.rst:7531
msgid ""
"The '``fptrunc``' instruction takes a :ref:`floating point <t_floating>` "
"value to cast and a :ref:`floating point <t_floating>` type to cast it "
"to. The size of ``value`` must be larger than the size of ``ty2``. This "
"implies that ``fptrunc`` cannot be used to make a *no-op cast*."
msgstr ""

#: ../../LangRef.rst:7539
msgid ""
"The '``fptrunc``' instruction casts a ``value`` from a larger "
":ref:`floating point <t_floating>` type to a smaller :ref:`floating point"
" <t_floating>` type. If the value cannot fit (i.e. overflows) within the "
"destination type, ``ty2``, then the results are undefined. If the cast "
"produces an inexact result, how rounding is performed (e.g. truncation, "
"also known as round to zero) is undefined."
msgstr ""

#: ../../LangRef.rst:7555
msgid "'``fpext .. to``' Instruction"
msgstr ""

#: ../../LangRef.rst:7567
msgid ""
"The '``fpext``' extends a floating point ``value`` to a larger floating "
"point value."
msgstr ""

#: ../../LangRef.rst:7573
msgid ""
"The '``fpext``' instruction takes a :ref:`floating point <t_floating>` "
"``value`` to cast, and a :ref:`floating point <t_floating>` type to cast "
"it to. The source type must be smaller than the destination type."
msgstr ""

#: ../../LangRef.rst:7580
msgid ""
"The '``fpext``' instruction extends the ``value`` from a smaller "
":ref:`floating point <t_floating>` type to a larger :ref:`floating point "
"<t_floating>` type. The ``fpext`` cannot be used to make a *no-op cast* "
"because it always changes bits. Use ``bitcast`` to make a *no-op cast* "
"for a floating point cast."
msgstr ""

#: ../../LangRef.rst:7595
msgid "'``fptoui .. to``' Instruction"
msgstr ""

#: ../../LangRef.rst:7607
msgid ""
"The '``fptoui``' converts a floating point ``value`` to its unsigned "
"integer equivalent of type ``ty2``."
msgstr ""

#: ../../LangRef.rst:7613
msgid ""
"The '``fptoui``' instruction takes a value to cast, which must be a "
"scalar or vector :ref:`floating point <t_floating>` value, and a type to "
"cast it to ``ty2``, which must be an :ref:`integer <t_integer>` type. If "
"``ty`` is a vector floating point type, ``ty2`` must be a vector integer "
"type with the same number of elements as ``ty``"
msgstr ""

#: ../../LangRef.rst:7622
msgid ""
"The '``fptoui``' instruction converts its :ref:`floating point "
"<t_floating>` operand into the nearest (rounding towards zero) unsigned "
"integer value. If the value cannot fit in ``ty2``, the results are "
"undefined."
msgstr ""

#: ../../LangRef.rst:7637
msgid "'``fptosi .. to``' Instruction"
msgstr ""

#: ../../LangRef.rst:7649
msgid ""
"The '``fptosi``' instruction converts :ref:`floating point <t_floating>` "
"``value`` to type ``ty2``."
msgstr ""

#: ../../LangRef.rst:7655
msgid ""
"The '``fptosi``' instruction takes a value to cast, which must be a "
"scalar or vector :ref:`floating point <t_floating>` value, and a type to "
"cast it to ``ty2``, which must be an :ref:`integer <t_integer>` type. If "
"``ty`` is a vector floating point type, ``ty2`` must be a vector integer "
"type with the same number of elements as ``ty``"
msgstr ""

#: ../../LangRef.rst:7664
msgid ""
"The '``fptosi``' instruction converts its :ref:`floating point "
"<t_floating>` operand into the nearest (rounding towards zero) signed "
"integer value. If the value cannot fit in ``ty2``, the results are "
"undefined."
msgstr ""

#: ../../LangRef.rst:7679
msgid "'``uitofp .. to``' Instruction"
msgstr ""

#: ../../LangRef.rst:7691
msgid ""
"The '``uitofp``' instruction regards ``value`` as an unsigned integer and"
" converts that value to the ``ty2`` type."
msgstr ""

#: ../../LangRef.rst:7697
msgid ""
"The '``uitofp``' instruction takes a value to cast, which must be a "
"scalar or vector :ref:`integer <t_integer>` value, and a type to cast it "
"to ``ty2``, which must be an :ref:`floating point <t_floating>` type. If "
"``ty`` is a vector integer type, ``ty2`` must be a vector floating point "
"type with the same number of elements as ``ty``"
msgstr ""

#: ../../LangRef.rst:7706
msgid ""
"The '``uitofp``' instruction interprets its operand as an unsigned "
"integer quantity and converts it to the corresponding floating point "
"value. If the value cannot fit in the floating point value, the results "
"are undefined."
msgstr ""

#: ../../LangRef.rst:7720
msgid "'``sitofp .. to``' Instruction"
msgstr ""

#: ../../LangRef.rst:7732
msgid ""
"The '``sitofp``' instruction regards ``value`` as a signed integer and "
"converts that value to the ``ty2`` type."
msgstr ""

#: ../../LangRef.rst:7738
msgid ""
"The '``sitofp``' instruction takes a value to cast, which must be a "
"scalar or vector :ref:`integer <t_integer>` value, and a type to cast it "
"to ``ty2``, which must be an :ref:`floating point <t_floating>` type. If "
"``ty`` is a vector integer type, ``ty2`` must be a vector floating point "
"type with the same number of elements as ``ty``"
msgstr ""

#: ../../LangRef.rst:7747
msgid ""
"The '``sitofp``' instruction interprets its operand as a signed integer "
"quantity and converts it to the corresponding floating point value. If "
"the value cannot fit in the floating point value, the results are "
"undefined."
msgstr ""

#: ../../LangRef.rst:7763
msgid "'``ptrtoint .. to``' Instruction"
msgstr ""

#: ../../LangRef.rst:7775
msgid ""
"The '``ptrtoint``' instruction converts the pointer or a vector of "
"pointers ``value`` to the integer (or vector of integers) type ``ty2``."
msgstr ""

#: ../../LangRef.rst:7781
msgid ""
"The '``ptrtoint``' instruction takes a ``value`` to cast, which must be a"
" value of type :ref:`pointer <t_pointer>` or a vector of pointers, and a "
"type to cast it to ``ty2``, which must be an :ref:`integer <t_integer>` "
"or a vector of integers type."
msgstr ""

#: ../../LangRef.rst:7789
msgid ""
"The '``ptrtoint``' instruction converts ``value`` to integer type ``ty2``"
" by interpreting the pointer value as an integer and either truncating or"
" zero extending that value to the size of the integer type. If ``value`` "
"is smaller than ``ty2`` then a zero extension is done. If ``value`` is "
"larger than ``ty2`` then a truncation is done. If they are the same size,"
" then nothing is done (*no-op cast*) other than a type change."
msgstr ""

#: ../../LangRef.rst:7809
msgid "'``inttoptr .. to``' Instruction"
msgstr ""

#: ../../LangRef.rst:7821
msgid ""
"The '``inttoptr``' instruction converts an integer ``value`` to a pointer"
" type, ``ty2``."
msgstr ""

#: ../../LangRef.rst:7827
msgid ""
"The '``inttoptr``' instruction takes an :ref:`integer <t_integer>` value "
"to cast, and a type to cast it to, which must be a :ref:`pointer "
"<t_pointer>` type."
msgstr ""

#: ../../LangRef.rst:7834
msgid ""
"The '``inttoptr``' instruction converts ``value`` to type ``ty2`` by "
"applying either a zero extension or a truncation depending on the size of"
" the integer ``value``. If ``value`` is larger than the size of a pointer"
" then a truncation is done. If ``value`` is smaller than the size of a "
"pointer then a zero extension is done. If they are the same size, nothing"
" is done (*no-op cast*)."
msgstr ""

#: ../../LangRef.rst:7854
msgid "'``bitcast .. to``' Instruction"
msgstr ""

#: ../../LangRef.rst:7866
msgid ""
"The '``bitcast``' instruction converts ``value`` to type ``ty2`` without "
"changing any bits."
msgstr ""

#: ../../LangRef.rst:7872
msgid ""
"The '``bitcast``' instruction takes a value to cast, which must be a non-"
"aggregate first class value, and a type to cast it to, which must also be"
" a non-aggregate :ref:`first class <t_firstclass>` type. The bit sizes of"
" ``value`` and the destination type, ``ty2``, must be identical. If the "
"source type is a pointer, the destination type must also be a pointer of "
"the same size. This instruction supports bitwise conversion of vectors to"
" integers and to vectors of other types (as long as they have the same "
"size)."
msgstr ""

#: ../../LangRef.rst:7884
msgid ""
"The '``bitcast``' instruction converts ``value`` to type ``ty2``. It is "
"always a *no-op cast* because no bits change with this conversion. The "
"conversion is done as if the ``value`` had been stored to memory and read"
" back as type ``ty2``. Pointer (or vector of pointers) types may only be "
"converted to other pointer (or vector of pointers) types with the same "
"address space through this instruction. To convert pointers to other "
"types, use the :ref:`inttoptr <i_inttoptr>` or :ref:`ptrtoint "
"<i_ptrtoint>` instructions first."
msgstr ""

#: ../../LangRef.rst:7906
msgid "'``addrspacecast .. to``' Instruction"
msgstr ""

#: ../../LangRef.rst:7918
msgid ""
"The '``addrspacecast``' instruction converts ``ptrval`` from ``pty`` in "
"address space ``n`` to type ``pty2`` in address space ``m``."
msgstr ""

#: ../../LangRef.rst:7924
msgid ""
"The '``addrspacecast``' instruction takes a pointer or vector of pointer "
"value to cast and a pointer type to cast it to, which must have a "
"different address space."
msgstr ""

#: ../../LangRef.rst:7931
msgid ""
"The '``addrspacecast``' instruction converts the pointer value ``ptrval``"
" to type ``pty2``. It can be a *no-op cast* or a complex value "
"modification, depending on the target and the address space pair. Pointer"
" conversions within the same address space must be performed with the "
"``bitcast`` instruction. Note that if the address space conversion is "
"legal then both result and operand refer to the same memory location."
msgstr ""

#: ../../LangRef.rst:7951
msgid "Other Operations"
msgstr ""

#: ../../LangRef.rst:7953
msgid ""
"The instructions in this category are the \"miscellaneous\" instructions,"
" which defy better classification."
msgstr ""

#: ../../LangRef.rst:7959
msgid "'``icmp``' Instruction"
msgstr ""

#: ../../LangRef.rst:7971
msgid ""
"The '``icmp``' instruction returns a boolean value or a vector of boolean"
" values based on comparison of its two integer, integer vector, pointer, "
"or pointer vector operands."
msgstr ""

#: ../../LangRef.rst:7978
msgid ""
"The '``icmp``' instruction takes three operands. The first operand is the"
" condition code indicating the kind of comparison to perform. It is not a"
" value, just a keyword. The possible condition code are:"
msgstr ""

#: ../../LangRef.rst:7982
msgid "``eq``: equal"
msgstr ""

#: ../../LangRef.rst:7983
msgid "``ne``: not equal"
msgstr ""

#: ../../LangRef.rst:7984
msgid "``ugt``: unsigned greater than"
msgstr ""

#: ../../LangRef.rst:7985
msgid "``uge``: unsigned greater or equal"
msgstr ""

#: ../../LangRef.rst:7986
msgid "``ult``: unsigned less than"
msgstr ""

#: ../../LangRef.rst:7987
msgid "``ule``: unsigned less or equal"
msgstr ""

#: ../../LangRef.rst:7988
msgid "``sgt``: signed greater than"
msgstr ""

#: ../../LangRef.rst:7989
msgid "``sge``: signed greater or equal"
msgstr ""

#: ../../LangRef.rst:7990
msgid "``slt``: signed less than"
msgstr ""

#: ../../LangRef.rst:7991
msgid "``sle``: signed less or equal"
msgstr ""

#: ../../LangRef.rst:7993
msgid ""
"The remaining two arguments must be :ref:`integer <t_integer>` or "
":ref:`pointer <t_pointer>` or integer :ref:`vector <t_vector>` typed. "
"They must also be identical types."
msgstr ""

#: ../../LangRef.rst:8000
msgid ""
"The '``icmp``' compares ``op1`` and ``op2`` according to the condition "
"code given as ``cond``. The comparison performed always yields either an "
":ref:`i1 <t_integer>` or vector of ``i1`` result, as follows:"
msgstr ""

#: ../../LangRef.rst:8004
msgid ""
"``eq``: yields ``true`` if the operands are equal, ``false`` otherwise. "
"No sign interpretation is necessary or performed."
msgstr ""

#: ../../LangRef.rst:8006
msgid ""
"``ne``: yields ``true`` if the operands are unequal, ``false`` otherwise."
" No sign interpretation is necessary or performed."
msgstr ""

#: ../../LangRef.rst:8008
msgid ""
"``ugt``: interprets the operands as unsigned values and yields ``true`` "
"if ``op1`` is greater than ``op2``."
msgstr ""

#: ../../LangRef.rst:8010
msgid ""
"``uge``: interprets the operands as unsigned values and yields ``true`` "
"if ``op1`` is greater than or equal to ``op2``."
msgstr ""

#: ../../LangRef.rst:8012
msgid ""
"``ult``: interprets the operands as unsigned values and yields ``true`` "
"if ``op1`` is less than ``op2``."
msgstr ""

#: ../../LangRef.rst:8014
msgid ""
"``ule``: interprets the operands as unsigned values and yields ``true`` "
"if ``op1`` is less than or equal to ``op2``."
msgstr ""

#: ../../LangRef.rst:8016
msgid ""
"``sgt``: interprets the operands as signed values and yields ``true`` if "
"``op1`` is greater than ``op2``."
msgstr ""

#: ../../LangRef.rst:8018
msgid ""
"``sge``: interprets the operands as signed values and yields ``true`` if "
"``op1`` is greater than or equal to ``op2``."
msgstr ""

#: ../../LangRef.rst:8020
msgid ""
"``slt``: interprets the operands as signed values and yields ``true`` if "
"``op1`` is less than ``op2``."
msgstr ""

#: ../../LangRef.rst:8022
msgid ""
"``sle``: interprets the operands as signed values and yields ``true`` if "
"``op1`` is less than or equal to ``op2``."
msgstr ""

#: ../../LangRef.rst:8025
msgid ""
"If the operands are :ref:`pointer <t_pointer>` typed, the pointer values "
"are compared as if they were integers."
msgstr ""

#: ../../LangRef.rst:8028
msgid ""
"If the operands are integer vectors, then they are compared element by "
"element. The result is an ``i1`` vector with the same number of elements "
"as the values being compared. Otherwise, the result is an ``i1``."
msgstr ""

#: ../../LangRef.rst:8044
msgid ""
"Note that the code generator does not yet support vector types with the "
"``icmp`` instruction."
msgstr ""

#: ../../LangRef.rst:8050
msgid "'``fcmp``' Instruction"
msgstr ""

#: ../../LangRef.rst:8062
msgid ""
"The '``fcmp``' instruction returns a boolean value or vector of boolean "
"values based on comparison of its operands."
msgstr ""

#: ../../LangRef.rst:8065
msgid ""
"If the operands are floating point scalars, then the result type is a "
"boolean (:ref:`i1 <t_integer>`)."
msgstr ""

#: ../../LangRef.rst:8068
msgid ""
"If the operands are floating point vectors, then the result type is a "
"vector of boolean with the same number of elements as the operands being "
"compared."
msgstr ""

#: ../../LangRef.rst:8075
msgid ""
"The '``fcmp``' instruction takes three operands. The first operand is the"
" condition code indicating the kind of comparison to perform. It is not a"
" value, just a keyword. The possible condition code are:"
msgstr ""

#: ../../LangRef.rst:8079
msgid "``false``: no comparison, always returns false"
msgstr ""

#: ../../LangRef.rst:8080
msgid "``oeq``: ordered and equal"
msgstr ""

#: ../../LangRef.rst:8081
msgid "``ogt``: ordered and greater than"
msgstr ""

#: ../../LangRef.rst:8082
msgid "``oge``: ordered and greater than or equal"
msgstr ""

#: ../../LangRef.rst:8083
msgid "``olt``: ordered and less than"
msgstr ""

#: ../../LangRef.rst:8084
msgid "``ole``: ordered and less than or equal"
msgstr ""

#: ../../LangRef.rst:8085
msgid "``one``: ordered and not equal"
msgstr ""

#: ../../LangRef.rst:8086
msgid "``ord``: ordered (no nans)"
msgstr ""

#: ../../LangRef.rst:8087
msgid "``ueq``: unordered or equal"
msgstr ""

#: ../../LangRef.rst:8088
msgid "``ugt``: unordered or greater than"
msgstr ""

#: ../../LangRef.rst:8089
msgid "``uge``: unordered or greater than or equal"
msgstr ""

#: ../../LangRef.rst:8090
msgid "``ult``: unordered or less than"
msgstr ""

#: ../../LangRef.rst:8091
msgid "``ule``: unordered or less than or equal"
msgstr ""

#: ../../LangRef.rst:8092
msgid "``une``: unordered or not equal"
msgstr ""

#: ../../LangRef.rst:8093
msgid "``uno``: unordered (either nans)"
msgstr ""

#: ../../LangRef.rst:8094
msgid "``true``: no comparison, always returns true"
msgstr ""

#: ../../LangRef.rst:8096
msgid ""
"*Ordered* means that neither operand is a QNAN while *unordered* means "
"that either operand may be a QNAN."
msgstr ""

#: ../../LangRef.rst:8099
msgid ""
"Each of ``val1`` and ``val2`` arguments must be either a :ref:`floating "
"point <t_floating>` type or a :ref:`vector <t_vector>` of floating point "
"type. They must have identical types."
msgstr ""

#: ../../LangRef.rst:8106
msgid ""
"The '``fcmp``' instruction compares ``op1`` and ``op2`` according to the "
"condition code given as ``cond``. If the operands are vectors, then the "
"vectors are compared element by element. Each comparison performed always"
" yields an :ref:`i1 <t_integer>` result, as follows:"
msgstr ""

#: ../../LangRef.rst:8111
msgid "``false``: always yields ``false``, regardless of operands."
msgstr ""

#: ../../LangRef.rst:8112
msgid ""
"``oeq``: yields ``true`` if both operands are not a QNAN and ``op1`` is "
"equal to ``op2``."
msgstr ""

#: ../../LangRef.rst:8114
msgid ""
"``ogt``: yields ``true`` if both operands are not a QNAN and ``op1`` is "
"greater than ``op2``."
msgstr ""

#: ../../LangRef.rst:8116
msgid ""
"``oge``: yields ``true`` if both operands are not a QNAN and ``op1`` is "
"greater than or equal to ``op2``."
msgstr ""

#: ../../LangRef.rst:8118
msgid ""
"``olt``: yields ``true`` if both operands are not a QNAN and ``op1`` is "
"less than ``op2``."
msgstr ""

#: ../../LangRef.rst:8120
msgid ""
"``ole``: yields ``true`` if both operands are not a QNAN and ``op1`` is "
"less than or equal to ``op2``."
msgstr ""

#: ../../LangRef.rst:8122
msgid ""
"``one``: yields ``true`` if both operands are not a QNAN and ``op1`` is "
"not equal to ``op2``."
msgstr ""

#: ../../LangRef.rst:8124
msgid "``ord``: yields ``true`` if both operands are not a QNAN."
msgstr ""

#: ../../LangRef.rst:8125
msgid ""
"``ueq``: yields ``true`` if either operand is a QNAN or ``op1`` is equal "
"to ``op2``."
msgstr ""

#: ../../LangRef.rst:8127
msgid ""
"``ugt``: yields ``true`` if either operand is a QNAN or ``op1`` is "
"greater than ``op2``."
msgstr ""

#: ../../LangRef.rst:8129
msgid ""
"``uge``: yields ``true`` if either operand is a QNAN or ``op1`` is "
"greater than or equal to ``op2``."
msgstr ""

#: ../../LangRef.rst:8131
msgid ""
"``ult``: yields ``true`` if either operand is a QNAN or ``op1`` is less "
"than ``op2``."
msgstr ""

#: ../../LangRef.rst:8133
msgid ""
"``ule``: yields ``true`` if either operand is a QNAN or ``op1`` is less "
"than or equal to ``op2``."
msgstr ""

#: ../../LangRef.rst:8135
msgid ""
"``une``: yields ``true`` if either operand is a QNAN or ``op1`` is not "
"equal to ``op2``."
msgstr ""

#: ../../LangRef.rst:8137
msgid "``uno``: yields ``true`` if either operand is a QNAN."
msgstr ""

#: ../../LangRef.rst:8138
msgid "``true``: always yields ``true``, regardless of operands."
msgstr ""

#: ../../LangRef.rst:8140
msgid ""
"The ``fcmp`` instruction can also optionally take any number of :ref"
":`fast-math flags <fastmath>`, which are optimization hints to enable "
"otherwise unsafe floating point optimizations."
msgstr ""

#: ../../LangRef.rst:8144
msgid ""
"Any set of fast-math flags are legal on an ``fcmp`` instruction, but the "
"only flags that have any effect on its semantics are those that allow "
"assumptions to be made about the values of input arguments; namely "
"``nnan``, ``ninf``, and ``nsz``. See :ref:`fastmath` for more "
"information."
msgstr ""

#: ../../LangRef.rst:8159
msgid ""
"Note that the code generator does not yet support vector types with the "
"``fcmp`` instruction."
msgstr ""

#: ../../LangRef.rst:8165
msgid "'``phi``' Instruction"
msgstr ""

#: ../../LangRef.rst:8177
msgid ""
"The '``phi``' instruction is used to implement the  node in the SSA "
"graph representing the function."
msgstr ""

#: ../../LangRef.rst:8183
msgid ""
"The type of the incoming values is specified with the first type field. "
"After this, the '``phi``' instruction takes a list of pairs as arguments,"
" with one pair for each predecessor basic block of the current block. "
"Only values of :ref:`first class <t_firstclass>` type may be used as the "
"value arguments to the PHI node. Only labels may be used as the label "
"arguments."
msgstr ""

#: ../../LangRef.rst:8190
msgid ""
"There must be no non-phi instructions between the start of a basic block "
"and the PHI instructions: i.e. PHI instructions must be first in a basic "
"block."
msgstr ""

#: ../../LangRef.rst:8194
msgid ""
"For the purposes of the SSA form, the use of each incoming value is "
"deemed to occur on the edge from the corresponding predecessor block to "
"the current block (but after any definition of an '``invoke``' "
"instruction's return value on the same edge)."
msgstr ""

#: ../../LangRef.rst:8202
msgid ""
"At runtime, the '``phi``' instruction logically takes on the value "
"specified by the pair corresponding to the predecessor basic block that "
"executed just prior to the current block."
msgstr ""

#: ../../LangRef.rst:8219
msgid "'``select``' Instruction"
msgstr ""

#: ../../LangRef.rst:8233
msgid ""
"The '``select``' instruction is used to choose one value based on a "
"condition, without IR-level branching."
msgstr ""

#: ../../LangRef.rst:8239
msgid ""
"The '``select``' instruction requires an 'i1' value or a vector of 'i1' "
"values indicating the condition, and two values of the same :ref:`first "
"class <t_firstclass>` type."
msgstr ""

#: ../../LangRef.rst:8246
msgid ""
"If the condition is an i1 and it evaluates to 1, the instruction returns "
"the first value argument; otherwise, it returns the second value "
"argument."
msgstr ""

#: ../../LangRef.rst:8250
msgid ""
"If the condition is a vector of i1, then the value arguments must be "
"vectors of the same size, and the selection is done element by element."
msgstr ""

#: ../../LangRef.rst:8253
msgid ""
"If the condition is an i1 and the value arguments are vectors of the same"
" size, then an entire vector is selected."
msgstr ""

#: ../../LangRef.rst:8266
msgid "'``call``' Instruction"
msgstr ""

#: ../../LangRef.rst:8279
msgid "The '``call``' instruction represents a simple function call."
msgstr ""

#: ../../LangRef.rst:8286
msgid ""
"The optional ``tail`` and ``musttail`` markers indicate that the "
"optimizers should perform tail call optimization. The ``tail`` marker is "
"a hint that `can be ignored <CodeGenerator.html#sibcallopt>`_. The "
"``musttail`` marker means that the call must be tail call optimized in "
"order for the program to be correct. The ``musttail`` marker provides "
"these guarantees:"
msgstr ""

#: ../../LangRef.rst:8292
msgid ""
"The call will not cause unbounded stack growth if it is part of a "
"recursive cycle in the call graph."
msgstr ""

#: ../../LangRef.rst:8294
msgid ""
"Arguments with the :ref:`inalloca <attr_inalloca>` attribute are "
"forwarded in place."
msgstr ""

#: ../../LangRef.rst:8297
msgid ""
"Both markers imply that the callee does not access allocas or varargs "
"from the caller. Calls marked ``musttail`` must obey the following "
"additional rules:"
msgstr ""

#: ../../LangRef.rst:8301
msgid ""
"The call must immediately precede a :ref:`ret <i_ret>` instruction, or a "
"pointer bitcast followed by a ret instruction."
msgstr ""

#: ../../LangRef.rst:8303
msgid ""
"The ret instruction must return the (possibly bitcasted) value produced "
"by the call or void."
msgstr ""

#: ../../LangRef.rst:8305
msgid ""
"The caller and callee prototypes must match. Pointer types of parameters "
"or return types may differ in pointee type, but not in address space."
msgstr ""

#: ../../LangRef.rst:8308
msgid "The calling conventions of the caller and callee must match."
msgstr ""

#: ../../LangRef.rst:8309
msgid ""
"All ABI-impacting function attributes, such as sret, byval, inreg, "
"returned, and inalloca, must match."
msgstr ""

#: ../../LangRef.rst:8311
msgid ""
"The callee must be varargs iff the caller is varargs. Bitcasting a non-"
"varargs function to the appropriate varargs type is legal so long as the "
"non-varargs prefixes obey the other rules."
msgstr ""

#: ../../LangRef.rst:8315
msgid ""
"Tail call optimization for calls marked ``tail`` is guaranteed to occur "
"if the following conditions are met:"
msgstr ""

#: ../../LangRef.rst:8318
msgid "Caller and callee both have the calling convention ``fastcc``."
msgstr ""

#: ../../LangRef.rst:8319
msgid ""
"The call is in tail position (ret immediately follows call and ret uses "
"value of call or is void)."
msgstr ""

#: ../../LangRef.rst:8321
msgid ""
"Option ``-tailcallopt`` is enabled, or ``llvm::GuaranteedTailCallOpt`` is"
" ``true``."
msgstr ""

#: ../../LangRef.rst:8323
msgid "`Platform-specific constraints are met. <CodeGenerator.html#tailcallopt>`_"
msgstr ""

#: ../../LangRef.rst:8326
msgid ""
"The optional ``notail`` marker indicates that the optimizers should not "
"add ``tail`` or ``musttail`` markers to the call. It is used to prevent "
"tail call optimization from being performed on the call."
msgstr ""

#: ../../LangRef.rst:8330
msgid ""
"The optional ``fast-math flags`` marker indicates that the call has one "
"or more :ref:`fast-math flags <fastmath>`, which are optimization hints "
"to enable otherwise unsafe floating-point optimizations. Fast-math flags "
"are only valid for calls that return a floating-point scalar or vector "
"type."
msgstr ""

#: ../../LangRef.rst:8335
msgid ""
"The optional \"cconv\" marker indicates which :ref:`calling convention "
"<callingconv>` the call should use. If none is specified, the call "
"defaults to using C calling conventions. The calling convention of the "
"call must match the calling convention of the target function, or else "
"the behavior is undefined."
msgstr ""

#: ../../LangRef.rst:8343
msgid ""
"'``ty``': the type of the call instruction itself which is also the type "
"of the return value. Functions that return no value are marked ``void``."
msgstr ""

#: ../../LangRef.rst:8346
msgid ""
"'``fnty``': shall be the signature of the pointer to function value being"
" invoked. The argument types must match the types implied by this "
"signature. This type can be omitted if the function is not varargs and if"
" the function type does not return a pointer to a function."
msgstr ""

#: ../../LangRef.rst:8351
msgid ""
"'``fnptrval``': An LLVM value containing a pointer to a function to be "
"invoked. In most cases, this is a direct function invocation, but "
"indirect ``call``'s are just as possible, calling an arbitrary pointer to"
" function value."
msgstr ""

#: ../../LangRef.rst:8368
msgid ""
"The '``call``' instruction is used to cause control flow to transfer to a"
" specified function, with its incoming arguments bound to the specified "
"values. Upon a '``ret``' instruction in the called function, control flow"
" continues with the instruction after the function call, and the return "
"value of the function is bound to the result argument."
msgstr ""

#: ../../LangRef.rst:8392
msgid ""
"llvm treats calls to some functions with names and arguments that match "
"the standard C99 library as being the C99 library functions, and may "
"perform optimizations or generate code for them under that assumption. "
"This is something we'd like to change in the future to provide better "
"support for freestanding environments and non-C-based languages."
msgstr ""

#: ../../LangRef.rst:8401
msgid "'``va_arg``' Instruction"
msgstr ""

#: ../../LangRef.rst:8413
msgid ""
"The '``va_arg``' instruction is used to access arguments passed through "
"the \"variable argument\" area of a function call. It is used to "
"implement the ``va_arg`` macro in C."
msgstr ""

#: ../../LangRef.rst:8420
msgid ""
"This instruction takes a ``va_list*`` value and the type of the argument."
" It returns a value of the specified argument type and increments the "
"``va_list`` to point to the next argument. The actual type of ``va_list``"
" is target specific."
msgstr ""

#: ../../LangRef.rst:8428
msgid ""
"The '``va_arg``' instruction loads an argument of the specified type from"
" the specified ``va_list`` and causes the ``va_list`` to point to the "
"next argument. For more information, see the variable argument handling "
":ref:`Intrinsic Functions <int_varargs>`."
msgstr ""

#: ../../LangRef.rst:8433
msgid ""
"It is legal for this instruction to be called in a function which does "
"not take a variable number of arguments, for example, the ``vfprintf`` "
"function."
msgstr ""

#: ../../LangRef.rst:8437
msgid ""
"``va_arg`` is an LLVM instruction instead of an :ref:`intrinsic function "
"<intrinsics>` because it takes a type as an argument."
msgstr ""

#: ../../LangRef.rst:8443
msgid "See the :ref:`variable argument processing <int_varargs>` section."
msgstr ""

#: ../../LangRef.rst:8445
msgid ""
"Note that the code generator does not yet fully support va\\_arg on many "
"targets. Also, it does not currently support va\\_arg with aggregate "
"types on any target."
msgstr ""

#: ../../LangRef.rst:8452
msgid "'``landingpad``' Instruction"
msgstr ""

#: ../../LangRef.rst:8468
msgid ""
"The '``landingpad``' instruction is used by `LLVM's exception handling "
"system <ExceptionHandling.html#overview>`_ to specify that a basic block "
"is a landing pad --- one where the exception lands, and corresponds to "
"the code found in the ``catch`` portion of a ``try``/``catch`` sequence. "
"It defines values supplied by the :ref:`personality function "
"<personalityfn>` upon re-entry to the function. The ``resultval`` has the"
" type ``resultty``."
msgstr ""

#: ../../LangRef.rst:8478
msgid ""
"The optional ``cleanup`` flag indicates that the landing pad block is a "
"cleanup."
msgstr ""

#: ../../LangRef.rst:8481
msgid ""
"A ``clause`` begins with the clause type --- ``catch`` or ``filter`` --- "
"and contains the global variable representing the \"type\" that may be "
"caught or filtered respectively. Unlike the ``catch`` clause, the "
"``filter`` clause takes an array constant as its argument. Use \"``[0 x "
"i8**] undef``\" for a filter which cannot throw. The '``landingpad``' "
"instruction must contain *at least* one ``clause`` or the ``cleanup`` "
"flag."
msgstr ""

#: ../../LangRef.rst:8492
msgid ""
"The '``landingpad``' instruction defines the values which are set by the "
":ref:`personality function <personalityfn>` upon re-entry to the "
"function, and therefore the \"result type\" of the ``landingpad`` "
"instruction. As with calling conventions, how the personality function "
"results are represented in LLVM IR is target specific."
msgstr ""

#: ../../LangRef.rst:8498
msgid ""
"The clauses are applied in order from top to bottom. If two "
"``landingpad`` instructions are merged together through inlining, the "
"clauses from the calling function are appended to the list of clauses. "
"When the call stack is being unwound due to an exception being thrown, "
"the exception is compared against each ``clause`` in turn. If it doesn't "
"match any of the clauses, and the ``cleanup`` flag is not set, then "
"unwinding continues further up the call stack."
msgstr ""

#: ../../LangRef.rst:8506
msgid "The ``landingpad`` instruction has several restrictions:"
msgstr ""

#: ../../LangRef.rst:8508
msgid ""
"A landing pad block is a basic block which is the unwind destination of "
"an '``invoke``' instruction."
msgstr ""

#: ../../LangRef.rst:8510
msgid ""
"A landing pad block must have a '``landingpad``' instruction as its first"
" non-PHI instruction."
msgstr ""

#: ../../LangRef.rst:8512
msgid ""
"There can be only one '``landingpad``' instruction within the landing pad"
" block."
msgstr ""

#: ../../LangRef.rst:8514
msgid ""
"A basic block that is not a landing pad block may not include a "
"'``landingpad``' instruction."
msgstr ""

#: ../../LangRef.rst:8536
msgid "'``catchpad``' Instruction"
msgstr ""

#: ../../LangRef.rst:8548
msgid ""
"The '``catchpad``' instruction is used by `LLVM's exception handling "
"system <ExceptionHandling.html#overview>`_ to specify that a basic block "
"begins a catch handler --- one where a personality routine attempts to "
"transfer control to catch an exception."
msgstr ""

#: ../../LangRef.rst:8556
msgid ""
"The ``catchswitch`` operand must always be a token produced by a "
":ref:`catchswitch <i_catchswitch>` instruction in a predecessor block. "
"This ensures that each ``catchpad`` has exactly one predecessor block, "
"and it always terminates in a ``catchswitch``."
msgstr ""

#: ../../LangRef.rst:8561
msgid ""
"The ``args`` correspond to whatever information the personality routine "
"requires to know if this is an appropriate handler for the exception. "
"Control will transfer to the ``catchpad`` if this is the first "
"appropriate handler for the exception."
msgstr ""

#: ../../LangRef.rst:8566
msgid ""
"The ``resultval`` has the type :ref:`token <t_token>` and is used to "
"match the ``catchpad`` to corresponding :ref:`catchrets <i_catchret>` and"
" other nested EH pads."
msgstr ""

#: ../../LangRef.rst:8573
msgid ""
"When the call stack is being unwound due to an exception being thrown, "
"the exception is compared against the ``args``. If it doesn't match, "
"control will not reach the ``catchpad`` instruction.  The representation "
"of ``args`` is entirely target and personality function-specific."
msgstr ""

#: ../../LangRef.rst:8578
msgid ""
"Like the :ref:`landingpad <i_landingpad>` instruction, the ``catchpad`` "
"instruction must be the first non-phi of its parent basic block."
msgstr ""

#: ../../LangRef.rst:8581
msgid ""
"The meaning of the tokens produced and consumed by ``catchpad`` and other"
" \"pad\" instructions is described in the `Windows exception handling "
"documentation\\ <ExceptionHandling.html#wineh>`_."
msgstr ""

#: ../../LangRef.rst:8585
msgid ""
"When a ``catchpad`` has been \"entered\" but not yet \"exited\" (as "
"described in the `EH documentation\\ <ExceptionHandling.html#wineh-"
"constraints>`_), it is undefined behavior to execute a :ref:`call "
"<i_call>` or :ref:`invoke <i_invoke>` that does not carry an appropriate "
":ref:`\"funclet\" bundle <ob_funclet>`."
msgstr ""

#: ../../LangRef.rst:8604
msgid "'``cleanuppad``' Instruction"
msgstr ""

#: ../../LangRef.rst:8616
msgid ""
"The '``cleanuppad``' instruction is used by `LLVM's exception handling "
"system <ExceptionHandling.html#overview>`_ to specify that a basic block "
"is a cleanup block --- one where a personality routine attempts to "
"transfer control to run cleanup actions. The ``args`` correspond to "
"whatever additional information the :ref:`personality function "
"<personalityfn>` requires to execute the cleanup. The ``resultval`` has "
"the type :ref:`token <t_token>` and is used to match the ``cleanuppad`` "
"to corresponding :ref:`cleanuprets <i_cleanupret>`. The ``parent`` "
"argument is the token of the funclet that contains the ``cleanuppad`` "
"instruction. If the ``cleanuppad`` is not inside a funclet, this operand "
"may be the token ``none``."
msgstr ""

#: ../../LangRef.rst:8632
msgid ""
"The instruction takes a list of arbitrary values which are interpreted by"
" the :ref:`personality function <personalityfn>`."
msgstr ""

#: ../../LangRef.rst:8638
msgid ""
"When the call stack is being unwound due to an exception being thrown, "
"the :ref:`personality function <personalityfn>` transfers control to the "
"``cleanuppad`` with the aid of the personality-specific arguments. As "
"with calling conventions, how the personality function results are "
"represented in LLVM IR is target specific."
msgstr ""

#: ../../LangRef.rst:8644
msgid "The ``cleanuppad`` instruction has several restrictions:"
msgstr ""

#: ../../LangRef.rst:8646
msgid ""
"A cleanup block is a basic block which is the unwind destination of an "
"exceptional instruction."
msgstr ""

#: ../../LangRef.rst:8648
msgid ""
"A cleanup block must have a '``cleanuppad``' instruction as its first "
"non-PHI instruction."
msgstr ""

#: ../../LangRef.rst:8650
msgid ""
"There can be only one '``cleanuppad``' instruction within the cleanup "
"block."
msgstr ""

#: ../../LangRef.rst:8652
msgid ""
"A basic block that is not a cleanup block may not include a "
"'``cleanuppad``' instruction."
msgstr ""

#: ../../LangRef.rst:8655
msgid ""
"When a ``cleanuppad`` has been \"entered\" but not yet \"exited\" (as "
"described in the `EH documentation\\ <ExceptionHandling.html#wineh-"
"constraints>`_), it is undefined behavior to execute a :ref:`call "
"<i_call>` or :ref:`invoke <i_invoke>` that does not carry an appropriate "
":ref:`\"funclet\" bundle <ob_funclet>`."
msgstr ""

#: ../../LangRef.rst:8670
msgid "Intrinsic Functions"
msgstr ""

#: ../../LangRef.rst:8672
msgid ""
"LLVM supports the notion of an \"intrinsic function\". These functions "
"have well known names and semantics and are required to follow certain "
"restrictions. Overall, these intrinsics represent an extension mechanism "
"for the LLVM language that does not require changing all of the "
"transformations in LLVM when adding to the language (or the bitcode "
"reader/writer, the parser, etc...)."
msgstr ""

#: ../../LangRef.rst:8679
msgid ""
"Intrinsic function names must all start with an \"``llvm.``\" prefix. "
"This prefix is reserved in LLVM for intrinsic names; thus, function names"
" may not begin with this prefix. Intrinsic functions must always be "
"external functions: you cannot define the body of intrinsic functions. "
"Intrinsic functions may only be used in call or invoke instructions: it "
"is illegal to take the address of an intrinsic function. Additionally, "
"because intrinsic functions are part of the LLVM language, it is required"
" if any are added that they be documented here."
msgstr ""

#: ../../LangRef.rst:8688
msgid ""
"Some intrinsic functions can be overloaded, i.e., the intrinsic "
"represents a family of functions that perform the same operation but on "
"different data types. Because LLVM can represent over 8 million different"
" integer types, overloading is used commonly to allow an intrinsic "
"function to operate on any integer type. One or more of the argument "
"types or the result type can be overloaded to accept any integer type. "
"Argument types may also be defined as exactly matching a previous "
"argument's type or the result type. This allows an intrinsic function "
"which accepts multiple arguments, but needs all of them to be of the same"
" type, to only be overloaded with respect to a single argument or the "
"result."
msgstr ""

#: ../../LangRef.rst:8700
msgid ""
"Overloaded intrinsics will have the names of its overloaded argument "
"types encoded into its function name, each preceded by a period. Only "
"those types which are overloaded result in a name suffix. Arguments whose"
" type is matched against another type do not. For example, the "
"``llvm.ctpop`` function can take an integer of any width and returns an "
"integer of exactly the same integer width. This leads to a family of "
"functions such as ``i8 @llvm.ctpop.i8(i8 %val)`` and ``i29 "
"@llvm.ctpop.i29(i29 %val)``. Only one type, the return type, is "
"overloaded, and only one type suffix is required. Because the argument's "
"type is matched against the return type, it does not require its own name"
" suffix."
msgstr ""

#: ../../LangRef.rst:8712
msgid ""
"To learn how to add an intrinsic function, please see the `Extending LLVM"
" Guide <ExtendingLLVM.html>`_."
msgstr ""

#: ../../LangRef.rst:8718
msgid "Variable Argument Handling Intrinsics"
msgstr ""

#: ../../LangRef.rst:8720
msgid ""
"Variable argument support is defined in LLVM with the :ref:`va_arg "
"<i_va_arg>` instruction and these three intrinsic functions. These "
"functions are related to the similarly named macros defined in the "
"``<stdarg.h>`` header file."
msgstr ""

#: ../../LangRef.rst:8725
msgid ""
"All of these functions operate on arguments that use a target-specific "
"value type \"``va_list``\". The LLVM assembly language reference manual "
"does not define what this type is, so all transformations should be "
"prepared to handle these functions regardless of the type used."
msgstr ""

#: ../../LangRef.rst:8730
msgid ""
"This example shows how the :ref:`va_arg <i_va_arg>` instruction and the "
"variable argument handling intrinsic functions are used."
msgstr ""

#: ../../LangRef.rst:8769
msgid "'``llvm.va_start``' Intrinsic"
msgstr ""

#: ../../LangRef.rst:8781
msgid ""
"The '``llvm.va_start``' intrinsic initializes ``*<arglist>`` for "
"subsequent use by ``va_arg``."
msgstr ""

#: ../../LangRef.rst:8787
msgid "The argument is a pointer to a ``va_list`` element to initialize."
msgstr ""

#: ../../LangRef.rst:8792
msgid ""
"The '``llvm.va_start``' intrinsic works just like the ``va_start`` macro "
"available in C. In a target-dependent way, it initializes the ``va_list``"
" element to which the argument points, so that the next call to "
"``va_arg`` will produce the first variable argument passed to the "
"function. Unlike the C ``va_start`` macro, this intrinsic does not need "
"to know the last argument of the function as the compiler can figure that"
" out."
msgstr ""

#: ../../LangRef.rst:8801
msgid "'``llvm.va_end``' Intrinsic"
msgstr ""

#: ../../LangRef.rst:8813
msgid ""
"The '``llvm.va_end``' intrinsic destroys ``*<arglist>``, which has been "
"initialized previously with ``llvm.va_start`` or ``llvm.va_copy``."
msgstr ""

#: ../../LangRef.rst:8819
msgid "The argument is a pointer to a ``va_list`` to destroy."
msgstr ""

#: ../../LangRef.rst:8824
msgid ""
"The '``llvm.va_end``' intrinsic works just like the ``va_end`` macro "
"available in C. In a target-dependent way, it destroys the ``va_list`` "
"element to which the argument points. Calls to :ref:`llvm.va_start "
"<int_va_start>` and :ref:`llvm.va_copy <int_va_copy>` must be matched "
"exactly with calls to ``llvm.va_end``."
msgstr ""

#: ../../LangRef.rst:8834
msgid "'``llvm.va_copy``' Intrinsic"
msgstr ""

#: ../../LangRef.rst:8846
msgid ""
"The '``llvm.va_copy``' intrinsic copies the current argument position "
"from the source argument list to the destination argument list."
msgstr ""

#: ../../LangRef.rst:8852
msgid ""
"The first argument is a pointer to a ``va_list`` element to initialize. "
"The second argument is a pointer to a ``va_list`` element to copy from."
msgstr ""

#: ../../LangRef.rst:8858
msgid ""
"The '``llvm.va_copy``' intrinsic works just like the ``va_copy`` macro "
"available in C. In a target-dependent way, it copies the source "
"``va_list`` element into the destination ``va_list`` element. This "
"intrinsic is necessary because the `` llvm.va_start`` intrinsic may be "
"arbitrarily complex and require, for example, memory allocation."
msgstr ""

#: ../../LangRef.rst:8865
msgid "Accurate Garbage Collection Intrinsics"
msgstr ""

#: ../../LangRef.rst:8867
msgid ""
"LLVM's support for `Accurate Garbage Collection "
"<GarbageCollection.html>`_ (GC) requires the frontend to generate code "
"containing appropriate intrinsic calls and select an appropriate GC "
"strategy which knows how to lower these intrinsics in a manner which is "
"appropriate for the target collector."
msgstr ""

#: ../../LangRef.rst:8872
msgid ""
"These intrinsics allow identification of :ref:`GC roots on the stack "
"<int_gcroot>`, as well as garbage collector implementations that require "
":ref:`read <int_gcread>` and :ref:`write <int_gcwrite>` barriers. "
"Frontends for type-safe garbage collected languages should generate these"
" intrinsics to make use of the LLVM garbage collectors. For more details,"
" see `Garbage Collection with LLVM <GarbageCollection.html>`_."
msgstr ""

#: ../../LangRef.rst:8880
msgid "Experimental Statepoint Intrinsics"
msgstr ""

#: ../../LangRef.rst:8882
msgid ""
"LLVM provides an second experimental set of intrinsics for describing "
"garbage collection safepoints in compiled code. These intrinsics are an "
"alternative to the ``llvm.gcroot`` intrinsics, but are compatible with "
"the ones for :ref:`read <int_gcread>` and :ref:`write <int_gcwrite>` "
"barriers. The differences in approach are covered in the `Garbage "
"Collection with LLVM <GarbageCollection.html>`_ documentation. The "
"intrinsics themselves are described in :doc:`Statepoints`."
msgstr ""

#: ../../LangRef.rst:8893
msgid "'``llvm.gcroot``' Intrinsic"
msgstr ""

#: ../../LangRef.rst:8905
msgid ""
"The '``llvm.gcroot``' intrinsic declares the existence of a GC root to "
"the code generator, and allows some metadata to be associated with it."
msgstr ""

#: ../../LangRef.rst:8911
msgid ""
"The first argument specifies the address of a stack object that contains "
"the root pointer. The second pointer (which must be either a constant or "
"a global value address) contains the meta-data to be associated with the "
"root."
msgstr ""

#: ../../LangRef.rst:8919
msgid ""
"At runtime, a call to this intrinsic stores a null pointer into the "
"\"ptrloc\" location. At compile-time, the code generator generates "
"information to allow the runtime to find the pointer at GC safe points. "
"The '``llvm.gcroot``' intrinsic may only be used in a function which "
":ref:`specifies a GC algorithm <gc>`."
msgstr ""

#: ../../LangRef.rst:8928
msgid "'``llvm.gcread``' Intrinsic"
msgstr ""

#: ../../LangRef.rst:8940
msgid ""
"The '``llvm.gcread``' intrinsic identifies reads of references from heap "
"locations, allowing garbage collector implementations that require read "
"barriers."
msgstr ""

#: ../../LangRef.rst:8947
msgid ""
"The second argument is the address to read from, which should be an "
"address allocated from the garbage collector. The first object is a "
"pointer to the start of the referenced object, if needed by the language "
"runtime (otherwise null)."
msgstr ""

#: ../../LangRef.rst:8955
msgid ""
"The '``llvm.gcread``' intrinsic has the same semantics as a load "
"instruction, but may be replaced with substantially more complex code by "
"the garbage collector runtime, as needed. The '``llvm.gcread``' intrinsic"
" may only be used in a function which :ref:`specifies a GC algorithm "
"<gc>`."
msgstr ""

#: ../../LangRef.rst:8964
msgid "'``llvm.gcwrite``' Intrinsic"
msgstr ""

#: ../../LangRef.rst:8976
msgid ""
"The '``llvm.gcwrite``' intrinsic identifies writes of references to heap "
"locations, allowing garbage collector implementations that require write "
"barriers (such as generational or reference counting collectors)."
msgstr ""

#: ../../LangRef.rst:8983
msgid ""
"The first argument is the reference to store, the second is the start of "
"the object to store it to, and the third is the address of the field of "
"Obj to store to. If the runtime does not require a pointer to the object,"
" Obj may be null."
msgstr ""

#: ../../LangRef.rst:8991
msgid ""
"The '``llvm.gcwrite``' intrinsic has the same semantics as a store "
"instruction, but may be replaced with substantially more complex code by "
"the garbage collector runtime, as needed. The '``llvm.gcwrite``' "
"intrinsic may only be used in a function which :ref:`specifies a GC "
"algorithm <gc>`."
msgstr ""

#: ../../LangRef.rst:8998
msgid "Code Generator Intrinsics"
msgstr ""

#: ../../LangRef.rst:9000
msgid ""
"These intrinsics are provided by LLVM to expose special features that may"
" only be implemented with code generator support."
msgstr ""

#: ../../LangRef.rst:9004
msgid "'``llvm.returnaddress``' Intrinsic"
msgstr ""

#: ../../LangRef.rst:9016
msgid ""
"The '``llvm.returnaddress``' intrinsic attempts to compute a target-"
"specific value indicating the return address of the current function or "
"one of its callers."
msgstr ""

#: ../../LangRef.rst:9023
msgid ""
"The argument to this intrinsic indicates which function to return the "
"address for. Zero indicates the calling function, one indicates its "
"caller, etc. The argument is **required** to be a constant integer value."
msgstr ""

#: ../../LangRef.rst:9031
msgid ""
"The '``llvm.returnaddress``' intrinsic either returns a pointer "
"indicating the return address of the specified call frame, or zero if it "
"cannot be identified. The value returned by this intrinsic is likely to "
"be incorrect or 0 for arguments other than zero, so it should only be "
"used for debugging purposes."
msgstr ""

#: ../../LangRef.rst:9037 ../../LangRef.rst:9074
msgid ""
"Note that calling this intrinsic does not prevent function inlining or "
"other aggressive transformations, so the value returned may not be that "
"of the obvious source-language caller."
msgstr ""

#: ../../LangRef.rst:9042
msgid "'``llvm.frameaddress``' Intrinsic"
msgstr ""

#: ../../LangRef.rst:9054
msgid ""
"The '``llvm.frameaddress``' intrinsic attempts to return the target-"
"specific frame pointer value for the specified stack frame."
msgstr ""

#: ../../LangRef.rst:9060
msgid ""
"The argument to this intrinsic indicates which function to return the "
"frame pointer for. Zero indicates the calling function, one indicates its"
" caller, etc. The argument is **required** to be a constant integer "
"value."
msgstr ""

#: ../../LangRef.rst:9068
msgid ""
"The '``llvm.frameaddress``' intrinsic either returns a pointer indicating"
" the frame address of the specified call frame, or zero if it cannot be "
"identified. The value returned by this intrinsic is likely to be "
"incorrect or 0 for arguments other than zero, so it should only be used "
"for debugging purposes."
msgstr ""

#: ../../LangRef.rst:9079
msgid "'``llvm.localescape``' and '``llvm.localrecover``' Intrinsics"
msgstr ""

#: ../../LangRef.rst:9092
msgid ""
"The '``llvm.localescape``' intrinsic escapes offsets of a collection of "
"static allocas, and the '``llvm.localrecover``' intrinsic applies those "
"offsets to a live frame pointer to recover the address of the allocation."
" The offset is computed during frame layout of the caller of "
"``llvm.localescape``."
msgstr ""

#: ../../LangRef.rst:9100
msgid ""
"All arguments to '``llvm.localescape``' must be pointers to static "
"allocas or casts of static allocas. Each function can only call "
"'``llvm.localescape``' once, and it can only do so from the entry block."
msgstr ""

#: ../../LangRef.rst:9104
msgid ""
"The ``func`` argument to '``llvm.localrecover``' must be a constant "
"bitcasted pointer to a function defined in the current module. The code "
"generator cannot determine the frame allocation offset of functions "
"defined in other modules."
msgstr ""

#: ../../LangRef.rst:9109
msgid ""
"The ``fp`` argument to '``llvm.localrecover``' must be a frame pointer of"
" a call frame that is currently live. The return value of "
"'``llvm.localaddress``' is one way to produce such a value, but various "
"runtimes also expose a suitable pointer in platform-specific ways."
msgstr ""

#: ../../LangRef.rst:9114
msgid ""
"The ``idx`` argument to '``llvm.localrecover``' indicates which alloca "
"passed to '``llvm.localescape``' to recover. It is zero-indexed."
msgstr ""

#: ../../LangRef.rst:9120
msgid ""
"These intrinsics allow a group of functions to share access to a set of "
"local stack allocations of a one parent function. The parent function may"
" call the '``llvm.localescape``' intrinsic once from the function entry "
"block, and the child functions can use '``llvm.localrecover``' to access "
"the escaped allocas. The '``llvm.localescape``' intrinsic blocks "
"inlining, as inlining changes where the escaped allocas are allocated, "
"which would break attempts to use '``llvm.localrecover``'."
msgstr ""

#: ../../LangRef.rst:9132
msgid "'``llvm.read_register``' and '``llvm.write_register``' Intrinsics"
msgstr ""

#: ../../LangRef.rst:9148
msgid ""
"The '``llvm.read_register``' and '``llvm.write_register``' intrinsics "
"provides access to the named register. The register must be valid on the "
"architecture being compiled to. The type needs to be compatible with the "
"register being read."
msgstr ""

#: ../../LangRef.rst:9156
msgid ""
"The '``llvm.read_register``' intrinsic returns the current value of the "
"register, where possible. The '``llvm.write_register``' intrinsic sets "
"the current value of the register, where possible."
msgstr ""

#: ../../LangRef.rst:9160
msgid ""
"This is useful to implement named register global variables that need to "
"always be mapped to a specific register, as is common practice on bare-"
"metal programs including OS kernels."
msgstr ""

#: ../../LangRef.rst:9164
msgid ""
"The compiler doesn't check for register availability or use of the used "
"register in surrounding code, including inline assembly. Because of that,"
" allocatable registers are not supported."
msgstr ""

#: ../../LangRef.rst:9168
msgid ""
"Warning: So far it only works with the stack pointer on selected "
"architectures (ARM, AArch64, PowerPC and x86_64). Significant amount of "
"work is needed to support other registers and even more so, allocatable "
"registers."
msgstr ""

#: ../../LangRef.rst:9176
msgid "'``llvm.stacksave``' Intrinsic"
msgstr ""

#: ../../LangRef.rst:9188
msgid ""
"The '``llvm.stacksave``' intrinsic is used to remember the current state "
"of the function stack, for use with :ref:`llvm.stackrestore "
"<int_stackrestore>`. This is useful for implementing language features "
"like scoped automatic variable sized arrays in C99."
msgstr ""

#: ../../LangRef.rst:9197
msgid ""
"This intrinsic returns a opaque pointer value that can be passed to "
":ref:`llvm.stackrestore <int_stackrestore>`. When an "
"``llvm.stackrestore`` intrinsic is executed with a value saved from "
"``llvm.stacksave``, it effectively restores the state of the stack to the"
" state it was in when the ``llvm.stacksave`` intrinsic executed. In "
"practice, this pops any :ref:`alloca <i_alloca>` blocks from the stack "
"that were allocated after the ``llvm.stacksave`` was executed."
msgstr ""

#: ../../LangRef.rst:9208
msgid "'``llvm.stackrestore``' Intrinsic"
msgstr ""

#: ../../LangRef.rst:9220
msgid ""
"The '``llvm.stackrestore``' intrinsic is used to restore the state of the"
" function stack to the state it was in when the corresponding "
":ref:`llvm.stacksave <int_stacksave>` intrinsic executed. This is useful "
"for implementing language features like scoped automatic variable sized "
"arrays in C99."
msgstr ""

#: ../../LangRef.rst:9229
msgid "See the description for :ref:`llvm.stacksave <int_stacksave>`."
msgstr ""

#: ../../LangRef.rst:9234
msgid "'``llvm.get.dynamic.area.offset``' Intrinsic"
msgstr ""

#: ../../LangRef.rst:9258
msgid ""
"These intrinsics return a non-negative integer value that can be used to "
"get the address of the most recent dynamic alloca, allocated by "
":ref:`alloca <i_alloca>` on the caller's stack. In particular, for "
"targets where stack grows downwards, adding this offset to the native "
"stack pointer would get the address of the most recent dynamic alloca. "
"For targets where stack grows upwards, the situation is a bit more "
"complicated, because substracting this value from stack pointer would get"
" the address one past the end of the most recent dynamic alloca."
msgstr ""

#: ../../LangRef.rst:9266
msgid ""
"Although for most targets `llvm.get.dynamic.area.offset "
"<int_get_dynamic_area_offset>` returns just a zero, for others, such as "
"PowerPC and PowerPC64, it returns a compile-time-known constant value."
msgstr ""

#: ../../LangRef.rst:9270
msgid ""
"The return value type of :ref:`llvm.get.dynamic.area.offset "
"<int_get_dynamic_area_offset>` must match the target's generic address "
"space's (address space 0) pointer type."
msgstr ""

#: ../../LangRef.rst:9274
msgid "'``llvm.prefetch``' Intrinsic"
msgstr ""

#: ../../LangRef.rst:9286
msgid ""
"The '``llvm.prefetch``' intrinsic is a hint to the code generator to "
"insert a prefetch instruction if supported; otherwise, it is a noop. "
"Prefetches have no effect on the behavior of the program but can change "
"its performance characteristics."
msgstr ""

#: ../../LangRef.rst:9294
msgid ""
"``address`` is the address to be prefetched, ``rw`` is the specifier "
"determining if the fetch should be for a read (0) or write (1), and "
"``locality`` is a temporal locality specifier ranging from (0) - no "
"locality, to (3) - extremely local keep in cache. The ``cache type`` "
"specifies whether the prefetch is performed on the data (1) or "
"instruction (0) cache. The ``rw``, ``locality`` and ``cache type`` "
"arguments must be constant integers."
msgstr ""

#: ../../LangRef.rst:9305
msgid ""
"This intrinsic does not modify the behavior of the program. In "
"particular, prefetches cannot trap and do not produce a value. On targets"
" that support this intrinsic, the prefetch can provide hints to the "
"processor cache for better performance."
msgstr ""

#: ../../LangRef.rst:9311
msgid "'``llvm.pcmarker``' Intrinsic"
msgstr ""

#: ../../LangRef.rst:9323
msgid ""
"The '``llvm.pcmarker``' intrinsic is a method to export a Program Counter"
" (PC) in a region of code to simulators and other tools. The method is "
"target specific, but it is expected that the marker will use exported "
"symbols to transmit the PC of the marker. The marker makes no guarantees "
"that it will remain with any specific instruction after optimizations. It"
" is possible that the presence of a marker will inhibit optimizations. "
"The intended use is to be inserted after optimizations to allow "
"correlations of simulation runs."
msgstr ""

#: ../../LangRef.rst:9335
msgid "``id`` is a numerical id identifying the marker."
msgstr ""

#: ../../LangRef.rst:9340
msgid ""
"This intrinsic does not modify the behavior of the program. Backends that"
" do not support this intrinsic may ignore it."
msgstr ""

#: ../../LangRef.rst:9344
msgid "'``llvm.readcyclecounter``' Intrinsic"
msgstr ""

#: ../../LangRef.rst:9356
msgid ""
"The '``llvm.readcyclecounter``' intrinsic provides access to the cycle "
"counter register (or similar low latency, high accuracy clocks) on those "
"targets that support it. On X86, it should map to RDTSC. On Alpha, it "
"should map to RPCC. As the backing counters overflow quickly (on the "
"order of 9 seconds on alpha), this should only be used for small timings."
msgstr ""

#: ../../LangRef.rst:9366
msgid ""
"When directly supported, reading the cycle counter should not modify any "
"memory. Implementations are allowed to either return a application "
"specific value or a system wide value. On backends without support, this "
"is lowered to a constant 0."
msgstr ""

#: ../../LangRef.rst:9371
msgid ""
"Note that runtime support may be conditional on the privilege-level code "
"is running at and the host platform."
msgstr ""

#: ../../LangRef.rst:9375
msgid "'``llvm.clear_cache``' Intrinsic"
msgstr ""

#: ../../LangRef.rst:9387
msgid ""
"The '``llvm.clear_cache``' intrinsic ensures visibility of modifications "
"in the specified range to the execution unit of the processor. On targets"
" with non-unified instruction and data cache, the implementation flushes "
"the instruction cache."
msgstr ""

#: ../../LangRef.rst:9395
msgid ""
"On platforms with coherent instruction and data caches (e.g. x86), this "
"intrinsic is a nop. On platforms with non-coherent instruction and data "
"cache (e.g. ARM, MIPS), the intrinsic is lowered either to appropriate "
"instructions or a system call, if cache flushing requires special "
"privileges."
msgstr ""

#: ../../LangRef.rst:9401
msgid ""
"The default behavior is to emit a call to ``__clear_cache`` from the run "
"time library."
msgstr ""

#: ../../LangRef.rst:9404
msgid ""
"This instrinsic does *not* empty the instruction pipeline. Modifications "
"of the current function are outside the scope of the intrinsic."
msgstr ""

#: ../../LangRef.rst:9408
msgid "'``llvm.instrprof_increment``' Intrinsic"
msgstr ""

#: ../../LangRef.rst:9421
msgid ""
"The '``llvm.instrprof_increment``' intrinsic can be emitted by a frontend"
" for use with instrumentation based profiling. These will be lowered by "
"the ``-instrprof`` pass to generate execution counts of a program at "
"runtime."
msgstr ""

#: ../../LangRef.rst:9429
msgid ""
"The first argument is a pointer to a global variable containing the name "
"of the entity being instrumented. This should generally be the (mangled) "
"function name for a set of counters."
msgstr ""

#: ../../LangRef.rst:9433
msgid ""
"The second argument is a hash value that can be used by the consumer of "
"the profile data to detect changes to the instrumented source, and the "
"third is the number of counters associated with ``name``. It is an error "
"if ``hash`` or ``num-counters`` differ between two instances of "
"``instrprof_increment`` that refer to the same name."
msgstr ""

#: ../../LangRef.rst:9439
msgid ""
"The last argument refers to which of the counters for ``name`` should be "
"incremented. It should be a value between 0 and ``num-counters``."
msgstr ""

#: ../../LangRef.rst:9445
msgid ""
"This intrinsic represents an increment of a profiling counter. It will "
"cause the ``-instrprof`` pass to generate the appropriate data structures"
" and the code to increment the appropriate value, in a format that can be"
" written out by a compiler runtime and consumed via the ``llvm-profdata``"
" tool."
msgstr ""

#: ../../LangRef.rst:9452
msgid "'``llvm.instrprof_value_profile``' Intrinsic"
msgstr ""

#: ../../LangRef.rst:9466
msgid ""
"The '``llvm.instrprof_value_profile``' intrinsic can be emitted by a "
"frontend for use with instrumentation based profiling. This will be "
"lowered by the ``-instrprof`` pass to find out the target values, "
"instrumented expressions take in a program at runtime."
msgstr ""

#: ../../LangRef.rst:9474
msgid ""
"The first argument is a pointer to a global variable containing the name "
"of the entity being instrumented. ``name`` should generally be the "
"(mangled) function name for a set of counters."
msgstr ""

#: ../../LangRef.rst:9478
msgid ""
"The second argument is a hash value that can be used by the consumer of "
"the profile data to detect changes to the instrumented source. It is an "
"error if ``hash`` differs between two instances of ``llvm.instrprof_*`` "
"that refer to the same name."
msgstr ""

#: ../../LangRef.rst:9483
msgid ""
"The third argument is the value of the expression being profiled. The "
"profiled expression's value should be representable as an unsigned 64-bit"
" value. The fourth argument represents the kind of value profiling that "
"is being done. The supported value profiling kinds are enumerated through"
" the ``InstrProfValueKind`` type declared in the "
"``<include/llvm/ProfileData/InstrProf.h>`` header file. The last argument"
" is the index of the instrumented expression within ``name``. It should "
"be >= 0."
msgstr ""

#: ../../LangRef.rst:9494
msgid ""
"This intrinsic represents the point where a call to a runtime routine "
"should be inserted for value profiling of target expressions. "
"``-instrprof`` pass will generate the appropriate data structures and "
"replace the ``llvm.instrprof_value_profile`` intrinsic with the call to "
"the profile runtime library with proper arguments."
msgstr ""

#: ../../LangRef.rst:9501
msgid "Standard C Library Intrinsics"
msgstr ""

#: ../../LangRef.rst:9503
msgid ""
"LLVM provides intrinsics for a few important standard C library "
"functions. These intrinsics allow source-language front-ends to pass "
"information about the alignment of the pointer arguments to the code "
"generator, providing opportunity for more efficient code generation."
msgstr ""

#: ../../LangRef.rst:9511
msgid "'``llvm.memcpy``' Intrinsic"
msgstr ""

#: ../../LangRef.rst:9516
msgid ""
"This is an overloaded intrinsic. You can use ``llvm.memcpy`` on any "
"integer bit width and for different address spaces. Not all targets "
"support all bit widths however."
msgstr ""

#: ../../LangRef.rst:9530
msgid ""
"The '``llvm.memcpy.*``' intrinsics copy a block of memory from the source"
" location to the destination location."
msgstr ""

#: ../../LangRef.rst:9533
msgid ""
"Note that, unlike the standard libc function, the ``llvm.memcpy.*`` "
"intrinsics do not return a value, takes extra alignment/isvolatile "
"arguments and the pointers can be in specified address spaces."
msgstr ""

#: ../../LangRef.rst:9540 ../../LangRef.rst:9595
msgid ""
"The first argument is a pointer to the destination, the second is a "
"pointer to the source. The third argument is an integer argument "
"specifying the number of bytes to copy, the fourth argument is the "
"alignment of the source and destination locations, and the fifth is a "
"boolean indicating a volatile access."
msgstr ""

#: ../../LangRef.rst:9546
msgid ""
"If the call to this intrinsic has an alignment value that is not 0 or 1, "
"then the caller guarantees that both the source and destination pointers "
"are aligned to that boundary."
msgstr ""

#: ../../LangRef.rst:9550
msgid ""
"If the ``isvolatile`` parameter is ``true``, the ``llvm.memcpy`` call is "
"a :ref:`volatile operation <volatile>`. The detailed access behavior is "
"not very cleanly specified and it is unwise to depend on it."
msgstr ""

#: ../../LangRef.rst:9557
msgid ""
"The '``llvm.memcpy.*``' intrinsics copy a block of memory from the source"
" location to the destination location, which are not allowed to overlap. "
"It copies \"len\" bytes of memory over. If the argument is known to be "
"aligned to some boundary, this can be specified as the fourth argument, "
"otherwise it should be set to 0 or 1 (both meaning no alignment)."
msgstr ""

#: ../../LangRef.rst:9564
msgid "'``llvm.memmove``' Intrinsic"
msgstr ""

#: ../../LangRef.rst:9569
msgid ""
"This is an overloaded intrinsic. You can use llvm.memmove on any integer "
"bit width and for different address space. Not all targets support all "
"bit widths however."
msgstr ""

#: ../../LangRef.rst:9583
msgid ""
"The '``llvm.memmove.*``' intrinsics move a block of memory from the "
"source location to the destination location. It is similar to the "
"'``llvm.memcpy``' intrinsic but allows the two memory locations to "
"overlap."
msgstr ""

#: ../../LangRef.rst:9588
msgid ""
"Note that, unlike the standard libc function, the ``llvm.memmove.*`` "
"intrinsics do not return a value, takes extra alignment/isvolatile "
"arguments and the pointers can be in specified address spaces."
msgstr ""

#: ../../LangRef.rst:9601
msgid ""
"If the call to this intrinsic has an alignment value that is not 0 or 1, "
"then the caller guarantees that the source and destination pointers are "
"aligned to that boundary."
msgstr ""

#: ../../LangRef.rst:9605
msgid ""
"If the ``isvolatile`` parameter is ``true``, the ``llvm.memmove`` call is"
" a :ref:`volatile operation <volatile>`. The detailed access behavior is "
"not very cleanly specified and it is unwise to depend on it."
msgstr ""

#: ../../LangRef.rst:9612
msgid ""
"The '``llvm.memmove.*``' intrinsics copy a block of memory from the "
"source location to the destination location, which may overlap. It copies"
" \"len\" bytes of memory over. If the argument is known to be aligned to "
"some boundary, this can be specified as the fourth argument, otherwise it"
" should be set to 0 or 1 (both meaning no alignment)."
msgstr ""

#: ../../LangRef.rst:9619
msgid "'``llvm.memset.*``' Intrinsics"
msgstr ""

#: ../../LangRef.rst:9624
msgid ""
"This is an overloaded intrinsic. You can use llvm.memset on any integer "
"bit width and for different address spaces. However, not all targets "
"support all bit widths."
msgstr ""

#: ../../LangRef.rst:9638
msgid ""
"The '``llvm.memset.*``' intrinsics fill a block of memory with a "
"particular byte value."
msgstr ""

#: ../../LangRef.rst:9641
msgid ""
"Note that, unlike the standard libc function, the ``llvm.memset`` "
"intrinsic does not return a value and takes extra alignment/volatile "
"arguments. Also, the destination can be in an arbitrary address space."
msgstr ""

#: ../../LangRef.rst:9648
msgid ""
"The first argument is a pointer to the destination to fill, the second is"
" the byte value with which to fill it, the third argument is an integer "
"argument specifying the number of bytes to fill, and the fourth argument "
"is the known alignment of the destination location."
msgstr ""

#: ../../LangRef.rst:9653
msgid ""
"If the call to this intrinsic has an alignment value that is not 0 or 1, "
"then the caller guarantees that the destination pointer is aligned to "
"that boundary."
msgstr ""

#: ../../LangRef.rst:9657
msgid ""
"If the ``isvolatile`` parameter is ``true``, the ``llvm.memset`` call is "
"a :ref:`volatile operation <volatile>`. The detailed access behavior is "
"not very cleanly specified and it is unwise to depend on it."
msgstr ""

#: ../../LangRef.rst:9664
msgid ""
"The '``llvm.memset.*``' intrinsics fill \"len\" bytes of memory starting "
"at the destination location. If the argument is known to be aligned to "
"some boundary, this can be specified as the fourth argument, otherwise it"
" should be set to 0 or 1 (both meaning no alignment)."
msgstr ""

#: ../../LangRef.rst:9670
msgid "'``llvm.sqrt.*``' Intrinsic"
msgstr ""

#: ../../LangRef.rst:9675
msgid ""
"This is an overloaded intrinsic. You can use ``llvm.sqrt`` on any "
"floating point or vector of floating point type. Not all targets support "
"all types however."
msgstr ""

#: ../../LangRef.rst:9690
msgid ""
"The '``llvm.sqrt``' intrinsics return the sqrt of the specified operand, "
"returning the same value as the libm '``sqrt``' functions would. Unlike "
"``sqrt`` in libm, however, ``llvm.sqrt`` has undefined behavior for "
"negative numbers other than -0.0 (which allows for better optimization, "
"because there is no need to worry about errno being set). "
"``llvm.sqrt(-0.0)`` is defined to return -0.0 like IEEE sqrt."
msgstr ""

#: ../../LangRef.rst:9700 ../../LangRef.rst:9773 ../../LangRef.rst:9809
#: ../../LangRef.rst:9882 ../../LangRef.rst:9917 ../../LangRef.rst:9952
#: ../../LangRef.rst:9987 ../../LangRef.rst:10022 ../../LangRef.rst:10058
#: ../../LangRef.rst:10094 ../../LangRef.rst:10248 ../../LangRef.rst:10283
#: ../../LangRef.rst:10319 ../../LangRef.rst:10356 ../../LangRef.rst:10392
#: ../../LangRef.rst:10428
msgid "The argument and return value are floating point numbers of the same type."
msgstr ""

#: ../../LangRef.rst:9706
msgid ""
"This function returns the sqrt of the specified operand if it is a "
"nonnegative floating point number."
msgstr ""

#: ../../LangRef.rst:9710
msgid "'``llvm.powi.*``' Intrinsic"
msgstr ""

#: ../../LangRef.rst:9715
msgid ""
"This is an overloaded intrinsic. You can use ``llvm.powi`` on any "
"floating point or vector of floating point type. Not all targets support "
"all types however."
msgstr ""

#: ../../LangRef.rst:9730
msgid ""
"The '``llvm.powi.*``' intrinsics return the first operand raised to the "
"specified (positive or negative) power. The order of evaluation of "
"multiplications is not defined. When a vector of floating point type is "
"used, the second argument remains a scalar integer value."
msgstr ""

#: ../../LangRef.rst:9738
msgid ""
"The second argument is an integer power, and the first is a value to "
"raise to that power."
msgstr ""

#: ../../LangRef.rst:9744
msgid ""
"This function returns the first value raised to the second power with an "
"unspecified sequence of rounding operations."
msgstr ""

#: ../../LangRef.rst:9748
msgid "'``llvm.sin.*``' Intrinsic"
msgstr ""

#: ../../LangRef.rst:9753
msgid ""
"This is an overloaded intrinsic. You can use ``llvm.sin`` on any floating"
" point or vector of floating point type. Not all targets support all "
"types however."
msgstr ""

#: ../../LangRef.rst:9768
msgid "The '``llvm.sin.*``' intrinsics return the sine of the operand."
msgstr ""

#: ../../LangRef.rst:9779
msgid ""
"This function returns the sine of the specified operand, returning the "
"same values as the libm ``sin`` functions would, and handles error "
"conditions in the same way."
msgstr ""

#: ../../LangRef.rst:9784
msgid "'``llvm.cos.*``' Intrinsic"
msgstr ""

#: ../../LangRef.rst:9789
msgid ""
"This is an overloaded intrinsic. You can use ``llvm.cos`` on any floating"
" point or vector of floating point type. Not all targets support all "
"types however."
msgstr ""

#: ../../LangRef.rst:9804
msgid "The '``llvm.cos.*``' intrinsics return the cosine of the operand."
msgstr ""

#: ../../LangRef.rst:9815
msgid ""
"This function returns the cosine of the specified operand, returning the "
"same values as the libm ``cos`` functions would, and handles error "
"conditions in the same way."
msgstr ""

#: ../../LangRef.rst:9820
msgid "'``llvm.pow.*``' Intrinsic"
msgstr ""

#: ../../LangRef.rst:9825
msgid ""
"This is an overloaded intrinsic. You can use ``llvm.pow`` on any floating"
" point or vector of floating point type. Not all targets support all "
"types however."
msgstr ""

#: ../../LangRef.rst:9840
msgid ""
"The '``llvm.pow.*``' intrinsics return the first operand raised to the "
"specified (positive or negative) power."
msgstr ""

#: ../../LangRef.rst:9846
msgid ""
"The second argument is a floating point power, and the first is a value "
"to raise to that power."
msgstr ""

#: ../../LangRef.rst:9852
msgid ""
"This function returns the first value raised to the second power, "
"returning the same values as the libm ``pow`` functions would, and "
"handles error conditions in the same way."
msgstr ""

#: ../../LangRef.rst:9857
msgid "'``llvm.exp.*``' Intrinsic"
msgstr ""

#: ../../LangRef.rst:9862
msgid ""
"This is an overloaded intrinsic. You can use ``llvm.exp`` on any floating"
" point or vector of floating point type. Not all targets support all "
"types however."
msgstr ""

#: ../../LangRef.rst:9877
msgid "The '``llvm.exp.*``' intrinsics perform the exp function."
msgstr ""

#: ../../LangRef.rst:9888
msgid ""
"This function returns the same values as the libm ``exp`` functions "
"would, and handles error conditions in the same way."
msgstr ""

#: ../../LangRef.rst:9892
msgid "'``llvm.exp2.*``' Intrinsic"
msgstr ""

#: ../../LangRef.rst:9897
msgid ""
"This is an overloaded intrinsic. You can use ``llvm.exp2`` on any "
"floating point or vector of floating point type. Not all targets support "
"all types however."
msgstr ""

#: ../../LangRef.rst:9912
msgid "The '``llvm.exp2.*``' intrinsics perform the exp2 function."
msgstr ""

#: ../../LangRef.rst:9923
msgid ""
"This function returns the same values as the libm ``exp2`` functions "
"would, and handles error conditions in the same way."
msgstr ""

#: ../../LangRef.rst:9927
msgid "'``llvm.log.*``' Intrinsic"
msgstr ""

#: ../../LangRef.rst:9932
msgid ""
"This is an overloaded intrinsic. You can use ``llvm.log`` on any floating"
" point or vector of floating point type. Not all targets support all "
"types however."
msgstr ""

#: ../../LangRef.rst:9947
msgid "The '``llvm.log.*``' intrinsics perform the log function."
msgstr ""

#: ../../LangRef.rst:9958
msgid ""
"This function returns the same values as the libm ``log`` functions "
"would, and handles error conditions in the same way."
msgstr ""

#: ../../LangRef.rst:9962
msgid "'``llvm.log10.*``' Intrinsic"
msgstr ""

#: ../../LangRef.rst:9967
msgid ""
"This is an overloaded intrinsic. You can use ``llvm.log10`` on any "
"floating point or vector of floating point type. Not all targets support "
"all types however."
msgstr ""

#: ../../LangRef.rst:9982
msgid "The '``llvm.log10.*``' intrinsics perform the log10 function."
msgstr ""

#: ../../LangRef.rst:9993
msgid ""
"This function returns the same values as the libm ``log10`` functions "
"would, and handles error conditions in the same way."
msgstr ""

#: ../../LangRef.rst:9997
msgid "'``llvm.log2.*``' Intrinsic"
msgstr ""

#: ../../LangRef.rst:10002
msgid ""
"This is an overloaded intrinsic. You can use ``llvm.log2`` on any "
"floating point or vector of floating point type. Not all targets support "
"all types however."
msgstr ""

#: ../../LangRef.rst:10017
msgid "The '``llvm.log2.*``' intrinsics perform the log2 function."
msgstr ""

#: ../../LangRef.rst:10028
msgid ""
"This function returns the same values as the libm ``log2`` functions "
"would, and handles error conditions in the same way."
msgstr ""

#: ../../LangRef.rst:10032
msgid "'``llvm.fma.*``' Intrinsic"
msgstr ""

#: ../../LangRef.rst:10037
msgid ""
"This is an overloaded intrinsic. You can use ``llvm.fma`` on any floating"
" point or vector of floating point type. Not all targets support all "
"types however."
msgstr ""

#: ../../LangRef.rst:10052
msgid "The '``llvm.fma.*``' intrinsics perform the fused multiply-add operation."
msgstr ""

#: ../../LangRef.rst:10064
msgid ""
"This function returns the same values as the libm ``fma`` functions "
"would, and does not set errno."
msgstr ""

#: ../../LangRef.rst:10068
msgid "'``llvm.fabs.*``' Intrinsic"
msgstr ""

#: ../../LangRef.rst:10073
msgid ""
"This is an overloaded intrinsic. You can use ``llvm.fabs`` on any "
"floating point or vector of floating point type. Not all targets support "
"all types however."
msgstr ""

#: ../../LangRef.rst:10088
msgid "The '``llvm.fabs.*``' intrinsics return the absolute value of the operand."
msgstr ""

#: ../../LangRef.rst:10100
msgid ""
"This function returns the same values as the libm ``fabs`` functions "
"would, and handles error conditions in the same way."
msgstr ""

#: ../../LangRef.rst:10104
msgid "'``llvm.minnum.*``' Intrinsic"
msgstr ""

#: ../../LangRef.rst:10109
msgid ""
"This is an overloaded intrinsic. You can use ``llvm.minnum`` on any "
"floating point or vector of floating point type. Not all targets support "
"all types however."
msgstr ""

#: ../../LangRef.rst:10124
msgid ""
"The '``llvm.minnum.*``' intrinsics return the minimum of the two "
"arguments."
msgstr ""

#: ../../LangRef.rst:10131 ../../LangRef.rst:10173 ../../LangRef.rst:10213
msgid ""
"The arguments and return value are floating point numbers of the same "
"type."
msgstr ""

#: ../../LangRef.rst:10137
msgid ""
"Follows the IEEE-754 semantics for minNum, which also match for libm's "
"fmin."
msgstr ""

#: ../../LangRef.rst:10140
msgid ""
"If either operand is a NaN, returns the other non-NaN operand. Returns "
"NaN only if both operands are NaN. If the operands compare equal, returns"
" a value that compares equal to both operands. This means that "
"fmin(+/-0.0, +/-0.0) could return either -0.0 or 0.0."
msgstr ""

#: ../../LangRef.rst:10146
msgid "'``llvm.maxnum.*``' Intrinsic"
msgstr ""

#: ../../LangRef.rst:10151
msgid ""
"This is an overloaded intrinsic. You can use ``llvm.maxnum`` on any "
"floating point or vector of floating point type. Not all targets support "
"all types however."
msgstr ""

#: ../../LangRef.rst:10166
msgid ""
"The '``llvm.maxnum.*``' intrinsics return the maximum of the two "
"arguments."
msgstr ""

#: ../../LangRef.rst:10178
msgid ""
"Follows the IEEE-754 semantics for maxNum, which also match for libm's "
"fmax."
msgstr ""

#: ../../LangRef.rst:10181
msgid ""
"If either operand is a NaN, returns the other non-NaN operand. Returns "
"NaN only if both operands are NaN. If the operands compare equal, returns"
" a value that compares equal to both operands. This means that "
"fmax(+/-0.0, +/-0.0) could return either -0.0 or 0.0."
msgstr ""

#: ../../LangRef.rst:10187
msgid "'``llvm.copysign.*``' Intrinsic"
msgstr ""

#: ../../LangRef.rst:10192
msgid ""
"This is an overloaded intrinsic. You can use ``llvm.copysign`` on any "
"floating point or vector of floating point type. Not all targets support "
"all types however."
msgstr ""

#: ../../LangRef.rst:10207
msgid ""
"The '``llvm.copysign.*``' intrinsics return a value with the magnitude of"
" the first operand and the sign of the second operand."
msgstr ""

#: ../../LangRef.rst:10219
msgid ""
"This function returns the same values as the libm ``copysign`` functions "
"would, and handles error conditions in the same way."
msgstr ""

#: ../../LangRef.rst:10223
msgid "'``llvm.floor.*``' Intrinsic"
msgstr ""

#: ../../LangRef.rst:10228
msgid ""
"This is an overloaded intrinsic. You can use ``llvm.floor`` on any "
"floating point or vector of floating point type. Not all targets support "
"all types however."
msgstr ""

#: ../../LangRef.rst:10243
msgid "The '``llvm.floor.*``' intrinsics return the floor of the operand."
msgstr ""

#: ../../LangRef.rst:10254
msgid ""
"This function returns the same values as the libm ``floor`` functions "
"would, and handles error conditions in the same way."
msgstr ""

#: ../../LangRef.rst:10258
msgid "'``llvm.ceil.*``' Intrinsic"
msgstr ""

#: ../../LangRef.rst:10263
msgid ""
"This is an overloaded intrinsic. You can use ``llvm.ceil`` on any "
"floating point or vector of floating point type. Not all targets support "
"all types however."
msgstr ""

#: ../../LangRef.rst:10278
msgid "The '``llvm.ceil.*``' intrinsics return the ceiling of the operand."
msgstr ""

#: ../../LangRef.rst:10289
msgid ""
"This function returns the same values as the libm ``ceil`` functions "
"would, and handles error conditions in the same way."
msgstr ""

#: ../../LangRef.rst:10293
msgid "'``llvm.trunc.*``' Intrinsic"
msgstr ""

#: ../../LangRef.rst:10298
msgid ""
"This is an overloaded intrinsic. You can use ``llvm.trunc`` on any "
"floating point or vector of floating point type. Not all targets support "
"all types however."
msgstr ""

#: ../../LangRef.rst:10313
msgid ""
"The '``llvm.trunc.*``' intrinsics returns the operand rounded to the "
"nearest integer not larger in magnitude than the operand."
msgstr ""

#: ../../LangRef.rst:10325
msgid ""
"This function returns the same values as the libm ``trunc`` functions "
"would, and handles error conditions in the same way."
msgstr ""

#: ../../LangRef.rst:10329
msgid "'``llvm.rint.*``' Intrinsic"
msgstr ""

#: ../../LangRef.rst:10334
msgid ""
"This is an overloaded intrinsic. You can use ``llvm.rint`` on any "
"floating point or vector of floating point type. Not all targets support "
"all types however."
msgstr ""

#: ../../LangRef.rst:10349
msgid ""
"The '``llvm.rint.*``' intrinsics returns the operand rounded to the "
"nearest integer. It may raise an inexact floating-point exception if the "
"operand isn't an integer."
msgstr ""

#: ../../LangRef.rst:10362
msgid ""
"This function returns the same values as the libm ``rint`` functions "
"would, and handles error conditions in the same way."
msgstr ""

#: ../../LangRef.rst:10366
msgid "'``llvm.nearbyint.*``' Intrinsic"
msgstr ""

#: ../../LangRef.rst:10371
msgid ""
"This is an overloaded intrinsic. You can use ``llvm.nearbyint`` on any "
"floating point or vector of floating point type. Not all targets support "
"all types however."
msgstr ""

#: ../../LangRef.rst:10386
msgid ""
"The '``llvm.nearbyint.*``' intrinsics returns the operand rounded to the "
"nearest integer."
msgstr ""

#: ../../LangRef.rst:10398
msgid ""
"This function returns the same values as the libm ``nearbyint`` functions"
" would, and handles error conditions in the same way."
msgstr ""

#: ../../LangRef.rst:10402
msgid "'``llvm.round.*``' Intrinsic"
msgstr ""

#: ../../LangRef.rst:10407
msgid ""
"This is an overloaded intrinsic. You can use ``llvm.round`` on any "
"floating point or vector of floating point type. Not all targets support "
"all types however."
msgstr ""

#: ../../LangRef.rst:10422
msgid ""
"The '``llvm.round.*``' intrinsics returns the operand rounded to the "
"nearest integer."
msgstr ""

#: ../../LangRef.rst:10434
msgid ""
"This function returns the same values as the libm ``round`` functions "
"would, and handles error conditions in the same way."
msgstr ""

#: ../../LangRef.rst:10438
msgid "Bit Manipulation Intrinsics"
msgstr ""

#: ../../LangRef.rst:10440
msgid ""
"LLVM provides intrinsics for a few important bit manipulation operations."
" These allow efficient code generation for some algorithms."
msgstr ""

#: ../../LangRef.rst:10444
msgid "'``llvm.bitreverse.*``' Intrinsics"
msgstr ""

#: ../../LangRef.rst:10449
msgid ""
"This is an overloaded intrinsic function. You can use bitreverse on any "
"integer type."
msgstr ""

#: ../../LangRef.rst:10461
msgid ""
"The '``llvm.bitreverse``' family of intrinsics is used to reverse the "
"bitpattern of an integer value; for example ``0b1234567`` becomes "
"``0b7654321``."
msgstr ""

#: ../../LangRef.rst:10468
msgid ""
"The ``llvm.bitreverse.iN`` intrinsic returns an i16 value that has bit "
"``M`` in the input moved to bit ``N-M`` in the output."
msgstr ""

#: ../../LangRef.rst:10472
msgid "'``llvm.bswap.*``' Intrinsics"
msgstr ""

#: ../../LangRef.rst:10477
msgid ""
"This is an overloaded intrinsic function. You can use bswap on any "
"integer type that is an even number of bytes (i.e. BitWidth % 16 == 0)."
msgstr ""

#: ../../LangRef.rst:10489
msgid ""
"The '``llvm.bswap``' family of intrinsics is used to byte swap integer "
"values with an even number of bytes (positive multiple of 16 bits). These"
" are useful for performing operations on data that is not in the target's"
" native byte order."
msgstr ""

#: ../../LangRef.rst:10497
msgid ""
"The ``llvm.bswap.i16`` intrinsic returns an i16 value that has the high "
"and low byte of the input i16 swapped. Similarly, the ``llvm.bswap.i32`` "
"intrinsic returns an i32 value that has the four bytes of the input i32 "
"swapped, so that if the input bytes are numbered 0, 1, 2, 3 then the "
"returned i32 will have its bytes in 3, 2, 1, 0 order. The "
"``llvm.bswap.i48``, ``llvm.bswap.i64`` and other intrinsics extend this "
"concept to additional even-byte lengths (6 bytes, 8 bytes and more, "
"respectively)."
msgstr ""

#: ../../LangRef.rst:10507
msgid "'``llvm.ctpop.*``' Intrinsic"
msgstr ""

#: ../../LangRef.rst:10512
msgid ""
"This is an overloaded intrinsic. You can use llvm.ctpop on any integer "
"bit width, or on any vector with integer elements. Not all targets "
"support all bit widths or vector types, however."
msgstr ""

#: ../../LangRef.rst:10528
msgid ""
"The '``llvm.ctpop``' family of intrinsics counts the number of bits set "
"in a value."
msgstr ""

#: ../../LangRef.rst:10534
msgid ""
"The only argument is the value to be counted. The argument may be of any "
"integer type, or a vector with integer elements. The return type must "
"match the argument type."
msgstr ""

#: ../../LangRef.rst:10541
msgid ""
"The '``llvm.ctpop``' intrinsic counts the 1's in a variable, or within "
"each element of a vector."
msgstr ""

#: ../../LangRef.rst:10545
msgid "'``llvm.ctlz.*``' Intrinsic"
msgstr ""

#: ../../LangRef.rst:10550
msgid ""
"This is an overloaded intrinsic. You can use ``llvm.ctlz`` on any integer"
" bit width, or any vector whose elements are integers. Not all targets "
"support all bit widths or vector types, however."
msgstr ""

#: ../../LangRef.rst:10566
msgid ""
"The '``llvm.ctlz``' family of intrinsic functions counts the number of "
"leading zeros in a variable."
msgstr ""

#: ../../LangRef.rst:10572 ../../LangRef.rst:10619
msgid ""
"The first argument is the value to be counted. This argument may be of "
"any integer type, or a vector with integer element type. The return type "
"must match the first argument type."
msgstr ""

#: ../../LangRef.rst:10576 ../../LangRef.rst:10623
msgid ""
"The second argument must be a constant and is a flag to indicate whether "
"the intrinsic should ensure that a zero as the first argument produces a "
"defined result. Historically some architectures did not provide a defined"
" result for zero values as efficiently, and many algorithms are now "
"predicated on avoiding zero-value inputs."
msgstr ""

#: ../../LangRef.rst:10585
msgid ""
"The '``llvm.ctlz``' intrinsic counts the leading (most significant) zeros"
" in a variable, or within each element of the vector. If ``src == 0`` "
"then the result is the size in bits of the type of ``src`` if "
"``is_zero_undef == 0`` and ``undef`` otherwise. For example, "
"``llvm.ctlz(i32 2) = 30``."
msgstr ""

#: ../../LangRef.rst:10592
msgid "'``llvm.cttz.*``' Intrinsic"
msgstr ""

#: ../../LangRef.rst:10597
msgid ""
"This is an overloaded intrinsic. You can use ``llvm.cttz`` on any integer"
" bit width, or any vector of integer elements. Not all targets support "
"all bit widths or vector types, however."
msgstr ""

#: ../../LangRef.rst:10613
msgid ""
"The '``llvm.cttz``' family of intrinsic functions counts the number of "
"trailing zeros."
msgstr ""

#: ../../LangRef.rst:10632
msgid ""
"The '``llvm.cttz``' intrinsic counts the trailing (least significant) "
"zeros in a variable, or within each element of a vector. If ``src == 0`` "
"then the result is the size in bits of the type of ``src`` if "
"``is_zero_undef == 0`` and ``undef`` otherwise. For example, "
"``llvm.cttz(2) = 1``."
msgstr ""

#: ../../LangRef.rst:10641
msgid "Arithmetic with Overflow Intrinsics"
msgstr ""

#: ../../LangRef.rst:10643
msgid "LLVM provides intrinsics for some arithmetic with overflow operations."
msgstr ""

#: ../../LangRef.rst:10646
msgid "'``llvm.sadd.with.overflow.*``' Intrinsics"
msgstr ""

#: ../../LangRef.rst:10651
msgid ""
"This is an overloaded intrinsic. You can use ``llvm.sadd.with.overflow`` "
"on any integer bit width."
msgstr ""

#: ../../LangRef.rst:10663
msgid ""
"The '``llvm.sadd.with.overflow``' family of intrinsic functions perform a"
" signed addition of the two arguments, and indicate whether an overflow "
"occurred during the signed summation."
msgstr ""

#: ../../LangRef.rst:10670
msgid ""
"The arguments (%a and %b) and the first element of the result structure "
"may be of integer types of any bit width, but they must have the same bit"
" width. The second element of the result structure must be of type "
"``i1``. ``%a`` and ``%b`` are the two values that will undergo signed "
"addition."
msgstr ""

#: ../../LangRef.rst:10679
msgid ""
"The '``llvm.sadd.with.overflow``' family of intrinsic functions perform a"
" signed addition of the two variables. They return a structure --- the "
"first element of which is the signed summation, and the second element of"
" which is a bit specifying if the signed summation resulted in an "
"overflow."
msgstr ""

#: ../../LangRef.rst:10696
msgid "'``llvm.uadd.with.overflow.*``' Intrinsics"
msgstr ""

#: ../../LangRef.rst:10701
msgid ""
"This is an overloaded intrinsic. You can use ``llvm.uadd.with.overflow`` "
"on any integer bit width."
msgstr ""

#: ../../LangRef.rst:10713
msgid ""
"The '``llvm.uadd.with.overflow``' family of intrinsic functions perform "
"an unsigned addition of the two arguments, and indicate whether a carry "
"occurred during the unsigned summation."
msgstr ""

#: ../../LangRef.rst:10720
msgid ""
"The arguments (%a and %b) and the first element of the result structure "
"may be of integer types of any bit width, but they must have the same bit"
" width. The second element of the result structure must be of type "
"``i1``. ``%a`` and ``%b`` are the two values that will undergo unsigned "
"addition."
msgstr ""

#: ../../LangRef.rst:10729
msgid ""
"The '``llvm.uadd.with.overflow``' family of intrinsic functions perform "
"an unsigned addition of the two arguments. They return a structure --- "
"the first element of which is the sum, and the second element of which is"
" a bit specifying if the unsigned summation resulted in a carry."
msgstr ""

#: ../../LangRef.rst:10745
msgid "'``llvm.ssub.with.overflow.*``' Intrinsics"
msgstr ""

#: ../../LangRef.rst:10750
msgid ""
"This is an overloaded intrinsic. You can use ``llvm.ssub.with.overflow`` "
"on any integer bit width."
msgstr ""

#: ../../LangRef.rst:10762
msgid ""
"The '``llvm.ssub.with.overflow``' family of intrinsic functions perform a"
" signed subtraction of the two arguments, and indicate whether an "
"overflow occurred during the signed subtraction."
msgstr ""

#: ../../LangRef.rst:10769
msgid ""
"The arguments (%a and %b) and the first element of the result structure "
"may be of integer types of any bit width, but they must have the same bit"
" width. The second element of the result structure must be of type "
"``i1``. ``%a`` and ``%b`` are the two values that will undergo signed "
"subtraction."
msgstr ""

#: ../../LangRef.rst:10778
msgid ""
"The '``llvm.ssub.with.overflow``' family of intrinsic functions perform a"
" signed subtraction of the two arguments. They return a structure --- the"
" first element of which is the subtraction, and the second element of "
"which is a bit specifying if the signed subtraction resulted in an "
"overflow."
msgstr ""

#: ../../LangRef.rst:10795
msgid "'``llvm.usub.with.overflow.*``' Intrinsics"
msgstr ""

#: ../../LangRef.rst:10800
msgid ""
"This is an overloaded intrinsic. You can use ``llvm.usub.with.overflow`` "
"on any integer bit width."
msgstr ""

#: ../../LangRef.rst:10812
msgid ""
"The '``llvm.usub.with.overflow``' family of intrinsic functions perform "
"an unsigned subtraction of the two arguments, and indicate whether an "
"overflow occurred during the unsigned subtraction."
msgstr ""

#: ../../LangRef.rst:10819
msgid ""
"The arguments (%a and %b) and the first element of the result structure "
"may be of integer types of any bit width, but they must have the same bit"
" width. The second element of the result structure must be of type "
"``i1``. ``%a`` and ``%b`` are the two values that will undergo unsigned "
"subtraction."
msgstr ""

#: ../../LangRef.rst:10828
msgid ""
"The '``llvm.usub.with.overflow``' family of intrinsic functions perform "
"an unsigned subtraction of the two arguments. They return a structure ---"
" the first element of which is the subtraction, and the second element of"
" which is a bit specifying if the unsigned subtraction resulted in an "
"overflow."
msgstr ""

#: ../../LangRef.rst:10845
msgid "'``llvm.smul.with.overflow.*``' Intrinsics"
msgstr ""

#: ../../LangRef.rst:10850
msgid ""
"This is an overloaded intrinsic. You can use ``llvm.smul.with.overflow`` "
"on any integer bit width."
msgstr ""

#: ../../LangRef.rst:10862
msgid ""
"The '``llvm.smul.with.overflow``' family of intrinsic functions perform a"
" signed multiplication of the two arguments, and indicate whether an "
"overflow occurred during the signed multiplication."
msgstr ""

#: ../../LangRef.rst:10869
msgid ""
"The arguments (%a and %b) and the first element of the result structure "
"may be of integer types of any bit width, but they must have the same bit"
" width. The second element of the result structure must be of type "
"``i1``. ``%a`` and ``%b`` are the two values that will undergo signed "
"multiplication."
msgstr ""

#: ../../LangRef.rst:10878
msgid ""
"The '``llvm.smul.with.overflow``' family of intrinsic functions perform a"
" signed multiplication of the two arguments. They return a structure --- "
"the first element of which is the multiplication, and the second element "
"of which is a bit specifying if the signed multiplication resulted in an "
"overflow."
msgstr ""

#: ../../LangRef.rst:10895
msgid "'``llvm.umul.with.overflow.*``' Intrinsics"
msgstr ""

#: ../../LangRef.rst:10900
msgid ""
"This is an overloaded intrinsic. You can use ``llvm.umul.with.overflow`` "
"on any integer bit width."
msgstr ""

#: ../../LangRef.rst:10912
msgid ""
"The '``llvm.umul.with.overflow``' family of intrinsic functions perform a"
" unsigned multiplication of the two arguments, and indicate whether an "
"overflow occurred during the unsigned multiplication."
msgstr ""

#: ../../LangRef.rst:10919
msgid ""
"The arguments (%a and %b) and the first element of the result structure "
"may be of integer types of any bit width, but they must have the same bit"
" width. The second element of the result structure must be of type "
"``i1``. ``%a`` and ``%b`` are the two values that will undergo unsigned "
"multiplication."
msgstr ""

#: ../../LangRef.rst:10928
msgid ""
"The '``llvm.umul.with.overflow``' family of intrinsic functions perform "
"an unsigned multiplication of the two arguments. They return a structure "
"--- the first element of which is the multiplication, and the second "
"element of which is a bit specifying if the unsigned multiplication "
"resulted in an overflow."
msgstr ""

#: ../../LangRef.rst:10945
msgid "Specialised Arithmetic Intrinsics"
msgstr ""

#: ../../LangRef.rst:10948
msgid "'``llvm.canonicalize.*``' Intrinsic"
msgstr ""

#: ../../LangRef.rst:10961
msgid ""
"The '``llvm.canonicalize.*``' intrinsic returns the platform specific "
"canonical encoding of a floating point number. This canonicalization is "
"useful for implementing certain numeric primitives such as frexp. The "
"canonical encoding is defined by IEEE-754-2008 to be:"
msgstr ""

#: ../../LangRef.rst:10972
msgid ""
"This operation can also be considered equivalent to the IEEE-754-2008 "
"conversion of a floating-point value to the same format. NaNs are handled"
" according to section 6.2."
msgstr ""

#: ../../LangRef.rst:10976
msgid "Examples of non-canonical encodings:"
msgstr ""

#: ../../LangRef.rst:10978
msgid ""
"x87 pseudo denormals, pseudo NaNs, pseudo Infinity, Unnormals. These are "
"converted to a canonical representation per hardware-specific protocol."
msgstr ""

#: ../../LangRef.rst:10980
msgid ""
"Many normal decimal floating point numbers have non-canonical alternative"
" encodings."
msgstr ""

#: ../../LangRef.rst:10982
msgid ""
"Some machines, like GPUs or ARMv7 NEON, do not support subnormal values. "
"These are treated as non-canonical encodings of zero and with be flushed "
"to a zero of the same sign by this operation."
msgstr ""

#: ../../LangRef.rst:10986
msgid ""
"Note that per IEEE-754-2008 6.2, systems that support signaling NaNs with"
" default exception handling must signal an invalid exception, and produce"
" a quiet NaN result."
msgstr ""

#: ../../LangRef.rst:10990
msgid ""
"This function should always be implementable as multiplication by 1.0, "
"provided that the compiler does not constant fold the operation. "
"Likewise, division by 1.0 and ``llvm.minnum(x, x)`` are possible "
"implementations. Addition with -0.0 is also sufficient provided that the "
"rounding mode is not -Infinity."
msgstr ""

#: ../../LangRef.rst:10995
msgid "``@llvm.canonicalize`` must preserve the equality relation. That is:"
msgstr ""

#: ../../LangRef.rst:10997
msgid "``(@llvm.canonicalize(x) == x)`` is equivalent to ``(x == x)``"
msgstr ""

#: ../../LangRef.rst:10998
msgid ""
"``(@llvm.canonicalize(x) == @llvm.canonicalize(y))`` is equivalent to to "
"``(x == y)``"
msgstr ""

#: ../../LangRef.rst:11001
msgid ""
"Additionally, the sign of zero must be conserved: "
"``@llvm.canonicalize(-0.0) = -0.0`` and ``@llvm.canonicalize(+0.0) = "
"+0.0``"
msgstr ""

#: ../../LangRef.rst:11004
msgid ""
"The payload bits of a NaN must be conserved, with two exceptions. First, "
"environments which use only a single canonical representation of NaN must"
" perform said canonicalization. Second, SNaNs must be quieted per the "
"usual methods."
msgstr ""

#: ../../LangRef.rst:11009
msgid "The canonicalization operation may be optimized away if:"
msgstr ""

#: ../../LangRef.rst:11011
msgid ""
"The input is known to be canonical. For example, it was produced by a "
"floating-point operation that is required by the standard to be "
"canonical."
msgstr ""

#: ../../LangRef.rst:11013
msgid ""
"The result is consumed only by (or fused with) other floating-point "
"operations. That is, the bits of the floating point value are not "
"examined."
msgstr ""

#: ../../LangRef.rst:11017
msgid "'``llvm.fmuladd.*``' Intrinsic"
msgstr ""

#: ../../LangRef.rst:11030
msgid ""
"The '``llvm.fmuladd.*``' intrinsic functions represent multiply-add "
"expressions that can be fused if the code generator determines that (a) "
"the target instruction set has support for a fused operation, and (b) "
"that the fused operation is more efficient than the equivalent, separate "
"pair of mul and add instructions."
msgstr ""

#: ../../LangRef.rst:11039
msgid ""
"The '``llvm.fmuladd.*``' intrinsics each take three arguments: two "
"multiplicands, a and b, and an addend c."
msgstr ""

#: ../../LangRef.rst:11045
msgid "The expression:"
msgstr ""

#: ../../LangRef.rst:11051
msgid ""
"is equivalent to the expression a \\* b + c, except that rounding will "
"not be performed between the multiplication and addition steps if the "
"code generator fuses the operations. Fusion is not guaranteed, even if "
"the target platform supports it. If a fused multiply-add is required the "
"corresponding llvm.fma.\\* intrinsic function should be used instead. "
"This never sets errno, just as '``llvm.fma.*``'."
msgstr ""

#: ../../LangRef.rst:11066
msgid "Half Precision Floating Point Intrinsics"
msgstr ""

#: ../../LangRef.rst:11068
msgid ""
"For most target platforms, half precision floating point is a storage-"
"only format. This means that it is a dense encoding (in memory) but does "
"not support computation in the format."
msgstr ""

#: ../../LangRef.rst:11072
msgid ""
"This means that code must first load the half-precision floating point "
"value as an i16, then convert it to float with "
":ref:`llvm.convert.from.fp16 <int_convert_from_fp16>`. Computation can "
"then be performed on the float value (including extending to double etc)."
" To store the value back to memory, it is first converted to float if "
"needed, then converted to i16 with :ref:`llvm.convert.to.fp16 "
"<int_convert_to_fp16>`, then storing as an i16 value."
msgstr ""

#: ../../LangRef.rst:11084
msgid "'``llvm.convert.to.fp16``' Intrinsic"
msgstr ""

#: ../../LangRef.rst:11097
msgid ""
"The '``llvm.convert.to.fp16``' intrinsic function performs a conversion "
"from a conventional floating point type to half precision floating point "
"format."
msgstr ""

#: ../../LangRef.rst:11103 ../../LangRef.rst:11144
msgid ""
"The intrinsic function contains single argument - the value to be "
"converted."
msgstr ""

#: ../../LangRef.rst:11109
msgid ""
"The '``llvm.convert.to.fp16``' intrinsic function performs a conversion "
"from a conventional floating point format to half precision floating "
"point format. The return value is an ``i16`` which contains the converted"
" number."
msgstr ""

#: ../../LangRef.rst:11124
msgid "'``llvm.convert.from.fp16``' Intrinsic"
msgstr ""

#: ../../LangRef.rst:11137
msgid ""
"The '``llvm.convert.from.fp16``' intrinsic function performs a conversion"
" from half precision floating point format to single precision floating "
"point format."
msgstr ""

#: ../../LangRef.rst:11150
msgid ""
"The '``llvm.convert.from.fp16``' intrinsic function performs a conversion"
" from half single precision floating point format to single precision "
"floating point format. The input half-float value is represented by an "
"``i16`` value."
msgstr ""

#: ../../LangRef.rst:11166
msgid "Debugger Intrinsics"
msgstr ""

#: ../../LangRef.rst:11168
msgid ""
"The LLVM debugger intrinsics (which all start with ``llvm.dbg.`` prefix),"
" are described in the `LLVM Source Level Debugging "
"<SourceLevelDebugging.html#format_common_intrinsics>`_ document."
msgstr ""

#: ../../LangRef.rst:11174
msgid "Exception Handling Intrinsics"
msgstr ""

#: ../../LangRef.rst:11176
msgid ""
"The LLVM exception handling intrinsics (which all start with ``llvm.eh.``"
" prefix), are described in the `LLVM Exception Handling "
"<ExceptionHandling.html#format_common_intrinsics>`_ document."
msgstr ""

#: ../../LangRef.rst:11183
msgid "Trampoline Intrinsics"
msgstr ""

#: ../../LangRef.rst:11185
msgid ""
"These intrinsics make it possible to excise one parameter, marked with "
"the :ref:`nest <nest>` attribute, from a function. The result is a "
"callable function pointer lacking the nest parameter - the caller does "
"not need to provide a value for it. Instead, the value to use is stored "
"in advance in a \"trampoline\", a block of memory usually allocated on "
"the stack, which also contains code to splice the nest value into the "
"argument list. This is used to implement the GCC nested function address "
"extension."
msgstr ""

#: ../../LangRef.rst:11194
#, python-format
msgid ""
"For example, if the function is ``i32 f(i8* nest %c, i32 %x, i32 %y)`` "
"then the resulting function pointer has signature ``i32 (i32, i32)*``. It"
" can be created as follows:"
msgstr ""

#: ../../LangRef.rst:11206
#, python-format
msgid ""
"The call ``%val = call i32 %fp(i32 %x, i32 %y)`` is then equivalent to "
"``%val = call i32 %f(i8* %nval, i32 %x, i32 %y)``."
msgstr ""

#: ../../LangRef.rst:11212
msgid "'``llvm.init.trampoline``' Intrinsic"
msgstr ""

#: ../../LangRef.rst:11224
msgid ""
"This fills the memory pointed to by ``tramp`` with executable code, "
"turning it into a trampoline."
msgstr ""

#: ../../LangRef.rst:11230
msgid ""
"The ``llvm.init.trampoline`` intrinsic takes three arguments, all "
"pointers. The ``tramp`` argument must point to a sufficiently large and "
"sufficiently aligned block of memory; this memory is written to by the "
"intrinsic. Note that the size and the alignment are target-specific - "
"LLVM currently provides no portable way of determining them, so a front-"
"end that generates this intrinsic needs to have some target-specific "
"knowledge. The ``func`` argument must hold a function bitcast to an "
"``i8*``."
msgstr ""

#: ../../LangRef.rst:11242
msgid ""
"The block of memory pointed to by ``tramp`` is filled with target "
"dependent code, turning it into a function. Then ``tramp`` needs to be "
"passed to :ref:`llvm.adjust.trampoline <int_at>` to get a pointer which "
"can be :ref:`bitcast (to a new function) and called <int_trampoline>`. "
"The new function's signature is the same as that of ``func`` with any "
"arguments marked with the ``nest`` attribute removed. At most one such "
"``nest`` argument is allowed, and it must be of pointer type. Calling the"
" new function is equivalent to calling ``func`` with the same argument "
"list, but with ``nval`` used for the missing ``nest`` argument. If, after"
" calling ``llvm.init.trampoline``, the memory pointed to by ``tramp`` is "
"modified, then the effect of any later call to the returned function "
"pointer is undefined."
msgstr ""

#: ../../LangRef.rst:11258
msgid "'``llvm.adjust.trampoline``' Intrinsic"
msgstr ""

#: ../../LangRef.rst:11270
msgid ""
"This performs any required machine-specific adjustment to the address of "
"a trampoline (passed as ``tramp``)."
msgstr ""

#: ../../LangRef.rst:11276
msgid ""
"``tramp`` must point to a block of memory which already has trampoline "
"code filled in by a previous call to :ref:`llvm.init.trampoline "
"<int_it>`."
msgstr ""

#: ../../LangRef.rst:11283
msgid ""
"On some architectures the address of the code to be executed needs to be "
"different than the address where the trampoline is actually stored. This "
"intrinsic returns the executable address corresponding to ``tramp`` after"
" performing the required machine specific adjustments. The pointer "
"returned can then be :ref:`bitcast and executed <int_trampoline>`."
msgstr ""

#: ../../LangRef.rst:11292
msgid "Masked Vector Load and Store Intrinsics"
msgstr ""

#: ../../LangRef.rst:11294
msgid ""
"LLVM provides intrinsics for predicated vector load and store operations."
" The predicate is specified by a mask operand, which holds one bit per "
"vector element, switching the associated vector lane on or off. The "
"memory addresses corresponding to the \"off\" lanes are not accessed. "
"When all bits of the mask are on, the intrinsic is identical to a regular"
" vector load or store. When all bits are off, no memory is accessed."
msgstr ""

#: ../../LangRef.rst:11299
msgid "'``llvm.masked.load.*``' Intrinsics"
msgstr ""

#: ../../LangRef.rst:11303
msgid ""
"This is an overloaded intrinsic. The loaded data is a vector of any "
"integer, floating point or pointer data type."
msgstr ""

#: ../../LangRef.rst:11317
msgid ""
"Reads a vector from memory according to the provided mask. The mask holds"
" a bit for each vector lane, and is used to prevent memory accesses to "
"the masked-off lanes. The masked-off lanes in the result vector are taken"
" from the corresponding lanes of the '``passthru``' operand."
msgstr ""

#: ../../LangRef.rst:11323
msgid ""
"The first operand is the base pointer for the load. The second operand is"
" the alignment of the source location. It must be a constant integer "
"value. The third operand, mask, is a vector of boolean values with the "
"same number of elements as the return type. The fourth is a pass-through "
"value that is used to fill the masked-off lanes of the result. The return"
" type, underlying type of the base pointer and the type of the "
"'``passthru``' operand are the same vector types."
msgstr ""

#: ../../LangRef.rst:11329
msgid ""
"The '``llvm.masked.load``' intrinsic is designed for conditional reading "
"of selected vector elements in a single IR operation. It is useful for "
"targets that support vector masked loads and allows vectorizing "
"predicated basic blocks on these targets. Other targets may support this "
"intrinsic differently, for example by lowering it into a sequence of "
"branches that guard scalar load operations. The result of this operation "
"is equivalent to a regular vector load instruction followed by a 'select'"
" between the loaded and the passthru values, predicated on the same mask."
" However, using this intrinsic prevents exceptions on memory access to "
"masked-off lanes."
msgstr ""

#: ../../LangRef.rst:11344
msgid "'``llvm.masked.store.*``' Intrinsics"
msgstr ""

#: ../../LangRef.rst:11348
msgid ""
"This is an overloaded intrinsic. The data stored in memory is a vector of"
" any integer, floating point or pointer data type."
msgstr ""

#: ../../LangRef.rst:11362
msgid ""
"Writes a vector to memory according to the provided mask. The mask holds "
"a bit for each vector lane, and is used to prevent memory accesses to the"
" masked-off lanes."
msgstr ""

#: ../../LangRef.rst:11367
msgid ""
"The first operand is the vector value to be written to memory. The second"
" operand is the base pointer for the store, it has the same underlying "
"type as the value operand. The third operand is the alignment of the "
"destination location. The fourth operand, mask, is a vector of boolean "
"values. The types of the mask and the value operand must have the same "
"number of vector elements."
msgstr ""

#: ../../LangRef.rst:11373
msgid ""
"The '``llvm.masked.store``' intrinsics is designed for conditional "
"writing of selected vector elements in a single IR operation. It is "
"useful for targets that support vector masked store and allows "
"vectorizing predicated basic blocks on these targets. Other targets may "
"support this intrinsic differently, for example by lowering it into a "
"sequence of branches that guard scalar store operations. The result of "
"this operation is equivalent to a load-modify-store sequence. However, "
"using this intrinsic prevents exceptions and data races on memory access "
"to masked-off lanes."
msgstr ""

#: ../../LangRef.rst:11387
msgid "Masked Vector Gather and Scatter Intrinsics"
msgstr ""

#: ../../LangRef.rst:11389
msgid ""
"LLVM provides intrinsics for vector gather and scatter operations. They "
"are similar to :ref:`Masked Vector Load and Store <int_mload_mstore>`, "
"except they are designed for arbitrary memory accesses, rather than "
"sequential memory accesses. Gather and scatter also employ a mask "
"operand, which holds one bit per vector element, switching the associated"
" vector lane on or off. The memory addresses corresponding to the \"off\""
" lanes are not accessed. When all bits are off, no memory is accessed."
msgstr ""

#: ../../LangRef.rst:11394
msgid "'``llvm.masked.gather.*``' Intrinsics"
msgstr ""

#: ../../LangRef.rst:11398
msgid ""
"This is an overloaded intrinsic. The loaded data are multiple scalar "
"values of any integer, floating point or pointer data type gathered "
"together into one vector."
msgstr ""

#: ../../LangRef.rst:11409
msgid ""
"Reads scalar values from arbitrary memory locations and gathers them into"
" one vector. The memory locations are provided in the vector of pointers "
"'``ptrs``'. The memory is accessed according to the provided mask. The "
"mask holds a bit for each vector lane, and is used to prevent memory "
"accesses to the masked-off lanes. The masked-off lanes in the result "
"vector are taken from the corresponding lanes of the '``passthru``' "
"operand."
msgstr ""

#: ../../LangRef.rst:11415
msgid ""
"The first operand is a vector of pointers which holds all memory "
"addresses to read. The second operand is an alignment of the source "
"addresses. It must be a constant integer value. The third operand, mask, "
"is a vector of boolean values with the same number of elements as the "
"return type. The fourth is a pass-through value that is used to fill the "
"masked-off lanes of the result. The return type, underlying type of the "
"vector of pointers and the type of the '``passthru``' operand are the "
"same vector types."
msgstr ""

#: ../../LangRef.rst:11421
msgid ""
"The '``llvm.masked.gather``' intrinsic is designed for conditional "
"reading of multiple scalar values from arbitrary memory locations in a "
"single IR operation. It is useful for targets that support vector masked "
"gathers and allows vectorizing basic blocks with data and control "
"divergence. Other targets may support this intrinsic differently, for "
"example by lowering it into a sequence of scalar load operations. The "
"semantics of this operation are equivalent to a sequence of conditional "
"scalar loads with subsequent gathering all loaded values into a single "
"vector. The mask restricts memory access to certain lanes and facilitates"
" vectorization of predicated basic blocks."
msgstr ""

#: ../../LangRef.rst:11448
msgid "'``llvm.masked.scatter.*``' Intrinsics"
msgstr ""

#: ../../LangRef.rst:11452
msgid ""
"This is an overloaded intrinsic. The data stored in memory is a vector of"
" any integer, floating point or pointer data type. Each vector element is"
" stored in an arbitrary memory address. Scatter with overlapping "
"addresses is guaranteed to be ordered from least-significant to most-"
"significant element."
msgstr ""

#: ../../LangRef.rst:11463
msgid ""
"Writes each element from the value vector to the corresponding memory "
"address. The memory addresses are represented as a vector of pointers. "
"Writing is done according to the provided mask. The mask holds a bit for "
"each vector lane, and is used to prevent memory accesses to the masked-"
"off lanes."
msgstr ""

#: ../../LangRef.rst:11468
msgid ""
"The first operand is a vector value to be written to memory. The second "
"operand is a vector of pointers, pointing to where the value elements "
"should be stored. It has the same underlying type as the value operand. "
"The third operand is an alignment of the destination addresses. The "
"fourth operand, mask, is a vector of boolean values. The types of the "
"mask and the value operand must have the same number of vector elements."
msgstr ""

#: ../../LangRef.rst:11474
msgid ""
"The '``llvm.masked.scatter``' intrinsics is designed for writing selected"
" vector elements to arbitrary memory addresses in a single IR operation. "
"The operation may be conditional, when not all bits in the mask are "
"switched on. It is useful for targets that support vector masked scatter "
"and allows vectorizing basic blocks with data and control divergence. "
"Other targets may support this intrinsic differently, for example by "
"lowering it into a sequence of branches that guard scalar store "
"operations."
msgstr ""

#: ../../LangRef.rst:11498
msgid "Memory Use Markers"
msgstr ""

#: ../../LangRef.rst:11500
msgid ""
"This class of intrinsics provides information about the lifetime of "
"memory objects and ranges where variables are immutable."
msgstr ""

#: ../../LangRef.rst:11506
msgid "'``llvm.lifetime.start``' Intrinsic"
msgstr ""

#: ../../LangRef.rst:11518
msgid ""
"The '``llvm.lifetime.start``' intrinsic specifies the start of a memory "
"object's lifetime."
msgstr ""

#: ../../LangRef.rst:11524 ../../LangRef.rst:11557 ../../LangRef.rst:11588
msgid ""
"The first argument is a constant integer representing the size of the "
"object, or -1 if it is variable sized. The second argument is a pointer "
"to the object."
msgstr ""

#: ../../LangRef.rst:11531
msgid ""
"This intrinsic indicates that before this point in the code, the value of"
" the memory pointed to by ``ptr`` is dead. This means that it is known to"
" never be used and has an undefined value. A load from the pointer that "
"precedes this intrinsic can be replaced with ``'undef'``."
msgstr ""

#: ../../LangRef.rst:11539
msgid "'``llvm.lifetime.end``' Intrinsic"
msgstr ""

#: ../../LangRef.rst:11551
msgid ""
"The '``llvm.lifetime.end``' intrinsic specifies the end of a memory "
"object's lifetime."
msgstr ""

#: ../../LangRef.rst:11564
msgid ""
"This intrinsic indicates that after this point in the code, the value of "
"the memory pointed to by ``ptr`` is dead. This means that it is known to "
"never be used and has an undefined value. Any stores into the memory "
"object following this intrinsic may be removed as dead."
msgstr ""

#: ../../LangRef.rst:11570
msgid "'``llvm.invariant.start``' Intrinsic"
msgstr ""

#: ../../LangRef.rst:11582
msgid ""
"The '``llvm.invariant.start``' intrinsic specifies that the contents of a"
" memory object will not change."
msgstr ""

#: ../../LangRef.rst:11595
msgid ""
"This intrinsic indicates that until an ``llvm.invariant.end`` that uses "
"the return value, the referenced memory location is constant and "
"unchanging."
msgstr ""

#: ../../LangRef.rst:11600
msgid "'``llvm.invariant.end``' Intrinsic"
msgstr ""

#: ../../LangRef.rst:11612
msgid ""
"The '``llvm.invariant.end``' intrinsic specifies that the contents of a "
"memory object are mutable."
msgstr ""

#: ../../LangRef.rst:11618
msgid ""
"The first argument is the matching ``llvm.invariant.start`` intrinsic. "
"The second argument is a constant integer representing the size of the "
"object, or -1 if it is variable sized and the third argument is a pointer"
" to the object."
msgstr ""

#: ../../LangRef.rst:11626
msgid "This intrinsic indicates that the memory is mutable again."
msgstr ""

#: ../../LangRef.rst:11629
msgid "'``llvm.invariant.group.barrier``' Intrinsic"
msgstr ""

#: ../../LangRef.rst:11641
msgid ""
"The '``llvm.invariant.group.barrier``' intrinsic can be used when an "
"invariant established by invariant.group metadata no longer holds, to "
"obtain a new pointer value that does not carry the invariant information."
msgstr ""

#: ../../LangRef.rst:11649
msgid ""
"The ``llvm.invariant.group.barrier`` takes only one argument, which is "
"the pointer to the memory for which the ``invariant.group`` no longer "
"holds."
msgstr ""

#: ../../LangRef.rst:11655
msgid ""
"Returns another pointer that aliases its argument but which is considered"
" different for the purposes of ``load``/``store`` ``invariant.group`` "
"metadata."
msgstr ""

#: ../../LangRef.rst:11659
msgid "General Intrinsics"
msgstr ""

#: ../../LangRef.rst:11661
msgid ""
"This class of intrinsics is designed to be generic and has no specific "
"purpose."
msgstr ""

#: ../../LangRef.rst:11665
msgid "'``llvm.var.annotation``' Intrinsic"
msgstr ""

#: ../../LangRef.rst:11677
msgid "The '``llvm.var.annotation``' intrinsic."
msgstr ""

#: ../../LangRef.rst:11682
msgid ""
"The first argument is a pointer to a value, the second is a pointer to a "
"global string, the third is a pointer to a global string which is the "
"source file name, and the last argument is the line number."
msgstr ""

#: ../../LangRef.rst:11689
msgid ""
"This intrinsic allows annotation of local variables with arbitrary "
"strings. This can be useful for special purpose optimizations that want "
"to look for these annotations. These have no other defined use; they are "
"ignored by code generation and optimization."
msgstr ""

#: ../../LangRef.rst:11695
msgid "'``llvm.ptr.annotation.*``' Intrinsic"
msgstr ""

#: ../../LangRef.rst:11700
msgid ""
"This is an overloaded intrinsic. You can use '``llvm.ptr.annotation``' on"
" a pointer to an integer of any width. *NOTE* you must specify an address"
" space for the pointer. The identifier for the default address space is "
"the integer '``0``'."
msgstr ""

#: ../../LangRef.rst:11716
msgid "The '``llvm.ptr.annotation``' intrinsic."
msgstr ""

#: ../../LangRef.rst:11721
msgid ""
"The first argument is a pointer to an integer value of arbitrary bitwidth"
" (result of some expression), the second is a pointer to a global string,"
" the third is a pointer to a global string which is the source file name,"
" and the last argument is the line number. It returns the value of the "
"first argument."
msgstr ""

#: ../../LangRef.rst:11729
msgid ""
"This intrinsic allows annotation of a pointer to an integer with "
"arbitrary strings. This can be useful for special purpose optimizations "
"that want to look for these annotations. These have no other defined use;"
" they are ignored by code generation and optimization."
msgstr ""

#: ../../LangRef.rst:11735
msgid "'``llvm.annotation.*``' Intrinsic"
msgstr ""

#: ../../LangRef.rst:11740
msgid ""
"This is an overloaded intrinsic. You can use '``llvm.annotation``' on any"
" integer bit width."
msgstr ""

#: ../../LangRef.rst:11754
msgid "The '``llvm.annotation``' intrinsic."
msgstr ""

#: ../../LangRef.rst:11759
msgid ""
"The first argument is an integer value (result of some expression), the "
"second is a pointer to a global string, the third is a pointer to a "
"global string which is the source file name, and the last argument is the"
" line number. It returns the value of the first argument."
msgstr ""

#: ../../LangRef.rst:11767
msgid ""
"This intrinsic allows annotations to be put on arbitrary expressions with"
" arbitrary strings. This can be useful for special purpose optimizations "
"that want to look for these annotations. These have no other defined use;"
" they are ignored by code generation and optimization."
msgstr ""

#: ../../LangRef.rst:11773
msgid "'``llvm.trap``' Intrinsic"
msgstr ""

#: ../../LangRef.rst:11785
msgid "The '``llvm.trap``' intrinsic."
msgstr ""

#: ../../LangRef.rst:11790 ../../LangRef.rst:11817 ../../LangRef.rst:12058
msgid "None."
msgstr ""

#: ../../LangRef.rst:11795
msgid ""
"This intrinsic is lowered to the target dependent trap instruction. If "
"the target does not have a trap instruction, this intrinsic will be "
"lowered to a call of the ``abort()`` function."
msgstr ""

#: ../../LangRef.rst:11800
msgid "'``llvm.debugtrap``' Intrinsic"
msgstr ""

#: ../../LangRef.rst:11812
msgid "The '``llvm.debugtrap``' intrinsic."
msgstr ""

#: ../../LangRef.rst:11822
msgid ""
"This intrinsic is lowered to code which is intended to cause an execution"
" trap with the intention of requesting the attention of a debugger."
msgstr ""

#: ../../LangRef.rst:11827
msgid "'``llvm.stackprotector``' Intrinsic"
msgstr ""

#: ../../LangRef.rst:11839
msgid ""
"The ``llvm.stackprotector`` intrinsic takes the ``guard`` and stores it "
"onto the stack at ``slot``. The stack slot is adjusted to ensure that it "
"is placed on the stack before local variables."
msgstr ""

#: ../../LangRef.rst:11846
msgid ""
"The ``llvm.stackprotector`` intrinsic requires two pointer arguments. The"
" first argument is the value loaded from the stack guard "
"``@__stack_chk_guard``. The second variable is an ``alloca`` that has "
"enough space to hold the value of the guard."
msgstr ""

#: ../../LangRef.rst:11854
msgid ""
"This intrinsic causes the prologue/epilogue inserter to force the "
"position of the ``AllocaInst`` stack slot to be before local variables on"
" the stack. This is to ensure that if a local variable on the stack is "
"overwritten, it will destroy the value of the guard. When the function "
"exits, the guard on the stack is checked against the original guard by "
"``llvm.stackprotectorcheck``. If they are different, then "
"``llvm.stackprotectorcheck`` causes the program to abort by calling the "
"``__stack_chk_fail()`` function."
msgstr ""

#: ../../LangRef.rst:11863
msgid "'``llvm.stackprotectorcheck``' Intrinsic"
msgstr ""

#: ../../LangRef.rst:11875
msgid ""
"The ``llvm.stackprotectorcheck`` intrinsic compares ``guard`` against an "
"already created stack protector and if they are not equal calls the "
"``__stack_chk_fail()`` function."
msgstr ""

#: ../../LangRef.rst:11882
msgid ""
"The ``llvm.stackprotectorcheck`` intrinsic requires one pointer argument,"
" the the variable ``@__stack_chk_guard``."
msgstr ""

#: ../../LangRef.rst:11888
msgid ""
"This intrinsic is provided to perform the stack protector check by "
"comparing ``guard`` with the stack slot created by "
"``llvm.stackprotector`` and if the values do not match call the "
"``__stack_chk_fail()`` function."
msgstr ""

#: ../../LangRef.rst:11892
msgid ""
"The reason to provide this as an IR level intrinsic instead of "
"implementing it via other IR operations is that in order to perform this "
"operation at the IR level without an intrinsic, one would need to create "
"additional basic blocks to handle the success/failure cases. This makes "
"it difficult to stop the stack protector check from disrupting sibling "
"tail calls in Codegen. With this intrinsic, we are able to generate the "
"stack protector basic blocks late in codegen after the tail call decision"
" has occurred."
msgstr ""

#: ../../LangRef.rst:11901
msgid "'``llvm.objectsize``' Intrinsic"
msgstr ""

#: ../../LangRef.rst:11914
msgid ""
"The ``llvm.objectsize`` intrinsic is designed to provide information to "
"the optimizers to determine at compile time whether a) an operation (like"
" memcpy) will overflow a buffer that corresponds to an object, or b) that"
" a runtime check for overflow isn't necessary. An object in this context "
"means an allocation of a specific class, structure, array, or other "
"object."
msgstr ""

#: ../../LangRef.rst:11924
msgid ""
"The ``llvm.objectsize`` intrinsic takes two arguments. The first argument"
" is a pointer to or into the ``object``. The second argument is a boolean"
" and determines whether ``llvm.objectsize`` returns 0 (if true) or -1 (if"
" false) when the object size is unknown. The second argument only accepts"
" constants."
msgstr ""

#: ../../LangRef.rst:11933
msgid ""
"The ``llvm.objectsize`` intrinsic is lowered to a constant representing "
"the size of the object concerned. If the size cannot be determined at "
"compile time, ``llvm.objectsize`` returns ``i32/i64 -1 or 0`` (depending "
"on the ``min`` argument)."
msgstr ""

#: ../../LangRef.rst:11939
msgid "'``llvm.expect``' Intrinsic"
msgstr ""

#: ../../LangRef.rst:11944
msgid ""
"This is an overloaded intrinsic. You can use ``llvm.expect`` on any "
"integer bit width."
msgstr ""

#: ../../LangRef.rst:11956
msgid ""
"The ``llvm.expect`` intrinsic provides information about expected (the "
"most probable) value of ``val``, which can be used by optimizers."
msgstr ""

#: ../../LangRef.rst:11962
msgid ""
"The ``llvm.expect`` intrinsic takes two arguments. The first argument is "
"a value. The second argument is an expected value, this needs to be a "
"constant value, variables are not allowed."
msgstr ""

#: ../../LangRef.rst:11969
msgid "This intrinsic is lowered to the ``val``."
msgstr ""

#: ../../LangRef.rst:11974
msgid "'``llvm.assume``' Intrinsic"
msgstr ""

#: ../../LangRef.rst:11986
msgid ""
"The ``llvm.assume`` allows the optimizer to assume that the provided "
"condition is true. This information can then be used in simplifying other"
" parts of the code."
msgstr ""

#: ../../LangRef.rst:11993
msgid "The condition which the optimizer may assume is always true."
msgstr ""

#: ../../LangRef.rst:11998
msgid ""
"The intrinsic allows the optimizer to assume that the provided condition "
"is always true whenever the control flow reaches the intrinsic call. No "
"code is generated for this intrinsic, and instructions that contribute "
"only to the provided condition are not used for code generation. If the "
"condition is violated during execution, the behavior is undefined."
msgstr ""

#: ../../LangRef.rst:12004
msgid ""
"Note that the optimizer might limit the transformations performed on "
"values used by the ``llvm.assume`` intrinsic in order to preserve the "
"instructions only used to form the intrinsic's input argument. This might"
" prove undesirable if the extra information provided by the "
"``llvm.assume`` intrinsic does not cause sufficient overall improvement "
"in code quality. For this reason, ``llvm.assume`` should not be used to "
"document basic mathematical invariants that the optimizer can otherwise "
"deduce or facts that are of little use to the optimizer."
msgstr ""

#: ../../LangRef.rst:12016
msgid "'``llvm.bitset.test``' Intrinsic"
msgstr ""

#: ../../LangRef.rst:12029
msgid ""
"The first argument is a pointer to be tested. The second argument is a "
"metadata object representing an identifier for a :doc:`bitset <BitSets>`."
msgstr ""

#: ../../LangRef.rst:12035
msgid ""
"The ``llvm.bitset.test`` intrinsic tests whether the given pointer is a "
"member of the given bitset."
msgstr ""

#: ../../LangRef.rst:12039
msgid "'``llvm.donothing``' Intrinsic"
msgstr ""

#: ../../LangRef.rst:12051
msgid ""
"The ``llvm.donothing`` intrinsic doesn't perform any operation. It's one "
"of only two intrinsics (besides ``llvm.experimental.patchpoint``) that "
"can be called with an invoke instruction."
msgstr ""

#: ../../LangRef.rst:12063
msgid ""
"This intrinsic does nothing, and it's removed by optimizers and ignored "
"by codegen."
msgstr ""

#: ../../LangRef.rst:12067
msgid "Stack Map Intrinsics"
msgstr ""

#: ../../LangRef.rst:12069
msgid ""
"LLVM provides experimental intrinsics to support runtime patching "
"mechanisms commonly desired in dynamic language JITs. These intrinsics "
"are described in :doc:`StackMaps`."
msgstr ""

