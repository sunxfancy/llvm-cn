# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2003-2016, LLVM Project
# This file is distributed under the same license as the LLVM package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2016.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: LLVM 3.8\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2016-04-17 11:36+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.3.3\n"

#: ../../FaultMaps.rst:3
msgid "FaultMaps and implicit checks"
msgstr ""

#: ../../FaultMaps.rst:10
msgid "Motivation"
msgstr ""

#: ../../FaultMaps.rst:12
msgid ""
"Code generated by managed language runtimes tend to have checks that are "
"required for safety but never fail in practice.  In such cases, it is "
"profitable to make the non-failing case cheaper even if it makes the "
"failing case significantly more expensive.  This asymmetry can be "
"exploited by folding such safety checks into operations that can be made "
"to fault reliably if the check would have failed, and recovering from "
"such a fault by using a signal handler."
msgstr ""

#: ../../FaultMaps.rst:20
msgid ""
"For example, Java requires null checks on objects before they are read "
"from or written to.  If the object is ``null`` then a "
"``NullPointerException`` has to be thrown, interrupting normal execution."
"  In practice, however, dereferencing a ``null`` pointer is extremely "
"rare in well-behaved Java programs, and typically the null check can be "
"folded into a nearby memory operation that operates on the same memory "
"location."
msgstr ""

#: ../../FaultMaps.rst:29
msgid "The Fault Map Section"
msgstr ""

#: ../../FaultMaps.rst:31
msgid ""
"Information about implicit checks generated by LLVM are put in a special "
"\"fault map\" section.  On Darwin this section is named "
"``__llvm_faultmaps``."
msgstr ""

#: ../../FaultMaps.rst:35
msgid "The format of this section is"
msgstr ""

#: ../../FaultMaps.rst:58
msgid "The ``ImplicitNullChecks`` pass"
msgstr ""

#: ../../FaultMaps.rst:60
msgid ""
"The ``ImplicitNullChecks`` pass transforms explicit control flow for "
"checking if a pointer is ``null``, like:"
msgstr ""

#: ../../FaultMaps.rst:79
msgid ""
"to control flow implicit in the instruction loading or storing through "
"the pointer being null checked:"
msgstr ""

#: ../../FaultMaps.rst:92
msgid ""
"This transform happens at the ``MachineInstr`` level, not the LLVM IR "
"level (so the above example is only representative, not literal).  The "
"``ImplicitNullChecks`` pass runs during codegen, if ``-enable-implicit-"
"null-checks`` is passed to ``llc``."
msgstr ""

#: ../../FaultMaps.rst:97
msgid ""
"The ``ImplicitNullChecks`` pass adds entries to the ``__llvm_faultmaps`` "
"section described above as needed."
msgstr ""

#: ../../FaultMaps.rst:101
msgid "``make.implicit`` metadata"
msgstr ""

#: ../../FaultMaps.rst:103
msgid ""
"Making null checks implicit is an aggressive optimization, and it can be "
"a net performance pessimization if too many memory operations end up "
"faulting because of it.  A language runtime typically needs to ensure "
"that only a negligible number of implicit null checks actually fault once"
" the application has reached a steady state.  A standard way of doing "
"this is by healing failed implicit null checks into explicit null checks "
"via code patching or recompilation.  It follows that there are two "
"requirements an explicit null check needs to satisfy for it to be "
"profitable to convert it to an implicit null check:"
msgstr ""

#: ../../FaultMaps.rst:113
msgid ""
"The case where the pointer is actually null (i.e. the \"failing\" case) "
"is extremely rare."
msgstr ""

#: ../../FaultMaps.rst:116
msgid ""
"The failing path heals the implicit null check into an explicit null "
"check so that the application does not repeatedly page fault."
msgstr ""

#: ../../FaultMaps.rst:120
msgid ""
"The frontend is expected to mark branches that satisfy (1) and (2) using "
"a ``!make.implicit`` metadata node (the actual content of the metadata "
"node is ignored).  Only branches that are marked with ``!make.implicit`` "
"metadata are considered as candidates for conversion into implicit null "
"checks."
msgstr ""

#: ../../FaultMaps.rst:126
msgid ""
"(Note that while we could deal with (1) using profiling data, dealing "
"with (2) requires some information not present in branch profiles.)"
msgstr ""

