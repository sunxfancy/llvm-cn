# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2003-2016, LLVM Project
# This file is distributed under the same license as the LLVM package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2016.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: LLVM 3.8\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2016-04-17 11:36+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.3.3\n"

#: ../../TableGen/index.rst:3
msgid "TableGen"
msgstr ""

#: ../../TableGen/index.rst:17
msgid "Introduction"
msgstr ""

#: ../../TableGen/index.rst:19
msgid ""
"TableGen's purpose is to help a human develop and maintain records of "
"domain-specific information.  Because there may be a large number of "
"these records, it is specifically designed to allow writing flexible "
"descriptions and for common features of these records to be factored out."
"  This reduces the amount of duplication in the description, reduces the "
"chance of error, and makes it easier to structure domain specific "
"information."
msgstr ""

#: ../../TableGen/index.rst:26
msgid ""
"The core part of TableGen parses a file, instantiates the declarations, "
"and hands the result off to a domain-specific `backend`_ for processing."
msgstr ""

#: ../../TableGen/index.rst:29
msgid ""
"The current major users of TableGen are :doc:`../CodeGenerator` and the "
"`Clang diagnostics and attributes "
"<http://clang.llvm.org/docs/UsersManual.html#controlling-errors-and-"
"warnings>`_."
msgstr ""

#: ../../TableGen/index.rst:33
msgid ""
"Note that if you work on TableGen much, and use emacs or vim, that you "
"can find an emacs \"TableGen mode\" and a vim language file in the "
"``llvm/utils/emacs`` and ``llvm/utils/vim`` directories of your LLVM "
"distribution, respectively."
msgstr ""

#: ../../TableGen/index.rst:41
msgid "The TableGen program"
msgstr ""

#: ../../TableGen/index.rst:43
msgid ""
"TableGen files are interpreted by the TableGen program: `llvm-tblgen` "
"available on your build directory under `bin`. It is not installed in the"
" system (or where your sysroot is set to), since it has no use beyond "
"LLVM's build process."
msgstr ""

#: ../../TableGen/index.rst:48
msgid "Running TableGen"
msgstr ""

#: ../../TableGen/index.rst:50
msgid ""
"TableGen runs just like any other LLVM tool.  The first (optional) "
"argument specifies the file to read.  If a filename is not specified, "
"``llvm-tblgen`` reads from standard input."
msgstr ""

#: ../../TableGen/index.rst:54
msgid ""
"To be useful, one of the `backends`_ must be used.  These backends are "
"selectable on the command line (type '``llvm-tblgen -help``' for a list)."
"  For example, to get a list of all of the definitions that subclass a "
"particular type (which can be useful for building up an enum list of "
"these records), use the ``-print-enums`` option:"
msgstr ""

#: ../../TableGen/index.rst:79
msgid "The default backend prints out all of the records."
msgstr ""

#: ../../TableGen/index.rst:81
msgid ""
"If you plan to use TableGen, you will most likely have to write a "
"`backend`_ that extracts the information specific to what you need and "
"formats it in the appropriate way."
msgstr ""

#: ../../TableGen/index.rst:86
msgid "Example"
msgstr ""

#: ../../TableGen/index.rst:88
msgid ""
"With no other arguments, `llvm-tblgen` parses the specified file and "
"prints out all of the classes, then all of the definitions.  This is a "
"good way to see what the various definitions expand to fully.  Running "
"this on the ``X86.td`` file prints this (at the time of this writing):"
msgstr ""

#: ../../TableGen/index.rst:143
msgid ""
"This definition corresponds to the 32-bit register-register ``add`` "
"instruction of the x86 architecture.  ``def ADD32rr`` defines a record "
"named ``ADD32rr``, and the comment at the end of the line indicates the "
"superclasses of the definition.  The body of the record contains all of "
"the data that TableGen assembled for the record, indicating that the "
"instruction is part of the \"X86\" namespace, the pattern indicating how "
"the instruction is selected by the code generator, that it is a two-"
"address instruction, has a particular encoding, etc.  The contents and "
"semantics of the information in the record are specific to the needs of "
"the X86 backend, and are only shown as an example."
msgstr ""

#: ../../TableGen/index.rst:153
msgid ""
"As you can see, a lot of information is needed for every instruction "
"supported by the code generator, and specifying it all manually would be "
"unmaintainable, prone to bugs, and tiring to do in the first place.  "
"Because we are using TableGen, all of the information was derived from "
"the following definition:"
msgstr ""

#: ../../TableGen/index.rst:168
msgid ""
"This definition makes use of the custom class ``I`` (extended from the "
"custom class ``X86Inst``), which is defined in the X86-specific TableGen "
"file, to factor out the common features that instructions of its class "
"share.  A key feature of TableGen is that it allows the end-user to "
"define the abstractions they prefer to use when describing their "
"information."
msgstr ""

#: ../../TableGen/index.rst:174
msgid ""
"Each ``def`` record has a special entry called \"NAME\".  This is the "
"name of the record (\"``ADD32rr``\" above).  In the general case ``def`` "
"names can be formed from various kinds of string processing expressions "
"and ``NAME`` resolves to the final value obtained after resolving all of "
"those expressions.  The user may refer to ``NAME`` anywhere she desires "
"to use the ultimate name of the ``def``. ``NAME`` should not be defined "
"anywhere else in user code to avoid conflicts."
msgstr ""

#: ../../TableGen/index.rst:182
msgid "Syntax"
msgstr ""

#: ../../TableGen/index.rst:184
msgid ""
"TableGen has a syntax that is loosely based on C++ templates, with built-"
"in types and specification. In addition, TableGen's syntax introduces "
"some automation concepts like multiclass, foreach, let, etc."
msgstr ""

#: ../../TableGen/index.rst:189
msgid "Basic concepts"
msgstr ""

#: ../../TableGen/index.rst:191
msgid ""
"TableGen files consist of two key parts: 'classes' and 'definitions', "
"both of which are considered 'records'."
msgstr ""

#: ../../TableGen/index.rst:194
msgid ""
"**TableGen records** have a unique name, a list of values, and a list of "
"superclasses.  The list of values is the main data that TableGen builds "
"for each record; it is this that holds the domain specific information "
"for the application.  The interpretation of this data is left to a "
"specific `backend`_, but the structure and format rules are taken care of"
" and are fixed by TableGen."
msgstr ""

#: ../../TableGen/index.rst:201
msgid ""
"**TableGen definitions** are the concrete form of 'records'.  These "
"generally do not have any undefined values, and are marked with the "
"'``def``' keyword."
msgstr ""

#: ../../TableGen/index.rst:209
msgid ""
"In this example, FeatureFPARMv8 is ``SubtargetFeature`` record "
"initialised with some values. The names of the classes are defined via "
"the keyword `class` either on the same file or some other included. Most "
"target TableGen files include the generic ones in "
"``include/llvm/Target``."
msgstr ""

#: ../../TableGen/index.rst:214
msgid ""
"**TableGen classes** are abstract records that are used to build and "
"describe other records.  These classes allow the end-user to build "
"abstractions for either the domain they are targeting (such as "
"\"Register\", \"RegisterClass\", and \"Instruction\" in the LLVM code "
"generator) or for the implementor to help factor out common properties of"
" records (such as \"FPInst\", which is used to represent floating point "
"instructions in the X86 backend).  TableGen keeps track of all of the "
"classes that are used to build up a definition, so the backend can find "
"all definitions of a particular class, such as \"Instruction\"."
msgstr ""

#: ../../TableGen/index.rst:228
msgid ""
"Here, the class ProcNoItin, receiving parameters `Name` of type `string` "
"and a list of target features is specializing the class Processor by "
"passing the arguments down as well as hard-coding NoItineraries."
msgstr ""

#: ../../TableGen/index.rst:232
msgid ""
"**TableGen multiclasses** are groups of abstract records that are "
"instantiated all at once.  Each instantiation can result in multiple "
"TableGen definitions. If a multiclass inherits from another multiclass, "
"the definitions in the sub-multiclass become part of the current "
"multiclass, as if they were declared in the current multiclass."
msgstr ""

#: ../../TableGen/index.rst:258
msgid ""
"See the :doc:`TableGen Language Introduction <LangIntro>` for more "
"generic information on the usage of the language, and the :doc:`TableGen "
"Language Reference <LangRef>` for more in-depth description of the formal"
" language specification."
msgstr ""

#: ../../TableGen/index.rst:267
msgid "TableGen backends"
msgstr ""

#: ../../TableGen/index.rst:269
msgid ""
"TableGen files have no real meaning without a back-end. The default "
"operation of running ``llvm-tblgen`` is to print the information in a "
"textual format, but that's only useful for debugging of the TableGen "
"files themselves. The power in TableGen is, however, to interpret the "
"source files into an internal representation that can be generated into "
"anything you want."
msgstr ""

#: ../../TableGen/index.rst:275
msgid ""
"Current usage of TableGen is to create huge include files with tables "
"that you can either include directly (if the output is in the language "
"you're coding), or be used in pre-processing via macros surrounding the "
"include of the file."
msgstr ""

#: ../../TableGen/index.rst:279
msgid ""
"Direct output can be used if the back-end already prints a table in C "
"format or if the output is just a list of strings (for error and warning "
"messages). Pre-processed output should be used if the same information "
"needs to be used in different contexts (like Instruction names), so your "
"back-end should print a meta-information list that can be shaped into "
"different compile-time formats."
msgstr ""

#: ../../TableGen/index.rst:285
msgid "See the `TableGen BackEnds <BackEnds.html>`_ for more information."
msgstr ""

#: ../../TableGen/index.rst:288
msgid "TableGen Deficiencies"
msgstr ""

#: ../../TableGen/index.rst:290
msgid ""
"Despite being very generic, TableGen has some deficiencies that have been"
" pointed out numerous times. The common theme is that, while TableGen "
"allows you to build Domain-Specific-Languages, the final languages that "
"you create lack the power of other DSLs, which in turn increase "
"considerably the size and complexity of TableGen files."
msgstr ""

#: ../../TableGen/index.rst:296
msgid ""
"At the same time, TableGen allows you to create virtually any meaning of "
"the basic concepts via custom-made back-ends, which can pervert the "
"original design and make it very hard for newcomers to understand the "
"evil TableGen file."
msgstr ""

#: ../../TableGen/index.rst:301
msgid ""
"There are some in favour of extending the semantics even more, but making"
" sure back-ends adhere to strict rules. Others are suggesting we should "
"move to less, more powerful DSLs designed with specific purposes, or even"
" re-using existing DSLs."
msgstr ""

#: ../../TableGen/index.rst:306
msgid ""
"Either way, this is a discussion that will likely span across several "
"years, if not decades. You can read more in the `TableGen Deficiencies "
"<Deficiencies.html>`_ document."
msgstr ""

