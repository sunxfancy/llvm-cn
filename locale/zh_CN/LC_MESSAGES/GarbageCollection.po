# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2003-2016, LLVM Project
# This file is distributed under the same license as the LLVM package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2016.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: LLVM 3.8\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2016-04-17 11:36+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.3.3\n"

#: ../../GarbageCollection.rst:3
msgid "Garbage Collection with LLVM"
msgstr ""

#: ../../GarbageCollection.rst:9
msgid "Abstract"
msgstr ""

#: ../../GarbageCollection.rst:11
msgid ""
"This document covers how to integrate LLVM into a compiler for a language"
" which supports garbage collection.  **Note that LLVM itself does not "
"provide a garbage collector.**  You must provide your own."
msgstr ""

#: ../../GarbageCollection.rst:16
msgid "Quick Start"
msgstr ""

#: ../../GarbageCollection.rst:18
msgid ""
"First, you should pick a collector strategy.  LLVM includes a number of "
"built in ones, but you can also implement a loadable plugin with a custom"
" definition. Note that the collector strategy is a description of how "
"LLVM should generate code such that it interacts with your collector and "
"runtime, not a description of the collector itself."
msgstr ""

#: ../../GarbageCollection.rst:24
msgid ""
"Next, mark your generated functions as using your chosen collector "
"strategy. From c++, you can call:"
msgstr ""

#: ../../GarbageCollection.rst:32
msgid "This will produce IR like the following fragment:"
msgstr ""

#: ../../GarbageCollection.rst:39
msgid "When generating LLVM IR for your functions, you will need to:"
msgstr ""

#: ../../GarbageCollection.rst:41
msgid ""
"Use ``@llvm.gcread`` and/or ``@llvm.gcwrite`` in place of standard load "
"and store instructions.  These intrinsics are used to represent load and "
"store barriers.  If you collector does not require such barriers, you can"
" skip this step."
msgstr ""

#: ../../GarbageCollection.rst:46
msgid ""
"Use the memory allocation routines provided by your garbage collector's "
"runtime library."
msgstr ""

#: ../../GarbageCollection.rst:49
msgid ""
"If your collector requires them, generate type maps according to your "
"runtime's binary interface.  LLVM is not involved in the process.  In "
"particular, the LLVM type system is not suitable for conveying such "
"information though the compiler."
msgstr ""

#: ../../GarbageCollection.rst:54
msgid ""
"Insert any coordination code required for interacting with your "
"collector. Many collectors require running application code to "
"periodically check a flag and conditionally call a runtime function.  "
"This is often referred to as a safepoint poll."
msgstr ""

#: ../../GarbageCollection.rst:59
msgid ""
"You will need to identify roots (i.e. references to heap objects your "
"collector needs to know about) in your generated IR, so that LLVM can "
"encode them into your final stack maps.  Depending on the collector "
"strategy chosen, this is accomplished by using either the "
"``@llvm.gcroot`` intrinsics or an ``gc.statepoint`` relocation sequence."
msgstr ""

#: ../../GarbageCollection.rst:65
msgid ""
"Don't forget to create a root for each intermediate value that is "
"generated when evaluating an expression.  In ``h(f(), g())``, the result "
"of ``f()`` could easily be collected if evaluating ``g()`` triggers a "
"collection."
msgstr ""

#: ../../GarbageCollection.rst:69
msgid ""
"Finally, you need to link your runtime library with the generated program"
" executable (for a static compiler) or ensure the appropriate symbols are"
" available for the runtime linker (for a JIT compiler)."
msgstr ""

#: ../../GarbageCollection.rst:75
msgid "Introduction"
msgstr ""

#: ../../GarbageCollection.rst:78
msgid "What is Garbage Collection?"
msgstr ""

#: ../../GarbageCollection.rst:80
msgid ""
"Garbage collection is a widely used technique that frees the programmer "
"from having to know the lifetimes of heap objects, making software easier"
" to produce and maintain.  Many programming languages rely on garbage "
"collection for automatic memory management.  There are two primary forms "
"of garbage collection: conservative and accurate."
msgstr ""

#: ../../GarbageCollection.rst:86
msgid ""
"Conservative garbage collection often does not require any special "
"support from either the language or the compiler: it can handle non-type-"
"safe programming languages (such as C/C++) and does not require any "
"special information from the compiler.  The `Boehm collector "
"<http://www.hpl.hp.com/personal/Hans_Boehm/gc/>`__ is an example of a "
"state-of-the-art conservative collector."
msgstr ""

#: ../../GarbageCollection.rst:93
msgid ""
"Accurate garbage collection requires the ability to identify all pointers"
" in the program at run-time (which requires that the source-language be "
"type-safe in most cases).  Identifying pointers at run-time requires "
"compiler support to locate all places that hold live pointer variables at"
" run-time, including the :ref:`processor stack and registers <gcroot>`."
msgstr ""

#: ../../GarbageCollection.rst:99
msgid ""
"Conservative garbage collection is attractive because it does not require"
" any special compiler support, but it does have problems.  In particular,"
" because the conservative garbage collector cannot *know* that a "
"particular word in the machine is a pointer, it cannot move live objects "
"in the heap (preventing the use of compacting and generational GC "
"algorithms) and it can occasionally suffer from memory leaks due to "
"integer values that happen to point to objects in the program.  In "
"addition, some aggressive compiler transformations can break conservative"
" garbage collectors (though these seem rare in practice)."
msgstr ""

#: ../../GarbageCollection.rst:108
msgid ""
"Accurate garbage collectors do not suffer from any of these problems, but"
" they can suffer from degraded scalar optimization of the program.  In "
"particular, because the runtime must be able to identify and update all "
"pointers active in the program, some optimizations are less effective.  "
"In practice, however, the locality and performance benefits of using "
"aggressive garbage collection techniques dominates any low-level losses."
msgstr ""

#: ../../GarbageCollection.rst:115
msgid ""
"This document describes the mechanisms and interfaces provided by LLVM to"
" support accurate garbage collection."
msgstr ""

#: ../../GarbageCollection.rst:119
msgid "Goals and non-goals"
msgstr ""

#: ../../GarbageCollection.rst:121
msgid ""
"LLVM's intermediate representation provides :ref:`garbage collection "
"intrinsics <gc_intrinsics>` that offer support for a broad class of "
"collector models.  For instance, the intrinsics permit:"
msgstr ""

#: ../../GarbageCollection.rst:125
msgid "semi-space collectors"
msgstr ""

#: ../../GarbageCollection.rst:127
msgid "mark-sweep collectors"
msgstr ""

#: ../../GarbageCollection.rst:129
msgid "generational collectors"
msgstr ""

#: ../../GarbageCollection.rst:131
msgid "incremental collectors"
msgstr ""

#: ../../GarbageCollection.rst:133
msgid "concurrent collectors"
msgstr ""

#: ../../GarbageCollection.rst:135
msgid "cooperative collectors"
msgstr ""

#: ../../GarbageCollection.rst:137
msgid "reference counting"
msgstr ""

#: ../../GarbageCollection.rst:139
msgid ""
"We hope that the support built into the LLVM IR is sufficient to support "
"a broad class of garbage collected languages including Scheme, ML, Java, "
"C#, Perl, Python, Lua, Ruby, other scripting languages, and more."
msgstr ""

#: ../../GarbageCollection.rst:143
msgid ""
"Note that LLVM **does not itself provide a garbage collector** --- this "
"should be part of your language's runtime library.  LLVM provides a "
"framework for describing the garbage collectors requirements to the "
"compiler.  In particular, LLVM provides support for generating stack maps"
" at call sites, polling for a safepoint, and emitting load and store "
"barriers.  You can also extend LLVM - possibly through a loadable "
":ref:`code generation plugins <plugin>` - to generate code and data "
"structures which conforms to the *binary interface* specified by the "
"*runtime library*.  This is similar to the relationship between LLVM and "
"DWARF debugging info, for example.  The difference primarily lies in the "
"lack of an established standard in the domain of garbage collection --- "
"thus the need for a flexible extension mechanism."
msgstr ""

#: ../../GarbageCollection.rst:155
msgid ""
"The aspects of the binary interface with which LLVM's GC support is "
"concerned are:"
msgstr ""

#: ../../GarbageCollection.rst:158
msgid ""
"Creation of GC safepoints within code where collection is allowed to "
"execute safely."
msgstr ""

#: ../../GarbageCollection.rst:161
msgid ""
"Computation of the stack map.  For each safe point in the code, object "
"references within the stack frame must be identified so that the "
"collector may traverse and perhaps update them."
msgstr ""

#: ../../GarbageCollection.rst:165
msgid ""
"Write barriers when storing object references to the heap.  These are "
"commonly used to optimize incremental scans in generational collectors."
msgstr ""

#: ../../GarbageCollection.rst:168
msgid ""
"Emission of read barriers when loading object references.  These are "
"useful for interoperating with concurrent collectors."
msgstr ""

#: ../../GarbageCollection.rst:171
msgid "There are additional areas that LLVM does not directly address:"
msgstr ""

#: ../../GarbageCollection.rst:173
msgid "Registration of global roots with the runtime."
msgstr ""

#: ../../GarbageCollection.rst:175
msgid "Registration of stack map entries with the runtime."
msgstr ""

#: ../../GarbageCollection.rst:177
msgid ""
"The functions used by the program to allocate memory, trigger a "
"collection, etc."
msgstr ""

#: ../../GarbageCollection.rst:180
msgid ""
"Computation or compilation of type maps, or registration of them with the"
" runtime.  These are used to crawl the heap for object references."
msgstr ""

#: ../../GarbageCollection.rst:183
msgid ""
"In general, LLVM's support for GC does not include features which can be "
"adequately addressed with other features of the IR and does not specify a"
" particular binary interface.  On the plus side, this means that you "
"should be able to integrate LLVM with an existing runtime.  On the other "
"hand, it can have the effect of leaving a lot of work for the developer "
"of a novel language.  We try to mitigate this by providing built in "
"collector strategy descriptions that can work with many common collector "
"designs and easy extension points.  If you don't already have a specific "
"binary interface you need to support, we recommend trying to use one of "
"these built in collector strategies."
msgstr ""

#: ../../GarbageCollection.rst:197
msgid "LLVM IR Features"
msgstr ""

#: ../../GarbageCollection.rst:199
msgid ""
"This section describes the garbage collection facilities provided by the "
":doc:`LLVM intermediate representation <LangRef>`.  The exact behavior of"
" these IR features is specified by the selected :ref:`GC strategy "
"description <plugin>`."
msgstr ""

#: ../../GarbageCollection.rst:205
msgid "Specifying GC code generation: ``gc \"...\"``"
msgstr ""

#: ../../GarbageCollection.rst:211
msgid ""
"The ``gc`` function attribute is used to specify the desired GC strategy "
"to the compiler.  Its programmatic equivalent is the ``setGC`` method of "
"``Function``."
msgstr ""

#: ../../GarbageCollection.rst:214
msgid ""
"Setting ``gc \"name\"`` on a function triggers a search for a matching "
"subclass of GCStrategy.  Some collector strategies are built in.  You can"
" add others using either the loadable plugin mechanism, or by patching "
"your copy of LLVM. It is the selected GC strategy which defines the exact"
" nature of the code generated to support GC.  If none is found, the "
"compiler will raise an error."
msgstr ""

#: ../../GarbageCollection.rst:220
msgid ""
"Specifying the GC style on a per-function basis allows LLVM to link "
"together programs that use different garbage collection algorithms (or "
"none at all)."
msgstr ""

#: ../../GarbageCollection.rst:226
msgid "Identifying GC roots on the stack"
msgstr ""

#: ../../GarbageCollection.rst:228
msgid ""
"LLVM currently supports two different mechanisms for describing "
"references in compiled code at safepoints.  ``llvm.gcroot`` is the older "
"mechanism; ``gc.statepoint`` has been added more recently.  At the "
"moment, you can choose either implementation (on a per :ref:`GC strategy "
"<plugin>` basis).  Longer term, we will probably either migrate away from"
" ``llvm.gcroot`` entirely, or substantially merge their implementations. "
"Note that most new development work is focused on ``gc.statepoint``."
msgstr ""

#: ../../GarbageCollection.rst:237
msgid "Using ``gc.statepoint``"
msgstr ""

#: ../../GarbageCollection.rst:238
msgid ""
":doc:`This page <Statepoints>` contains detailed documentation for "
"``gc.statepoint``."
msgstr ""

#: ../../GarbageCollection.rst:242
msgid "Using ``llvm.gcwrite``"
msgstr ""

#: ../../GarbageCollection.rst:248
msgid ""
"The ``llvm.gcroot`` intrinsic is used to inform LLVM that a stack "
"variable references an object on the heap and is to be tracked for "
"garbage collection. The exact impact on generated code is specified by "
"the Function's selected :ref:`GC strategy <plugin>`.  All calls to "
"``llvm.gcroot`` **must** reside inside the first basic block."
msgstr ""

#: ../../GarbageCollection.rst:254
msgid ""
"The first argument **must** be a value referring to an alloca instruction"
" or a bitcast of an alloca.  The second contains a pointer to metadata "
"that should be associated with the pointer, and **must** be a constant or"
" global value address.  If your target collector uses tags, use a null "
"pointer for metadata."
msgstr ""

#: ../../GarbageCollection.rst:259
msgid ""
"A compiler which performs manual SSA construction **must** ensure that "
"SSA values representing GC references are stored in to the alloca passed "
"to the respective ``gcroot`` before every call site and reloaded after "
"every call. A compiler which uses mem2reg to raise imperative code using "
"``alloca`` into SSA form need only add a call to ``@llvm.gcroot`` for "
"those variables which are pointers into the GC heap."
msgstr ""

#: ../../GarbageCollection.rst:266
msgid ""
"It is also important to mark intermediate values with ``llvm.gcroot``.  "
"For example, consider ``h(f(), g())``.  Beware leaking the result of "
"``f()`` in the case that ``g()`` triggers a collection.  Note, that stack"
" variables must be initialized and marked with ``llvm.gcroot`` in "
"function's prologue."
msgstr ""

#: ../../GarbageCollection.rst:271
msgid ""
"The ``%metadata`` argument can be used to avoid requiring heap objects to"
" have 'isa' pointers or tag bits. [Appel89_, Goldberg91_, Tolmach94_] If "
"specified, its value will be tracked along with the location of the "
"pointer in the stack frame."
msgstr ""

#: ../../GarbageCollection.rst:276
msgid "Consider the following fragment of Java code:"
msgstr ""

#: ../../GarbageCollection.rst:285
msgid ""
"This block (which may be located in the middle of a function or in a loop"
" nest), could be compiled to this LLVM code:"
msgstr ""

#: ../../GarbageCollection.rst:315
msgid "Reading and writing references in the heap"
msgstr ""

#: ../../GarbageCollection.rst:317
msgid ""
"Some collectors need to be informed when the mutator (the program that "
"needs garbage collection) either reads a pointer from or writes a pointer"
" to a field of a heap object.  The code fragments inserted at these "
"points are called *read barriers* and *write barriers*, respectively.  "
"The amount of code that needs to be executed is usually quite small and "
"not on the critical path of any computation, so the overall performance "
"impact of the barrier is tolerable."
msgstr ""

#: ../../GarbageCollection.rst:324
#, python-format
msgid ""
"Barriers often require access to the *object pointer* rather than the "
"*derived pointer* (which is a pointer to the field within the object).  "
"Accordingly, these intrinsics take both pointers as separate arguments "
"for completeness.  In this snippet, ``%object`` is the object pointer, "
"and ``%derived`` is the derived pointer:"
msgstr ""

#: ../../GarbageCollection.rst:342
msgid ""
"LLVM does not enforce this relationship between the object and derived "
"pointer (although a particular :ref:`collector strategy <plugin>` might)."
"  However, it would be an unusual collector that violated it."
msgstr ""

#: ../../GarbageCollection.rst:346
msgid ""
"The use of these intrinsics is naturally optional if the target GC does "
"not require the corresponding barrier.  The GC strategy used with such a "
"collector should replace the intrinsic calls with the corresponding "
"``load`` or ``store`` instruction if they are used."
msgstr ""

#: ../../GarbageCollection.rst:351
msgid ""
"One known deficiency with the current design is that the barrier "
"intrinsics do not include the size or alignment of the underlying "
"operation performed.  It is currently assumed that the operation is of "
"pointer size and the alignment is assumed to be the target machine's "
"default alignment."
msgstr ""

#: ../../GarbageCollection.rst:357
msgid "Write barrier: ``llvm.gcwrite``"
msgstr ""

#: ../../GarbageCollection.rst:363
msgid ""
"For write barriers, LLVM provides the ``llvm.gcwrite`` intrinsic "
"function.  It has exactly the same semantics as a non-volatile ``store`` "
"to the derived pointer (the third argument).  The exact code generated is"
" specified by the Function's selected :ref:`GC strategy <plugin>`."
msgstr ""

#: ../../GarbageCollection.rst:368
msgid ""
"Many important algorithms require write barriers, including generational "
"and concurrent collectors.  Additionally, write barriers could be used to"
" implement reference counting."
msgstr ""

#: ../../GarbageCollection.rst:373
msgid "Read barrier: ``llvm.gcread``"
msgstr ""

#: ../../GarbageCollection.rst:379
msgid ""
"For read barriers, LLVM provides the ``llvm.gcread`` intrinsic function."
"  It has exactly the same semantics as a non-volatile ``load`` from the "
"derived pointer (the second argument).  The exact code generated is "
"specified by the Function's selected :ref:`GC strategy <plugin>`."
msgstr ""

#: ../../GarbageCollection.rst:384
msgid ""
"Read barriers are needed by fewer algorithms than write barriers, and may"
" have a greater performance impact since pointer reads are more frequent "
"than writes."
msgstr ""

#: ../../GarbageCollection.rst:392
msgid "Built In GC Strategies"
msgstr ""

#: ../../GarbageCollection.rst:394
msgid ""
"LLVM includes built in support for several varieties of garbage "
"collectors."
msgstr ""

#: ../../GarbageCollection.rst:397
msgid "The Shadow Stack GC"
msgstr ""

#: ../../GarbageCollection.rst:399
msgid "To use this collector strategy, mark your functions with:"
msgstr ""

#: ../../GarbageCollection.rst:405
msgid ""
"Unlike many GC algorithms which rely on a cooperative code generator to "
"compile stack maps, this algorithm carefully maintains a linked list of "
"stack roots [:ref:`Henderson2002 <henderson02>`].  This so-called "
"\"shadow stack\" mirrors the machine stack.  Maintaining this data "
"structure is slower than using a stack map compiled into the executable "
"as constant data, but has a significant portability advantage because it "
"requires no special support from the target code generator, and does not "
"require tricky platform-specific code to crawl the machine stack."
msgstr ""

#: ../../GarbageCollection.rst:413
msgid "The tradeoff for this simplicity and portability is:"
msgstr ""

#: ../../GarbageCollection.rst:415
msgid "High overhead per function call."
msgstr ""

#: ../../GarbageCollection.rst:417
msgid "Not thread-safe."
msgstr ""

#: ../../GarbageCollection.rst:419
msgid ""
"Still, it's an easy way to get started.  After your compiler and runtime "
"are up and running, writing a :ref:`plugin <plugin>` will allow you to "
"take advantage of :ref:`more advanced GC features <collector-algos>` of "
"LLVM in order to improve performance."
msgstr ""

#: ../../GarbageCollection.rst:425
msgid ""
"The shadow stack doesn't imply a memory allocation algorithm.  A "
"semispace collector or building atop ``malloc`` are great places to "
"start, and can be implemented with very little code."
msgstr ""

#: ../../GarbageCollection.rst:429
msgid ""
"When it comes time to collect, however, your runtime needs to traverse "
"the stack roots, and for this it needs to integrate with the shadow "
"stack.  Luckily, doing so is very simple. (This code is heavily commented"
" to help you understand the data structure, but there are only 20 lines "
"of meaningful code.)"
msgstr ""

#: ../../GarbageCollection.rst:485
msgid "The 'Erlang' and 'Ocaml' GCs"
msgstr ""

#: ../../GarbageCollection.rst:487
msgid ""
"LLVM ships with two example collectors which leverage the ``gcroot`` "
"mechanisms.  To our knowledge, these are not actually used by any "
"language runtime, but they do provide a reasonable starting point for "
"someone interested in writing an ``gcroot`` compatible GC plugin.  In "
"particular, these are the only in tree examples of how to produce a "
"custom binary stack map format using a ``gcroot`` strategy."
msgstr ""

#: ../../GarbageCollection.rst:494
msgid ""
"As there names imply, the binary format produced is intended to model "
"that used by the Erlang and OCaml compilers respectively."
msgstr ""

#: ../../GarbageCollection.rst:500
msgid "The Statepoint Example GC"
msgstr ""

#: ../../GarbageCollection.rst:506
msgid ""
"This GC provides an example of how one might use the infrastructure "
"provided by ``gc.statepoint``. This example GC is compatible with the "
":ref:`PlaceSafepoints` and :ref:`RewriteStatepointsForGC` utility passes "
"which simplify ``gc.statepoint`` sequence insertion. If you need to build"
" a custom GC strategy around the ``gc.statepoints`` mechanisms, it is "
"recommended that you use this one as a starting point."
msgstr ""

#: ../../GarbageCollection.rst:513
msgid ""
"This GC strategy does not support read or write barriers.  As a result, "
"these intrinsics are lowered to normal loads and stores."
msgstr ""

#: ../../GarbageCollection.rst:516
msgid ""
"The stack map format generated by this GC strategy can be found in the "
":ref:`stackmap-section` using a format documented :ref:`here <statepoint-"
"stackmap-format>`. This format is intended to be the standard format "
"supported by LLVM going forward."
msgstr ""

#: ../../GarbageCollection.rst:522
msgid "The CoreCLR GC"
msgstr ""

#: ../../GarbageCollection.rst:528
msgid ""
"This GC leverages the ``gc.statepoint`` mechanism to support the `CoreCLR"
" <https://github.com/dotnet/coreclr>`__ runtime."
msgstr ""

#: ../../GarbageCollection.rst:531
msgid ""
"Support for this GC strategy is a work in progress. This strategy will "
"differ from :ref:`statepoint-example GC<statepoint_example_gc>` strategy "
"in certain aspects like:"
msgstr ""

#: ../../GarbageCollection.rst:536
msgid ""
"Base-pointers of interior pointers are not explicitly tracked and "
"reported."
msgstr ""

#: ../../GarbageCollection.rst:539
msgid "A different format is used for encoding stack maps."
msgstr ""

#: ../../GarbageCollection.rst:541
msgid ""
"Safe-point polls are only needed before loop-back edges and before tail-"
"calls (not needed at function-entry)."
msgstr ""

#: ../../GarbageCollection.rst:545
msgid "Custom GC Strategies"
msgstr ""

#: ../../GarbageCollection.rst:547
msgid ""
"If none of the built in GC strategy descriptions met your needs above, "
"you will need to define a custom GCStrategy and possibly, a custom LLVM "
"pass to perform lowering.  Your best example of where to start defining a"
" custom GCStrategy would be to look at one of the built in strategies."
msgstr ""

#: ../../GarbageCollection.rst:552
msgid ""
"You may be able to structure this additional code as a loadable plugin "
"library. Loadable plugins are sufficient if all you need is to enable a "
"different combination of built in functionality, but if you need to "
"provide a custom lowering pass, you will need to build a patched version "
"of LLVM.  If you think you need a patched build, please ask for advice on"
" llvm-dev.  There may be an easy way we can extend the support to make it"
" work for your use case without requiring a custom build."
msgstr ""

#: ../../GarbageCollection.rst:561
msgid "Collector Requirements"
msgstr ""

#: ../../GarbageCollection.rst:563
msgid ""
"You should be able to leverage any existing collector library that "
"includes the following elements:"
msgstr ""

#: ../../GarbageCollection.rst:565
msgid ""
"A memory allocator which exposes an allocation function your compiled "
"code can call."
msgstr ""

#: ../../GarbageCollection.rst:568
msgid ""
"A binary format for the stack map.  A stack map describes the location of"
" references at a safepoint and is used by precise collectors to identify "
"references within a stack frame on the machine stack. Note that "
"collectors which conservatively scan the stack don't require such a "
"structure."
msgstr ""

#: ../../GarbageCollection.rst:573
msgid ""
"A stack crawler to discover functions on the call stack, and enumerate "
"the references listed in the stack map for each call site."
msgstr ""

#: ../../GarbageCollection.rst:576
msgid ""
"A mechanism for identifying references in global locations (e.g. global "
"variables)."
msgstr ""

#: ../../GarbageCollection.rst:579
msgid ""
"If you collector requires them, an LLVM IR implementation of your "
"collectors load and store barriers.  Note that since many collectors "
"don't require barriers at all, LLVM defaults to lowering such barriers to"
" normal loads and stores unless you arrange otherwise."
msgstr ""

#: ../../GarbageCollection.rst:586
msgid "Implementing a collector plugin"
msgstr ""

#: ../../GarbageCollection.rst:588
msgid ""
"User code specifies which GC code generation to use with the ``gc`` "
"function attribute or, equivalently, with the ``setGC`` method of "
"``Function``."
msgstr ""

#: ../../GarbageCollection.rst:591
msgid ""
"To implement a GC plugin, it is necessary to subclass "
"``llvm::GCStrategy``, which can be accomplished in a few lines of "
"boilerplate code.  LLVM's infrastructure provides access to several "
"important algorithms.  For an uncontroversial collector, all that remains"
" may be to compile LLVM's computed stack map to assembly code (using the "
"binary representation expected by the runtime library).  This can be "
"accomplished in about 100 lines of code."
msgstr ""

#: ../../GarbageCollection.rst:598
msgid ""
"This is not the appropriate place to implement a garbage collected heap "
"or a garbage collector itself.  That code should exist in the language's "
"runtime library.  The compiler plugin is responsible for generating code "
"which conforms to the binary interface defined by library, most "
"essentially the :ref:`stack map <stack-map>`."
msgstr ""

#: ../../GarbageCollection.rst:604
msgid "To subclass ``llvm::GCStrategy`` and register it with the compiler:"
msgstr ""

#: ../../GarbageCollection.rst:626
msgid "This boilerplate collector does nothing.  More specifically:"
msgstr ""

#: ../../GarbageCollection.rst:628
msgid ""
"``llvm.gcread`` calls are replaced with the corresponding ``load`` "
"instruction."
msgstr ""

#: ../../GarbageCollection.rst:631
msgid ""
"``llvm.gcwrite`` calls are replaced with the corresponding ``store`` "
"instruction."
msgstr ""

#: ../../GarbageCollection.rst:634
msgid "No safe points are added to the code."
msgstr ""

#: ../../GarbageCollection.rst:636
msgid "The stack map is not compiled into the executable."
msgstr ""

#: ../../GarbageCollection.rst:638
msgid ""
"Using the LLVM makefiles, this code can be compiled as a plugin using a "
"simple makefile:"
msgstr ""

#: ../../GarbageCollection.rst:651
msgid ""
"Once the plugin is compiled, code using it may be compiled using ``llc "
"-load=MyGC.so`` (though MyGC.so may have some other platform-specific "
"extension):"
msgstr ""

#: ../../GarbageCollection.rst:664
msgid ""
"It is also possible to statically link the collector plugin into tools, "
"such as a language-specific compiler front-end."
msgstr ""

#: ../../GarbageCollection.rst:670
msgid "Overview of available features"
msgstr ""

#: ../../GarbageCollection.rst:672
msgid ""
"``GCStrategy`` provides a range of features through which a plugin may do"
" useful work.  Some of these are callbacks, some are algorithms that can "
"be enabled, disabled, or customized.  This matrix summarizes the "
"supported (and planned) features and correlates them with the collection "
"techniques which typically require them."
msgstr ""

#: ../../GarbageCollection.rst:685
msgid "Algorithm"
msgstr ""

#: ../../GarbageCollection.rst:685
msgid "Done"
msgstr ""

#: ../../GarbageCollection.rst:685
msgid "Shadow stack"
msgstr ""

#: ../../GarbageCollection.rst:685
msgid "refcount"
msgstr ""

#: ../../GarbageCollection.rst:685
msgid "mark- sweep"
msgstr ""

#: ../../GarbageCollection.rst:685
msgid "copying"
msgstr ""

#: ../../GarbageCollection.rst:685
msgid "incremental"
msgstr ""

#: ../../GarbageCollection.rst:685
msgid "threaded"
msgstr ""

#: ../../GarbageCollection.rst:685
msgid "concurrent"
msgstr ""

#: ../../GarbageCollection.rst:688
msgid "stack map"
msgstr ""

#: ../../GarbageCollection.rst:688 ../../GarbageCollection.rst:690
#: ../../GarbageCollection.rst:696 ../../GarbageCollection.rst:699
#: ../../GarbageCollection.rst:701 ../../GarbageCollection.rst:703
#: ../../GarbageCollection.rst:708 ../../GarbageCollection.rst:711
#: ../../GarbageCollection.rst:717 ../../GarbageCollection.rst:726
msgid "|v|"
msgstr ""

#: ../../GarbageCollection.rst:688 ../../GarbageCollection.rst:690
#: ../../GarbageCollection.rst:699 ../../GarbageCollection.rst:701
#: ../../GarbageCollection.rst:703 ../../GarbageCollection.rst:708
#: ../../GarbageCollection.rst:711 ../../GarbageCollection.rst:717
#: ../../GarbageCollection.rst:726
msgid "|x|"
msgstr ""

#: ../../GarbageCollection.rst:690
msgid "initialize roots"
msgstr ""

#: ../../GarbageCollection.rst:693
msgid "derived pointers"
msgstr ""

#: ../../GarbageCollection.rst:693 ../../GarbageCollection.rst:714
#: ../../GarbageCollection.rst:720 ../../GarbageCollection.rst:728
#: ../../GarbageCollection.rst:730 ../../GarbageCollection.rst:732
#: ../../GarbageCollection.rst:735
msgid "NO"
msgstr ""

#: ../../GarbageCollection.rst:693
msgid "**N**\\*"
msgstr ""

#: ../../GarbageCollection.rst:696
msgid "**custom lowering**"
msgstr ""

#: ../../GarbageCollection.rst:699
msgid "*gcroot*"
msgstr ""

#: ../../GarbageCollection.rst:701
msgid "*gcwrite*"
msgstr ""

#: ../../GarbageCollection.rst:703
msgid "*gcread*"
msgstr ""

#: ../../GarbageCollection.rst:705
msgid "**safe points**"
msgstr ""

#: ../../GarbageCollection.rst:708
msgid "*in calls*"
msgstr ""

#: ../../GarbageCollection.rst:711
msgid "*before calls*"
msgstr ""

#: ../../GarbageCollection.rst:714
msgid "*for loops*"
msgstr ""

#: ../../GarbageCollection.rst:714 ../../GarbageCollection.rst:720
msgid "**N**"
msgstr ""

#: ../../GarbageCollection.rst:717
msgid "*before escape*"
msgstr ""

#: ../../GarbageCollection.rst:720
msgid "emit code at safe points"
msgstr ""

#: ../../GarbageCollection.rst:724
msgid "**output**"
msgstr ""

#: ../../GarbageCollection.rst:726
msgid "*assembly*"
msgstr ""

#: ../../GarbageCollection.rst:728
msgid "*JIT*"
msgstr ""

#: ../../GarbageCollection.rst:728 ../../GarbageCollection.rst:730
#: ../../GarbageCollection.rst:732 ../../GarbageCollection.rst:735
msgid "**?**"
msgstr ""

#: ../../GarbageCollection.rst:730
msgid "*obj*"
msgstr ""

#: ../../GarbageCollection.rst:732
msgid "live analysis"
msgstr ""

#: ../../GarbageCollection.rst:735
msgid "register map"
msgstr ""

#: ../../GarbageCollection.rst:738
msgid "\\* Derived pointers only pose a hasard to copying collections."
msgstr ""

#: ../../GarbageCollection.rst:740
msgid "**?** denotes a feature which could be utilized if available."
msgstr ""

#: ../../GarbageCollection.rst:743
msgid "To be clear, the collection techniques above are defined as:"
msgstr ""

#: ../../GarbageCollection.rst:746
msgid "Shadow Stack"
msgstr ""

#: ../../GarbageCollection.rst:746
msgid "The mutator carefully maintains a linked list of stack roots."
msgstr ""

#: ../../GarbageCollection.rst:750
msgid "Reference Counting"
msgstr ""

#: ../../GarbageCollection.rst:749
msgid ""
"The mutator maintains a reference count for each object and frees an "
"object when its count falls to zero."
msgstr ""

#: ../../GarbageCollection.rst:754
msgid "Mark-Sweep"
msgstr ""

#: ../../GarbageCollection.rst:753
msgid ""
"When the heap is exhausted, the collector marks reachable objects "
"starting from the roots, then deallocates unreachable objects in a sweep "
"phase."
msgstr ""

#: ../../GarbageCollection.rst:760
msgid "Copying"
msgstr ""

#: ../../GarbageCollection.rst:757
msgid ""
"As reachability analysis proceeds, the collector copies objects from one "
"heap area to another, compacting them in the process.  Copying collectors"
" enable highly efficient \"bump pointer\" allocation and can improve "
"locality of reference."
msgstr ""

#: ../../GarbageCollection.rst:765
msgid "Incremental"
msgstr ""

#: ../../GarbageCollection.rst:763
msgid ""
"(Including generational collectors.) Incremental collectors generally "
"have all the properties of a copying collector (regardless of whether the"
" mature heap is compacting), but bring the added complexity of requiring "
"write barriers."
msgstr ""

#: ../../GarbageCollection.rst:772
msgid "Threaded"
msgstr ""

#: ../../GarbageCollection.rst:768
msgid ""
"Denotes a multithreaded mutator; the collector must still stop the "
"mutator (\"stop the world\") before beginning reachability analysis.  "
"Stopping a multithreaded mutator is a complicated problem.  It generally "
"requires highly platform-specific code in the runtime, and the production"
" of carefully designed machine code at safe points."
msgstr ""

#: ../../GarbageCollection.rst:780
msgid "Concurrent"
msgstr ""

#: ../../GarbageCollection.rst:775
msgid ""
"In this technique, the mutator and the collector run concurrently, with "
"the goal of eliminating pause times.  In a *cooperative* collector, the "
"mutator further aids with collection should a pause occur, allowing "
"collection to take advantage of multiprocessor hosts.  The \"stop the "
"world\" problem of threaded collectors is generally still present to a "
"limited extent.  Sophisticated marking algorithms are necessary.  Read "
"barriers may be necessary."
msgstr ""

#: ../../GarbageCollection.rst:782
msgid ""
"As the matrix indicates, LLVM's garbage collection infrastructure is "
"already suitable for a wide variety of collectors, but does not currently"
" extend to multithreaded programs.  This will be added in the future as "
"there is interest."
msgstr ""

#: ../../GarbageCollection.rst:790
msgid "Computing stack maps"
msgstr ""

#: ../../GarbageCollection.rst:792
msgid ""
"LLVM automatically computes a stack map.  One of the most important "
"features of a ``GCStrategy`` is to compile this information into the "
"executable in the binary representation expected by the runtime library."
msgstr ""

#: ../../GarbageCollection.rst:796
msgid ""
"The stack map consists of the location and identity of each GC root in "
"the each function in the module.  For each root:"
msgstr ""

#: ../../GarbageCollection.rst:799
msgid "``RootNum``: The index of the root."
msgstr ""

#: ../../GarbageCollection.rst:801
msgid "``StackOffset``: The offset of the object relative to the frame pointer."
msgstr ""

#: ../../GarbageCollection.rst:803
msgid ""
"``RootMetadata``: The value passed as the ``%metadata`` parameter to the "
"``@llvm.gcroot`` intrinsic."
msgstr ""

#: ../../GarbageCollection.rst:806
msgid "Also, for the function as a whole:"
msgstr ""

#: ../../GarbageCollection.rst:809
msgid ""
"``getFrameSize()``: The overall size of the function's initial stack "
"frame,"
msgstr ""

#: ../../GarbageCollection.rst:809
msgid "not accounting for any dynamic allocation."
msgstr ""

#: ../../GarbageCollection.rst:811
msgid "``roots_size()``: The count of roots in the function."
msgstr ""

#: ../../GarbageCollection.rst:813
msgid ""
"To access the stack map, use ``GCFunctionMetadata::roots_begin()`` and "
"-``end()`` from the :ref:`GCMetadataPrinter <assembly>`:"
msgstr ""

#: ../../GarbageCollection.rst:832
msgid ""
"If the ``llvm.gcroot`` intrinsic is eliminated before code generation by "
"a custom lowering pass, LLVM will compute an empty stack map.  This may "
"be useful for collector plugins which implement reference counting or a "
"shadow stack."
msgstr ""

#: ../../GarbageCollection.rst:839
msgid "Initializing roots to null: ``InitRoots``"
msgstr ""

#: ../../GarbageCollection.rst:847
msgid ""
"When set, LLVM will automatically initialize each root to ``null`` upon "
"entry to the function.  This prevents the GC's sweep phase from visiting "
"uninitialized pointers, which will almost certainly cause it to crash.  "
"This initialization occurs before custom lowering, so the two may be used"
" together."
msgstr ""

#: ../../GarbageCollection.rst:852
msgid ""
"Since LLVM does not yet compute liveness information, there is no means "
"of distinguishing an uninitialized stack root from an initialized one.  "
"Therefore, this feature should be used by all GC plugins.  It is enabled "
"by default."
msgstr ""

#: ../../GarbageCollection.rst:857
msgid ""
"Custom lowering of intrinsics: ``CustomRoots``, ``CustomReadBarriers``, "
"and ``CustomWriteBarriers``"
msgstr ""

#: ../../GarbageCollection.rst:859
msgid ""
"For GCs which use barriers or unusual treatment of stack roots, these "
"flags allow the collector to perform arbitrary transformations of the "
"LLVM IR:"
msgstr ""

#: ../../GarbageCollection.rst:874
msgid ""
"If any of these flags are set, LLVM suppresses its default lowering for "
"the corresponding intrinsics.  Instead, you must provide a custom Pass "
"which lowers the intrinsics as desired.  If you have opted in to custom "
"lowering of a particular intrinsic your pass **must** eliminate all "
"instances of the corresponding intrinsic in functions which opt in to "
"your GC.  The best example of such a pass is the ShadowStackGC and it's "
"ShadowStackGCLowering pass."
msgstr ""

#: ../../GarbageCollection.rst:882
msgid ""
"There is currently no way to register such a custom lowering pass without"
" building a custom copy of LLVM."
msgstr ""

#: ../../GarbageCollection.rst:888
msgid "Generating safe points: ``NeededSafePoints``"
msgstr ""

#: ../../GarbageCollection.rst:890
msgid "LLVM can compute four kinds of safe points:"
msgstr ""

#: ../../GarbageCollection.rst:905
msgid ""
"A collector can request any combination of the four by setting the "
"``NeededSafePoints`` mask:"
msgstr ""

#: ../../GarbageCollection.rst:917
msgid "It can then use the following routines to access safe points."
msgstr ""

#: ../../GarbageCollection.rst:932
msgid ""
"Almost every collector requires ``PostCall`` safe points, since these "
"correspond to the moments when the function is suspended during a call to"
" a subroutine."
msgstr ""

#: ../../GarbageCollection.rst:935
msgid ""
"Threaded programs generally require ``Loop`` safe points to guarantee "
"that the application will reach a safe point within a bounded amount of "
"time, even if it is executing a long-running loop which contains no "
"function calls."
msgstr ""

#: ../../GarbageCollection.rst:939
msgid ""
"Threaded collectors may also require ``Return`` and ``PreCall`` safe "
"points to implement \"stop the world\" techniques using self-modifying "
"code, where it is important that the program not exit the function "
"without reaching a safe point (because only the topmost function has been"
" patched)."
msgstr ""

#: ../../GarbageCollection.rst:947
msgid "Emitting assembly code: ``GCMetadataPrinter``"
msgstr ""

#: ../../GarbageCollection.rst:949
msgid ""
"LLVM allows a plugin to print arbitrary assembly code before and after "
"the rest of a module's assembly code.  At the end of the module, the GC "
"can compile the LLVM stack map into assembly code. (At the beginning, "
"this information is not yet computed.)"
msgstr ""

#: ../../GarbageCollection.rst:954
msgid ""
"Since AsmWriter and CodeGen are separate components of LLVM, a separate "
"abstract base class and registry is provided for printing assembly code, "
"the ``GCMetadaPrinter`` and ``GCMetadataPrinterRegistry``.  The AsmWriter"
" will look for such a subclass if the ``GCStrategy`` sets "
"``UsesMetadata``:"
msgstr ""

#: ../../GarbageCollection.rst:965
msgid "This separation allows JIT-only clients to be smaller."
msgstr ""

#: ../../GarbageCollection.rst:967
msgid ""
"Note that LLVM does not currently have analogous APIs to support code "
"generation in the JIT, nor using the object writers."
msgstr ""

#: ../../GarbageCollection.rst:991
msgid ""
"The collector should use ``AsmPrinter`` to print portable assembly code."
"  The collector itself contains the stack map for the entire module, and "
"may access the ``GCFunctionInfo`` using its own ``begin()`` and ``end()``"
" methods.  Here's a realistic example:"
msgstr ""

#: ../../GarbageCollection.rst:1077
msgid "References"
msgstr ""

#: ../../GarbageCollection.rst:1081
msgid ""
"[Appel89] Runtime Tags Aren't Necessary. Andrew W. Appel. Lisp and "
"Symbolic Computation 19(7):703-705, July 1989."
msgstr ""

#: ../../GarbageCollection.rst:1086
msgid ""
"[Goldberg91] Tag-free garbage collection for strongly typed programming "
"languages. Benjamin Goldberg. ACM SIGPLAN PLDI'91."
msgstr ""

#: ../../GarbageCollection.rst:1091
msgid ""
"[Tolmach94] Tag-free garbage collection using explicit type parameters. "
"Andrew Tolmach. Proceedings of the 1994 ACM conference on LISP and "
"functional programming."
msgstr ""

#: ../../GarbageCollection.rst:1097
msgid ""
"[Henderson2002] `Accurate Garbage Collection in an Uncooperative "
"Environment <http://citeseer.ist.psu.edu/henderson02accurate.html>`__"
msgstr ""

